// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

mod debug;
mod deserialize;
mod serialize;

/// A specification of the type and number of accelerator cards attached to the
/// instance.
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AcceleratorConfig {
    /// The number of the guest accelerator cards exposed to this instance.
    pub accelerator_count: std::option::Option<i32>,

    /// Full or partial URL of the accelerator type resource to attach to this
    /// instance. For example:projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100
    /// If you are creating an instance template, specify only the
    /// accelerator name.
    /// See GPUs on Compute Engine
    /// for a full list of accelerator types.
    pub accelerator_type: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl AcceleratorConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [accelerator_count][crate::model::AcceleratorConfig::accelerator_count].
    pub fn set_accelerator_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.accelerator_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [accelerator_count][crate::model::AcceleratorConfig::accelerator_count].
    pub fn set_or_clear_accelerator_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.accelerator_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [accelerator_type][crate::model::AcceleratorConfig::accelerator_type].
    pub fn set_accelerator_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.accelerator_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [accelerator_type][crate::model::AcceleratorConfig::accelerator_type].
    pub fn set_or_clear_accelerator_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.accelerator_type = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for AcceleratorConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.AcceleratorConfig"
    }
}

/// An access configuration attached to an instance's network interface.
/// Only one access config per instance is supported.
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AccessConfig {
    /// Applies to ipv6AccessConfigs only.
    /// The first IPv6 address of the external IPv6 range associated
    /// with this instance, prefix length is stored inexternalIpv6PrefixLength in ipv6AccessConfig. To
    /// use a static external IP address, it must be unused and in the same region
    /// as the instance's zone. If not specified, Google Cloud will automatically
    /// assign an external IPv6 address from the instance's subnetwork.
    pub external_ipv_6: std::option::Option<std::string::String>,

    /// Applies to ipv6AccessConfigs only. The prefix length of the
    /// external IPv6 range.
    pub external_ipv_6_prefix_length: std::option::Option<i32>,

    /// [Output Only] Type of the resource. Alwayscompute#accessConfig for access configs.
    pub kind: std::option::Option<std::string::String>,

    /// The name of this access configuration. In accessConfigs
    /// (IPv4), the default and recommended name is External NAT, but
    /// you can use any arbitrary string, such as My external IP orNetwork Access. In ipv6AccessConfigs, the
    /// recommend name is External IPv6.
    pub name: std::option::Option<std::string::String>,

    /// Applies to accessConfigs (IPv4) only. Anexternal IP
    /// address associated with this instance. Specify an unused static
    /// external IP address available to the project or leave this field undefined
    /// to use an IP from a shared ephemeral IP address pool. If you specify a
    /// static external IP address, it must live in the same region as the zone of
    /// the instance.
    pub nat_ip: std::option::Option<std::string::String>,

    /// This signifies the networking tier used for configuring this access
    /// configuration and can only take the following values: PREMIUM,STANDARD.
    ///
    /// If an AccessConfig is specified without a valid external IP address, an
    /// ephemeral IP will be created with this networkTier.
    ///
    /// If an AccessConfig with a valid external IP address is specified, it must
    /// match that of the networkTier associated with the Address resource owning
    /// that IP.
    pub network_tier: std::option::Option<crate::model::access_config::NetworkTier>,

    /// The DNS domain name for the public PTR record.
    ///
    /// You can set this field only if the `setPublicPtr` field is enabled inaccessConfig. If this field is unspecified inipv6AccessConfig, a default PTR record will be created for
    /// first IP in associated external IPv6 range.
    pub public_ptr_domain_name: std::option::Option<std::string::String>,

    /// The resource URL for the security policy associated with this access
    /// config.
    pub security_policy: std::option::Option<std::string::String>,

    /// Specifies whether a public DNS 'PTR' record should be created to map the
    /// external IP address of the instance to a DNS domain name.
    ///
    /// This field is not used in ipv6AccessConfig. A default PTR
    /// record will be created if the VM has external IPv6 range associated.
    pub set_public_ptr: std::option::Option<bool>,

    /// The type of configuration. In accessConfigs (IPv4), the
    /// default and only option is ONE_TO_ONE_NAT. Inipv6AccessConfigs, the default and only option isDIRECT_IPV6.
    pub r#type: std::option::Option<crate::model::access_config::Type>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl AccessConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [external_ipv_6][crate::model::AccessConfig::external_ipv_6].
    pub fn set_external_ipv_6<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.external_ipv_6 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_ipv_6][crate::model::AccessConfig::external_ipv_6].
    pub fn set_or_clear_external_ipv_6<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.external_ipv_6 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_ipv_6_prefix_length][crate::model::AccessConfig::external_ipv_6_prefix_length].
    pub fn set_external_ipv_6_prefix_length<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.external_ipv_6_prefix_length = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_ipv_6_prefix_length][crate::model::AccessConfig::external_ipv_6_prefix_length].
    pub fn set_or_clear_external_ipv_6_prefix_length<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.external_ipv_6_prefix_length = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::AccessConfig::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::AccessConfig::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::AccessConfig::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::AccessConfig::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [nat_ip][crate::model::AccessConfig::nat_ip].
    pub fn set_nat_ip<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.nat_ip = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nat_ip][crate::model::AccessConfig::nat_ip].
    pub fn set_or_clear_nat_ip<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.nat_ip = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_tier][crate::model::AccessConfig::network_tier].
    pub fn set_network_tier<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::access_config::NetworkTier>,
    {
        self.network_tier = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_tier][crate::model::AccessConfig::network_tier].
    pub fn set_or_clear_network_tier<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::access_config::NetworkTier>,
    {
        self.network_tier = v.map(|x| x.into());
        self
    }

    /// Sets the value of [public_ptr_domain_name][crate::model::AccessConfig::public_ptr_domain_name].
    pub fn set_public_ptr_domain_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.public_ptr_domain_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [public_ptr_domain_name][crate::model::AccessConfig::public_ptr_domain_name].
    pub fn set_or_clear_public_ptr_domain_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.public_ptr_domain_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [security_policy][crate::model::AccessConfig::security_policy].
    pub fn set_security_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.security_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [security_policy][crate::model::AccessConfig::security_policy].
    pub fn set_or_clear_security_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.security_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [set_public_ptr][crate::model::AccessConfig::set_public_ptr].
    pub fn set_set_public_ptr<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.set_public_ptr = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [set_public_ptr][crate::model::AccessConfig::set_public_ptr].
    pub fn set_or_clear_set_public_ptr<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.set_public_ptr = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::AccessConfig::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::access_config::Type>,
    {
        self.r#type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#type][crate::model::AccessConfig::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::access_config::Type>,
    {
        self.r#type = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for AccessConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.AccessConfig"
    }
}

/// Defines additional types related to [AccessConfig].
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
pub mod access_config {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [networkTier][google.cloud.compute.v1.AccessConfig.networkTier] field.
    ///
    /// [google.cloud.compute.v1.AccessConfig.networkTier]: crate::model::access_config::NetworkTier
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NetworkTier {
        /// Public internet quality with fixed bandwidth.
        FixedStandard,
        /// High quality, Google-grade network tier, support for all networking
        /// products.
        Premium,
        /// Public internet quality, only limited support for other networking
        /// products.
        Standard,
        /// (Output only) Temporary tier for FIXED_STANDARD when fixed standard tier
        /// is expired or not configured.
        StandardOverridesFixedStandard,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NetworkTier::value] or
        /// [NetworkTier::name].
        UnknownValue(network_tier::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod network_tier {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl NetworkTier {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::FixedStandard => std::option::Option::Some(0),
                Self::Premium => std::option::Option::Some(1),
                Self::Standard => std::option::Option::Some(2),
                Self::StandardOverridesFixedStandard => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::FixedStandard => std::option::Option::Some("FIXED_STANDARD"),
                Self::Premium => std::option::Option::Some("PREMIUM"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::StandardOverridesFixedStandard => {
                    std::option::Option::Some("STANDARD_OVERRIDES_FIXED_STANDARD")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for NetworkTier {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for NetworkTier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for NetworkTier {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::FixedStandard,
                1 => Self::Premium,
                2 => Self::Standard,
                3 => Self::StandardOverridesFixedStandard,
                _ => Self::UnknownValue(network_tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for NetworkTier {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FIXED_STANDARD" => Self::FixedStandard,
                "PREMIUM" => Self::Premium,
                "STANDARD" => Self::Standard,
                "STANDARD_OVERRIDES_FIXED_STANDARD" => Self::StandardOverridesFixedStandard,
                _ => Self::UnknownValue(network_tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for NetworkTier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::FixedStandard => serializer.serialize_str("FIXED_STANDARD"),
                Self::Premium => serializer.serialize_str("PREMIUM"),
                Self::Standard => serializer.serialize_str("STANDARD"),
                Self::StandardOverridesFixedStandard => {
                    serializer.serialize_str("STANDARD_OVERRIDES_FIXED_STANDARD")
                }
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for NetworkTier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NetworkTier>::new(
                ".google.cloud.compute.v1.AccessConfig.networkTier",
            ))
        }
    }

    /// The enumerated type for the [type][google.cloud.compute.v1.AccessConfig.type] field.
    ///
    /// [google.cloud.compute.v1.AccessConfig.type]: crate::model::access_config::Type
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        DirectIpv6,
        OneToOneNat,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::DirectIpv6 => std::option::Option::Some(0),
                Self::OneToOneNat => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::DirectIpv6 => std::option::Option::Some("DIRECT_IPV6"),
                Self::OneToOneNat => std::option::Option::Some("ONE_TO_ONE_NAT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::DirectIpv6,
                1 => Self::OneToOneNat,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DIRECT_IPV6" => Self::DirectIpv6,
                "ONE_TO_ONE_NAT" => Self::OneToOneNat,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::DirectIpv6 => serializer.serialize_str("DIRECT_IPV6"),
                Self::OneToOneNat => serializer.serialize_str("ONE_TO_ONE_NAT"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.compute.v1.AccessConfig.type",
            ))
        }
    }
}

/// Specifies options for controlling advanced machine features.
/// Options that would traditionally be configured in a BIOS belong
/// here. Features that require operating system support may have
/// corresponding entries in the GuestOsFeatures of anImage (e.g., whether or not the OS in theImage supports nested virtualization being enabled or
/// disabled).
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AdvancedMachineFeatures {
    /// Whether to enable nested virtualization or not (default is false).
    pub enable_nested_virtualization: std::option::Option<bool>,

    /// Whether to enable UEFI networking for instance creation.
    pub enable_uefi_networking: std::option::Option<bool>,

    /// Type of Performance Monitoring Unit requested on instance.
    pub performance_monitoring_unit:
        std::option::Option<crate::model::advanced_machine_features::PerformanceMonitoringUnit>,

    /// The number of threads per physical core. To disable simultaneous
    /// multithreading (SMT) set this to 1. If unset, the maximum number
    /// of threads supported per core by the underlying processor is
    /// assumed.
    pub threads_per_core: std::option::Option<i32>,

    /// Turbo frequency mode to use for the instance.
    /// Supported modes include:
    ///
    /// * ALL_CORE_MAX
    ///
    /// Using empty string or not setting this field will use the platform-specific
    /// default turbo mode.
    pub turbo_mode: std::option::Option<std::string::String>,

    /// The number of physical cores to expose to an instance. Multiply by
    /// the number of threads per core to compute the total number of virtual
    /// CPUs to expose to the instance. If unset, the number of cores is
    /// inferred from the instance's nominal CPU count and the underlying
    /// platform's SMT width.
    pub visible_core_count: std::option::Option<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl AdvancedMachineFeatures {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_nested_virtualization][crate::model::AdvancedMachineFeatures::enable_nested_virtualization].
    pub fn set_enable_nested_virtualization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_nested_virtualization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_nested_virtualization][crate::model::AdvancedMachineFeatures::enable_nested_virtualization].
    pub fn set_or_clear_enable_nested_virtualization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_nested_virtualization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_uefi_networking][crate::model::AdvancedMachineFeatures::enable_uefi_networking].
    pub fn set_enable_uefi_networking<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_uefi_networking = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_uefi_networking][crate::model::AdvancedMachineFeatures::enable_uefi_networking].
    pub fn set_or_clear_enable_uefi_networking<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_uefi_networking = v.map(|x| x.into());
        self
    }

    /// Sets the value of [performance_monitoring_unit][crate::model::AdvancedMachineFeatures::performance_monitoring_unit].
    pub fn set_performance_monitoring_unit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::advanced_machine_features::PerformanceMonitoringUnit>,
    {
        self.performance_monitoring_unit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [performance_monitoring_unit][crate::model::AdvancedMachineFeatures::performance_monitoring_unit].
    pub fn set_or_clear_performance_monitoring_unit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::advanced_machine_features::PerformanceMonitoringUnit>,
    {
        self.performance_monitoring_unit = v.map(|x| x.into());
        self
    }

    /// Sets the value of [threads_per_core][crate::model::AdvancedMachineFeatures::threads_per_core].
    pub fn set_threads_per_core<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.threads_per_core = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threads_per_core][crate::model::AdvancedMachineFeatures::threads_per_core].
    pub fn set_or_clear_threads_per_core<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.threads_per_core = v.map(|x| x.into());
        self
    }

    /// Sets the value of [turbo_mode][crate::model::AdvancedMachineFeatures::turbo_mode].
    pub fn set_turbo_mode<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.turbo_mode = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [turbo_mode][crate::model::AdvancedMachineFeatures::turbo_mode].
    pub fn set_or_clear_turbo_mode<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.turbo_mode = v.map(|x| x.into());
        self
    }

    /// Sets the value of [visible_core_count][crate::model::AdvancedMachineFeatures::visible_core_count].
    pub fn set_visible_core_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.visible_core_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [visible_core_count][crate::model::AdvancedMachineFeatures::visible_core_count].
    pub fn set_or_clear_visible_core_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.visible_core_count = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for AdvancedMachineFeatures {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.AdvancedMachineFeatures"
    }
}

/// Defines additional types related to [AdvancedMachineFeatures].
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
pub mod advanced_machine_features {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [performanceMonitoringUnit][google.cloud.compute.v1.AdvancedMachineFeatures.performanceMonitoringUnit] field.
    ///
    /// [google.cloud.compute.v1.AdvancedMachineFeatures.performanceMonitoringUnit]: crate::model::advanced_machine_features::PerformanceMonitoringUnit
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PerformanceMonitoringUnit {
        /// Architecturally defined non-LLC events.
        Architectural,
        /// Most documented core/L2 and LLC events.
        Enhanced,
        Unspecified,
        /// Most documented core/L2 events.
        Standard,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PerformanceMonitoringUnit::value] or
        /// [PerformanceMonitoringUnit::name].
        UnknownValue(performance_monitoring_unit::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod performance_monitoring_unit {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl PerformanceMonitoringUnit {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Architectural => std::option::Option::Some(0),
                Self::Enhanced => std::option::Option::Some(1),
                Self::Unspecified => std::option::Option::Some(2),
                Self::Standard => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Architectural => std::option::Option::Some("ARCHITECTURAL"),
                Self::Enhanced => std::option::Option::Some("ENHANCED"),
                Self::Unspecified => {
                    std::option::Option::Some("PERFORMANCE_MONITORING_UNIT_UNSPECIFIED")
                }
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for PerformanceMonitoringUnit {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for PerformanceMonitoringUnit {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for PerformanceMonitoringUnit {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Architectural,
                1 => Self::Enhanced,
                2 => Self::Unspecified,
                3 => Self::Standard,
                _ => Self::UnknownValue(performance_monitoring_unit::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for PerformanceMonitoringUnit {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ARCHITECTURAL" => Self::Architectural,
                "ENHANCED" => Self::Enhanced,
                "PERFORMANCE_MONITORING_UNIT_UNSPECIFIED" => Self::Unspecified,
                "STANDARD" => Self::Standard,
                _ => Self::UnknownValue(performance_monitoring_unit::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for PerformanceMonitoringUnit {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Architectural => serializer.serialize_str("ARCHITECTURAL"),
                Self::Enhanced => serializer.serialize_str("ENHANCED"),
                Self::Unspecified => {
                    serializer.serialize_str("PERFORMANCE_MONITORING_UNIT_UNSPECIFIED")
                }
                Self::Standard => serializer.serialize_str("STANDARD"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for PerformanceMonitoringUnit {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<PerformanceMonitoringUnit>::new(
                    ".google.cloud.compute.v1.AdvancedMachineFeatures.performanceMonitoringUnit",
                ),
            )
        }
    }
}

/// An alias IP range attached to an instance's network interface.
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AliasIpRange {
    /// The IP alias ranges to allocate for this interface. This IP CIDR range
    /// must belong to the specified subnetwork and cannot contain IP addresses
    /// reserved by system or used by other network interfaces. This range may be
    /// a single IP address (such as 10.2.3.4), a netmask (such as/24) or a CIDR-formatted string (such as10.1.2.0/24).
    pub ip_cidr_range: std::option::Option<std::string::String>,

    /// The name of a subnetwork secondary IP range from which to allocate an IP
    /// alias range. If not specified, the primary range of the subnetwork is used.
    pub subnetwork_range_name: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl AliasIpRange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip_cidr_range][crate::model::AliasIpRange::ip_cidr_range].
    pub fn set_ip_cidr_range<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ip_cidr_range = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ip_cidr_range][crate::model::AliasIpRange::ip_cidr_range].
    pub fn set_or_clear_ip_cidr_range<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ip_cidr_range = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subnetwork_range_name][crate::model::AliasIpRange::subnetwork_range_name].
    pub fn set_subnetwork_range_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subnetwork_range_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subnetwork_range_name][crate::model::AliasIpRange::subnetwork_range_name].
    pub fn set_or_clear_subnetwork_range_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subnetwork_range_name = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for AliasIpRange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.AliasIpRange"
    }
}

/// An instance-attached disk resource.
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AttachedDisk {
    /// [Output Only] The architecture of the attached disk. Valid values are ARM64
    /// or X86_64.
    pub architecture: std::option::Option<crate::model::attached_disk::Architecture>,

    /// Specifies whether the disk will be auto-deleted when the instance is
    /// deleted (but not when the disk is detached from the instance).
    pub auto_delete: std::option::Option<bool>,

    /// Indicates that this is a boot disk. The virtual machine will use the first
    /// partition of the disk for its root filesystem.
    pub boot: std::option::Option<bool>,

    /// Specifies a unique device name of your choice that is reflected into the/dev/disk/by-id/google-* tree of a Linux operating system
    /// running within the instance. This name can be used to reference the device
    /// for mounting, resizing, and so on, from within the instance.
    ///
    /// If not specified, the server chooses a default device name to apply to this
    /// disk, in the form persistent-disk-x, where x is a number
    /// assigned by Google Compute Engine. This field is only applicable for
    /// persistent disks.
    pub device_name: std::option::Option<std::string::String>,

    /// Encrypts or decrypts a disk using acustomer-supplied
    /// encryption key.
    ///
    /// If you are creating a new disk, this field encrypts the new disk using
    /// an encryption key that you provide. If you are attaching an existing
    /// disk that is already encrypted, this field decrypts the disk using
    /// the customer-supplied encryption key.
    ///
    /// If you encrypt a disk using a customer-supplied key, you must provide the
    /// same key again when you attempt to use this resource at a later time. For
    /// example, you must provide the key when you create a snapshot or an image
    /// from the disk or when you attach the disk to a virtual machine instance.
    ///
    /// If you do not provide an encryption key, then the disk will be encrypted
    /// using an automatically generated key and you do not need to provide a key
    /// to use the disk later.
    ///
    /// Note:
    ///
    /// Instance templates do not storecustomer-supplied
    /// encryption keys, so you cannot use your own keys to encrypt disks in amanaged instance group.
    ///
    /// You cannot create VMs that have disks with customer-supplied keys using
    /// the bulk
    /// insert method.
    pub disk_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// The size of the disk in GB.
    pub disk_size_gb: std::option::Option<i64>,

    /// [Input Only] Whether to force attach the regional disk even if it's
    /// currently attached to another instance. If you try to force attach a zonal
    /// disk to an instance, you will receive an error.
    pub force_attach: std::option::Option<bool>,

    /// A list of features to enable on the guest operating system. Applicable
    /// only for bootable images. Read
    /// Enabling guest operating system features to see a list of available
    /// options.
    pub guest_os_features: std::vec::Vec<crate::model::GuestOsFeature>,

    /// [Output Only] A zero-based index to this disk, where 0 is reserved for the
    /// boot disk. If you have many disks attached to an instance, each
    /// disk would have a unique index number.
    pub index: std::option::Option<i32>,

    /// [Input Only] Specifies the parameters for a new disk that will be created
    /// alongside the new instance. Use initialization parameters to create boot
    /// disks or local SSDs attached to the new instance.
    ///
    /// This property is mutually exclusive with the source property;
    /// you can only define one or the other, but not both.
    pub initialize_params: std::option::Option<crate::model::AttachedDiskInitializeParams>,

    /// Specifies the disk interface to use for attaching this disk, which is
    /// either SCSI or NVME. For most machine types, the
    /// default is SCSI. Local SSDs can use either NVME or SCSI.
    /// In certain configurations, persistent disks can use NVMe. For more
    /// information, seeAbout
    /// persistent disks.
    pub interface: std::option::Option<crate::model::attached_disk::Interface>,

    /// [Output Only] Type of the resource. Alwayscompute#attachedDisk for attached disks.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] Any valid publicly visible licenses.
    pub licenses: std::vec::Vec<std::string::String>,

    /// The mode in which to attach this disk, either READ_WRITE orREAD_ONLY. If not specified, the default is to attach the disk
    /// in READ_WRITE mode.
    pub mode: std::option::Option<crate::model::attached_disk::Mode>,

    /// For LocalSSD disks on VM Instances in STOPPED or SUSPENDED state, this
    /// field is set to PRESERVED if the LocalSSD data has been saved
    /// to a persistent location by customer request.  (see the
    /// discard_local_ssd option on Stop/Suspend).
    /// Read-only in the api.
    pub saved_state: std::option::Option<crate::model::attached_disk::SavedState>,

    /// [Output Only] shielded vm initial state stored on disk
    pub shielded_instance_initial_state: std::option::Option<crate::model::InitialStateConfig>,

    /// Specifies a valid partial or full URL to an existing Persistent Disk
    /// resource. When creating a new instance boot disk, one ofinitializeParams.sourceImage orinitializeParams.sourceSnapshot or disks.source
    /// is required.
    ///
    /// If desired, you can also attach existing non-root persistent disks using
    /// this property. This field is only applicable for persistent disks.
    ///
    /// Note that for InstanceTemplate, specify the disk name for zonal disk,
    /// and the URL for regional disk.
    pub source: std::option::Option<std::string::String>,

    /// Specifies the type of the disk, either SCRATCH orPERSISTENT. If not specified, the default isPERSISTENT.
    pub r#type: std::option::Option<crate::model::attached_disk::Type>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl AttachedDisk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [architecture][crate::model::AttachedDisk::architecture].
    pub fn set_architecture<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::Architecture>,
    {
        self.architecture = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [architecture][crate::model::AttachedDisk::architecture].
    pub fn set_or_clear_architecture<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::Architecture>,
    {
        self.architecture = v.map(|x| x.into());
        self
    }

    /// Sets the value of [auto_delete][crate::model::AttachedDisk::auto_delete].
    pub fn set_auto_delete<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.auto_delete = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [auto_delete][crate::model::AttachedDisk::auto_delete].
    pub fn set_or_clear_auto_delete<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.auto_delete = v.map(|x| x.into());
        self
    }

    /// Sets the value of [boot][crate::model::AttachedDisk::boot].
    pub fn set_boot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.boot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [boot][crate::model::AttachedDisk::boot].
    pub fn set_or_clear_boot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.boot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [device_name][crate::model::AttachedDisk::device_name].
    pub fn set_device_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.device_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [device_name][crate::model::AttachedDisk::device_name].
    pub fn set_or_clear_device_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.device_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_encryption_key][crate::model::AttachedDisk::disk_encryption_key].
    pub fn set_disk_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.disk_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_encryption_key][crate::model::AttachedDisk::disk_encryption_key].
    pub fn set_or_clear_disk_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.disk_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::AttachedDisk::disk_size_gb].
    pub fn set_disk_size_gb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.disk_size_gb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_size_gb][crate::model::AttachedDisk::disk_size_gb].
    pub fn set_or_clear_disk_size_gb<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.disk_size_gb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [force_attach][crate::model::AttachedDisk::force_attach].
    pub fn set_force_attach<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.force_attach = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [force_attach][crate::model::AttachedDisk::force_attach].
    pub fn set_or_clear_force_attach<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.force_attach = v.map(|x| x.into());
        self
    }

    /// Sets the value of [guest_os_features][crate::model::AttachedDisk::guest_os_features].
    pub fn set_guest_os_features<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GuestOsFeature>,
    {
        use std::iter::Iterator;
        self.guest_os_features = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [index][crate::model::AttachedDisk::index].
    pub fn set_index<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.index = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [index][crate::model::AttachedDisk::index].
    pub fn set_or_clear_index<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.index = v.map(|x| x.into());
        self
    }

    /// Sets the value of [initialize_params][crate::model::AttachedDisk::initialize_params].
    pub fn set_initialize_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttachedDiskInitializeParams>,
    {
        self.initialize_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [initialize_params][crate::model::AttachedDisk::initialize_params].
    pub fn set_or_clear_initialize_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttachedDiskInitializeParams>,
    {
        self.initialize_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [interface][crate::model::AttachedDisk::interface].
    pub fn set_interface<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::Interface>,
    {
        self.interface = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [interface][crate::model::AttachedDisk::interface].
    pub fn set_or_clear_interface<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::Interface>,
    {
        self.interface = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::AttachedDisk::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::AttachedDisk::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [licenses][crate::model::AttachedDisk::licenses].
    pub fn set_licenses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.licenses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [mode][crate::model::AttachedDisk::mode].
    pub fn set_mode<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::Mode>,
    {
        self.mode = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mode][crate::model::AttachedDisk::mode].
    pub fn set_or_clear_mode<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::Mode>,
    {
        self.mode = v.map(|x| x.into());
        self
    }

    /// Sets the value of [saved_state][crate::model::AttachedDisk::saved_state].
    pub fn set_saved_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::SavedState>,
    {
        self.saved_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [saved_state][crate::model::AttachedDisk::saved_state].
    pub fn set_or_clear_saved_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::SavedState>,
    {
        self.saved_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [shielded_instance_initial_state][crate::model::AttachedDisk::shielded_instance_initial_state].
    pub fn set_shielded_instance_initial_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InitialStateConfig>,
    {
        self.shielded_instance_initial_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shielded_instance_initial_state][crate::model::AttachedDisk::shielded_instance_initial_state].
    pub fn set_or_clear_shielded_instance_initial_state<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::InitialStateConfig>,
    {
        self.shielded_instance_initial_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::AttachedDisk::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::AttachedDisk::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::AttachedDisk::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::Type>,
    {
        self.r#type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#type][crate::model::AttachedDisk::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::Type>,
    {
        self.r#type = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for AttachedDisk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.AttachedDisk"
    }
}

/// Defines additional types related to [AttachedDisk].
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
pub mod attached_disk {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [architecture][google.cloud.compute.v1.AttachedDisk.architecture] field.
    ///
    /// [google.cloud.compute.v1.AttachedDisk.architecture]: crate::model::attached_disk::Architecture
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Architecture {
        /// Default value indicating Architecture is not set.
        Unspecified,
        /// Machines with architecture ARM64
        Arm64,
        /// Machines with architecture X86_64
        X8664,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Architecture::value] or
        /// [Architecture::name].
        UnknownValue(architecture::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod architecture {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl Architecture {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Arm64 => std::option::Option::Some(1),
                Self::X8664 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ARCHITECTURE_UNSPECIFIED"),
                Self::Arm64 => std::option::Option::Some("ARM64"),
                Self::X8664 => std::option::Option::Some("X86_64"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for Architecture {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for Architecture {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for Architecture {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Arm64,
                2 => Self::X8664,
                _ => Self::UnknownValue(architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for Architecture {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
                "ARM64" => Self::Arm64,
                "X86_64" => Self::X8664,
                _ => Self::UnknownValue(architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for Architecture {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_str("ARCHITECTURE_UNSPECIFIED"),
                Self::Arm64 => serializer.serialize_str("ARM64"),
                Self::X8664 => serializer.serialize_str("X86_64"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Architecture {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Architecture>::new(
                ".google.cloud.compute.v1.AttachedDisk.architecture",
            ))
        }
    }

    /// The enumerated type for the [interface][google.cloud.compute.v1.AttachedDisk.interface] field.
    ///
    /// [google.cloud.compute.v1.AttachedDisk.interface]: crate::model::attached_disk::Interface
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Interface {
        Nvme,
        Scsi,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Interface::value] or
        /// [Interface::name].
        UnknownValue(interface::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod interface {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl Interface {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Nvme => std::option::Option::Some(0),
                Self::Scsi => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Nvme => std::option::Option::Some("NVME"),
                Self::Scsi => std::option::Option::Some("SCSI"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for Interface {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for Interface {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for Interface {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Nvme,
                1 => Self::Scsi,
                _ => Self::UnknownValue(interface::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for Interface {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NVME" => Self::Nvme,
                "SCSI" => Self::Scsi,
                _ => Self::UnknownValue(interface::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for Interface {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Nvme => serializer.serialize_str("NVME"),
                Self::Scsi => serializer.serialize_str("SCSI"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Interface {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Interface>::new(
                ".google.cloud.compute.v1.AttachedDisk.interface",
            ))
        }
    }

    /// The enumerated type for the [mode][google.cloud.compute.v1.AttachedDisk.mode] field.
    ///
    /// [google.cloud.compute.v1.AttachedDisk.mode]: crate::model::attached_disk::Mode
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Attaches this disk in read-only mode. Multiple virtual machines can use
        /// a disk in read-only mode at a time.
        ReadOnly,
        /// *[Default]* Attaches this disk in read-write mode. Only one
        /// virtual machine at a time can be attached to a disk in read-write mode.
        ReadWrite,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::ReadOnly => std::option::Option::Some(0),
                Self::ReadWrite => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::ReadOnly => std::option::Option::Some("READ_ONLY"),
                Self::ReadWrite => std::option::Option::Some("READ_WRITE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::ReadOnly,
                1 => Self::ReadWrite,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "READ_ONLY" => Self::ReadOnly,
                "READ_WRITE" => Self::ReadWrite,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::ReadOnly => serializer.serialize_str("READ_ONLY"),
                Self::ReadWrite => serializer.serialize_str("READ_WRITE"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.cloud.compute.v1.AttachedDisk.mode",
            ))
        }
    }

    /// The enumerated type for the [savedState][google.cloud.compute.v1.AttachedDisk.savedState] field.
    ///
    /// [google.cloud.compute.v1.AttachedDisk.savedState]: crate::model::attached_disk::SavedState
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SavedState {
        /// *[Default]* Disk state has not been preserved.
        DiskSavedStateUnspecified,
        /// Disk state has been preserved.
        Preserved,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SavedState::value] or
        /// [SavedState::name].
        UnknownValue(saved_state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod saved_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl SavedState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::DiskSavedStateUnspecified => std::option::Option::Some(0),
                Self::Preserved => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::DiskSavedStateUnspecified => {
                    std::option::Option::Some("DISK_SAVED_STATE_UNSPECIFIED")
                }
                Self::Preserved => std::option::Option::Some("PRESERVED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for SavedState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for SavedState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for SavedState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::DiskSavedStateUnspecified,
                1 => Self::Preserved,
                _ => Self::UnknownValue(saved_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for SavedState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISK_SAVED_STATE_UNSPECIFIED" => Self::DiskSavedStateUnspecified,
                "PRESERVED" => Self::Preserved,
                _ => Self::UnknownValue(saved_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for SavedState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::DiskSavedStateUnspecified => {
                    serializer.serialize_str("DISK_SAVED_STATE_UNSPECIFIED")
                }
                Self::Preserved => serializer.serialize_str("PRESERVED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for SavedState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SavedState>::new(
                ".google.cloud.compute.v1.AttachedDisk.savedState",
            ))
        }
    }

    /// The enumerated type for the [type][google.cloud.compute.v1.AttachedDisk.type] field.
    ///
    /// [google.cloud.compute.v1.AttachedDisk.type]: crate::model::attached_disk::Type
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        Persistent,
        Scratch,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Persistent => std::option::Option::Some(0),
                Self::Scratch => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Persistent => std::option::Option::Some("PERSISTENT"),
                Self::Scratch => std::option::Option::Some("SCRATCH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Persistent,
                1 => Self::Scratch,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PERSISTENT" => Self::Persistent,
                "SCRATCH" => Self::Scratch,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Persistent => serializer.serialize_str("PERSISTENT"),
                Self::Scratch => serializer.serialize_str("SCRATCH"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.compute.v1.AttachedDisk.type",
            ))
        }
    }
}

/// [Input Only] Specifies the parameters for a new disk that will be created
/// alongside the new instance. Use initialization parameters to create boot
/// disks or local SSDs attached to the new instance.
///
/// This field is persisted and returned for instanceTemplate and not returned
/// in the context of instance.
///
/// This property is mutually exclusive with the source property;
/// you can only define one or the other, but not both.
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AttachedDiskInitializeParams {
    /// The architecture of the attached disk. Valid values are
    /// arm64 or x86_64.
    pub architecture:
        std::option::Option<crate::model::attached_disk_initialize_params::Architecture>,

    /// An optional description. Provide this property when creating the disk.
    pub description: std::option::Option<std::string::String>,

    /// Specifies the disk name. If not specified, the default is to use the name
    /// of the instance. If a disk with the same name already exists in the given
    /// region, the existing disk is attached to the new instance and the
    /// new disk is not created.
    pub disk_name: std::option::Option<std::string::String>,

    /// Specifies the size of the disk in base-2 GB. The size must be at least
    /// 10 GB. If you specify a sourceImage, which is required for
    /// boot disks, the default size is the size of the sourceImage.
    /// If you do not specify a sourceImage, the default disk size
    /// is 500 GB.
    pub disk_size_gb: std::option::Option<i64>,

    /// Specifies the disk type to use to create the instance. If not specified,
    /// the default is pd-standard, specified using the full URL.
    /// For example:
    ///
    /// <https://www.googleapis.com/compute/v1/projects/project/zones/zone/diskTypes/pd-standard>
    ///
    /// For a full list of acceptable values, seePersistent disk
    /// types. If you specify this field when creating a VM, you can provide
    /// either the full or partial URL. For example, the following values are
    /// valid:
    ///
    /// ```norust
    ///  - https://www.googleapis.com/compute/v1/projects/project/zones/zone/diskTypes/diskType
    /// ```
    ///
    /// - projects/project/zones/zone/diskTypes/diskType
    /// - zones/zone/diskTypes/diskType
    ///
    /// If you specify this field when creating or updating an instance template
    /// or all-instances configuration, specify the type of the disk, not the
    /// URL. For example: pd-standard.
    pub disk_type: std::option::Option<std::string::String>,

    /// Whether this disk is using confidential compute mode.
    pub enable_confidential_compute: std::option::Option<bool>,

    /// Labels to apply to this disk. These can be later modified by thedisks.setLabels method. This field is only applicable for
    /// persistent disks.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// A list of publicly visible licenses. Reserved for Google's use.
    pub licenses: std::vec::Vec<std::string::String>,

    /// Specifies which action to take on instance update with this disk. Default
    /// is to use the existing disk.
    pub on_update_action:
        std::option::Option<crate::model::attached_disk_initialize_params::OnUpdateAction>,

    /// Indicates how many IOPS to provision for the disk. This sets the number
    /// of I/O operations per second that the disk can handle. Values must be
    /// between 10,000 and 120,000. For more details, see theExtreme persistent
    /// disk documentation.
    pub provisioned_iops: std::option::Option<i64>,

    /// Indicates how much throughput to provision for the disk. This sets the
    /// number of throughput mb per second that the disk can handle. Values must
    /// greater than or equal to 1.
    pub provisioned_throughput: std::option::Option<i64>,

    /// Required for each regional disk associated with the instance. Specify
    /// the URLs of the zones where the disk should be replicated to.
    /// You must provide exactly two replica zones, and one zone must be the same
    /// as the instance zone.
    pub replica_zones: std::vec::Vec<std::string::String>,

    /// Resource manager tags to be bound to the disk. Tag keys and values
    /// have the same definition as resource
    /// manager tags. Keys must be in the format `tagKeys/{tag_key_id}`, and
    /// values are in the format `tagValues/456`. The field is ignored (both PUT
    /// & PATCH) when empty.
    pub resource_manager_tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Resource policies applied to this disk for automatic snapshot creations.
    /// Specified using the full or partial URL. For instance template, specify
    /// only the resource policy name.
    pub resource_policies: std::vec::Vec<std::string::String>,

    /// The source image to create this disk. When creating a new instance boot
    /// disk, one of initializeParams.sourceImage orinitializeParams.sourceSnapshot or disks.source
    /// is required.
    ///
    /// To create a disk with one of the public operating system
    /// images, specify the image by its family name. For example, specifyfamily/debian-9 to use the latest Debian 9 image:
    ///
    /// projects/debian-cloud/global/images/family/debian-9
    ///
    /// Alternatively, use a specific version of a public operating system image:
    ///
    /// projects/debian-cloud/global/images/debian-9-stretch-vYYYYMMDD
    ///
    /// To create a disk with a custom image that you created, specify the
    /// image name in the following format:
    ///
    /// global/images/my-custom-image
    ///
    /// You can also specify a custom image by its image family, which returns
    /// the latest version of the image in that family. Replace the image name
    /// with family/family-name:
    ///
    /// global/images/family/my-image-family
    ///
    /// If the source image is deleted later, this field will not be set.
    pub source_image: std::option::Option<std::string::String>,

    /// Thecustomer-supplied
    /// encryption key of the source image. Required if the source image is
    /// protected by a customer-supplied encryption key.
    ///
    /// InstanceTemplate and InstancePropertiesPatch do not storecustomer-supplied
    /// encryption keys, so you cannot create disks for instances in a managed instance group if the
    /// source images are encrypted with your own keys.
    pub source_image_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// The source snapshot to create this disk. When creating a new instance
    /// boot disk, one of initializeParams.sourceSnapshot orinitializeParams.sourceImage or disks.source
    /// is required.
    ///
    /// To create a disk with a snapshot that you created, specify the
    /// snapshot name in the following format:
    ///
    /// global/snapshots/my-backup
    ///
    /// If the source snapshot is deleted later, this field will not be set.
    ///
    /// Note: You cannot create VMs in bulk using a snapshot as the source. Use
    /// an image instead when you create VMs using
    /// the bulk
    /// insert method.
    pub source_snapshot: std::option::Option<std::string::String>,

    /// Thecustomer-supplied
    /// encryption key of the source snapshot.
    pub source_snapshot_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// The storage pool in which the new disk is created. You can provide
    /// this as a partial or full URL to the resource. For example, the following
    /// are valid values:
    ///
    /// ```norust
    ///  - https://www.googleapis.com/compute/v1/projects/project/zones/zone/storagePools/storagePool
    ///  - projects/project/zones/zone/storagePools/storagePool
    /// ```
    ///
    /// - zones/zone/storagePools/storagePool
    pub storage_pool: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl AttachedDiskInitializeParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [architecture][crate::model::AttachedDiskInitializeParams::architecture].
    pub fn set_architecture<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk_initialize_params::Architecture>,
    {
        self.architecture = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [architecture][crate::model::AttachedDiskInitializeParams::architecture].
    pub fn set_or_clear_architecture<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk_initialize_params::Architecture>,
    {
        self.architecture = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::AttachedDiskInitializeParams::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::AttachedDiskInitializeParams::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_name][crate::model::AttachedDiskInitializeParams::disk_name].
    pub fn set_disk_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.disk_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_name][crate::model::AttachedDiskInitializeParams::disk_name].
    pub fn set_or_clear_disk_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.disk_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::AttachedDiskInitializeParams::disk_size_gb].
    pub fn set_disk_size_gb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.disk_size_gb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_size_gb][crate::model::AttachedDiskInitializeParams::disk_size_gb].
    pub fn set_or_clear_disk_size_gb<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.disk_size_gb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_type][crate::model::AttachedDiskInitializeParams::disk_type].
    pub fn set_disk_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.disk_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_type][crate::model::AttachedDiskInitializeParams::disk_type].
    pub fn set_or_clear_disk_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.disk_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_confidential_compute][crate::model::AttachedDiskInitializeParams::enable_confidential_compute].
    pub fn set_enable_confidential_compute<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_confidential_compute = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_confidential_compute][crate::model::AttachedDiskInitializeParams::enable_confidential_compute].
    pub fn set_or_clear_enable_confidential_compute<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_confidential_compute = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::AttachedDiskInitializeParams::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [licenses][crate::model::AttachedDiskInitializeParams::licenses].
    pub fn set_licenses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.licenses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [on_update_action][crate::model::AttachedDiskInitializeParams::on_update_action].
    pub fn set_on_update_action<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk_initialize_params::OnUpdateAction>,
    {
        self.on_update_action = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [on_update_action][crate::model::AttachedDiskInitializeParams::on_update_action].
    pub fn set_or_clear_on_update_action<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk_initialize_params::OnUpdateAction>,
    {
        self.on_update_action = v.map(|x| x.into());
        self
    }

    /// Sets the value of [provisioned_iops][crate::model::AttachedDiskInitializeParams::provisioned_iops].
    pub fn set_provisioned_iops<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.provisioned_iops = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provisioned_iops][crate::model::AttachedDiskInitializeParams::provisioned_iops].
    pub fn set_or_clear_provisioned_iops<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.provisioned_iops = v.map(|x| x.into());
        self
    }

    /// Sets the value of [provisioned_throughput][crate::model::AttachedDiskInitializeParams::provisioned_throughput].
    pub fn set_provisioned_throughput<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.provisioned_throughput = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provisioned_throughput][crate::model::AttachedDiskInitializeParams::provisioned_throughput].
    pub fn set_or_clear_provisioned_throughput<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.provisioned_throughput = v.map(|x| x.into());
        self
    }

    /// Sets the value of [replica_zones][crate::model::AttachedDiskInitializeParams::replica_zones].
    pub fn set_replica_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.replica_zones = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource_manager_tags][crate::model::AttachedDiskInitializeParams::resource_manager_tags].
    pub fn set_resource_manager_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_manager_tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [resource_policies][crate::model::AttachedDiskInitializeParams::resource_policies].
    pub fn set_resource_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source_image][crate::model::AttachedDiskInitializeParams::source_image].
    pub fn set_source_image<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_image = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_image][crate::model::AttachedDiskInitializeParams::source_image].
    pub fn set_or_clear_source_image<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_image = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_image_encryption_key][crate::model::AttachedDiskInitializeParams::source_image_encryption_key].
    pub fn set_source_image_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_image_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_image_encryption_key][crate::model::AttachedDiskInitializeParams::source_image_encryption_key].
    pub fn set_or_clear_source_image_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_image_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_snapshot][crate::model::AttachedDiskInitializeParams::source_snapshot].
    pub fn set_source_snapshot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_snapshot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_snapshot][crate::model::AttachedDiskInitializeParams::source_snapshot].
    pub fn set_or_clear_source_snapshot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_snapshot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_snapshot_encryption_key][crate::model::AttachedDiskInitializeParams::source_snapshot_encryption_key].
    pub fn set_source_snapshot_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_snapshot_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_snapshot_encryption_key][crate::model::AttachedDiskInitializeParams::source_snapshot_encryption_key].
    pub fn set_or_clear_source_snapshot_encryption_key<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_snapshot_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [storage_pool][crate::model::AttachedDiskInitializeParams::storage_pool].
    pub fn set_storage_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.storage_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [storage_pool][crate::model::AttachedDiskInitializeParams::storage_pool].
    pub fn set_or_clear_storage_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.storage_pool = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for AttachedDiskInitializeParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.AttachedDiskInitializeParams"
    }
}

/// Defines additional types related to [AttachedDiskInitializeParams].
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
pub mod attached_disk_initialize_params {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [architecture][google.cloud.compute.v1.AttachedDiskInitializeParams.architecture] field.
    ///
    /// [google.cloud.compute.v1.AttachedDiskInitializeParams.architecture]: crate::model::attached_disk_initialize_params::Architecture
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Architecture {
        /// Default value indicating Architecture is not set.
        Unspecified,
        /// Machines with architecture ARM64
        Arm64,
        /// Machines with architecture X86_64
        X8664,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Architecture::value] or
        /// [Architecture::name].
        UnknownValue(architecture::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod architecture {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl Architecture {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Arm64 => std::option::Option::Some(1),
                Self::X8664 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ARCHITECTURE_UNSPECIFIED"),
                Self::Arm64 => std::option::Option::Some("ARM64"),
                Self::X8664 => std::option::Option::Some("X86_64"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for Architecture {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for Architecture {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for Architecture {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Arm64,
                2 => Self::X8664,
                _ => Self::UnknownValue(architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for Architecture {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
                "ARM64" => Self::Arm64,
                "X86_64" => Self::X8664,
                _ => Self::UnknownValue(architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for Architecture {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_str("ARCHITECTURE_UNSPECIFIED"),
                Self::Arm64 => serializer.serialize_str("ARM64"),
                Self::X8664 => serializer.serialize_str("X86_64"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Architecture {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Architecture>::new(
                ".google.cloud.compute.v1.AttachedDiskInitializeParams.architecture",
            ))
        }
    }

    /// The enumerated type for the [onUpdateAction][google.cloud.compute.v1.AttachedDiskInitializeParams.onUpdateAction] field.
    ///
    /// [google.cloud.compute.v1.AttachedDiskInitializeParams.onUpdateAction]: crate::model::attached_disk_initialize_params::OnUpdateAction
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OnUpdateAction {
        /// Always recreate the disk.
        RecreateDisk,
        /// Recreate the disk if source (image, snapshot) of this disk is different
        /// from source of existing disk.
        RecreateDiskIfSourceChanged,
        /// Use the existing disk, this is the default behaviour.
        UseExistingDisk,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OnUpdateAction::value] or
        /// [OnUpdateAction::name].
        UnknownValue(on_update_action::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod on_update_action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl OnUpdateAction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::RecreateDisk => std::option::Option::Some(0),
                Self::RecreateDiskIfSourceChanged => std::option::Option::Some(1),
                Self::UseExistingDisk => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::RecreateDisk => std::option::Option::Some("RECREATE_DISK"),
                Self::RecreateDiskIfSourceChanged => {
                    std::option::Option::Some("RECREATE_DISK_IF_SOURCE_CHANGED")
                }
                Self::UseExistingDisk => std::option::Option::Some("USE_EXISTING_DISK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for OnUpdateAction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for OnUpdateAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for OnUpdateAction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::RecreateDisk,
                1 => Self::RecreateDiskIfSourceChanged,
                2 => Self::UseExistingDisk,
                _ => Self::UnknownValue(on_update_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for OnUpdateAction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RECREATE_DISK" => Self::RecreateDisk,
                "RECREATE_DISK_IF_SOURCE_CHANGED" => Self::RecreateDiskIfSourceChanged,
                "USE_EXISTING_DISK" => Self::UseExistingDisk,
                _ => Self::UnknownValue(on_update_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for OnUpdateAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::RecreateDisk => serializer.serialize_str("RECREATE_DISK"),
                Self::RecreateDiskIfSourceChanged => {
                    serializer.serialize_str("RECREATE_DISK_IF_SOURCE_CHANGED")
                }
                Self::UseExistingDisk => serializer.serialize_str("USE_EXISTING_DISK"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for OnUpdateAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OnUpdateAction>::new(
                ".google.cloud.compute.v1.AttachedDiskInitializeParams.onUpdateAction",
            ))
        }
    }
}

/// Specifies the audit configuration for a service.
/// The configuration determines which permission types are logged, and what
/// identities, if any, are exempted from logging.
/// An AuditConfig must have one or more AuditLogConfigs.
///
/// If there are AuditConfigs for both `allServices` and a specific service,
/// the union of the two AuditConfigs is used for that service: the log_types
/// specified in each AuditConfig are enabled, and the exempted_members in each
/// AuditLogConfig are exempted.
///
/// Example Policy with multiple AuditConfigs:
///
/// ```norust
/// {
///   "audit_configs": [
///     {
///       "service": "allServices",
///       "audit_log_configs": [
///         {
///           "log_type": "DATA_READ",
///           "exempted_members": [
///             "user:jose@example.com"
///           ]
///         },
///         {
///           "log_type": "DATA_WRITE"
///         },
///         {
///           "log_type": "ADMIN_READ"
///         }
///       ]
///     },
///     {
///       "service": "sampleservice.googleapis.com",
///       "audit_log_configs": [
///         {
///           "log_type": "DATA_READ"
///         },
///         {
///           "log_type": "DATA_WRITE",
///           "exempted_members": [
///             "user:aliya@example.com"
///           ]
///         }
///       ]
///     }
///   ]
/// }
/// ```
///
/// For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ
/// logging. It also exempts `jose@example.com` from DATA_READ logging, and
/// `aliya@example.com` from DATA_WRITE logging.
#[cfg(any(feature = "images", feature = "instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AuditConfig {
    /// The configuration for logging of each type of permission.
    pub audit_log_configs: std::vec::Vec<crate::model::AuditLogConfig>,

    /// Specifies a service that will be enabled for audit logging.
    /// For example, `storage.googleapis.com`, `cloudsql.googleapis.com`.
    /// `allServices` is a special value that covers all services.
    pub service: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances",))]
impl AuditConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audit_log_configs][crate::model::AuditConfig::audit_log_configs].
    pub fn set_audit_log_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AuditLogConfig>,
    {
        use std::iter::Iterator;
        self.audit_log_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service][crate::model::AuditConfig::service].
    pub fn set_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service][crate::model::AuditConfig::service].
    pub fn set_or_clear_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.service = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
impl wkt::message::Message for AuditConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.AuditConfig"
    }
}

/// Provides the configuration for logging a type of permissions.
/// Example:
///
/// ```norust
/// {
///   "audit_log_configs": [
///     {
///       "log_type": "DATA_READ",
///       "exempted_members": [
///         "user:jose@example.com"
///       ]
///     },
///     {
///       "log_type": "DATA_WRITE"
///     }
///   ]
/// }
/// ```
///
/// This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting
/// jose@example.com from DATA_READ logging.
#[cfg(any(feature = "images", feature = "instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AuditLogConfig {
    /// Specifies the identities that do not cause logging for this type of
    /// permission.
    /// Follows the same format of Binding.members.
    pub exempted_members: std::vec::Vec<std::string::String>,

    /// The log type that this config enables.
    pub log_type: std::option::Option<crate::model::audit_log_config::LogType>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances",))]
impl AuditLogConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [exempted_members][crate::model::AuditLogConfig::exempted_members].
    pub fn set_exempted_members<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exempted_members = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [log_type][crate::model::AuditLogConfig::log_type].
    pub fn set_log_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::audit_log_config::LogType>,
    {
        self.log_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [log_type][crate::model::AuditLogConfig::log_type].
    pub fn set_or_clear_log_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::audit_log_config::LogType>,
    {
        self.log_type = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
impl wkt::message::Message for AuditLogConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.AuditLogConfig"
    }
}

/// Defines additional types related to [AuditLogConfig].
#[cfg(any(feature = "images", feature = "instances",))]
pub mod audit_log_config {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [logType][google.cloud.compute.v1.AuditLogConfig.logType] field.
    ///
    /// [google.cloud.compute.v1.AuditLogConfig.logType]: crate::model::audit_log_config::LogType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "images", feature = "instances",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LogType {
        /// Admin reads. Example: CloudIAM getIamPolicy
        AdminRead,
        /// Data reads. Example: CloudSQL Users list
        DataRead,
        /// Data writes. Example: CloudSQL Users create
        DataWrite,
        /// Default case. Should never be this.
        Unspecified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LogType::value] or
        /// [LogType::name].
        UnknownValue(log_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "images", feature = "instances",))]
    pub mod log_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl LogType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::AdminRead => std::option::Option::Some(0),
                Self::DataRead => std::option::Option::Some(1),
                Self::DataWrite => std::option::Option::Some(2),
                Self::Unspecified => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::AdminRead => std::option::Option::Some("ADMIN_READ"),
                Self::DataRead => std::option::Option::Some("DATA_READ"),
                Self::DataWrite => std::option::Option::Some("DATA_WRITE"),
                Self::Unspecified => std::option::Option::Some("LOG_TYPE_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl std::default::Default for LogType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl std::fmt::Display for LogType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl std::convert::From<i32> for LogType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::AdminRead,
                1 => Self::DataRead,
                2 => Self::DataWrite,
                3 => Self::Unspecified,
                _ => Self::UnknownValue(log_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl std::convert::From<&str> for LogType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ADMIN_READ" => Self::AdminRead,
                "DATA_READ" => Self::DataRead,
                "DATA_WRITE" => Self::DataWrite,
                "LOG_TYPE_UNSPECIFIED" => Self::Unspecified,
                _ => Self::UnknownValue(log_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl serde::ser::Serialize for LogType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::AdminRead => serializer.serialize_str("ADMIN_READ"),
                Self::DataRead => serializer.serialize_str("DATA_READ"),
                Self::DataWrite => serializer.serialize_str("DATA_WRITE"),
                Self::Unspecified => serializer.serialize_str("LOG_TYPE_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl<'de> serde::de::Deserialize<'de> for LogType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LogType>::new(
                ".google.cloud.compute.v1.AuditLogConfig.logType",
            ))
        }
    }
}

/// Associates `members`, or principals, with a `role`.
#[cfg(any(feature = "images", feature = "instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Binding {
    /// The condition that is associated with this binding.
    ///
    /// If the condition evaluates to `true`, then this binding applies to the
    /// current request.
    ///
    /// If the condition evaluates to `false`, then this binding does not apply to
    /// the current request. However, a different role binding might grant the same
    /// role to one or more of the principals in this binding.
    ///
    /// To learn which resources support conditions in their IAM policies, see the
    /// [IAM
    /// documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
    pub condition: std::option::Option<crate::model::Expr>,

    /// Specifies the principals requesting access for a Google Cloud resource.
    /// `members` can have the following values:
    ///
    /// * `allUsers`: A special identifier that represents anyone who is
    ///   on the internet; with or without a Google account.
    ///
    /// * `allAuthenticatedUsers`: A special identifier that represents anyone
    ///   who is authenticated with a Google account or a service account.
    ///   Does not include identities that come from external identity providers
    ///   (IdPs) through identity federation.
    ///
    /// * `user:{emailid}`: An email address that represents a specific Google
    ///   account. For example, `alice@example.com` .
    ///
    /// * `serviceAccount:{emailid}`: An email address that represents a Google
    ///   service account. For example,
    ///   `my-other-app@appspot.gserviceaccount.com`.
    ///
    /// * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An
    ///   identifier for a
    ///   [Kubernetes service
    ///   account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts).
    ///   For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`.
    ///
    /// * `group:{emailid}`: An email address that represents a Google group.
    ///   For example, `admins@example.com`.
    ///
    /// * `domain:{domain}`: The G Suite domain (primary) that represents all the
    ///   users of that domain. For example, `google.com` or `example.com`.
    ///
    /// * `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`:
    ///   A single identity in a workforce identity pool.
    ///
    /// * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`:
    ///   All workforce identities in a group.
    ///
    /// * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`:
    ///   All workforce identities with a specific attribute value.
    ///
    /// * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/*`:
    ///   All identities in a workforce identity pool.
    ///
    /// * `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`:
    ///   A single identity in a workload identity pool.
    ///
    /// * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`:
    ///   A workload identity pool group.
    ///
    /// * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`:
    ///   All identities in a workload identity pool with a certain attribute.
    ///
    /// * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/*`:
    ///   All identities in a workload identity pool.
    ///
    /// * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique
    ///   identifier) representing a user that has been recently deleted. For
    ///   example, `alice@example.com?uid=123456789012345678901`. If the user is
    ///   recovered, this value reverts to `user:{emailid}` and the recovered user
    ///   retains the role in the binding.
    ///
    /// * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus
    ///   unique identifier) representing a service account that has been recently
    ///   deleted. For example,
    ///   `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`.
    ///   If the service account is undeleted, this value reverts to
    ///   `serviceAccount:{emailid}` and the undeleted service account retains the
    ///   role in the binding.
    ///
    /// * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique
    ///   identifier) representing a Google group that has been recently
    ///   deleted. For example, `admins@example.com?uid=123456789012345678901`. If
    ///   the group is recovered, this value reverts to `group:{emailid}` and the
    ///   recovered group retains the role in the binding.
    ///
    /// * `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`:
    ///   Deleted single identity in a workforce identity pool. For example,
    ///   `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`.
    ///
    pub members: std::vec::Vec<std::string::String>,

    /// Role that is assigned to the list of `members`, or principals.
    /// For example, `roles/viewer`, `roles/editor`, or `roles/owner`.
    ///
    /// For an overview of the IAM roles and permissions, see the
    /// [IAM documentation](https://cloud.google.com/iam/docs/roles-overview). For
    /// a list of the available pre-defined roles, see
    /// [here](https://cloud.google.com/iam/docs/understanding-roles).
    pub role: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances",))]
impl Binding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [condition][crate::model::Binding::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Expr>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::Binding::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Expr>,
    {
        self.condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [members][crate::model::Binding::members].
    pub fn set_members<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.members = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [role][crate::model::Binding::role].
    pub fn set_role<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.role = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [role][crate::model::Binding::role].
    pub fn set_or_clear_role<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.role = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
impl wkt::message::Message for Binding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Binding"
    }
}

/// A transient resource used in compute.instances.bulkInsert and
/// compute.regionInstances.bulkInsert . This resource is not persisted
/// anywhere, it is used only for processing the requests.
#[cfg(any(feature = "instances", feature = "region-instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkInsertInstanceResource {
    /// The maximum number of instances to create.
    pub count: std::option::Option<i64>,

    /// The instance properties defining the VM instances to be created. Required
    /// if sourceInstanceTemplate is not provided.
    pub instance_properties: std::option::Option<crate::model::InstanceProperties>,

    /// Policy for choosing target zone. For more information, seeCreate VMs in
    /// bulk.
    pub location_policy: std::option::Option<crate::model::LocationPolicy>,

    /// The minimum number of instances to create. If no min_count is
    /// specified then count is used as the default value. Ifmin_count instances cannot be created, then no instances will
    /// be created and instances already created will be deleted.
    pub min_count: std::option::Option<i64>,

    /// The string pattern used for the names of the VMs.
    /// Either name_pattern or per_instance_properties
    /// must be set. The pattern must contain one continuous sequence of
    /// placeholder hash characters (#) with each character corresponding to one
    /// digit of the generated instance name. Example: a name_pattern
    /// of inst-#### generates instance names such asinst-0001 and inst-0002. If existing instances
    /// in the same project and zone have names that match the name pattern
    /// then the generated instance numbers start after the biggest
    /// existing number. For example, if there exists an instance with nameinst-0050, then instance names generated using the patterninst-#### begin with inst-0051. The name pattern
    /// placeholder #...# can contain up to 18 characters.
    pub name_pattern: std::option::Option<std::string::String>,

    /// Per-instance properties to be set on individual instances.
    /// Keys of this map specify requested instance names.
    /// Can be empty if name_pattern is used.
    pub per_instance_properties: std::collections::HashMap<
        std::string::String,
        crate::model::BulkInsertInstanceResourcePerInstanceProperties,
    >,

    /// Specifies the instance template from which to create instances. You may
    /// combine sourceInstanceTemplate withinstanceProperties to override specific values from an
    /// existing instance template. Bulk API follows the semantics of JSON Merge
    /// Patch described by RFC
    /// 7396.
    ///
    /// It can be a full or partial URL. For example, the following are
    /// all valid URLs to an instance template:
    ///
    /// ```norust
    ///   - https://www.googleapis.com/compute/v1/projects/project/global/instanceTemplates/instanceTemplate
    ///   - projects/project/global/instanceTemplates/instanceTemplate
    ///   - global/instanceTemplates/instanceTemplate
    /// ```
    ///
    /// This field is optional.
    pub source_instance_template: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "instances", feature = "region-instances",))]
impl BulkInsertInstanceResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [count][crate::model::BulkInsertInstanceResource::count].
    pub fn set_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [count][crate::model::BulkInsertInstanceResource::count].
    pub fn set_or_clear_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_properties][crate::model::BulkInsertInstanceResource::instance_properties].
    pub fn set_instance_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceProperties>,
    {
        self.instance_properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_properties][crate::model::BulkInsertInstanceResource::instance_properties].
    pub fn set_or_clear_instance_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceProperties>,
    {
        self.instance_properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [location_policy][crate::model::BulkInsertInstanceResource::location_policy].
    pub fn set_location_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LocationPolicy>,
    {
        self.location_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [location_policy][crate::model::BulkInsertInstanceResource::location_policy].
    pub fn set_or_clear_location_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LocationPolicy>,
    {
        self.location_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [min_count][crate::model::BulkInsertInstanceResource::min_count].
    pub fn set_min_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.min_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_count][crate::model::BulkInsertInstanceResource::min_count].
    pub fn set_or_clear_min_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.min_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name_pattern][crate::model::BulkInsertInstanceResource::name_pattern].
    pub fn set_name_pattern<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name_pattern = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name_pattern][crate::model::BulkInsertInstanceResource::name_pattern].
    pub fn set_or_clear_name_pattern<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name_pattern = v.map(|x| x.into());
        self
    }

    /// Sets the value of [per_instance_properties][crate::model::BulkInsertInstanceResource::per_instance_properties].
    pub fn set_per_instance_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::BulkInsertInstanceResourcePerInstanceProperties>,
    {
        use std::iter::Iterator;
        self.per_instance_properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [source_instance_template][crate::model::BulkInsertInstanceResource::source_instance_template].
    pub fn set_source_instance_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_instance_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_instance_template][crate::model::BulkInsertInstanceResource::source_instance_template].
    pub fn set_or_clear_source_instance_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_instance_template = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "instances", feature = "region-instances",))]
impl wkt::message::Message for BulkInsertInstanceResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.BulkInsertInstanceResource"
    }
}

/// Per-instance properties to be set on individual instances.
/// To be extended in the future.
#[cfg(any(feature = "instances", feature = "region-instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkInsertInstanceResourcePerInstanceProperties {
    /// Specifies the hostname of the instance. More details in:
    /// <https://cloud.google.com/compute/docs/instances/custom-hostname-vm#naming_convention>
    pub hostname: std::option::Option<std::string::String>,

    /// This field is only temporary. It will be removed. Do not use it.
    pub name: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "instances", feature = "region-instances",))]
impl BulkInsertInstanceResourcePerInstanceProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hostname][crate::model::BulkInsertInstanceResourcePerInstanceProperties::hostname].
    pub fn set_hostname<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.hostname = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hostname][crate::model::BulkInsertInstanceResourcePerInstanceProperties::hostname].
    pub fn set_or_clear_hostname<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.hostname = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::BulkInsertInstanceResourcePerInstanceProperties::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::BulkInsertInstanceResourcePerInstanceProperties::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "instances", feature = "region-instances",))]
impl wkt::message::Message for BulkInsertInstanceResourcePerInstanceProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.BulkInsertInstanceResourcePerInstanceProperties"
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkInsertOperationStatus {
    /// [Output Only] Count of VMs successfully created so far.
    pub created_vm_count: std::option::Option<i32>,

    /// [Output Only] Count of VMs that got deleted during rollback.
    pub deleted_vm_count: std::option::Option<i32>,

    /// [Output Only] Count of VMs that started creating but encountered an
    /// error.
    pub failed_to_create_vm_count: std::option::Option<i32>,

    /// [Output Only] Creation status of BulkInsert operation - information
    /// if the flow is rolling forward or rolling back.
    pub status: std::option::Option<crate::model::bulk_insert_operation_status::Status>,

    /// [Output Only] Count of VMs originally planned to be created.
    pub target_vm_count: std::option::Option<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl BulkInsertOperationStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [created_vm_count][crate::model::BulkInsertOperationStatus::created_vm_count].
    pub fn set_created_vm_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.created_vm_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [created_vm_count][crate::model::BulkInsertOperationStatus::created_vm_count].
    pub fn set_or_clear_created_vm_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.created_vm_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deleted_vm_count][crate::model::BulkInsertOperationStatus::deleted_vm_count].
    pub fn set_deleted_vm_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.deleted_vm_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleted_vm_count][crate::model::BulkInsertOperationStatus::deleted_vm_count].
    pub fn set_or_clear_deleted_vm_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.deleted_vm_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [failed_to_create_vm_count][crate::model::BulkInsertOperationStatus::failed_to_create_vm_count].
    pub fn set_failed_to_create_vm_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.failed_to_create_vm_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [failed_to_create_vm_count][crate::model::BulkInsertOperationStatus::failed_to_create_vm_count].
    pub fn set_or_clear_failed_to_create_vm_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.failed_to_create_vm_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::BulkInsertOperationStatus::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::bulk_insert_operation_status::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::BulkInsertOperationStatus::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::bulk_insert_operation_status::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_vm_count][crate::model::BulkInsertOperationStatus::target_vm_count].
    pub fn set_target_vm_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.target_vm_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_vm_count][crate::model::BulkInsertOperationStatus::target_vm_count].
    pub fn set_or_clear_target_vm_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.target_vm_count = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl wkt::message::Message for BulkInsertOperationStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.BulkInsertOperationStatus"
    }
}

/// Defines additional types related to [BulkInsertOperationStatus].
#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
pub mod bulk_insert_operation_status {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [status][google.cloud.compute.v1.BulkInsertOperationStatus.status] field.
    ///
    /// [google.cloud.compute.v1.BulkInsertOperationStatus.status]: crate::model::bulk_insert_operation_status::Status
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Rolling forward - creating VMs.
        Creating,
        /// Done
        Done,
        /// Rolling back - cleaning up after an error.
        RollingBack,
        Unspecified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Creating => std::option::Option::Some(0),
                Self::Done => std::option::Option::Some(1),
                Self::RollingBack => std::option::Option::Some(2),
                Self::Unspecified => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::RollingBack => std::option::Option::Some("ROLLING_BACK"),
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Creating,
                1 => Self::Done,
                2 => Self::RollingBack,
                3 => Self::Unspecified,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CREATING" => Self::Creating,
                "DONE" => Self::Done,
                "ROLLING_BACK" => Self::RollingBack,
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Creating => serializer.serialize_str("CREATING"),
                Self::Done => serializer.serialize_str("DONE"),
                Self::RollingBack => serializer.serialize_str("ROLLING_BACK"),
                Self::Unspecified => serializer.serialize_str("STATUS_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.cloud.compute.v1.BulkInsertOperationStatus.status",
            ))
        }
    }
}

/// A set of Confidential Instance options.
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConfidentialInstanceConfig {
    /// Defines the type of technology used by the confidential instance.
    pub confidential_instance_type:
        std::option::Option<crate::model::confidential_instance_config::ConfidentialInstanceType>,

    /// Defines whether the instance should have confidential compute enabled.
    pub enable_confidential_compute: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl ConfidentialInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [confidential_instance_type][crate::model::ConfidentialInstanceConfig::confidential_instance_type].
    pub fn set_confidential_instance_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::confidential_instance_config::ConfidentialInstanceType>,
    {
        self.confidential_instance_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [confidential_instance_type][crate::model::ConfidentialInstanceConfig::confidential_instance_type].
    pub fn set_or_clear_confidential_instance_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::confidential_instance_config::ConfidentialInstanceType>,
    {
        self.confidential_instance_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_confidential_compute][crate::model::ConfidentialInstanceConfig::enable_confidential_compute].
    pub fn set_enable_confidential_compute<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_confidential_compute = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_confidential_compute][crate::model::ConfidentialInstanceConfig::enable_confidential_compute].
    pub fn set_or_clear_enable_confidential_compute<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_confidential_compute = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for ConfidentialInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ConfidentialInstanceConfig"
    }
}

/// Defines additional types related to [ConfidentialInstanceConfig].
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
pub mod confidential_instance_config {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [confidentialInstanceType][google.cloud.compute.v1.ConfidentialInstanceConfig.confidentialInstanceType] field.
    ///
    /// [google.cloud.compute.v1.ConfidentialInstanceConfig.confidentialInstanceType]: crate::model::confidential_instance_config::ConfidentialInstanceType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConfidentialInstanceType {
        /// No type specified. Do not use this value.
        Unspecified,
        /// AMD Secure Encrypted Virtualization.
        Sev,
        /// AMD Secure Encrypted Virtualization - Secure Nested Paging.
        SevSnp,
        /// Intel Trust Domain eXtension.
        Tdx,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConfidentialInstanceType::value] or
        /// [ConfidentialInstanceType::name].
        UnknownValue(confidential_instance_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod confidential_instance_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl ConfidentialInstanceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Sev => std::option::Option::Some(1),
                Self::SevSnp => std::option::Option::Some(2),
                Self::Tdx => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("CONFIDENTIAL_INSTANCE_TYPE_UNSPECIFIED")
                }
                Self::Sev => std::option::Option::Some("SEV"),
                Self::SevSnp => std::option::Option::Some("SEV_SNP"),
                Self::Tdx => std::option::Option::Some("TDX"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for ConfidentialInstanceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for ConfidentialInstanceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for ConfidentialInstanceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Sev,
                2 => Self::SevSnp,
                3 => Self::Tdx,
                _ => Self::UnknownValue(confidential_instance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for ConfidentialInstanceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONFIDENTIAL_INSTANCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SEV" => Self::Sev,
                "SEV_SNP" => Self::SevSnp,
                "TDX" => Self::Tdx,
                _ => Self::UnknownValue(confidential_instance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for ConfidentialInstanceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => {
                    serializer.serialize_str("CONFIDENTIAL_INSTANCE_TYPE_UNSPECIFIED")
                }
                Self::Sev => serializer.serialize_str("SEV"),
                Self::SevSnp => serializer.serialize_str("SEV_SNP"),
                Self::Tdx => serializer.serialize_str("TDX"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for ConfidentialInstanceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<ConfidentialInstanceType>::new(
                    ".google.cloud.compute.v1.ConfidentialInstanceConfig.confidentialInstanceType",
                ),
            )
        }
    }
}

#[cfg(any(
    feature = "images",
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomerEncryptionKey {
    /// The name of the encryption key that is stored in Google Cloud KMS.
    /// For example:
    ///
    /// "kmsKeyName": "projects/kms_project_id/locations/region/keyRings/
    /// key_region/cryptoKeys/key
    ///
    /// The fully-qualifed key name may be returned for resource GET requests. For
    /// example:
    ///
    /// "kmsKeyName": "projects/kms_project_id/locations/region/keyRings/
    /// key_region/cryptoKeys/key
    /// /cryptoKeyVersions/1
    pub kms_key_name: std::option::Option<std::string::String>,

    /// The service account being used for the encryption request for the given KMS
    /// key. If absent, the Compute Engine default service account is used.
    /// For example:
    ///
    /// "kmsKeyServiceAccount": "name@project_id.iam.gserviceaccount.com/
    pub kms_key_service_account: std::option::Option<std::string::String>,

    /// Specifies a 256-bit customer-supplied
    /// encryption key, encoded in RFC
    /// 4648 base64 to either encrypt or decrypt this resource. You can
    /// provide either the rawKey or thersaEncryptedKey.
    /// For example:
    ///
    /// "rawKey":
    /// "SGVsbG8gZnJvbSBHb29nbGUgQ2xvdWQgUGxhdGZvcm0="
    pub raw_key: std::option::Option<std::string::String>,

    /// Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit
    /// customer-supplied encryption key to either encrypt or decrypt this
    /// resource. You can provide either the rawKey or thersaEncryptedKey.
    /// For example:
    ///
    /// "rsaEncryptedKey":
    /// "ieCx/NcW06PcT7Ep1X6LUTc/hLvUDYyzSZPPVCVPTVEohpeHASqC8uw5TzyO9U+Fka9JFH
    /// z0mBibXUInrC/jEk014kCK/NPjYgEMOyssZ4ZINPKxlUh2zn1bV+MCaTICrdmuSBTWlUUiFoD
    /// D6PYznLwh8ZNdaheCeZ8ewEXgFQ8V+sDroLaN3Xs3MDTXQEMMoNUXMCZEIpg9Vtp9x2oe=="
    ///
    /// The key must meet the following requirements before you can provide it to
    /// Compute Engine:
    ///
    /// 1. The key is wrapped using a RSA public key certificate provided by
    ///    Google.
    /// 1. After being wrapped, the key must be encoded in RFC 4648 base64
    ///    encoding.
    ///
    /// Gets the RSA public key certificate provided by Google at:
    ///
    /// <https://cloud-certs.storage.googleapis.com/google-cloud-csek-ingress.pem>
    pub rsa_encrypted_key: std::option::Option<std::string::String>,

    /// [Output only] TheRFC
    /// 4648 base64 encoded SHA-256 hash of the customer-supplied
    /// encryption key that protects this resource.
    pub sha256: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "images",
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl CustomerEncryptionKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::CustomerEncryptionKey::kms_key_name].
    pub fn set_kms_key_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kms_key_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kms_key_name][crate::model::CustomerEncryptionKey::kms_key_name].
    pub fn set_or_clear_kms_key_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kms_key_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kms_key_service_account][crate::model::CustomerEncryptionKey::kms_key_service_account].
    pub fn set_kms_key_service_account<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kms_key_service_account = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kms_key_service_account][crate::model::CustomerEncryptionKey::kms_key_service_account].
    pub fn set_or_clear_kms_key_service_account<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kms_key_service_account = v.map(|x| x.into());
        self
    }

    /// Sets the value of [raw_key][crate::model::CustomerEncryptionKey::raw_key].
    pub fn set_raw_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.raw_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [raw_key][crate::model::CustomerEncryptionKey::raw_key].
    pub fn set_or_clear_raw_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.raw_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rsa_encrypted_key][crate::model::CustomerEncryptionKey::rsa_encrypted_key].
    pub fn set_rsa_encrypted_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.rsa_encrypted_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rsa_encrypted_key][crate::model::CustomerEncryptionKey::rsa_encrypted_key].
    pub fn set_or_clear_rsa_encrypted_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.rsa_encrypted_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sha256][crate::model::CustomerEncryptionKey::sha256].
    pub fn set_sha256<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.sha256 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sha256][crate::model::CustomerEncryptionKey::sha256].
    pub fn set_or_clear_sha256<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.sha256 = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "images",
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for CustomerEncryptionKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.CustomerEncryptionKey"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomerEncryptionKeyProtectedDisk {
    /// Decrypts data associated with the disk with acustomer-supplied
    /// encryption key.
    pub disk_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// Specifies a valid partial or full URL to an existing Persistent Disk
    /// resource. This field is only applicable for persistent disks.
    /// For example:
    ///
    /// "source": "/compute/v1/projects/project_id/zones/zone/disks/
    /// disk_name
    pub source: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl CustomerEncryptionKeyProtectedDisk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disk_encryption_key][crate::model::CustomerEncryptionKeyProtectedDisk::disk_encryption_key].
    pub fn set_disk_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.disk_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_encryption_key][crate::model::CustomerEncryptionKeyProtectedDisk::disk_encryption_key].
    pub fn set_or_clear_disk_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.disk_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::CustomerEncryptionKeyProtectedDisk::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::CustomerEncryptionKeyProtectedDisk::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for CustomerEncryptionKeyProtectedDisk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.CustomerEncryptionKeyProtectedDisk"
    }
}

/// Deprecation status for a public resource.
#[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeprecationStatus {
    /// An optional RFC3339 timestamp on or after which the state of this
    /// resource is intended to change to DELETED. This is only
    /// informational and the status will not change unless the client explicitly
    /// changes it.
    pub deleted: std::option::Option<std::string::String>,

    /// An optional RFC3339 timestamp on or after which the state of this
    /// resource is intended to change to DEPRECATED. This is only
    /// informational and the status will not change unless the client explicitly
    /// changes it.
    pub deprecated: std::option::Option<std::string::String>,

    /// An optional RFC3339 timestamp on or after which the state of this
    /// resource is intended to change to OBSOLETE. This is only
    /// informational and the status will not change unless the client explicitly
    /// changes it.
    pub obsolete: std::option::Option<std::string::String>,

    /// The URL of the suggested replacement for a deprecated resource.
    /// The suggested replacement resource must be the same kind of resource as the
    /// deprecated resource.
    pub replacement: std::option::Option<std::string::String>,

    /// The deprecation state of this resource. This can be ACTIVE,DEPRECATED, OBSOLETE, or DELETED.
    /// Operations which communicate the end of life date for an image, can useACTIVE. Operations which create a new resource using aDEPRECATED resource will return successfully, but with a
    /// warning indicating the deprecated resource and recommending its
    /// replacement. Operations which use OBSOLETE orDELETED resources will be rejected and result in an error.
    pub state: std::option::Option<crate::model::deprecation_status::State>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
impl DeprecationStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deleted][crate::model::DeprecationStatus::deleted].
    pub fn set_deleted<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.deleted = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleted][crate::model::DeprecationStatus::deleted].
    pub fn set_or_clear_deleted<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.deleted = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deprecated][crate::model::DeprecationStatus::deprecated].
    pub fn set_deprecated<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.deprecated = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deprecated][crate::model::DeprecationStatus::deprecated].
    pub fn set_or_clear_deprecated<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.deprecated = v.map(|x| x.into());
        self
    }

    /// Sets the value of [obsolete][crate::model::DeprecationStatus::obsolete].
    pub fn set_obsolete<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.obsolete = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [obsolete][crate::model::DeprecationStatus::obsolete].
    pub fn set_or_clear_obsolete<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.obsolete = v.map(|x| x.into());
        self
    }

    /// Sets the value of [replacement][crate::model::DeprecationStatus::replacement].
    pub fn set_replacement<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.replacement = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replacement][crate::model::DeprecationStatus::replacement].
    pub fn set_or_clear_replacement<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.replacement = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::DeprecationStatus::state].
    pub fn set_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::deprecation_status::State>,
    {
        self.state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state][crate::model::DeprecationStatus::state].
    pub fn set_or_clear_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::deprecation_status::State>,
    {
        self.state = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
impl wkt::message::Message for DeprecationStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.DeprecationStatus"
    }
}

/// Defines additional types related to [DeprecationStatus].
#[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
pub mod deprecation_status {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [state][google.cloud.compute.v1.DeprecationStatus.state] field.
    ///
    /// [google.cloud.compute.v1.DeprecationStatus.state]: crate::model::deprecation_status::State
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        Active,
        Deleted,
        Deprecated,
        Obsolete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Active => std::option::Option::Some(0),
                Self::Deleted => std::option::Option::Some(1),
                Self::Deprecated => std::option::Option::Some(2),
                Self::Obsolete => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::Deprecated => std::option::Option::Some("DEPRECATED"),
                Self::Obsolete => std::option::Option::Some("OBSOLETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Active,
                1 => Self::Deleted,
                2 => Self::Deprecated,
                3 => Self::Obsolete,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACTIVE" => Self::Active,
                "DELETED" => Self::Deleted,
                "DEPRECATED" => Self::Deprecated,
                "OBSOLETE" => Self::Obsolete,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Active => serializer.serialize_str("ACTIVE"),
                Self::Deleted => serializer.serialize_str("DELETED"),
                Self::Deprecated => serializer.serialize_str("DEPRECATED"),
                Self::Obsolete => serializer.serialize_str("OBSOLETE"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.compute.v1.DeprecationStatus.state",
            ))
        }
    }
}

/// A specification of the desired way to instantiate a disk in the instance
/// template when its created from a source instance.
#[cfg(feature = "region-instance-templates")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DiskInstantiationConfig {
    /// Specifies whether the disk will be auto-deleted when the instance is
    /// deleted (but not when the disk is detached from the instance).
    pub auto_delete: std::option::Option<bool>,

    /// The custom source image to be used to restore this disk when instantiating
    /// this instance template.
    pub custom_image: std::option::Option<std::string::String>,

    /// Specifies the device name of the disk to which the configurations apply to.
    pub device_name: std::option::Option<std::string::String>,

    /// Specifies whether to include the disk and what image to use. Possible
    /// values are:
    ///
    /// ```norust
    ///  - source-image: to use the same image that was used to
    ///  create the source instance's corresponding disk. Applicable to the boot
    ///  disk and additional read-write disks.
    ///  - source-image-family: to use the same image family that
    ///  was used to create the source instance's corresponding disk. Applicable
    ///  to the boot disk and additional read-write disks.
    ///  - custom-image: to use a user-provided image url for disk
    ///  creation. Applicable to the boot disk and additional read-write
    ///  disks.
    /// ```
    ///
    /// - attach-read-only: to attach a read-only
    ///   disk. Applicable to read-only disks.
    ///   - do-not-include: to exclude a disk from the template.
    ///     Applicable to additional read-write disks, local SSDs, and read-only
    ///     disks.
    pub instantiate_from:
        std::option::Option<crate::model::disk_instantiation_config::InstantiateFrom>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-templates")]
impl DiskInstantiationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auto_delete][crate::model::DiskInstantiationConfig::auto_delete].
    pub fn set_auto_delete<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.auto_delete = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [auto_delete][crate::model::DiskInstantiationConfig::auto_delete].
    pub fn set_or_clear_auto_delete<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.auto_delete = v.map(|x| x.into());
        self
    }

    /// Sets the value of [custom_image][crate::model::DiskInstantiationConfig::custom_image].
    pub fn set_custom_image<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.custom_image = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [custom_image][crate::model::DiskInstantiationConfig::custom_image].
    pub fn set_or_clear_custom_image<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.custom_image = v.map(|x| x.into());
        self
    }

    /// Sets the value of [device_name][crate::model::DiskInstantiationConfig::device_name].
    pub fn set_device_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.device_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [device_name][crate::model::DiskInstantiationConfig::device_name].
    pub fn set_or_clear_device_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.device_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instantiate_from][crate::model::DiskInstantiationConfig::instantiate_from].
    pub fn set_instantiate_from<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::disk_instantiation_config::InstantiateFrom>,
    {
        self.instantiate_from = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instantiate_from][crate::model::DiskInstantiationConfig::instantiate_from].
    pub fn set_or_clear_instantiate_from<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::disk_instantiation_config::InstantiateFrom>,
    {
        self.instantiate_from = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "region-instance-templates")]
impl wkt::message::Message for DiskInstantiationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.DiskInstantiationConfig"
    }
}

/// Defines additional types related to [DiskInstantiationConfig].
#[cfg(feature = "region-instance-templates")]
pub mod disk_instantiation_config {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [instantiateFrom][google.cloud.compute.v1.DiskInstantiationConfig.instantiateFrom] field.
    ///
    /// [google.cloud.compute.v1.DiskInstantiationConfig.instantiateFrom]: crate::model::disk_instantiation_config::InstantiateFrom
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "region-instance-templates")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstantiateFrom {
        /// Attach the existing disk in read-only mode. The request will fail if the
        /// disk was attached in read-write mode on the source instance. Applicable
        /// to: read-only disks.
        AttachReadOnly,
        /// Create a blank disk. The disk will be created unformatted. Applicable to:
        /// additional read-write disks, local SSDs.
        Blank,
        /// Use the custom image specified in the custom_image field. Applicable to:
        /// boot disk, additional read-write disks.
        CustomImage,
        /// Use the default instantiation option for the corresponding type of disk.
        /// For boot disk and any other R/W disks, new custom images will be created
        /// from each disk. For read-only disks, they will be attached in read-only
        /// mode. Local SSD disks will be created as blank volumes.
        Default,
        /// Do not include the disk in the instance template. Applicable to:
        /// additional read-write disks, local SSDs, read-only disks.
        DoNotInclude,
        /// Use the same source image used for creation of the source instance's
        /// corresponding disk. The request will fail if the source VM's disk was
        /// created from a snapshot. Applicable to: boot disk, additional read-write
        /// disks.
        SourceImage,
        /// Use the same source image family used for creation of the source
        /// instance's corresponding disk. The request will fail if the source image
        /// of the source disk does not belong to any image family. Applicable to:
        /// boot disk, additional read-write disks.
        SourceImageFamily,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstantiateFrom::value] or
        /// [InstantiateFrom::name].
        UnknownValue(instantiate_from::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "region-instance-templates")]
    pub mod instantiate_from {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "region-instance-templates")]
    impl InstantiateFrom {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::AttachReadOnly => std::option::Option::Some(0),
                Self::Blank => std::option::Option::Some(1),
                Self::CustomImage => std::option::Option::Some(2),
                Self::Default => std::option::Option::Some(3),
                Self::DoNotInclude => std::option::Option::Some(4),
                Self::SourceImage => std::option::Option::Some(5),
                Self::SourceImageFamily => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::AttachReadOnly => std::option::Option::Some("ATTACH_READ_ONLY"),
                Self::Blank => std::option::Option::Some("BLANK"),
                Self::CustomImage => std::option::Option::Some("CUSTOM_IMAGE"),
                Self::Default => std::option::Option::Some("DEFAULT"),
                Self::DoNotInclude => std::option::Option::Some("DO_NOT_INCLUDE"),
                Self::SourceImage => std::option::Option::Some("SOURCE_IMAGE"),
                Self::SourceImageFamily => std::option::Option::Some("SOURCE_IMAGE_FAMILY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "region-instance-templates")]
    impl std::default::Default for InstantiateFrom {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "region-instance-templates")]
    impl std::fmt::Display for InstantiateFrom {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "region-instance-templates")]
    impl std::convert::From<i32> for InstantiateFrom {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::AttachReadOnly,
                1 => Self::Blank,
                2 => Self::CustomImage,
                3 => Self::Default,
                4 => Self::DoNotInclude,
                5 => Self::SourceImage,
                6 => Self::SourceImageFamily,
                _ => Self::UnknownValue(instantiate_from::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "region-instance-templates")]
    impl std::convert::From<&str> for InstantiateFrom {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ATTACH_READ_ONLY" => Self::AttachReadOnly,
                "BLANK" => Self::Blank,
                "CUSTOM_IMAGE" => Self::CustomImage,
                "DEFAULT" => Self::Default,
                "DO_NOT_INCLUDE" => Self::DoNotInclude,
                "SOURCE_IMAGE" => Self::SourceImage,
                "SOURCE_IMAGE_FAMILY" => Self::SourceImageFamily,
                _ => Self::UnknownValue(instantiate_from::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "region-instance-templates")]
    impl serde::ser::Serialize for InstantiateFrom {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::AttachReadOnly => serializer.serialize_str("ATTACH_READ_ONLY"),
                Self::Blank => serializer.serialize_str("BLANK"),
                Self::CustomImage => serializer.serialize_str("CUSTOM_IMAGE"),
                Self::Default => serializer.serialize_str("DEFAULT"),
                Self::DoNotInclude => serializer.serialize_str("DO_NOT_INCLUDE"),
                Self::SourceImage => serializer.serialize_str("SOURCE_IMAGE"),
                Self::SourceImageFamily => serializer.serialize_str("SOURCE_IMAGE_FAMILY"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "region-instance-templates")]
    impl<'de> serde::de::Deserialize<'de> for InstantiateFrom {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InstantiateFrom>::new(
                ".google.cloud.compute.v1.DiskInstantiationConfig.instantiateFrom",
            ))
        }
    }
}

/// A set of Display Device options
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DisplayDevice {
    /// Defines whether the instance has Display enabled.
    pub enable_display: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl DisplayDevice {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_display][crate::model::DisplayDevice::enable_display].
    pub fn set_enable_display<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_display = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_display][crate::model::DisplayDevice::enable_display].
    pub fn set_or_clear_enable_display<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_display = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for DisplayDevice {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.DisplayDevice"
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DistributionPolicy {
    /// The distribution shape to which the group converges either proactively or
    /// on resize events (depending on the value set inupdatePolicy.instanceRedistributionType).
    pub target_shape: std::option::Option<crate::model::distribution_policy::TargetShape>,

    /// Zones where the regional managed instance group will create and manage
    /// its instances.
    pub zones: std::vec::Vec<crate::model::DistributionPolicyZoneConfiguration>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl DistributionPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_shape][crate::model::DistributionPolicy::target_shape].
    pub fn set_target_shape<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::distribution_policy::TargetShape>,
    {
        self.target_shape = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_shape][crate::model::DistributionPolicy::target_shape].
    pub fn set_or_clear_target_shape<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::distribution_policy::TargetShape>,
    {
        self.target_shape = v.map(|x| x.into());
        self
    }

    /// Sets the value of [zones][crate::model::DistributionPolicy::zones].
    pub fn set_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DistributionPolicyZoneConfiguration>,
    {
        use std::iter::Iterator;
        self.zones = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for DistributionPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.DistributionPolicy"
    }
}

/// Defines additional types related to [DistributionPolicy].
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
pub mod distribution_policy {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [targetShape][google.cloud.compute.v1.DistributionPolicy.targetShape] field.
    ///
    /// [google.cloud.compute.v1.DistributionPolicy.targetShape]: crate::model::distribution_policy::TargetShape
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetShape {
        /// The group picks zones for creating VM instances to fulfill the requested
        /// number of VMs within present resource constraints and to maximize
        /// utilization of unused zonal reservations. Recommended for batch workloads
        /// that do not require high availability.
        Any,
        /// The group creates all VM instances within a single zone. The zone is
        /// selected based on the present resource constraints and to maximize
        /// utilization of unused zonal reservations.
        /// Recommended for batch workloads with heavy interprocess communication.
        AnySingleZone,
        /// The group prioritizes acquisition of resources, scheduling VMs in zones
        /// where resources are available while distributing VMs as evenly as
        /// possible across selected zones to minimize the impact of zonal failure.
        /// Recommended for highly available serving workloads.
        Balanced,
        /// The group schedules VM instance creation and deletion to achieve and
        /// maintain an even number of managed instances across the selected zones.
        /// The distribution is even when the number of managed instances does not
        /// differ by more than 1 between any two zones. Recommended for highly
        /// available serving workloads.
        Even,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TargetShape::value] or
        /// [TargetShape::name].
        UnknownValue(target_shape::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod target_shape {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl TargetShape {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Any => std::option::Option::Some(0),
                Self::AnySingleZone => std::option::Option::Some(1),
                Self::Balanced => std::option::Option::Some(2),
                Self::Even => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Any => std::option::Option::Some("ANY"),
                Self::AnySingleZone => std::option::Option::Some("ANY_SINGLE_ZONE"),
                Self::Balanced => std::option::Option::Some("BALANCED"),
                Self::Even => std::option::Option::Some("EVEN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for TargetShape {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for TargetShape {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for TargetShape {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Any,
                1 => Self::AnySingleZone,
                2 => Self::Balanced,
                3 => Self::Even,
                _ => Self::UnknownValue(target_shape::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for TargetShape {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANY" => Self::Any,
                "ANY_SINGLE_ZONE" => Self::AnySingleZone,
                "BALANCED" => Self::Balanced,
                "EVEN" => Self::Even,
                _ => Self::UnknownValue(target_shape::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for TargetShape {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Any => serializer.serialize_str("ANY"),
                Self::AnySingleZone => serializer.serialize_str("ANY_SINGLE_ZONE"),
                Self::Balanced => serializer.serialize_str("BALANCED"),
                Self::Even => serializer.serialize_str("EVEN"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for TargetShape {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TargetShape>::new(
                ".google.cloud.compute.v1.DistributionPolicy.targetShape",
            ))
        }
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DistributionPolicyZoneConfiguration {
    /// The URL of thezone.
    /// The zone must exist in the region where the managed instance group is
    /// located.
    pub zone: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl DistributionPolicyZoneConfiguration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [zone][crate::model::DistributionPolicyZoneConfiguration::zone].
    pub fn set_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [zone][crate::model::DistributionPolicyZoneConfiguration::zone].
    pub fn set_or_clear_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for DistributionPolicyZoneConfiguration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.DistributionPolicyZoneConfiguration"
    }
}

/// A Duration represents a fixed-length span of time represented
/// as a count of seconds and fractions of seconds at nanosecond
/// resolution. It is independent of any calendar and concepts like "day"
/// or "month". Range is approximately 10,000 years.
#[cfg(any(
    feature = "instance-group-manager-resize-requests",
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Duration {
    /// Span of time that's a fraction of a second at nanosecond resolution.
    /// Durations less than one second are represented with a 0
    /// `seconds` field and a positive `nanos` field. Must be from 0
    /// to 999,999,999 inclusive.
    pub nanos: std::option::Option<i32>,

    /// Span of time at a resolution of a second. Must be from 0
    /// to 315,576,000,000 inclusive. Note: these bounds are computed from:
    /// 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
    pub seconds: std::option::Option<i64>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-manager-resize-requests",
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl Duration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [nanos][crate::model::Duration::nanos].
    pub fn set_nanos<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.nanos = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nanos][crate::model::Duration::nanos].
    pub fn set_or_clear_nanos<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.nanos = v.map(|x| x.into());
        self
    }

    /// Sets the value of [seconds][crate::model::Duration::seconds].
    pub fn set_seconds<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.seconds = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [seconds][crate::model::Duration::seconds].
    pub fn set_or_clear_seconds<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.seconds = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-manager-resize-requests",
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for Duration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Duration"
    }
}

/// Describes the cause of the error with structured details.
///
/// Example of an error when contacting the "pubsub.googleapis.com" API when it
/// is not enabled:
///
/// ```norust
/// { "reason": "API_DISABLED"
///   "domain": "googleapis.com"
///   "metadata": {
///     "resource": "projects/123",
///     "service": "pubsub.googleapis.com"
///   }
/// }
/// ```
///
/// This response indicates that the pubsub.googleapis.com API is not enabled.
///
/// Example of an error that is returned when attempting to create a Spanner
/// instance in a region that is out of stock:
///
/// ```norust
/// { "reason": "STOCKOUT"
///   "domain": "spanner.googleapis.com",
///   "metadata": {
///     "availableRegions": "us-central1,us-east2"
///   }
/// }
/// ```
#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ErrorInfo {
    /// The logical grouping to which the "reason" belongs. The error domain
    /// is typically the registered service name of the tool or product that
    /// generates the error. Example: "pubsub.googleapis.com". If the error is
    /// generated by some common infrastructure, the error domain must be a
    /// globally unique value that identifies the infrastructure. For Google API
    /// infrastructure, the error domain is "googleapis.com".
    pub domain: std::option::Option<std::string::String>,

    /// Additional structured details about this error.
    ///
    /// Keys must match a regular expression of `a-z+` but should
    /// ideally be lowerCamelCase. Also, they must be limited to 64 characters in
    /// length. When identifying the current value of an exceeded limit, the units
    /// should be contained in the key, not the value.  For example, rather than
    /// `{"instanceLimit": "100/request"}`, should be returned as,
    /// `{"instanceLimitPerRequest": "100"}`, if the client exceeds the number of
    /// instances that can be created in a single (batch) request.
    pub metadatas: std::collections::HashMap<std::string::String, std::string::String>,

    /// The reason of the error. This is a constant value that identifies the
    /// proximate cause of the error. Error reasons are unique within a particular
    /// domain of errors. This should be at most 63 characters and match a
    /// regular expression of `A-Z+[A-Z0-9]`, which represents
    /// UPPER_SNAKE_CASE.
    pub reason: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl ErrorInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [domain][crate::model::ErrorInfo::domain].
    pub fn set_domain<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.domain = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [domain][crate::model::ErrorInfo::domain].
    pub fn set_or_clear_domain<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.domain = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadatas][crate::model::ErrorInfo::metadatas].
    pub fn set_metadatas<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadatas = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [reason][crate::model::ErrorInfo::reason].
    pub fn set_reason<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.reason = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reason][crate::model::ErrorInfo::reason].
    pub fn set_or_clear_reason<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.reason = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl wkt::message::Message for ErrorInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ErrorInfo"
    }
}

/// Represents a textual expression in the Common Expression Language (CEL)
/// syntax. CEL is a C-like expression language. The syntax and semantics of CEL
/// are documented at <https://github.com/google/cel-spec>.
///
/// Example (Comparison):
///
/// ```norust
/// title: "Summary size limit"
/// description: "Determines if a summary is less than 100 chars"
/// expression: "document.summary.size() < 100"
/// ```
///
/// Example (Equality):
///
/// ```norust
/// title: "Requestor is owner"
/// description: "Determines if requestor is the document owner"
/// expression: "document.owner == request.auth.claims.email"
/// ```
///
/// Example (Logic):
///
/// ```norust
/// title: "Public documents"
/// description: "Determine whether the document should be publicly visible"
/// expression: "document.type != 'private' && document.type != 'internal'"
/// ```
///
/// Example (Data Manipulation):
///
/// ```norust
/// title: "Notification string"
/// description: "Create a notification string with a timestamp."
/// expression: "'New message received at ' + string(document.create_time)"
/// ```
///
/// The exact variables and functions that may be referenced within an expression
/// are determined by the service that evaluates it. See the service
/// documentation for additional information.
#[cfg(any(feature = "images", feature = "instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Expr {
    /// Optional. Description of the expression. This is a longer text which
    /// describes the expression, e.g. when hovered over it in a UI.
    pub description: std::option::Option<std::string::String>,

    /// Textual representation of an expression in Common Expression Language
    /// syntax.
    pub expression: std::option::Option<std::string::String>,

    /// Optional. String indicating the location of the expression for error
    /// reporting, e.g. a file name and a position in the file.
    pub location: std::option::Option<std::string::String>,

    /// Optional. Title for the expression, i.e. a short string describing
    /// its purpose. This can be used e.g. in UIs which allow to enter the
    /// expression.
    pub title: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances",))]
impl Expr {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::Expr::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::Expr::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expression][crate::model::Expr::expression].
    pub fn set_expression<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.expression = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expression][crate::model::Expr::expression].
    pub fn set_or_clear_expression<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.expression = v.map(|x| x.into());
        self
    }

    /// Sets the value of [location][crate::model::Expr::location].
    pub fn set_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [location][crate::model::Expr::location].
    pub fn set_or_clear_location<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.location = v.map(|x| x.into());
        self
    }

    /// Sets the value of [title][crate::model::Expr::title].
    pub fn set_title<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.title = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [title][crate::model::Expr::title].
    pub fn set_or_clear_title<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.title = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
impl wkt::message::Message for Expr {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Expr"
    }
}

#[cfg(any(
    feature = "images",
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FileContentBuffer {
    /// The raw content in the secure keys file.
    pub content: std::option::Option<::bytes::Bytes>,

    /// The file type of source file.
    pub file_type: std::option::Option<crate::model::file_content_buffer::FileType>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "images",
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl FileContentBuffer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::FileContentBuffer::content].
    pub fn set_content<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.content = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [content][crate::model::FileContentBuffer::content].
    pub fn set_or_clear_content<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.content = v.map(|x| x.into());
        self
    }

    /// Sets the value of [file_type][crate::model::FileContentBuffer::file_type].
    pub fn set_file_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::file_content_buffer::FileType>,
    {
        self.file_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [file_type][crate::model::FileContentBuffer::file_type].
    pub fn set_or_clear_file_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::file_content_buffer::FileType>,
    {
        self.file_type = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "images",
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for FileContentBuffer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.FileContentBuffer"
    }
}

/// Defines additional types related to [FileContentBuffer].
#[cfg(any(
    feature = "images",
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
pub mod file_content_buffer {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [fileType][google.cloud.compute.v1.FileContentBuffer.fileType] field.
    ///
    /// [google.cloud.compute.v1.FileContentBuffer.fileType]: crate::model::file_content_buffer::FileType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "images",
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FileType {
        Bin,
        Undefined,
        X509,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FileType::value] or
        /// [FileType::name].
        UnknownValue(file_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "images",
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod file_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "images",
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl FileType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Bin => std::option::Option::Some(0),
                Self::Undefined => std::option::Option::Some(1),
                Self::X509 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Bin => std::option::Option::Some("BIN"),
                Self::Undefined => std::option::Option::Some("UNDEFINED"),
                Self::X509 => std::option::Option::Some("X509"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "images",
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for FileType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "images",
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for FileType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "images",
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for FileType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Bin,
                1 => Self::Undefined,
                2 => Self::X509,
                _ => Self::UnknownValue(file_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "images",
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for FileType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BIN" => Self::Bin,
                "UNDEFINED" => Self::Undefined,
                "X509" => Self::X509,
                _ => Self::UnknownValue(file_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "images",
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for FileType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Bin => serializer.serialize_str("BIN"),
                Self::Undefined => serializer.serialize_str("UNDEFINED"),
                Self::X509 => serializer.serialize_str("X509"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "images",
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for FileType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FileType>::new(
                ".google.cloud.compute.v1.FileContentBuffer.fileType",
            ))
        }
    }
}

/// Represents a Firewall Rule resource.
///
/// Firewall rules allow or deny ingress traffic to, and egress traffic from your
/// instances. For more information, readFirewall rules.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Firewall {
    /// The list of ALLOW rules specified by this firewall. Each rule specifies a
    /// protocol and port-range tuple that describes a permitted connection.
    pub allowed: std::vec::Vec<crate::model::firewall::Allowed>,

    /// [Output Only] Creation timestamp inRFC3339
    /// text format.
    pub creation_timestamp: std::option::Option<std::string::String>,

    /// The list of DENY rules specified by this firewall. Each rule specifies a
    /// protocol and port-range tuple that describes a denied connection.
    pub denied: std::vec::Vec<crate::model::firewall::Denied>,

    /// An optional description of this resource. Provide this field when you
    /// create the resource.
    pub description: std::option::Option<std::string::String>,

    /// If destination ranges are specified, the firewall rule applies only to
    /// traffic that has destination IP address in these ranges. These ranges must
    /// be expressed inCIDR format. Both IPv4 and IPv6 are supported.
    pub destination_ranges: std::vec::Vec<std::string::String>,

    /// Direction of traffic to which this firewall applies, either `INGRESS` or
    /// `EGRESS`. The default is `INGRESS`. For `EGRESS` traffic, you cannot
    /// specify the sourceTags fields.
    pub direction: std::option::Option<crate::model::firewall::Direction>,

    /// Denotes whether the firewall rule is disabled. When set to true, the
    /// firewall rule is not enforced and the network behaves as if it did not
    /// exist. If this is unspecified, the firewall rule will be enabled.
    pub disabled: std::option::Option<bool>,

    /// [Output Only] The unique identifier for the resource. This identifier is
    /// defined by the server.
    pub id: std::option::Option<u64>,

    /// [Output Only] Type of the resource. Always compute#firewall
    /// for firewall rules.
    pub kind: std::option::Option<std::string::String>,

    /// This field denotes the logging options for a particular firewall rule. If
    /// logging is enabled, logs will be exported to Cloud Logging.
    pub log_config: std::option::Option<crate::model::FirewallLogConfig>,

    /// Name of the resource; provided by the client when the resource is created.
    /// The name must be 1-63 characters long, and comply withRFC1035.
    /// Specifically, the name must be 1-63 characters long and match the regular
    /// expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character
    /// must be a lowercase letter, and all following characters (except for the
    /// last character) must be a dash, lowercase letter, or digit. The last
    /// character must be a lowercase letter or digit.
    pub name: std::option::Option<std::string::String>,

    /// URL of the network resource for this firewall rule. If not
    /// specified when creating a firewall rule, the default network
    /// is used:
    ///
    /// global/networks/default
    ///
    /// If you choose to specify this field, you can specify the network as a full
    /// or partial URL. For example, the following are all valid URLs:
    ///
    ///
    /// <https://www.googleapis.com/compute/v1/projects/myproject/global/networks/my-network>
    ///
    /// - projects/myproject/global/networks/my-network
    /// - global/networks/default
    pub network: std::option::Option<std::string::String>,

    /// Input only. [Input Only] Additional params passed with the request, but not persisted
    /// as part of resource payload.
    pub params: std::option::Option<crate::model::FirewallParams>,

    /// Priority for this rule.
    /// This is an integer between `0` and `65535`, both inclusive.
    /// The default value is `1000`.
    /// Relative priorities determine which rule takes effect if multiple rules
    /// apply. Lower values indicate higher priority. For example, a rule with
    /// priority `0` has higher precedence than a rule with priority `1`.
    /// DENY rules take precedence over ALLOW rules if they have equal priority.
    /// Note that VPC networks have implied
    /// rules with a priority of `65535`. To avoid conflicts with the implied
    /// rules, use a priority number less than `65535`.
    pub priority: std::option::Option<i32>,

    /// [Output Only] Server-defined URL for the resource.
    pub self_link: std::option::Option<std::string::String>,

    /// If source ranges are specified, the firewall rule applies only to traffic
    /// that has a source IP address in these ranges. These ranges must be
    /// expressed inCIDR format. One or both of sourceRanges
    /// and sourceTags may be set.
    /// If both fields are set, the rule applies to traffic that has a
    /// source IP address within sourceRanges OR a source IP
    /// from a resource with a matching tag listed in thesourceTags field. The connection does not need to match
    /// both fields for the rule to
    /// apply. Both IPv4 and IPv6 are supported.
    pub source_ranges: std::vec::Vec<std::string::String>,

    /// If source service accounts are specified, the firewall rules apply only to
    /// traffic originating from an instance with a service account in this list.
    /// Source service accounts cannot be used to control traffic to an instance's
    /// external IP address because service accounts are associated with an
    /// instance, not an IP address.sourceRanges can be set at the same time assourceServiceAccounts.
    /// If both are set, the firewall applies to traffic that
    /// has a source IP address within the sourceRanges OR a source
    /// IP that belongs to an instance with service account listed insourceServiceAccount. The connection does not need to match
    /// both fields for the firewall to apply.sourceServiceAccounts cannot be used at the same time assourceTags or targetTags.
    pub source_service_accounts: std::vec::Vec<std::string::String>,

    /// If source tags are specified, the firewall rule applies only to traffic
    /// with source IPs that match the primary network interfaces of VM instances
    /// that have the tag and are in the same VPC network.
    /// Source tags cannot be used to control traffic to an instance's external IP
    /// address, it only applies to traffic between instances in the same virtual
    /// network. Because tags are associated with instances, not IP addresses.
    /// One or both of sourceRanges and sourceTags may be
    /// set. If both fields are set, the firewall applies to traffic that has a
    /// source IP address within sourceRanges OR a source IP from a
    /// resource with a matching tag listed in the sourceTags
    /// field. The connection does not need to match both fields for the
    /// firewall to apply.
    pub source_tags: std::vec::Vec<std::string::String>,

    /// A list of service accounts indicating sets of instances located in the
    /// network that may make network connections as specified inallowed[].targetServiceAccounts cannot be used at the same time astargetTags or sourceTags.
    /// If neither targetServiceAccounts nor targetTags
    /// are specified, the firewall rule applies to all instances on the specified
    /// network.
    pub target_service_accounts: std::vec::Vec<std::string::String>,

    /// A list of tags that controls which instances the firewall rule
    /// applies to. If targetTags are specified, then the firewall
    /// rule applies only to instances in the VPC network that have one of those
    /// tags. If no targetTags are specified, the firewall rule
    /// applies to all instances on the specified network.
    pub target_tags: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl Firewall {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowed][crate::model::Firewall::allowed].
    pub fn set_allowed<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::firewall::Allowed>,
    {
        use std::iter::Iterator;
        self.allowed = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [creation_timestamp][crate::model::Firewall::creation_timestamp].
    pub fn set_creation_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_timestamp][crate::model::Firewall::creation_timestamp].
    pub fn set_or_clear_creation_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [denied][crate::model::Firewall::denied].
    pub fn set_denied<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::firewall::Denied>,
    {
        use std::iter::Iterator;
        self.denied = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [description][crate::model::Firewall::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::Firewall::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination_ranges][crate::model::Firewall::destination_ranges].
    pub fn set_destination_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.destination_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [direction][crate::model::Firewall::direction].
    pub fn set_direction<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::firewall::Direction>,
    {
        self.direction = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [direction][crate::model::Firewall::direction].
    pub fn set_or_clear_direction<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::firewall::Direction>,
    {
        self.direction = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disabled][crate::model::Firewall::disabled].
    pub fn set_disabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.disabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disabled][crate::model::Firewall::disabled].
    pub fn set_or_clear_disabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.disabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::Firewall::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::Firewall::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::Firewall::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::Firewall::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [log_config][crate::model::Firewall::log_config].
    pub fn set_log_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FirewallLogConfig>,
    {
        self.log_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [log_config][crate::model::Firewall::log_config].
    pub fn set_or_clear_log_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FirewallLogConfig>,
    {
        self.log_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::Firewall::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::Firewall::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network][crate::model::Firewall::network].
    pub fn set_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network][crate::model::Firewall::network].
    pub fn set_or_clear_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [params][crate::model::Firewall::params].
    pub fn set_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FirewallParams>,
    {
        self.params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [params][crate::model::Firewall::params].
    pub fn set_or_clear_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FirewallParams>,
    {
        self.params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [priority][crate::model::Firewall::priority].
    pub fn set_priority<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.priority = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [priority][crate::model::Firewall::priority].
    pub fn set_or_clear_priority<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.priority = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::Firewall::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::Firewall::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_ranges][crate::model::Firewall::source_ranges].
    pub fn set_source_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.source_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source_service_accounts][crate::model::Firewall::source_service_accounts].
    pub fn set_source_service_accounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.source_service_accounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source_tags][crate::model::Firewall::source_tags].
    pub fn set_source_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.source_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_service_accounts][crate::model::Firewall::target_service_accounts].
    pub fn set_target_service_accounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_service_accounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_tags][crate::model::Firewall::target_tags].
    pub fn set_target_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for Firewall {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Firewall"
    }
}

/// Defines additional types related to [Firewall].
#[cfg(feature = "instances")]
pub mod firewall {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [allowed][google.cloud.compute.v1.Firewall.allowed] field.
    ///
    /// [google.cloud.compute.v1.Firewall.allowed]: crate::model::firewall::Allowed
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Allowed {
        /// The IP protocol to which this rule applies. The protocol type is
        /// required when creating a firewall rule. This value can either be one of the
        /// following well known protocol strings (tcp, udp,icmp, esp, ah, ipip,sctp) or the IP protocol number.
        pub ip_protocol: std::option::Option<std::string::String>,

        /// An optional list of ports to which this rule applies.
        /// This field is only applicable for the UDP or TCP protocol.
        /// Each entry must be either an integer or a range.
        /// If not specified, this rule applies to connections through any port.
        ///
        /// Example inputs include: ["22"], ["80","443"],
        /// and ["12345-12349"].
        pub ports: std::vec::Vec<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl Allowed {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ip_protocol][crate::model::firewall::Allowed::ip_protocol].
        pub fn set_ip_protocol<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.ip_protocol = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [ip_protocol][crate::model::firewall::Allowed::ip_protocol].
        pub fn set_or_clear_ip_protocol<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.ip_protocol = v.map(|x| x.into());
            self
        }

        /// Sets the value of [ports][crate::model::firewall::Allowed::ports].
        pub fn set_ports<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.ports = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "instances")]
    impl wkt::message::Message for Allowed {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.Firewall.allowed"
        }
    }

    /// The message type for the [denied][google.cloud.compute.v1.Firewall.denied] field.
    ///
    /// [google.cloud.compute.v1.Firewall.denied]: crate::model::firewall::Denied
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Denied {
        /// The IP protocol to which this rule applies. The protocol type is
        /// required when creating a firewall rule. This value can either be one of the
        /// following well known protocol strings (tcp, udp,icmp, esp, ah, ipip,sctp) or the IP protocol number.
        pub ip_protocol: std::option::Option<std::string::String>,

        /// An optional list of ports to which this rule applies.
        /// This field is only applicable for the UDP or TCP protocol.
        /// Each entry must be either an integer or a range.
        /// If not specified, this rule applies to connections through any port.
        ///
        /// Example inputs include: ["22"], ["80","443"],
        /// and ["12345-12349"].
        pub ports: std::vec::Vec<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl Denied {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ip_protocol][crate::model::firewall::Denied::ip_protocol].
        pub fn set_ip_protocol<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.ip_protocol = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [ip_protocol][crate::model::firewall::Denied::ip_protocol].
        pub fn set_or_clear_ip_protocol<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.ip_protocol = v.map(|x| x.into());
            self
        }

        /// Sets the value of [ports][crate::model::firewall::Denied::ports].
        pub fn set_ports<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.ports = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "instances")]
    impl wkt::message::Message for Denied {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.Firewall.denied"
        }
    }

    /// The enumerated type for the [direction][google.cloud.compute.v1.Firewall.direction] field.
    ///
    /// [google.cloud.compute.v1.Firewall.direction]: crate::model::firewall::Direction
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Direction {
        /// Indicates that firewall should apply to outgoing traffic.
        Egress,
        /// Indicates that firewall should apply to incoming traffic.
        Ingress,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Direction::value] or
        /// [Direction::name].
        UnknownValue(direction::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod direction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Direction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Egress => std::option::Option::Some(0),
                Self::Ingress => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Egress => std::option::Option::Some("EGRESS"),
                Self::Ingress => std::option::Option::Some("INGRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Direction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Direction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Direction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Egress,
                1 => Self::Ingress,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Direction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EGRESS" => Self::Egress,
                "INGRESS" => Self::Ingress,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Direction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Egress => serializer.serialize_str("EGRESS"),
                Self::Ingress => serializer.serialize_str("INGRESS"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Direction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Direction>::new(
                ".google.cloud.compute.v1.Firewall.direction",
            ))
        }
    }
}

/// The available logging options for a firewall rule.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallLogConfig {
    /// This field denotes whether to enable logging for a particular firewall
    /// rule.
    pub enable: std::option::Option<bool>,

    /// This field can only be specified for a particular firewall rule if
    /// logging is enabled for that rule. This field denotes whether to include
    /// or exclude metadata for firewall logs.
    pub metadata: std::option::Option<crate::model::firewall_log_config::Metadata>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl FirewallLogConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable][crate::model::FirewallLogConfig::enable].
    pub fn set_enable<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable][crate::model::FirewallLogConfig::enable].
    pub fn set_or_clear_enable<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::FirewallLogConfig::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::firewall_log_config::Metadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::FirewallLogConfig::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::firewall_log_config::Metadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for FirewallLogConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.FirewallLogConfig"
    }
}

/// Defines additional types related to [FirewallLogConfig].
#[cfg(feature = "instances")]
pub mod firewall_log_config {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [metadata][google.cloud.compute.v1.FirewallLogConfig.metadata] field.
    ///
    /// [google.cloud.compute.v1.FirewallLogConfig.metadata]: crate::model::firewall_log_config::Metadata
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Metadata {
        ExcludeAllMetadata,
        IncludeAllMetadata,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Metadata::value] or
        /// [Metadata::name].
        UnknownValue(metadata::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod metadata {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Metadata {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::ExcludeAllMetadata => std::option::Option::Some(0),
                Self::IncludeAllMetadata => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::ExcludeAllMetadata => std::option::Option::Some("EXCLUDE_ALL_METADATA"),
                Self::IncludeAllMetadata => std::option::Option::Some("INCLUDE_ALL_METADATA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Metadata {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Metadata {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Metadata {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::ExcludeAllMetadata,
                1 => Self::IncludeAllMetadata,
                _ => Self::UnknownValue(metadata::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Metadata {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXCLUDE_ALL_METADATA" => Self::ExcludeAllMetadata,
                "INCLUDE_ALL_METADATA" => Self::IncludeAllMetadata,
                _ => Self::UnknownValue(metadata::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Metadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::ExcludeAllMetadata => serializer.serialize_str("EXCLUDE_ALL_METADATA"),
                Self::IncludeAllMetadata => serializer.serialize_str("INCLUDE_ALL_METADATA"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Metadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Metadata>::new(
                ".google.cloud.compute.v1.FirewallLogConfig.metadata",
            ))
        }
    }
}

/// Additional firewall parameters.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallParams {
    /// Tag keys/values directly bound to this resource.
    /// Tag keys and values have the same definition as resource
    /// manager tags. The field is allowed for INSERT
    /// only. The keys/values to set on the resource should be specified in
    /// either ID { : } or Namespaced format
    /// { : }.
    /// For example the following are valid inputs:
    ///
    /// * {"tagKeys/333" : "tagValues/444", "tagKeys/123" : "tagValues/456"}
    /// * {"123/environment" : "production", "345/abc" : "xyz"}
    ///   Note:
    /// * Invalid combinations of ID & namespaced format is not supported. For
    ///   instance: {"123/environment" : "tagValues/444"} is invalid.
    pub resource_manager_tags: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl FirewallParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_manager_tags][crate::model::FirewallParams::resource_manager_tags].
    pub fn set_resource_manager_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_manager_tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for FirewallParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.FirewallParams"
    }
}

/// Represents a rule that describes one or more match conditions along with
/// the action to be taken when traffic matches this condition (allow or deny).
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallPolicyRule {
    /// The Action to perform when the client connection triggers the rule.
    /// Valid actions for firewall rules are: "allow", "deny",
    /// "apply_security_profile_group" and "goto_next".
    /// Valid actions for packet mirroring rules are: "mirror", "do_not_mirror"
    /// and "goto_next".
    pub action: std::option::Option<std::string::String>,

    /// An optional description for this resource.
    pub description: std::option::Option<std::string::String>,

    /// The direction in which this rule applies.
    pub direction: std::option::Option<crate::model::firewall_policy_rule::Direction>,

    /// Denotes whether the firewall policy rule is disabled. When set to true,
    /// the firewall policy rule is not enforced and traffic behaves as if it did
    /// not exist. If this is unspecified, the firewall policy rule will be
    /// enabled.
    pub disabled: std::option::Option<bool>,

    /// Denotes whether to enable logging for a particular rule. If logging is
    /// enabled, logs will be exported to the configured export destination in
    /// Stackdriver. Logs may be exported to BigQuery or Pub/Sub. Note: you
    /// cannot enable logging on "goto_next" rules.
    pub enable_logging: std::option::Option<bool>,

    /// [Output only] Type of the resource. Returnscompute#firewallPolicyRule for firewall rules andcompute#packetMirroringRule for packet mirroring rules.
    pub kind: std::option::Option<std::string::String>,

    /// A match condition that incoming traffic is evaluated against.
    /// If it evaluates to true, the corresponding 'action' is enforced.
    pub r#match: std::option::Option<crate::model::FirewallPolicyRuleMatcher>,

    /// An integer indicating the priority of a rule in the list. The priority
    /// must be a positive value between 0 and 2147483647.
    /// Rules are evaluated from highest to lowest priority where 0 is the
    /// highest priority and 2147483647 is the lowest priority.
    pub priority: std::option::Option<i32>,

    /// An optional name for the rule. This field is not a unique identifier
    /// and can be updated.
    pub rule_name: std::option::Option<std::string::String>,

    /// [Output Only] Calculation of the complexity of a single firewall policy
    /// rule.
    pub rule_tuple_count: std::option::Option<i32>,

    /// A fully-qualified URL of a SecurityProfile resource instance.
    /// Example:
    /// <https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group>
    /// Must be specified if action is one of 'apply_security_profile_group' or
    /// 'mirror'. Cannot be specified for other actions.
    pub security_profile_group: std::option::Option<std::string::String>,

    /// A list of network resource URLs to which this rule applies.  This field
    /// allows you to control which network's VMs get this rule.  If this field
    /// is left blank, all VMs within the organization will receive the rule.
    pub target_resources: std::vec::Vec<std::string::String>,

    /// A list of secure tags that controls which instances the firewall rule
    /// applies to. If targetSecureTag are specified, then the
    /// firewall rule applies only to instances in the VPC network that have one
    /// of those EFFECTIVE secure tags, if all the target_secure_tag are in
    /// INEFFECTIVE state, then this rule will be ignored.targetSecureTag may not be set at the same time astargetServiceAccounts.
    /// If neither targetServiceAccounts nortargetSecureTag are specified, the firewall rule applies
    /// to all instances on the specified network.
    /// Maximum number of target label tags allowed is 256.
    pub target_secure_tags: std::vec::Vec<crate::model::FirewallPolicyRuleSecureTag>,

    /// A list of service accounts indicating the sets of instances that are
    /// applied with this rule.
    pub target_service_accounts: std::vec::Vec<std::string::String>,

    /// Boolean flag indicating if the traffic should be TLS decrypted.
    /// Can be set only if action = 'apply_security_profile_group' and cannot
    /// be set for other actions.
    pub tls_inspect: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl FirewallPolicyRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [action][crate::model::FirewallPolicyRule::action].
    pub fn set_action<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.action = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [action][crate::model::FirewallPolicyRule::action].
    pub fn set_or_clear_action<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.action = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::FirewallPolicyRule::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::FirewallPolicyRule::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [direction][crate::model::FirewallPolicyRule::direction].
    pub fn set_direction<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::firewall_policy_rule::Direction>,
    {
        self.direction = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [direction][crate::model::FirewallPolicyRule::direction].
    pub fn set_or_clear_direction<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::firewall_policy_rule::Direction>,
    {
        self.direction = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disabled][crate::model::FirewallPolicyRule::disabled].
    pub fn set_disabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.disabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disabled][crate::model::FirewallPolicyRule::disabled].
    pub fn set_or_clear_disabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.disabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_logging][crate::model::FirewallPolicyRule::enable_logging].
    pub fn set_enable_logging<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_logging = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_logging][crate::model::FirewallPolicyRule::enable_logging].
    pub fn set_or_clear_enable_logging<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_logging = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::FirewallPolicyRule::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::FirewallPolicyRule::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#match][crate::model::FirewallPolicyRule::match].
    pub fn set_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicyRuleMatcher>,
    {
        self.r#match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#match][crate::model::FirewallPolicyRule::match].
    pub fn set_or_clear_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicyRuleMatcher>,
    {
        self.r#match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [priority][crate::model::FirewallPolicyRule::priority].
    pub fn set_priority<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.priority = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [priority][crate::model::FirewallPolicyRule::priority].
    pub fn set_or_clear_priority<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.priority = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rule_name][crate::model::FirewallPolicyRule::rule_name].
    pub fn set_rule_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.rule_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rule_name][crate::model::FirewallPolicyRule::rule_name].
    pub fn set_or_clear_rule_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.rule_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rule_tuple_count][crate::model::FirewallPolicyRule::rule_tuple_count].
    pub fn set_rule_tuple_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.rule_tuple_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rule_tuple_count][crate::model::FirewallPolicyRule::rule_tuple_count].
    pub fn set_or_clear_rule_tuple_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.rule_tuple_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [security_profile_group][crate::model::FirewallPolicyRule::security_profile_group].
    pub fn set_security_profile_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.security_profile_group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [security_profile_group][crate::model::FirewallPolicyRule::security_profile_group].
    pub fn set_or_clear_security_profile_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.security_profile_group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_resources][crate::model::FirewallPolicyRule::target_resources].
    pub fn set_target_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_secure_tags][crate::model::FirewallPolicyRule::target_secure_tags].
    pub fn set_target_secure_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallPolicyRuleSecureTag>,
    {
        use std::iter::Iterator;
        self.target_secure_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_service_accounts][crate::model::FirewallPolicyRule::target_service_accounts].
    pub fn set_target_service_accounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_service_accounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tls_inspect][crate::model::FirewallPolicyRule::tls_inspect].
    pub fn set_tls_inspect<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.tls_inspect = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tls_inspect][crate::model::FirewallPolicyRule::tls_inspect].
    pub fn set_or_clear_tls_inspect<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.tls_inspect = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for FirewallPolicyRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.FirewallPolicyRule"
    }
}

/// Defines additional types related to [FirewallPolicyRule].
#[cfg(feature = "instances")]
pub mod firewall_policy_rule {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [direction][google.cloud.compute.v1.FirewallPolicyRule.direction] field.
    ///
    /// [google.cloud.compute.v1.FirewallPolicyRule.direction]: crate::model::firewall_policy_rule::Direction
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Direction {
        Egress,
        Ingress,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Direction::value] or
        /// [Direction::name].
        UnknownValue(direction::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod direction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Direction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Egress => std::option::Option::Some(0),
                Self::Ingress => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Egress => std::option::Option::Some("EGRESS"),
                Self::Ingress => std::option::Option::Some("INGRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Direction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Direction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Direction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Egress,
                1 => Self::Ingress,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Direction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EGRESS" => Self::Egress,
                "INGRESS" => Self::Ingress,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Direction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Egress => serializer.serialize_str("EGRESS"),
                Self::Ingress => serializer.serialize_str("INGRESS"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Direction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Direction>::new(
                ".google.cloud.compute.v1.FirewallPolicyRule.direction",
            ))
        }
    }
}

/// Represents a match condition that incoming traffic is evaluated against.
/// Exactly one field must be specified.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallPolicyRuleMatcher {
    /// Address groups which should be matched against the traffic destination.
    /// Maximum number of destination address groups is 10.
    pub dest_address_groups: std::vec::Vec<std::string::String>,

    /// Fully Qualified Domain Name (FQDN) which should be matched against
    /// traffic destination.
    /// Maximum number of destination fqdn allowed is 100.
    pub dest_fqdns: std::vec::Vec<std::string::String>,

    /// CIDR IP address range.
    /// Maximum number of destination CIDR IP ranges allowed is 5000.
    pub dest_ip_ranges: std::vec::Vec<std::string::String>,

    /// Network type of the traffic destination. Allowed values are:
    ///
    /// ```norust
    ///  - UNSPECIFIED
    ///  - INTERNET
    ///  - NON_INTERNET
    /// ```
    pub dest_network_type:
        std::option::Option<crate::model::firewall_policy_rule_matcher::DestNetworkType>,

    /// Region codes whose IP addresses will be used to match for destination
    /// of traffic. Should be specified as 2 letter country code defined as per
    /// ISO 3166 alpha-2 country codes. ex."US"
    /// Maximum number of dest region codes allowed is 5000.
    pub dest_region_codes: std::vec::Vec<std::string::String>,

    /// Names of Network Threat Intelligence lists.
    /// The IPs in these lists will be matched against traffic destination.
    pub dest_threat_intelligences: std::vec::Vec<std::string::String>,

    /// Pairs of IP protocols and ports that the rule should match.
    pub layer_4_configs: std::vec::Vec<crate::model::FirewallPolicyRuleMatcherLayer4Config>,

    /// Address groups which should be matched against the traffic source.
    /// Maximum number of source address groups is 10.
    pub src_address_groups: std::vec::Vec<std::string::String>,

    /// Fully Qualified Domain Name (FQDN) which should be matched against
    /// traffic source.
    /// Maximum number of source fqdn allowed is 100.
    pub src_fqdns: std::vec::Vec<std::string::String>,

    /// CIDR IP address range.
    /// Maximum number of source CIDR IP ranges allowed is 5000.
    pub src_ip_ranges: std::vec::Vec<std::string::String>,

    /// Network type of the traffic source. Allowed values are:
    ///
    /// ```norust
    ///  - UNSPECIFIED
    ///  - INTERNET
    ///  - INTRA_VPC
    ///  - NON_INTERNET
    ///  - VPC_NETWORKS
    /// ```
    pub src_network_type:
        std::option::Option<crate::model::firewall_policy_rule_matcher::SrcNetworkType>,

    /// Networks of the traffic source. It can be either a full or partial url.
    pub src_networks: std::vec::Vec<std::string::String>,

    /// Region codes whose IP addresses will be used to match for source
    /// of traffic. Should be specified as 2 letter country code defined as per
    /// ISO 3166 alpha-2 country codes. ex."US"
    /// Maximum number of source region codes allowed is 5000.
    pub src_region_codes: std::vec::Vec<std::string::String>,

    /// List of secure tag values, which should be matched at the source
    /// of the traffic.
    /// For INGRESS rule, if all the srcSecureTag are INEFFECTIVE,
    /// and there is no srcIpRange, this rule will be ignored.
    /// Maximum number of source tag values allowed is 256.
    pub src_secure_tags: std::vec::Vec<crate::model::FirewallPolicyRuleSecureTag>,

    /// Names of Network Threat Intelligence lists.
    /// The IPs in these lists will be matched against traffic source.
    pub src_threat_intelligences: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl FirewallPolicyRuleMatcher {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dest_address_groups][crate::model::FirewallPolicyRuleMatcher::dest_address_groups].
    pub fn set_dest_address_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dest_address_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dest_fqdns][crate::model::FirewallPolicyRuleMatcher::dest_fqdns].
    pub fn set_dest_fqdns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dest_fqdns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dest_ip_ranges][crate::model::FirewallPolicyRuleMatcher::dest_ip_ranges].
    pub fn set_dest_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dest_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dest_network_type][crate::model::FirewallPolicyRuleMatcher::dest_network_type].
    pub fn set_dest_network_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::firewall_policy_rule_matcher::DestNetworkType>,
    {
        self.dest_network_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dest_network_type][crate::model::FirewallPolicyRuleMatcher::dest_network_type].
    pub fn set_or_clear_dest_network_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::firewall_policy_rule_matcher::DestNetworkType>,
    {
        self.dest_network_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dest_region_codes][crate::model::FirewallPolicyRuleMatcher::dest_region_codes].
    pub fn set_dest_region_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dest_region_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dest_threat_intelligences][crate::model::FirewallPolicyRuleMatcher::dest_threat_intelligences].
    pub fn set_dest_threat_intelligences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dest_threat_intelligences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [layer_4_configs][crate::model::FirewallPolicyRuleMatcher::layer_4_configs].
    pub fn set_layer_4_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallPolicyRuleMatcherLayer4Config>,
    {
        use std::iter::Iterator;
        self.layer_4_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [src_address_groups][crate::model::FirewallPolicyRuleMatcher::src_address_groups].
    pub fn set_src_address_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.src_address_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [src_fqdns][crate::model::FirewallPolicyRuleMatcher::src_fqdns].
    pub fn set_src_fqdns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.src_fqdns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [src_ip_ranges][crate::model::FirewallPolicyRuleMatcher::src_ip_ranges].
    pub fn set_src_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.src_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [src_network_type][crate::model::FirewallPolicyRuleMatcher::src_network_type].
    pub fn set_src_network_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::firewall_policy_rule_matcher::SrcNetworkType>,
    {
        self.src_network_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [src_network_type][crate::model::FirewallPolicyRuleMatcher::src_network_type].
    pub fn set_or_clear_src_network_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::firewall_policy_rule_matcher::SrcNetworkType>,
    {
        self.src_network_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [src_networks][crate::model::FirewallPolicyRuleMatcher::src_networks].
    pub fn set_src_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.src_networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [src_region_codes][crate::model::FirewallPolicyRuleMatcher::src_region_codes].
    pub fn set_src_region_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.src_region_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [src_secure_tags][crate::model::FirewallPolicyRuleMatcher::src_secure_tags].
    pub fn set_src_secure_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallPolicyRuleSecureTag>,
    {
        use std::iter::Iterator;
        self.src_secure_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [src_threat_intelligences][crate::model::FirewallPolicyRuleMatcher::src_threat_intelligences].
    pub fn set_src_threat_intelligences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.src_threat_intelligences = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for FirewallPolicyRuleMatcher {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.FirewallPolicyRuleMatcher"
    }
}

/// Defines additional types related to [FirewallPolicyRuleMatcher].
#[cfg(feature = "instances")]
pub mod firewall_policy_rule_matcher {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [destNetworkType][google.cloud.compute.v1.FirewallPolicyRuleMatcher.destNetworkType] field.
    ///
    /// [google.cloud.compute.v1.FirewallPolicyRuleMatcher.destNetworkType]: crate::model::firewall_policy_rule_matcher::DestNetworkType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DestNetworkType {
        Internet,
        IntraVpc,
        NonInternet,
        Unspecified,
        VpcNetworks,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DestNetworkType::value] or
        /// [DestNetworkType::name].
        UnknownValue(dest_network_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod dest_network_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl DestNetworkType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Internet => std::option::Option::Some(0),
                Self::IntraVpc => std::option::Option::Some(1),
                Self::NonInternet => std::option::Option::Some(2),
                Self::Unspecified => std::option::Option::Some(3),
                Self::VpcNetworks => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Internet => std::option::Option::Some("INTERNET"),
                Self::IntraVpc => std::option::Option::Some("INTRA_VPC"),
                Self::NonInternet => std::option::Option::Some("NON_INTERNET"),
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::VpcNetworks => std::option::Option::Some("VPC_NETWORKS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for DestNetworkType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for DestNetworkType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for DestNetworkType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Internet,
                1 => Self::IntraVpc,
                2 => Self::NonInternet,
                3 => Self::Unspecified,
                4 => Self::VpcNetworks,
                _ => Self::UnknownValue(dest_network_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for DestNetworkType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INTERNET" => Self::Internet,
                "INTRA_VPC" => Self::IntraVpc,
                "NON_INTERNET" => Self::NonInternet,
                "UNSPECIFIED" => Self::Unspecified,
                "VPC_NETWORKS" => Self::VpcNetworks,
                _ => Self::UnknownValue(dest_network_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for DestNetworkType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Internet => serializer.serialize_str("INTERNET"),
                Self::IntraVpc => serializer.serialize_str("INTRA_VPC"),
                Self::NonInternet => serializer.serialize_str("NON_INTERNET"),
                Self::Unspecified => serializer.serialize_str("UNSPECIFIED"),
                Self::VpcNetworks => serializer.serialize_str("VPC_NETWORKS"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for DestNetworkType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DestNetworkType>::new(
                ".google.cloud.compute.v1.FirewallPolicyRuleMatcher.destNetworkType",
            ))
        }
    }

    /// The enumerated type for the [srcNetworkType][google.cloud.compute.v1.FirewallPolicyRuleMatcher.srcNetworkType] field.
    ///
    /// [google.cloud.compute.v1.FirewallPolicyRuleMatcher.srcNetworkType]: crate::model::firewall_policy_rule_matcher::SrcNetworkType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SrcNetworkType {
        Internet,
        IntraVpc,
        NonInternet,
        Unspecified,
        VpcNetworks,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SrcNetworkType::value] or
        /// [SrcNetworkType::name].
        UnknownValue(src_network_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod src_network_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl SrcNetworkType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Internet => std::option::Option::Some(0),
                Self::IntraVpc => std::option::Option::Some(1),
                Self::NonInternet => std::option::Option::Some(2),
                Self::Unspecified => std::option::Option::Some(3),
                Self::VpcNetworks => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Internet => std::option::Option::Some("INTERNET"),
                Self::IntraVpc => std::option::Option::Some("INTRA_VPC"),
                Self::NonInternet => std::option::Option::Some("NON_INTERNET"),
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::VpcNetworks => std::option::Option::Some("VPC_NETWORKS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for SrcNetworkType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for SrcNetworkType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for SrcNetworkType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Internet,
                1 => Self::IntraVpc,
                2 => Self::NonInternet,
                3 => Self::Unspecified,
                4 => Self::VpcNetworks,
                _ => Self::UnknownValue(src_network_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for SrcNetworkType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INTERNET" => Self::Internet,
                "INTRA_VPC" => Self::IntraVpc,
                "NON_INTERNET" => Self::NonInternet,
                "UNSPECIFIED" => Self::Unspecified,
                "VPC_NETWORKS" => Self::VpcNetworks,
                _ => Self::UnknownValue(src_network_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for SrcNetworkType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Internet => serializer.serialize_str("INTERNET"),
                Self::IntraVpc => serializer.serialize_str("INTRA_VPC"),
                Self::NonInternet => serializer.serialize_str("NON_INTERNET"),
                Self::Unspecified => serializer.serialize_str("UNSPECIFIED"),
                Self::VpcNetworks => serializer.serialize_str("VPC_NETWORKS"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for SrcNetworkType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SrcNetworkType>::new(
                ".google.cloud.compute.v1.FirewallPolicyRuleMatcher.srcNetworkType",
            ))
        }
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallPolicyRuleMatcherLayer4Config {
    /// The IP protocol to which this rule applies. The protocol type is
    /// required when creating a firewall rule. This value can either be
    /// one of the following well known protocol strings (tcp,udp, icmp, esp,ah, ipip, sctp), or the IP
    /// protocol number.
    pub ip_protocol: std::option::Option<std::string::String>,

    /// An optional list of ports to which this rule applies. This field is
    /// only applicable for UDP or TCP protocol. Each entry must be either
    /// an integer or a range. If not specified, this rule applies to
    /// connections through any port.
    ///
    /// Example inputs include: ["22"],["80","443"], and ["12345-12349"].
    pub ports: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl FirewallPolicyRuleMatcherLayer4Config {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip_protocol][crate::model::FirewallPolicyRuleMatcherLayer4Config::ip_protocol].
    pub fn set_ip_protocol<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ip_protocol = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ip_protocol][crate::model::FirewallPolicyRuleMatcherLayer4Config::ip_protocol].
    pub fn set_or_clear_ip_protocol<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ip_protocol = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ports][crate::model::FirewallPolicyRuleMatcherLayer4Config::ports].
    pub fn set_ports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ports = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for FirewallPolicyRuleMatcherLayer4Config {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.FirewallPolicyRuleMatcherLayer4Config"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallPolicyRuleSecureTag {
    /// Name of the secure tag, created with TagManager's TagValue API.
    pub name: std::option::Option<std::string::String>,

    /// [Output Only] State of the secure tag, either `EFFECTIVE` or
    /// `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted
    /// or its network is deleted.
    pub state: std::option::Option<crate::model::firewall_policy_rule_secure_tag::State>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl FirewallPolicyRuleSecureTag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FirewallPolicyRuleSecureTag::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::FirewallPolicyRuleSecureTag::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::FirewallPolicyRuleSecureTag::state].
    pub fn set_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::firewall_policy_rule_secure_tag::State>,
    {
        self.state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state][crate::model::FirewallPolicyRuleSecureTag::state].
    pub fn set_or_clear_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::firewall_policy_rule_secure_tag::State>,
    {
        self.state = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for FirewallPolicyRuleSecureTag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.FirewallPolicyRuleSecureTag"
    }
}

/// Defines additional types related to [FirewallPolicyRuleSecureTag].
#[cfg(feature = "instances")]
pub mod firewall_policy_rule_secure_tag {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [state][google.cloud.compute.v1.FirewallPolicyRuleSecureTag.state] field.
    ///
    /// [google.cloud.compute.v1.FirewallPolicyRuleSecureTag.state]: crate::model::firewall_policy_rule_secure_tag::State
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        Effective,
        Ineffective,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Effective => std::option::Option::Some(0),
                Self::Ineffective => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Effective => std::option::Option::Some("EFFECTIVE"),
                Self::Ineffective => std::option::Option::Some("INEFFECTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Effective,
                1 => Self::Ineffective,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EFFECTIVE" => Self::Effective,
                "INEFFECTIVE" => Self::Ineffective,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Effective => serializer.serialize_str("EFFECTIVE"),
                Self::Ineffective => serializer.serialize_str("INEFFECTIVE"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.compute.v1.FirewallPolicyRuleSecureTag.state",
            ))
        }
    }
}

/// Encapsulates numeric value that can be either absolute or relative.
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FixedOrPercent {
    /// [Output Only] Absolute value of VM instances calculated based on the
    /// specific mode.
    ///
    /// ```norust
    /// - If the value is fixed, then the calculated
    ///  value is equal to the fixed value.
    /// - If the value is a percent, then the
    /// calculated
    ///  value is percent/100 * targetSize. For example,
    ///  the calculated value of a 80% of a managed instance group
    ///  with 150 instances would be (80/100 * 150) = 120 VM instances. If there
    ///  is a remainder, the number is rounded.
    /// ```
    pub calculated: std::option::Option<i32>,

    /// Specifies a fixed number of VM instances. This must be a positive integer.
    pub fixed: std::option::Option<i32>,

    /// Specifies a percentage of instances between 0 to 100%, inclusive. For
    /// example, specify 80 for 80%.
    pub percent: std::option::Option<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl FixedOrPercent {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [calculated][crate::model::FixedOrPercent::calculated].
    pub fn set_calculated<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.calculated = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [calculated][crate::model::FixedOrPercent::calculated].
    pub fn set_or_clear_calculated<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.calculated = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fixed][crate::model::FixedOrPercent::fixed].
    pub fn set_fixed<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.fixed = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fixed][crate::model::FixedOrPercent::fixed].
    pub fn set_or_clear_fixed<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.fixed = v.map(|x| x.into());
        self
    }

    /// Sets the value of [percent][crate::model::FixedOrPercent::percent].
    pub fn set_percent<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.percent = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [percent][crate::model::FixedOrPercent::percent].
    pub fn set_or_clear_percent<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.percent = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for FixedOrPercent {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.FixedOrPercent"
    }
}

#[cfg(feature = "images")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GlobalSetLabelsRequest {
    /// The fingerprint of the previous set of labels for this resource,
    /// used to detect conflicts. The fingerprint is initially generated by Compute
    /// Engine and changes after every request to modify or update labels. You must
    /// always provide an up-to-date fingerprint hash when updating or changing
    /// labels, otherwise the request will fail with error412 conditionNotMet.  Make a get() request to the
    /// resource to get the latest fingerprint.
    pub label_fingerprint: std::option::Option<::bytes::Bytes>,

    /// A list of labels to apply for this resource. Each label must comply with
    /// the
    /// requirements for labels. For example,"webserver-frontend": "images". A label value can also be
    /// empty (e.g. "my-label": "").
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "images")]
impl GlobalSetLabelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [label_fingerprint][crate::model::GlobalSetLabelsRequest::label_fingerprint].
    pub fn set_label_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.label_fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [label_fingerprint][crate::model::GlobalSetLabelsRequest::label_fingerprint].
    pub fn set_or_clear_label_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.label_fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::GlobalSetLabelsRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "images")]
impl wkt::message::Message for GlobalSetLabelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.GlobalSetLabelsRequest"
    }
}

#[cfg(feature = "images")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GlobalSetPolicyRequest {
    /// Flatten Policy to create a backward compatible wire-format.
    /// Deprecated. Use 'policy' to specify bindings.
    pub bindings: std::vec::Vec<crate::model::Binding>,

    /// Flatten Policy to create a backward compatible wire-format.
    /// Deprecated. Use 'policy' to specify the etag.
    pub etag: std::option::Option<::bytes::Bytes>,

    /// REQUIRED: The complete policy to be applied to the 'resource'. The size of
    /// the policy is limited to a few 10s of KB. An empty policy is in general a
    /// valid policy but certain services (like Projects) might reject them.
    pub policy: std::option::Option<crate::model::Policy>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "images")]
impl GlobalSetPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bindings][crate::model::GlobalSetPolicyRequest::bindings].
    pub fn set_bindings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Binding>,
    {
        use std::iter::Iterator;
        self.bindings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [etag][crate::model::GlobalSetPolicyRequest::etag].
    pub fn set_etag<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.etag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [etag][crate::model::GlobalSetPolicyRequest::etag].
    pub fn set_or_clear_etag<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.etag = v.map(|x| x.into());
        self
    }

    /// Sets the value of [policy][crate::model::GlobalSetPolicyRequest::policy].
    pub fn set_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Policy>,
    {
        self.policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy][crate::model::GlobalSetPolicyRequest::policy].
    pub fn set_or_clear_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Policy>,
    {
        self.policy = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "images")]
impl wkt::message::Message for GlobalSetPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.GlobalSetPolicyRequest"
    }
}

/// A guest attributes entry.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GuestAttributes {
    /// [Output Only] Type of the resource. Alwayscompute#guestAttributes for guest attributes entry.
    pub kind: std::option::Option<std::string::String>,

    /// The path to be queried. This can be the default namespace ('') or a
    /// nested namespace ('\/') or a specified key
    /// ('\/\').
    pub query_path: std::option::Option<std::string::String>,

    /// [Output Only] The value of the requested queried path.
    pub query_value: std::option::Option<crate::model::GuestAttributesValue>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// The key to search for.
    pub variable_key: std::option::Option<std::string::String>,

    /// [Output Only] The value found for the requested key.
    pub variable_value: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl GuestAttributes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::GuestAttributes::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::GuestAttributes::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query_path][crate::model::GuestAttributes::query_path].
    pub fn set_query_path<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.query_path = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_path][crate::model::GuestAttributes::query_path].
    pub fn set_or_clear_query_path<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.query_path = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query_value][crate::model::GuestAttributes::query_value].
    pub fn set_query_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GuestAttributesValue>,
    {
        self.query_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_value][crate::model::GuestAttributes::query_value].
    pub fn set_or_clear_query_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GuestAttributesValue>,
    {
        self.query_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::GuestAttributes::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::GuestAttributes::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [variable_key][crate::model::GuestAttributes::variable_key].
    pub fn set_variable_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.variable_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [variable_key][crate::model::GuestAttributes::variable_key].
    pub fn set_or_clear_variable_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.variable_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [variable_value][crate::model::GuestAttributes::variable_value].
    pub fn set_variable_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.variable_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [variable_value][crate::model::GuestAttributes::variable_value].
    pub fn set_or_clear_variable_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.variable_value = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for GuestAttributes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.GuestAttributes"
    }
}

/// A guest attributes namespace/key/value entry.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GuestAttributesEntry {
    /// Key for the guest attribute entry.
    pub key: std::option::Option<std::string::String>,

    /// Namespace for the guest attribute entry.
    pub namespace: std::option::Option<std::string::String>,

    /// Value for the guest attribute entry.
    pub value: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl GuestAttributesEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::GuestAttributesEntry::key].
    pub fn set_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key][crate::model::GuestAttributesEntry::key].
    pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [namespace][crate::model::GuestAttributesEntry::namespace].
    pub fn set_namespace<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.namespace = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [namespace][crate::model::GuestAttributesEntry::namespace].
    pub fn set_or_clear_namespace<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.namespace = v.map(|x| x.into());
        self
    }

    /// Sets the value of [value][crate::model::GuestAttributesEntry::value].
    pub fn set_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [value][crate::model::GuestAttributesEntry::value].
    pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.value = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for GuestAttributesEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.GuestAttributesEntry"
    }
}

/// Array of guest attribute namespace/key/value tuples.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GuestAttributesValue {
    pub items: std::vec::Vec<crate::model::GuestAttributesEntry>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl GuestAttributesValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [items][crate::model::GuestAttributesValue::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GuestAttributesEntry>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for GuestAttributesValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.GuestAttributesValue"
    }
}

/// Guest OS features.
#[cfg(any(
    feature = "images",
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GuestOsFeature {
    /// The ID of a supported feature. To add multiple values, use commas to
    /// separate values. Set to one or more of the following values:
    ///
    /// - VIRTIO_SCSI_MULTIQUEUE
    /// - WINDOWS
    /// - MULTI_IP_SUBNET
    /// - UEFI_COMPATIBLE
    /// - GVNIC
    /// - SEV_CAPABLE
    /// - SUSPEND_RESUME_COMPATIBLE
    /// - SEV_LIVE_MIGRATABLE_V2
    /// - SEV_SNP_CAPABLE
    /// - TDX_CAPABLE
    /// - IDPF
    /// - SNP_SVSM_CAPABLE
    ///
    /// For more information, see
    /// Enabling guest operating system features.
    pub r#type: std::option::Option<crate::model::guest_os_feature::Type>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "images",
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl GuestOsFeature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::GuestOsFeature::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::guest_os_feature::Type>,
    {
        self.r#type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#type][crate::model::GuestOsFeature::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::guest_os_feature::Type>,
    {
        self.r#type = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "images",
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for GuestOsFeature {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.GuestOsFeature"
    }
}

/// Defines additional types related to [GuestOsFeature].
#[cfg(any(
    feature = "images",
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
pub mod guest_os_feature {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [type][google.cloud.compute.v1.GuestOsFeature.type] field.
    ///
    /// [google.cloud.compute.v1.GuestOsFeature.type]: crate::model::guest_os_feature::Type
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "images",
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        BareMetalLinuxCompatible,
        FeatureTypeUnspecified,
        Gvnic,
        Idpf,
        MultiIpSubnet,
        SecureBoot,
        SevCapable,
        SevLiveMigratable,
        SevLiveMigratableV2,
        SevSnpCapable,
        SnpSvsmCapable,
        TdxCapable,
        UefiCompatible,
        VirtioScsiMultiqueue,
        Windows,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "images",
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "images",
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::BareMetalLinuxCompatible => std::option::Option::Some(0),
                Self::FeatureTypeUnspecified => std::option::Option::Some(1),
                Self::Gvnic => std::option::Option::Some(2),
                Self::Idpf => std::option::Option::Some(3),
                Self::MultiIpSubnet => std::option::Option::Some(4),
                Self::SecureBoot => std::option::Option::Some(5),
                Self::SevCapable => std::option::Option::Some(6),
                Self::SevLiveMigratable => std::option::Option::Some(7),
                Self::SevLiveMigratableV2 => std::option::Option::Some(8),
                Self::SevSnpCapable => std::option::Option::Some(9),
                Self::SnpSvsmCapable => std::option::Option::Some(10),
                Self::TdxCapable => std::option::Option::Some(11),
                Self::UefiCompatible => std::option::Option::Some(12),
                Self::VirtioScsiMultiqueue => std::option::Option::Some(13),
                Self::Windows => std::option::Option::Some(14),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::BareMetalLinuxCompatible => {
                    std::option::Option::Some("BARE_METAL_LINUX_COMPATIBLE")
                }
                Self::FeatureTypeUnspecified => {
                    std::option::Option::Some("FEATURE_TYPE_UNSPECIFIED")
                }
                Self::Gvnic => std::option::Option::Some("GVNIC"),
                Self::Idpf => std::option::Option::Some("IDPF"),
                Self::MultiIpSubnet => std::option::Option::Some("MULTI_IP_SUBNET"),
                Self::SecureBoot => std::option::Option::Some("SECURE_BOOT"),
                Self::SevCapable => std::option::Option::Some("SEV_CAPABLE"),
                Self::SevLiveMigratable => std::option::Option::Some("SEV_LIVE_MIGRATABLE"),
                Self::SevLiveMigratableV2 => std::option::Option::Some("SEV_LIVE_MIGRATABLE_V2"),
                Self::SevSnpCapable => std::option::Option::Some("SEV_SNP_CAPABLE"),
                Self::SnpSvsmCapable => std::option::Option::Some("SNP_SVSM_CAPABLE"),
                Self::TdxCapable => std::option::Option::Some("TDX_CAPABLE"),
                Self::UefiCompatible => std::option::Option::Some("UEFI_COMPATIBLE"),
                Self::VirtioScsiMultiqueue => std::option::Option::Some("VIRTIO_SCSI_MULTIQUEUE"),
                Self::Windows => std::option::Option::Some("WINDOWS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "images",
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "images",
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "images",
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::BareMetalLinuxCompatible,
                1 => Self::FeatureTypeUnspecified,
                2 => Self::Gvnic,
                3 => Self::Idpf,
                4 => Self::MultiIpSubnet,
                5 => Self::SecureBoot,
                6 => Self::SevCapable,
                7 => Self::SevLiveMigratable,
                8 => Self::SevLiveMigratableV2,
                9 => Self::SevSnpCapable,
                10 => Self::SnpSvsmCapable,
                11 => Self::TdxCapable,
                12 => Self::UefiCompatible,
                13 => Self::VirtioScsiMultiqueue,
                14 => Self::Windows,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "images",
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BARE_METAL_LINUX_COMPATIBLE" => Self::BareMetalLinuxCompatible,
                "FEATURE_TYPE_UNSPECIFIED" => Self::FeatureTypeUnspecified,
                "GVNIC" => Self::Gvnic,
                "IDPF" => Self::Idpf,
                "MULTI_IP_SUBNET" => Self::MultiIpSubnet,
                "SECURE_BOOT" => Self::SecureBoot,
                "SEV_CAPABLE" => Self::SevCapable,
                "SEV_LIVE_MIGRATABLE" => Self::SevLiveMigratable,
                "SEV_LIVE_MIGRATABLE_V2" => Self::SevLiveMigratableV2,
                "SEV_SNP_CAPABLE" => Self::SevSnpCapable,
                "SNP_SVSM_CAPABLE" => Self::SnpSvsmCapable,
                "TDX_CAPABLE" => Self::TdxCapable,
                "UEFI_COMPATIBLE" => Self::UefiCompatible,
                "VIRTIO_SCSI_MULTIQUEUE" => Self::VirtioScsiMultiqueue,
                "WINDOWS" => Self::Windows,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "images",
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::BareMetalLinuxCompatible => {
                    serializer.serialize_str("BARE_METAL_LINUX_COMPATIBLE")
                }
                Self::FeatureTypeUnspecified => {
                    serializer.serialize_str("FEATURE_TYPE_UNSPECIFIED")
                }
                Self::Gvnic => serializer.serialize_str("GVNIC"),
                Self::Idpf => serializer.serialize_str("IDPF"),
                Self::MultiIpSubnet => serializer.serialize_str("MULTI_IP_SUBNET"),
                Self::SecureBoot => serializer.serialize_str("SECURE_BOOT"),
                Self::SevCapable => serializer.serialize_str("SEV_CAPABLE"),
                Self::SevLiveMigratable => serializer.serialize_str("SEV_LIVE_MIGRATABLE"),
                Self::SevLiveMigratableV2 => serializer.serialize_str("SEV_LIVE_MIGRATABLE_V2"),
                Self::SevSnpCapable => serializer.serialize_str("SEV_SNP_CAPABLE"),
                Self::SnpSvsmCapable => serializer.serialize_str("SNP_SVSM_CAPABLE"),
                Self::TdxCapable => serializer.serialize_str("TDX_CAPABLE"),
                Self::UefiCompatible => serializer.serialize_str("UEFI_COMPATIBLE"),
                Self::VirtioScsiMultiqueue => serializer.serialize_str("VIRTIO_SCSI_MULTIQUEUE"),
                Self::Windows => serializer.serialize_str("WINDOWS"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "images",
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.compute.v1.GuestOsFeature.type",
            ))
        }
    }
}

/// Provides links to documentation or for performing an out of band action.
///
/// For example, if a quota check failed with an error indicating the calling
/// project hasn't enabled the accessed service, this can contain a URL pointing
/// directly to the right place in the developer console to flip the bit.
#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Help {
    /// URL(s) pointing to additional information on handling the current error.
    pub links: std::vec::Vec<crate::model::HelpLink>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl Help {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [links][crate::model::Help::links].
    pub fn set_links<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::HelpLink>,
    {
        use std::iter::Iterator;
        self.links = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl wkt::message::Message for Help {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Help"
    }
}

/// Describes a URL link.
#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HelpLink {
    /// Describes what the link offers.
    pub description: std::option::Option<std::string::String>,

    /// The URL of the link.
    pub url: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl HelpLink {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::HelpLink::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::HelpLink::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [url][crate::model::HelpLink::url].
    pub fn set_url<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.url = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [url][crate::model::HelpLink::url].
    pub fn set_or_clear_url<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.url = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl wkt::message::Message for HelpLink {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.HelpLink"
    }
}

/// Represents an Image resource.
///
/// You can use images to create boot disks for your VM instances.
/// For more information, read Images.
#[cfg(feature = "images")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Image {
    /// The architecture of the image. Valid values are
    /// ARM64 or X86_64.
    pub architecture: std::option::Option<crate::model::image::Architecture>,

    /// Size of the image tar.gz archive stored in Google Cloud
    /// Storage (in bytes).
    pub archive_size_bytes: std::option::Option<i64>,

    /// [Output Only] Creation timestamp inRFC3339
    /// text format.
    pub creation_timestamp: std::option::Option<std::string::String>,

    /// The deprecation status associated with this image.
    pub deprecated: std::option::Option<crate::model::DeprecationStatus>,

    /// An optional description of this resource. Provide this property when you
    /// create the resource.
    pub description: std::option::Option<std::string::String>,

    /// Size of the image when restored onto a persistent disk (in GB).
    pub disk_size_gb: std::option::Option<i64>,

    /// Whether this image is created from a confidential compute mode disk.
    /// [Output Only]: This field is not set by user, but from source disk.
    pub enable_confidential_compute: std::option::Option<bool>,

    /// The name of the image family to which this image belongs. The image
    /// family name can be from a publicly managed image family provided by
    /// Compute Engine, or from a custom image family you create. For example,centos-stream-9 is a publicly available image family.
    /// For more information, see Image
    /// family best practices.
    ///
    /// When creating disks, you can specify an image family instead of a specific
    /// image name. The image family always returns its latest image that is not
    /// deprecated. The name of the image family must comply with RFC1035.
    pub family: std::option::Option<std::string::String>,

    /// A list of features to enable on the guest operating system. Applicable
    /// only for bootable images. To see a list of available options, see theguestOSfeatures[].type parameter.
    pub guest_os_features: std::vec::Vec<crate::model::GuestOsFeature>,

    /// [Output Only] The unique identifier for the resource. This identifier is
    /// defined by the server.
    pub id: std::option::Option<u64>,

    /// Encrypts the image using acustomer-supplied
    /// encryption key.
    ///
    /// After you encrypt an image with a customer-supplied key, you must provide
    /// the same key if you use the image later (e.g. to create a disk from
    /// the image).
    ///
    /// Customer-supplied encryption keys do not protect access to metadata
    /// of the disk.
    ///
    /// If you do not provide an encryption key when creating the image, then the
    /// disk will be encrypted using an automatically generated key and you do not
    /// need to provide a key to use the image later.
    pub image_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// [Output Only] Type of the resource. Always compute#image for
    /// images.
    pub kind: std::option::Option<std::string::String>,

    /// A fingerprint for the labels being applied to this image, which is
    /// essentially a hash of the labels used for optimistic locking. The
    /// fingerprint is initially generated by Compute Engine and changes after
    /// every request to modify or update labels. You must always provide an
    /// up-to-date fingerprint hash in order to update or change labels,
    /// otherwise the request will fail with error412 conditionNotMet.
    ///
    /// To see the latest fingerprint, make a get() request to
    /// retrieve an image.
    pub label_fingerprint: std::option::Option<::bytes::Bytes>,

    /// Labels to apply to this image. These can be later modified by
    /// the setLabels method.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Integer license codes indicating which licenses are attached to this image.
    pub license_codes: std::vec::Vec<i64>,

    /// Any applicable license URI.
    pub licenses: std::vec::Vec<std::string::String>,

    /// Name of the resource; provided by the client when the resource is created.
    /// The name must be 1-63 characters long, and comply withRFC1035.
    /// Specifically, the name must be 1-63 characters long and match the regular
    /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
    /// character must be a lowercase letter, and all following characters must be
    /// a dash, lowercase letter, or digit, except the last character, which cannot
    /// be a dash.
    pub name: std::option::Option<std::string::String>,

    /// Input only. [Input Only] Additional params passed with the request, but not persisted
    /// as part of resource payload.
    pub params: std::option::Option<crate::model::ImageParams>,

    /// The parameters of the raw disk image.
    pub raw_disk: std::option::Option<crate::model::image::RawDisk>,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: std::option::Option<bool>,

    /// [Output Only] Reserved for future use.
    pub satisfies_pzs: std::option::Option<bool>,

    /// [Output Only] Server-defined URL for the resource.
    pub self_link: std::option::Option<std::string::String>,

    /// Set the secure boot keys of shielded instance.
    pub shielded_instance_initial_state: std::option::Option<crate::model::InitialStateConfig>,

    /// URL of the source disk used to create this image.
    /// For example, the following are valid values:
    ///
    /// - <https://www.googleapis.com/compute/v1/projects/project/zones/zone/disks/disk>
    /// - projects/project/zones/zone/disks/disk
    /// - zones/zone/disks/disk
    ///
    /// In order to create an image, you must provide the full or partial URL of
    /// one of the following:
    ///
    /// - The rawDisk.source URL
    /// - The sourceDisk URL
    /// - The sourceImage URL
    /// - The sourceSnapshot URL
    pub source_disk: std::option::Option<std::string::String>,

    /// Thecustomer-supplied
    /// encryption key of the source disk. Required if the source disk is
    /// protected by a customer-supplied encryption key.
    pub source_disk_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// [Output Only]
    /// The ID value of the disk used to create this image. This value may be used
    /// to determine whether the image was taken from the current or a previous
    /// instance of a given disk name.
    pub source_disk_id: std::option::Option<std::string::String>,

    /// URL of the source image used to create this image.
    /// The following are valid formats for the URL:
    ///
    /// - <https://www.googleapis.com/compute/v1/projects/project_id/global/>
    ///   images/image_name
    /// - projects/project_id/global/images/image_name
    ///
    /// In order to create an image, you must provide the full or partial URL of
    /// one of the following:
    ///
    /// - The rawDisk.source URL
    /// - The sourceDisk URL
    /// - The sourceImage URL
    /// - The sourceSnapshot URL
    pub source_image: std::option::Option<std::string::String>,

    /// The customer-supplied encryption key of the source image. Required if the
    /// source image is protected by a customer-supplied encryption key.
    pub source_image_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// [Output Only]
    /// The ID value of the image used to create this image. This value may be used
    /// to determine whether the image was taken from the current or a previous
    /// instance of a given image name.
    pub source_image_id: std::option::Option<std::string::String>,

    /// URL of the source snapshot used to create this image.
    /// The following are valid formats for the URL:
    ///
    /// - <https://www.googleapis.com/compute/v1/projects/project_id/global/>
    ///   snapshots/snapshot_name
    /// - projects/project_id/global/snapshots/snapshot_name
    ///
    /// In order to create an image, you must provide the full or partial URL of
    /// one of the following:
    ///
    /// - The rawDisk.source URL
    /// - The sourceDisk URL
    /// - The sourceImage URL
    /// - The sourceSnapshot URL
    pub source_snapshot: std::option::Option<std::string::String>,

    /// The customer-supplied encryption key of the source snapshot. Required if
    /// the source snapshot is protected by a customer-supplied encryption key.
    pub source_snapshot_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// [Output Only]
    /// The ID value of the snapshot used to create this image. This value may be
    /// used to determine whether the snapshot was taken from the current or a
    /// previous instance of a given snapshot name.
    pub source_snapshot_id: std::option::Option<std::string::String>,

    /// The type of the image used to create this disk. The
    /// default and only valid value is RAW.
    pub source_type: std::option::Option<crate::model::image::SourceType>,

    /// [Output Only] The status of the image. An image can be used to create other
    /// resources, such as instances, only after the image has been successfully
    /// created and the status is set to READY. Possible
    /// values are FAILED, PENDING, orREADY.
    pub status: std::option::Option<crate::model::image::Status>,

    /// Cloud Storage bucket storage location of the image (regional or
    /// multi-regional).
    pub storage_locations: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "images")]
impl Image {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [architecture][crate::model::Image::architecture].
    pub fn set_architecture<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::image::Architecture>,
    {
        self.architecture = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [architecture][crate::model::Image::architecture].
    pub fn set_or_clear_architecture<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::image::Architecture>,
    {
        self.architecture = v.map(|x| x.into());
        self
    }

    /// Sets the value of [archive_size_bytes][crate::model::Image::archive_size_bytes].
    pub fn set_archive_size_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.archive_size_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [archive_size_bytes][crate::model::Image::archive_size_bytes].
    pub fn set_or_clear_archive_size_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.archive_size_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creation_timestamp][crate::model::Image::creation_timestamp].
    pub fn set_creation_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_timestamp][crate::model::Image::creation_timestamp].
    pub fn set_or_clear_creation_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deprecated][crate::model::Image::deprecated].
    pub fn set_deprecated<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeprecationStatus>,
    {
        self.deprecated = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deprecated][crate::model::Image::deprecated].
    pub fn set_or_clear_deprecated<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeprecationStatus>,
    {
        self.deprecated = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::Image::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::Image::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::Image::disk_size_gb].
    pub fn set_disk_size_gb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.disk_size_gb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_size_gb][crate::model::Image::disk_size_gb].
    pub fn set_or_clear_disk_size_gb<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.disk_size_gb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_confidential_compute][crate::model::Image::enable_confidential_compute].
    pub fn set_enable_confidential_compute<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_confidential_compute = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_confidential_compute][crate::model::Image::enable_confidential_compute].
    pub fn set_or_clear_enable_confidential_compute<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_confidential_compute = v.map(|x| x.into());
        self
    }

    /// Sets the value of [family][crate::model::Image::family].
    pub fn set_family<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.family = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [family][crate::model::Image::family].
    pub fn set_or_clear_family<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.family = v.map(|x| x.into());
        self
    }

    /// Sets the value of [guest_os_features][crate::model::Image::guest_os_features].
    pub fn set_guest_os_features<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GuestOsFeature>,
    {
        use std::iter::Iterator;
        self.guest_os_features = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [id][crate::model::Image::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::Image::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [image_encryption_key][crate::model::Image::image_encryption_key].
    pub fn set_image_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.image_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [image_encryption_key][crate::model::Image::image_encryption_key].
    pub fn set_or_clear_image_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.image_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::Image::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::Image::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [label_fingerprint][crate::model::Image::label_fingerprint].
    pub fn set_label_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.label_fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [label_fingerprint][crate::model::Image::label_fingerprint].
    pub fn set_or_clear_label_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.label_fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Image::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [license_codes][crate::model::Image::license_codes].
    pub fn set_license_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.license_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [licenses][crate::model::Image::licenses].
    pub fn set_licenses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.licenses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [name][crate::model::Image::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::Image::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [params][crate::model::Image::params].
    pub fn set_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImageParams>,
    {
        self.params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [params][crate::model::Image::params].
    pub fn set_or_clear_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImageParams>,
    {
        self.params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [raw_disk][crate::model::Image::raw_disk].
    pub fn set_raw_disk<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::image::RawDisk>,
    {
        self.raw_disk = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [raw_disk][crate::model::Image::raw_disk].
    pub fn set_or_clear_raw_disk<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::image::RawDisk>,
    {
        self.raw_disk = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Image::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::Image::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Image::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::Image::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::Image::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::Image::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [shielded_instance_initial_state][crate::model::Image::shielded_instance_initial_state].
    pub fn set_shielded_instance_initial_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InitialStateConfig>,
    {
        self.shielded_instance_initial_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shielded_instance_initial_state][crate::model::Image::shielded_instance_initial_state].
    pub fn set_or_clear_shielded_instance_initial_state<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::InitialStateConfig>,
    {
        self.shielded_instance_initial_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_disk][crate::model::Image::source_disk].
    pub fn set_source_disk<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_disk = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_disk][crate::model::Image::source_disk].
    pub fn set_or_clear_source_disk<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_disk = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_disk_encryption_key][crate::model::Image::source_disk_encryption_key].
    pub fn set_source_disk_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_disk_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_disk_encryption_key][crate::model::Image::source_disk_encryption_key].
    pub fn set_or_clear_source_disk_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_disk_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_disk_id][crate::model::Image::source_disk_id].
    pub fn set_source_disk_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_disk_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_disk_id][crate::model::Image::source_disk_id].
    pub fn set_or_clear_source_disk_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_disk_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_image][crate::model::Image::source_image].
    pub fn set_source_image<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_image = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_image][crate::model::Image::source_image].
    pub fn set_or_clear_source_image<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_image = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_image_encryption_key][crate::model::Image::source_image_encryption_key].
    pub fn set_source_image_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_image_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_image_encryption_key][crate::model::Image::source_image_encryption_key].
    pub fn set_or_clear_source_image_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_image_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_image_id][crate::model::Image::source_image_id].
    pub fn set_source_image_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_image_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_image_id][crate::model::Image::source_image_id].
    pub fn set_or_clear_source_image_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_image_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_snapshot][crate::model::Image::source_snapshot].
    pub fn set_source_snapshot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_snapshot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_snapshot][crate::model::Image::source_snapshot].
    pub fn set_or_clear_source_snapshot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_snapshot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_snapshot_encryption_key][crate::model::Image::source_snapshot_encryption_key].
    pub fn set_source_snapshot_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_snapshot_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_snapshot_encryption_key][crate::model::Image::source_snapshot_encryption_key].
    pub fn set_or_clear_source_snapshot_encryption_key<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_snapshot_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_snapshot_id][crate::model::Image::source_snapshot_id].
    pub fn set_source_snapshot_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_snapshot_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_snapshot_id][crate::model::Image::source_snapshot_id].
    pub fn set_or_clear_source_snapshot_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_snapshot_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_type][crate::model::Image::source_type].
    pub fn set_source_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::image::SourceType>,
    {
        self.source_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_type][crate::model::Image::source_type].
    pub fn set_or_clear_source_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::image::SourceType>,
    {
        self.source_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::Image::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::image::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::Image::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::image::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [storage_locations][crate::model::Image::storage_locations].
    pub fn set_storage_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.storage_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "images")]
impl wkt::message::Message for Image {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Image"
    }
}

/// Defines additional types related to [Image].
#[cfg(feature = "images")]
pub mod image {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [rawDisk][google.cloud.compute.v1.Image.rawDisk] field.
    ///
    /// [google.cloud.compute.v1.Image.rawDisk]: crate::model::image::RawDisk
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RawDisk {
        /// The format used to encode and transmit the block device, which should beTAR. This is just a container and transmission format and not
        /// a runtime format. Provided by the client when the disk image is created.
        pub container_type: std::option::Option<crate::model::image::raw_disk::ContainerType>,

        /// [Deprecated] This field is deprecated.
        /// An optional SHA1 checksum of the disk image before unpackaging provided
        /// by the client when the disk image is created.
        #[deprecated]
        pub sha_1_checksum: std::option::Option<std::string::String>,

        /// The full Google Cloud Storage URL where the raw disk image archive is
        /// stored.
        /// The following are valid formats for the URL:
        ///
        /// - <https://storage.googleapis.com/bucket_name/image_archive_name>
        /// - <https://storage.googleapis.com/bucket_name/folder_name/image_archive_name>
        ///
        /// In order to create an image, you must provide the full or partial URL of
        /// one of the following:
        ///
        /// - The rawDisk.source URL
        /// - The sourceDisk URL
        /// - The sourceImage URL
        /// - The sourceSnapshot URL
        pub source: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl RawDisk {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [container_type][crate::model::image::RawDisk::container_type].
        pub fn set_container_type<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::image::raw_disk::ContainerType>,
        {
            self.container_type = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [container_type][crate::model::image::RawDisk::container_type].
        pub fn set_or_clear_container_type<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::image::raw_disk::ContainerType>,
        {
            self.container_type = v.map(|x| x.into());
            self
        }

        /// Sets the value of [sha_1_checksum][crate::model::image::RawDisk::sha_1_checksum].
        #[deprecated]
        pub fn set_sha_1_checksum<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.sha_1_checksum = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [sha_1_checksum][crate::model::image::RawDisk::sha_1_checksum].
        #[deprecated]
        pub fn set_or_clear_sha_1_checksum<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.sha_1_checksum = v.map(|x| x.into());
            self
        }

        /// Sets the value of [source][crate::model::image::RawDisk::source].
        pub fn set_source<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.source = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [source][crate::model::image::RawDisk::source].
        pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.source = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "images")]
    impl wkt::message::Message for RawDisk {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.Image.rawDisk"
        }
    }

    /// Defines additional types related to [RawDisk].
    #[cfg(feature = "images")]
    pub mod raw_disk {
        #[allow(unused_imports)]
        use super::*;

        /// The enumerated type for the [containerType][google.cloud.compute.v1.Image.rawDisk.containerType] field.
        ///
        /// [google.cloud.compute.v1.Image.rawDisk.containerType]: crate::model::image::raw_disk::ContainerType
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "images")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ContainerType {
            Tar,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ContainerType::value] or
            /// [ContainerType::name].
            UnknownValue(container_type::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "images")]
        pub mod container_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "images")]
        impl ContainerType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Tar => std::option::Option::Some(0),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Tar => std::option::Option::Some("TAR"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "images")]
        impl std::default::Default for ContainerType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "images")]
        impl std::fmt::Display for ContainerType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "images")]
        impl std::convert::From<i32> for ContainerType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Tar,
                    _ => Self::UnknownValue(container_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "images")]
        impl std::convert::From<&str> for ContainerType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TAR" => Self::Tar,
                    _ => Self::UnknownValue(container_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "images")]
        impl serde::ser::Serialize for ContainerType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Tar => serializer.serialize_str("TAR"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "images")]
        impl<'de> serde::de::Deserialize<'de> for ContainerType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ContainerType>::new(
                    ".google.cloud.compute.v1.Image.rawDisk.containerType",
                ))
            }
        }
    }

    /// The enumerated type for the [architecture][google.cloud.compute.v1.Image.architecture] field.
    ///
    /// [google.cloud.compute.v1.Image.architecture]: crate::model::image::Architecture
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "images")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Architecture {
        /// Default value indicating Architecture is not set.
        Unspecified,
        /// Machines with architecture ARM64
        Arm64,
        /// Machines with architecture X86_64
        X8664,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Architecture::value] or
        /// [Architecture::name].
        UnknownValue(architecture::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "images")]
    pub mod architecture {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "images")]
    impl Architecture {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Arm64 => std::option::Option::Some(1),
                Self::X8664 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ARCHITECTURE_UNSPECIFIED"),
                Self::Arm64 => std::option::Option::Some("ARM64"),
                Self::X8664 => std::option::Option::Some("X86_64"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "images")]
    impl std::default::Default for Architecture {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "images")]
    impl std::fmt::Display for Architecture {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "images")]
    impl std::convert::From<i32> for Architecture {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Arm64,
                2 => Self::X8664,
                _ => Self::UnknownValue(architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "images")]
    impl std::convert::From<&str> for Architecture {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
                "ARM64" => Self::Arm64,
                "X86_64" => Self::X8664,
                _ => Self::UnknownValue(architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "images")]
    impl serde::ser::Serialize for Architecture {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_str("ARCHITECTURE_UNSPECIFIED"),
                Self::Arm64 => serializer.serialize_str("ARM64"),
                Self::X8664 => serializer.serialize_str("X86_64"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "images")]
    impl<'de> serde::de::Deserialize<'de> for Architecture {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Architecture>::new(
                ".google.cloud.compute.v1.Image.architecture",
            ))
        }
    }

    /// The enumerated type for the [sourceType][google.cloud.compute.v1.Image.sourceType] field.
    ///
    /// [google.cloud.compute.v1.Image.sourceType]: crate::model::image::SourceType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "images")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceType {
        Raw,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SourceType::value] or
        /// [SourceType::name].
        UnknownValue(source_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "images")]
    pub mod source_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "images")]
    impl SourceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Raw => std::option::Option::Some(0),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Raw => std::option::Option::Some("RAW"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "images")]
    impl std::default::Default for SourceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "images")]
    impl std::fmt::Display for SourceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "images")]
    impl std::convert::From<i32> for SourceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Raw,
                _ => Self::UnknownValue(source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "images")]
    impl std::convert::From<&str> for SourceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RAW" => Self::Raw,
                _ => Self::UnknownValue(source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "images")]
    impl serde::ser::Serialize for SourceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Raw => serializer.serialize_str("RAW"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "images")]
    impl<'de> serde::de::Deserialize<'de> for SourceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SourceType>::new(
                ".google.cloud.compute.v1.Image.sourceType",
            ))
        }
    }

    /// The enumerated type for the [status][google.cloud.compute.v1.Image.status] field.
    ///
    /// [google.cloud.compute.v1.Image.status]: crate::model::image::Status
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "images")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Image is deleting.
        Deleting,
        /// Image creation failed due to an error.
        Failed,
        /// Image hasn't been created as yet.
        Pending,
        /// Image has been successfully created.
        Ready,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "images")]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "images")]
    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Deleting => std::option::Option::Some(0),
                Self::Failed => std::option::Option::Some(1),
                Self::Pending => std::option::Option::Some(2),
                Self::Ready => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "images")]
    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "images")]
    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "images")]
    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Deleting,
                1 => Self::Failed,
                2 => Self::Pending,
                3 => Self::Ready,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "images")]
    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DELETING" => Self::Deleting,
                "FAILED" => Self::Failed,
                "PENDING" => Self::Pending,
                "READY" => Self::Ready,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "images")]
    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Deleting => serializer.serialize_str("DELETING"),
                Self::Failed => serializer.serialize_str("FAILED"),
                Self::Pending => serializer.serialize_str("PENDING"),
                Self::Ready => serializer.serialize_str("READY"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "images")]
    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.cloud.compute.v1.Image.status",
            ))
        }
    }
}

/// Contains a list of images.
#[cfg(feature = "images")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImageList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of Image resources.
    pub items: std::vec::Vec<crate::model::Image>,

    /// Type of resource.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::image_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "images")]
impl ImageList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::ImageList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::ImageList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::ImageList::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Image>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::ImageList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::ImageList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::ImageList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::ImageList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::ImageList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::ImageList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::ImageList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::image_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::ImageList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::image_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "images")]
impl wkt::message::Message for ImageList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ImageList"
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ImageList {
    type PageItem = crate::model::Image;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [ImageList].
#[cfg(feature = "images")]
pub mod image_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.ImageList.warning] field.
    ///
    /// [google.cloud.compute.v1.ImageList.warning]: crate::model::image_list::Warning
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::image_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::image_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::image_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::image_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::image_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::image_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::image_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::image_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::image_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::image_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "images")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.ImageList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "images")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.ImageList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.ImageList.warning.data]: crate::model::image_list::warning::Data
        #[cfg(feature = "images")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "images")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::image_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::image_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::image_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::image_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "images")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.ImageList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.ImageList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.ImageList.warning.code]: crate::model::image_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "images")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "images")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "images")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "images")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "images")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "images")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "images")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "images")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "images")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.ImageList.warning.code",
                ))
            }
        }
    }
}

/// Additional image params.
#[cfg(feature = "images")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImageParams {
    /// Resource manager tags to be bound to the image. Tag keys and values have
    /// the same definition as resource
    /// manager tags. Keys must be in the format `tagKeys/{tag_key_id}`, and
    /// values are in the format `tagValues/456`. The field is ignored (both PUT &
    /// PATCH) when empty.
    pub resource_manager_tags: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "images")]
impl ImageParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_manager_tags][crate::model::ImageParams::resource_manager_tags].
    pub fn set_resource_manager_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_manager_tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "images")]
impl wkt::message::Message for ImageParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ImageParams"
    }
}

/// Initial State for shielded instance,
/// these are public keys which are safe to store in public
#[cfg(any(
    feature = "images",
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InitialStateConfig {
    /// The Key Database (db).
    pub dbs: std::vec::Vec<crate::model::FileContentBuffer>,

    /// The forbidden key database (dbx).
    pub dbxs: std::vec::Vec<crate::model::FileContentBuffer>,

    /// The Key Exchange Key (KEK).
    pub keks: std::vec::Vec<crate::model::FileContentBuffer>,

    /// The Platform Key (PK).
    pub pk: std::option::Option<crate::model::FileContentBuffer>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "images",
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl InitialStateConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dbs][crate::model::InitialStateConfig::dbs].
    pub fn set_dbs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileContentBuffer>,
    {
        use std::iter::Iterator;
        self.dbs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dbxs][crate::model::InitialStateConfig::dbxs].
    pub fn set_dbxs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileContentBuffer>,
    {
        use std::iter::Iterator;
        self.dbxs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [keks][crate::model::InitialStateConfig::keks].
    pub fn set_keks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileContentBuffer>,
    {
        use std::iter::Iterator;
        self.keks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pk][crate::model::InitialStateConfig::pk].
    pub fn set_pk<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FileContentBuffer>,
    {
        self.pk = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pk][crate::model::InitialStateConfig::pk].
    pub fn set_or_clear_pk<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FileContentBuffer>,
    {
        self.pk = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "images",
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for InitialStateConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InitialStateConfig"
    }
}

/// Represents an Instance resource.
///
/// An instance is a virtual machine that is hosted on Google Cloud Platform.
/// For more information, readVirtual Machine Instances.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Instance {
    /// Controls for advanced machine-related behavior features.
    pub advanced_machine_features: std::option::Option<crate::model::AdvancedMachineFeatures>,

    /// Allows this instance to send and receive packets with non-matching
    /// destination or source IPs. This is required if you plan to use this
    /// instance to forward routes. For more information, seeEnabling IP Forwarding.
    pub can_ip_forward: std::option::Option<bool>,

    pub confidential_instance_config: std::option::Option<crate::model::ConfidentialInstanceConfig>,

    /// [Output Only] The CPU platform used by this instance.
    pub cpu_platform: std::option::Option<std::string::String>,

    /// [Output Only] Creation timestamp inRFC3339 text format.
    pub creation_timestamp: std::option::Option<std::string::String>,

    /// Whether the resource should be protected against deletion.
    pub deletion_protection: std::option::Option<bool>,

    /// An optional description of this resource. Provide this property when you
    /// create the resource.
    pub description: std::option::Option<std::string::String>,

    /// Array of disks associated with this instance. Persistent disks must be
    /// created before you can assign them.
    pub disks: std::vec::Vec<crate::model::AttachedDisk>,

    /// Enables display device for the instance.
    pub display_device: std::option::Option<crate::model::DisplayDevice>,

    /// Specifies a fingerprint for this resource, which is essentially a hash of
    /// the instance's contents and used for optimistic locking. The
    /// fingerprint is initially generated by Compute Engine and changes after
    /// every request to modify or update the instance. You must always provide an
    /// up-to-date fingerprint hash in order to update the instance.
    ///
    /// To see the latest fingerprint, make get() request to the
    /// instance.
    pub fingerprint: std::option::Option<::bytes::Bytes>,

    /// A list of the type and count of accelerator cards attached to the instance.
    pub guest_accelerators: std::vec::Vec<crate::model::AcceleratorConfig>,

    /// Specifies the hostname of the instance. The specified hostname must be
    /// RFC1035 compliant. If hostname is not specified, the default hostname is
    /// [INSTANCE_NAME].c.[PROJECT_ID].internal when using the global DNS, and
    /// [INSTANCE_NAME].[ZONE].c.[PROJECT_ID].internal when using zonal DNS.
    pub hostname: std::option::Option<std::string::String>,

    /// [Output Only] The unique identifier for the resource. This identifier is
    /// defined by the server.
    pub id: std::option::Option<u64>,

    /// Encrypts suspended data for an instance with acustomer-managed
    /// encryption key.
    ///
    /// If you are creating a new instance, this field will encrypt the local SSD
    /// and in-memory contents of the instance during the suspend operation.
    ///
    /// If you do not provide an encryption key when creating the instance, then
    /// the local SSD and in-memory contents will be encrypted using
    /// an automatically generated key during the suspend operation.
    pub instance_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// KeyRevocationActionType of the instance. Supported options are "STOP" and
    /// "NONE". The default value is "NONE" if it is not specified.
    pub key_revocation_action_type:
        std::option::Option<crate::model::instance::KeyRevocationActionType>,

    /// [Output Only] Type of the resource. Always compute#instance
    /// for instances.
    pub kind: std::option::Option<std::string::String>,

    /// A fingerprint for this request, which is essentially a hash of
    /// the label's contents and used for optimistic locking. The
    /// fingerprint is initially generated by Compute Engine and changes after
    /// every request to modify or update labels. You must always provide an
    /// up-to-date fingerprint hash in order to update or change labels.
    ///
    /// To see the latest fingerprint, make get() request to the
    /// instance.
    pub label_fingerprint: std::option::Option<::bytes::Bytes>,

    /// Labels to apply to this instance. These can be later modified by
    /// the setLabels method.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// [Output Only] Last start timestamp inRFC3339 text format.
    pub last_start_timestamp: std::option::Option<std::string::String>,

    /// [Output Only] Last stop timestamp inRFC3339 text format.
    pub last_stop_timestamp: std::option::Option<std::string::String>,

    /// [Output Only] Last suspended timestamp inRFC3339 text format.
    pub last_suspended_timestamp: std::option::Option<std::string::String>,

    /// Full or partial URL of the machine type resource to use for this instance,
    /// in the format:zones/zone/machineTypes/machine-type. This is provided by the client
    /// when the instance is created. For example, the following is a valid partial
    /// url to a predefined
    /// machine type:
    ///
    /// zones/us-central1-f/machineTypes/n1-standard-1
    ///
    /// To create acustom
    /// machine type, provide a URL to a machine type in the following format,
    /// where CPUS is 1 or an even number up to 32 (2,
    /// 4, 6, ... 24, etc), and MEMORY is the total
    /// memory for this instance. Memory must be a multiple of 256 MB and must
    /// be supplied in MB (e.g. 5 GB of memory is 5120 MB):
    ///
    /// zones/zone/machineTypes/custom-CPUS-MEMORY
    ///
    /// For example: zones/us-central1-f/machineTypes/custom-4-5120
    /// For a full list of restrictions, read theSpecifications
    /// for custom machine types.
    pub machine_type: std::option::Option<std::string::String>,

    /// The metadata key/value pairs assigned
    /// to this instance. This includes metadata keys that were explicitly defined
    /// for the instance.
    pub metadata: std::option::Option<crate::model::Metadata>,

    /// Specifies aminimum CPU
    /// platform for the VM instance. Applicable values are the friendly names
    /// of CPU platforms, such as minCpuPlatform: "Intel
    /// Haswell" or minCpuPlatform: "Intel Sandy
    /// Bridge".
    pub min_cpu_platform: std::option::Option<std::string::String>,

    /// The name of the resource, provided by the client when initially creating
    /// the resource. The resource name must be 1-63 characters long, and comply
    /// withRFC1035.
    /// Specifically, the name must be 1-63 characters long and match the regular
    /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
    /// character must be a lowercase letter, and all following characters must be
    /// a dash, lowercase letter, or digit, except the last character, which cannot
    /// be a dash.
    pub name: std::option::Option<std::string::String>,

    /// An array of network configurations for this instance. These specify how
    /// interfaces are configured to interact with other network services, such as
    /// connecting to the internet. Multiple interfaces are supported
    /// per instance.
    pub network_interfaces: std::vec::Vec<crate::model::NetworkInterface>,

    pub network_performance_config: std::option::Option<crate::model::NetworkPerformanceConfig>,

    /// Input only. [Input Only] Additional params passed with the request, but not persisted
    /// as part of resource payload.
    pub params: std::option::Option<crate::model::InstanceParams>,

    /// The private IPv6 google access type for the VM.
    /// If not specified, use  INHERIT_FROM_SUBNETWORK as default.
    pub private_ipv_6_google_access:
        std::option::Option<crate::model::instance::PrivateIpv6GoogleAccess>,

    /// Specifies the reservations that this instance can consume from.
    pub reservation_affinity: std::option::Option<crate::model::ReservationAffinity>,

    /// Resource policies applied to this instance.
    pub resource_policies: std::vec::Vec<std::string::String>,

    /// [Output Only] Specifies values set for instance attributes as
    /// compared to the values requested by user in the corresponding input only
    /// field.
    pub resource_status: std::option::Option<crate::model::ResourceStatus>,

    /// [Output Only] Reserved for future use.
    pub satisfies_pzi: std::option::Option<bool>,

    /// [Output Only] Reserved for future use.
    pub satisfies_pzs: std::option::Option<bool>,

    /// Sets the scheduling options for this instance.
    pub scheduling: std::option::Option<crate::model::Scheduling>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// A list of service accounts, with their specified scopes, authorized for
    /// this instance. Only one service account per VM instance is supported.
    ///
    /// Service accounts generate access tokens that can be accessed
    /// through the metadata server and used to authenticate applications on the
    /// instance. SeeService Accounts
    /// for more information.
    pub service_accounts: std::vec::Vec<crate::model::ServiceAccount>,

    pub shielded_instance_config: std::option::Option<crate::model::ShieldedInstanceConfig>,

    pub shielded_instance_integrity_policy:
        std::option::Option<crate::model::ShieldedInstanceIntegrityPolicy>,

    /// Source machine image
    pub source_machine_image: std::option::Option<std::string::String>,

    /// Source machine image encryption key when creating an instance from a
    /// machine image.
    pub source_machine_image_encryption_key:
        std::option::Option<crate::model::CustomerEncryptionKey>,

    /// [Output Only] Whether a VM has been restricted for start because Compute
    /// Engine has detected suspicious activity.
    pub start_restricted: std::option::Option<bool>,

    /// [Output Only] The status of the instance. One of the
    /// following values: PROVISIONING, STAGING,RUNNING, STOPPING, SUSPENDING,SUSPENDED, REPAIRING, andTERMINATED. For more information about the status of the
    /// instance, see
    /// Instance life cycle.
    pub status: std::option::Option<crate::model::instance::Status>,

    /// [Output Only] An optional, human-readable explanation of the status.
    pub status_message: std::option::Option<std::string::String>,

    /// Tags to apply to this instance. Tags are used to identify valid
    /// sources or targets for network firewalls and are specified by the client
    /// during instance creation. The tags can be later modified by the setTags
    /// method. Each tag within the list must comply withRFC1035.
    /// Multiple tags can be specified via the 'tags.items' field.
    pub tags: std::option::Option<crate::model::Tags>,

    /// [Output Only] URL of the zone where the instance resides.
    /// You must specify this field as part of the HTTP request URL. It is
    /// not settable as a field in the request body.
    pub zone: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [advanced_machine_features][crate::model::Instance::advanced_machine_features].
    pub fn set_advanced_machine_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedMachineFeatures>,
    {
        self.advanced_machine_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [advanced_machine_features][crate::model::Instance::advanced_machine_features].
    pub fn set_or_clear_advanced_machine_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedMachineFeatures>,
    {
        self.advanced_machine_features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [can_ip_forward][crate::model::Instance::can_ip_forward].
    pub fn set_can_ip_forward<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.can_ip_forward = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [can_ip_forward][crate::model::Instance::can_ip_forward].
    pub fn set_or_clear_can_ip_forward<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.can_ip_forward = v.map(|x| x.into());
        self
    }

    /// Sets the value of [confidential_instance_config][crate::model::Instance::confidential_instance_config].
    pub fn set_confidential_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialInstanceConfig>,
    {
        self.confidential_instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [confidential_instance_config][crate::model::Instance::confidential_instance_config].
    pub fn set_or_clear_confidential_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialInstanceConfig>,
    {
        self.confidential_instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cpu_platform][crate::model::Instance::cpu_platform].
    pub fn set_cpu_platform<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.cpu_platform = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cpu_platform][crate::model::Instance::cpu_platform].
    pub fn set_or_clear_cpu_platform<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.cpu_platform = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creation_timestamp][crate::model::Instance::creation_timestamp].
    pub fn set_creation_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_timestamp][crate::model::Instance::creation_timestamp].
    pub fn set_or_clear_creation_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deletion_protection][crate::model::Instance::deletion_protection].
    pub fn set_deletion_protection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deletion_protection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deletion_protection][crate::model::Instance::deletion_protection].
    pub fn set_or_clear_deletion_protection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deletion_protection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::Instance::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::Instance::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disks][crate::model::Instance::disks].
    pub fn set_disks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedDisk>,
    {
        use std::iter::Iterator;
        self.disks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [display_device][crate::model::Instance::display_device].
    pub fn set_display_device<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DisplayDevice>,
    {
        self.display_device = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [display_device][crate::model::Instance::display_device].
    pub fn set_or_clear_display_device<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DisplayDevice>,
    {
        self.display_device = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fingerprint][crate::model::Instance::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::Instance::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [guest_accelerators][crate::model::Instance::guest_accelerators].
    pub fn set_guest_accelerators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AcceleratorConfig>,
    {
        use std::iter::Iterator;
        self.guest_accelerators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hostname][crate::model::Instance::hostname].
    pub fn set_hostname<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.hostname = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hostname][crate::model::Instance::hostname].
    pub fn set_or_clear_hostname<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.hostname = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::Instance::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::Instance::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_encryption_key][crate::model::Instance::instance_encryption_key].
    pub fn set_instance_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.instance_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_encryption_key][crate::model::Instance::instance_encryption_key].
    pub fn set_or_clear_instance_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.instance_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [key_revocation_action_type][crate::model::Instance::key_revocation_action_type].
    pub fn set_key_revocation_action_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::KeyRevocationActionType>,
    {
        self.key_revocation_action_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key_revocation_action_type][crate::model::Instance::key_revocation_action_type].
    pub fn set_or_clear_key_revocation_action_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::KeyRevocationActionType>,
    {
        self.key_revocation_action_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::Instance::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::Instance::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [label_fingerprint][crate::model::Instance::label_fingerprint].
    pub fn set_label_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.label_fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [label_fingerprint][crate::model::Instance::label_fingerprint].
    pub fn set_or_clear_label_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.label_fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [last_start_timestamp][crate::model::Instance::last_start_timestamp].
    pub fn set_last_start_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.last_start_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_start_timestamp][crate::model::Instance::last_start_timestamp].
    pub fn set_or_clear_last_start_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.last_start_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_stop_timestamp][crate::model::Instance::last_stop_timestamp].
    pub fn set_last_stop_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.last_stop_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_stop_timestamp][crate::model::Instance::last_stop_timestamp].
    pub fn set_or_clear_last_stop_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.last_stop_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_suspended_timestamp][crate::model::Instance::last_suspended_timestamp].
    pub fn set_last_suspended_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.last_suspended_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_suspended_timestamp][crate::model::Instance::last_suspended_timestamp].
    pub fn set_or_clear_last_suspended_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.last_suspended_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [machine_type][crate::model::Instance::machine_type].
    pub fn set_machine_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.machine_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [machine_type][crate::model::Instance::machine_type].
    pub fn set_or_clear_machine_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.machine_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::Instance::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::Instance::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [min_cpu_platform][crate::model::Instance::min_cpu_platform].
    pub fn set_min_cpu_platform<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.min_cpu_platform = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_cpu_platform][crate::model::Instance::min_cpu_platform].
    pub fn set_or_clear_min_cpu_platform<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.min_cpu_platform = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::Instance::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_interfaces][crate::model::Instance::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [network_performance_config][crate::model::Instance::network_performance_config].
    pub fn set_network_performance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPerformanceConfig>,
    {
        self.network_performance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_performance_config][crate::model::Instance::network_performance_config].
    pub fn set_or_clear_network_performance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPerformanceConfig>,
    {
        self.network_performance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [params][crate::model::Instance::params].
    pub fn set_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceParams>,
    {
        self.params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [params][crate::model::Instance::params].
    pub fn set_or_clear_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceParams>,
    {
        self.params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_ipv_6_google_access][crate::model::Instance::private_ipv_6_google_access].
    pub fn set_private_ipv_6_google_access<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::PrivateIpv6GoogleAccess>,
    {
        self.private_ipv_6_google_access = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_ipv_6_google_access][crate::model::Instance::private_ipv_6_google_access].
    pub fn set_or_clear_private_ipv_6_google_access<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::PrivateIpv6GoogleAccess>,
    {
        self.private_ipv_6_google_access = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reservation_affinity][crate::model::Instance::reservation_affinity].
    pub fn set_reservation_affinity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReservationAffinity>,
    {
        self.reservation_affinity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reservation_affinity][crate::model::Instance::reservation_affinity].
    pub fn set_or_clear_reservation_affinity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReservationAffinity>,
    {
        self.reservation_affinity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_policies][crate::model::Instance::resource_policies].
    pub fn set_resource_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource_status][crate::model::Instance::resource_status].
    pub fn set_resource_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceStatus>,
    {
        self.resource_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_status][crate::model::Instance::resource_status].
    pub fn set_or_clear_resource_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourceStatus>,
    {
        self.resource_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Instance::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::Instance::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Instance::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::Instance::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scheduling][crate::model::Instance::scheduling].
    pub fn set_scheduling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Scheduling>,
    {
        self.scheduling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scheduling][crate::model::Instance::scheduling].
    pub fn set_or_clear_scheduling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Scheduling>,
    {
        self.scheduling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::Instance::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::Instance::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_accounts][crate::model::Instance::service_accounts].
    pub fn set_service_accounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ServiceAccount>,
    {
        use std::iter::Iterator;
        self.service_accounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [shielded_instance_config][crate::model::Instance::shielded_instance_config].
    pub fn set_shielded_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
    {
        self.shielded_instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shielded_instance_config][crate::model::Instance::shielded_instance_config].
    pub fn set_or_clear_shielded_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
    {
        self.shielded_instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [shielded_instance_integrity_policy][crate::model::Instance::shielded_instance_integrity_policy].
    pub fn set_shielded_instance_integrity_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceIntegrityPolicy>,
    {
        self.shielded_instance_integrity_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shielded_instance_integrity_policy][crate::model::Instance::shielded_instance_integrity_policy].
    pub fn set_or_clear_shielded_instance_integrity_policy<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceIntegrityPolicy>,
    {
        self.shielded_instance_integrity_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_machine_image][crate::model::Instance::source_machine_image].
    pub fn set_source_machine_image<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_machine_image = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_machine_image][crate::model::Instance::source_machine_image].
    pub fn set_or_clear_source_machine_image<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_machine_image = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_machine_image_encryption_key][crate::model::Instance::source_machine_image_encryption_key].
    pub fn set_source_machine_image_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_machine_image_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_machine_image_encryption_key][crate::model::Instance::source_machine_image_encryption_key].
    pub fn set_or_clear_source_machine_image_encryption_key<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_machine_image_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_restricted][crate::model::Instance::start_restricted].
    pub fn set_start_restricted<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.start_restricted = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_restricted][crate::model::Instance::start_restricted].
    pub fn set_or_clear_start_restricted<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.start_restricted = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::Instance::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::Instance::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status_message][crate::model::Instance::status_message].
    pub fn set_status_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.status_message = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status_message][crate::model::Instance::status_message].
    pub fn set_or_clear_status_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.status_message = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tags][crate::model::Instance::tags].
    pub fn set_tags<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Tags>,
    {
        self.tags = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tags][crate::model::Instance::tags].
    pub fn set_or_clear_tags<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Tags>,
    {
        self.tags = v.map(|x| x.into());
        self
    }

    /// Sets the value of [zone][crate::model::Instance::zone].
    pub fn set_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [zone][crate::model::Instance::zone].
    pub fn set_or_clear_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Instance"
    }
}

/// Defines additional types related to [Instance].
#[cfg(feature = "instances")]
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [keyRevocationActionType][google.cloud.compute.v1.Instance.keyRevocationActionType] field.
    ///
    /// [google.cloud.compute.v1.Instance.keyRevocationActionType]: crate::model::instance::KeyRevocationActionType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum KeyRevocationActionType {
        /// Default value. This value is unused.
        Unspecified,
        /// Indicates user chose no operation.
        None,
        /// Indicates user chose to opt for VM shutdown on key revocation.
        Stop,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [KeyRevocationActionType::value] or
        /// [KeyRevocationActionType::name].
        UnknownValue(key_revocation_action_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod key_revocation_action_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl KeyRevocationActionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Stop => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED")
                }
                Self::None => std::option::Option::Some("NONE"),
                Self::Stop => std::option::Option::Some("STOP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for KeyRevocationActionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for KeyRevocationActionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for KeyRevocationActionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Stop,
                _ => Self::UnknownValue(key_revocation_action_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for KeyRevocationActionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "STOP" => Self::Stop,
                _ => Self::UnknownValue(key_revocation_action_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for KeyRevocationActionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => {
                    serializer.serialize_str("KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED")
                }
                Self::None => serializer.serialize_str("NONE"),
                Self::Stop => serializer.serialize_str("STOP"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for KeyRevocationActionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<KeyRevocationActionType>::new(
                    ".google.cloud.compute.v1.Instance.keyRevocationActionType",
                ),
            )
        }
    }

    /// The enumerated type for the [privateIpv6GoogleAccess][google.cloud.compute.v1.Instance.privateIpv6GoogleAccess] field.
    ///
    /// [google.cloud.compute.v1.Instance.privateIpv6GoogleAccess]: crate::model::instance::PrivateIpv6GoogleAccess
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrivateIpv6GoogleAccess {
        /// Bidirectional private IPv6 access to/from Google services. If
        /// specified, the subnetwork who is attached to the instance's default network
        /// interface will be assigned an internal IPv6 prefix if it doesn't have
        /// before.
        EnableBidirectionalAccessToGoogle,
        /// Outbound private IPv6 access from VMs in this subnet to Google services. If
        /// specified, the subnetwork who is attached to the instance's default network
        /// interface will be assigned an internal IPv6 prefix if it doesn't have
        /// before.
        EnableOutboundVmAccessToGoogle,
        /// Each network interface inherits PrivateIpv6GoogleAccess from its
        /// subnetwork.
        InheritFromSubnetwork,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PrivateIpv6GoogleAccess::value] or
        /// [PrivateIpv6GoogleAccess::name].
        UnknownValue(private_ipv_6_google_access::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod private_ipv_6_google_access {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl PrivateIpv6GoogleAccess {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::EnableBidirectionalAccessToGoogle => std::option::Option::Some(0),
                Self::EnableOutboundVmAccessToGoogle => std::option::Option::Some(1),
                Self::InheritFromSubnetwork => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::EnableBidirectionalAccessToGoogle => {
                    std::option::Option::Some("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE")
                }
                Self::EnableOutboundVmAccessToGoogle => {
                    std::option::Option::Some("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE")
                }
                Self::InheritFromSubnetwork => std::option::Option::Some("INHERIT_FROM_SUBNETWORK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for PrivateIpv6GoogleAccess {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for PrivateIpv6GoogleAccess {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for PrivateIpv6GoogleAccess {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::EnableBidirectionalAccessToGoogle,
                1 => Self::EnableOutboundVmAccessToGoogle,
                2 => Self::InheritFromSubnetwork,
                _ => Self::UnknownValue(private_ipv_6_google_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for PrivateIpv6GoogleAccess {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE" => Self::EnableBidirectionalAccessToGoogle,
                "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE" => Self::EnableOutboundVmAccessToGoogle,
                "INHERIT_FROM_SUBNETWORK" => Self::InheritFromSubnetwork,
                _ => Self::UnknownValue(private_ipv_6_google_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for PrivateIpv6GoogleAccess {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::EnableBidirectionalAccessToGoogle => {
                    serializer.serialize_str("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE")
                }
                Self::EnableOutboundVmAccessToGoogle => {
                    serializer.serialize_str("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE")
                }
                Self::InheritFromSubnetwork => serializer.serialize_str("INHERIT_FROM_SUBNETWORK"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for PrivateIpv6GoogleAccess {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<PrivateIpv6GoogleAccess>::new(
                    ".google.cloud.compute.v1.Instance.privateIpv6GoogleAccess",
                ),
            )
        }
    }

    /// The enumerated type for the [status][google.cloud.compute.v1.Instance.status] field.
    ///
    /// [google.cloud.compute.v1.Instance.status]: crate::model::instance::Status
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// The instance is halted and we are performing tear down tasks like network
        /// deprogramming, releasing quota, IP, tearing down disks etc.
        Deprovisioning,
        /// For Flex Start provisioning instance is waiting for available capacity
        /// from Dynamic Workload Scheduler (DWS).
        Pending,
        /// Resources are being allocated for the instance.
        Provisioning,
        /// The instance is in repair.
        Repairing,
        /// The instance is running.
        Running,
        /// All required resources have been allocated and the instance
        /// is being started.
        Staging,
        /// The instance has stopped successfully.
        Stopped,
        /// The instance is currently stopping (either being deleted or killed).
        Stopping,
        /// The instance has suspended.
        Suspended,
        /// The instance is suspending.
        Suspending,
        /// The instance has stopped (either by explicit action or underlying
        /// failure).
        Terminated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Deprovisioning => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Provisioning => std::option::Option::Some(2),
                Self::Repairing => std::option::Option::Some(3),
                Self::Running => std::option::Option::Some(4),
                Self::Staging => std::option::Option::Some(5),
                Self::Stopped => std::option::Option::Some(6),
                Self::Stopping => std::option::Option::Some(7),
                Self::Suspended => std::option::Option::Some(8),
                Self::Suspending => std::option::Option::Some(9),
                Self::Terminated => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Deprovisioning => std::option::Option::Some("DEPROVISIONING"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Repairing => std::option::Option::Some("REPAIRING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Staging => std::option::Option::Some("STAGING"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Suspended => std::option::Option::Some("SUSPENDED"),
                Self::Suspending => std::option::Option::Some("SUSPENDING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Deprovisioning,
                1 => Self::Pending,
                2 => Self::Provisioning,
                3 => Self::Repairing,
                4 => Self::Running,
                5 => Self::Staging,
                6 => Self::Stopped,
                7 => Self::Stopping,
                8 => Self::Suspended,
                9 => Self::Suspending,
                10 => Self::Terminated,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DEPROVISIONING" => Self::Deprovisioning,
                "PENDING" => Self::Pending,
                "PROVISIONING" => Self::Provisioning,
                "REPAIRING" => Self::Repairing,
                "RUNNING" => Self::Running,
                "STAGING" => Self::Staging,
                "STOPPED" => Self::Stopped,
                "STOPPING" => Self::Stopping,
                "SUSPENDED" => Self::Suspended,
                "SUSPENDING" => Self::Suspending,
                "TERMINATED" => Self::Terminated,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Deprovisioning => serializer.serialize_str("DEPROVISIONING"),
                Self::Pending => serializer.serialize_str("PENDING"),
                Self::Provisioning => serializer.serialize_str("PROVISIONING"),
                Self::Repairing => serializer.serialize_str("REPAIRING"),
                Self::Running => serializer.serialize_str("RUNNING"),
                Self::Staging => serializer.serialize_str("STAGING"),
                Self::Stopped => serializer.serialize_str("STOPPED"),
                Self::Stopping => serializer.serialize_str("STOPPING"),
                Self::Suspended => serializer.serialize_str("SUSPENDED"),
                Self::Suspending => serializer.serialize_str("SUSPENDING"),
                Self::Terminated => serializer.serialize_str("TERMINATED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.cloud.compute.v1.Instance.status",
            ))
        }
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceAggregatedList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// An object that contains a list of instances scoped by zone.
    pub items: std::collections::HashMap<std::string::String, crate::model::InstancesScopedList>,

    /// [Output Only] Type of resource. Alwayscompute#instanceAggregatedList for aggregated lists of
    /// Instance resources.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Unreachable resources.
    pub unreachables: std::vec::Vec<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::instance_aggregated_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstanceAggregatedList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::InstanceAggregatedList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::InstanceAggregatedList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::InstanceAggregatedList::items].
    pub fn set_items<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::InstancesScopedList>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [kind][crate::model::InstanceAggregatedList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::InstanceAggregatedList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstanceAggregatedList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::InstanceAggregatedList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::InstanceAggregatedList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::InstanceAggregatedList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [unreachables][crate::model::InstanceAggregatedList::unreachables].
    pub fn set_unreachables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warning][crate::model::InstanceAggregatedList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_aggregated_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::InstanceAggregatedList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_aggregated_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstanceAggregatedList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceAggregatedList"
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for InstanceAggregatedList {
    type PageItem = (std::string::String, crate::model::InstancesScopedList);

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        use std::iter::{IntoIterator, Iterator};
        self.items.into_iter().collect()
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [InstanceAggregatedList].
#[cfg(feature = "instances")]
pub mod instance_aggregated_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.InstanceAggregatedList.warning] field.
    ///
    /// [google.cloud.compute.v1.InstanceAggregatedList.warning]: crate::model::instance_aggregated_list::Warning
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::instance_aggregated_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::instance_aggregated_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::instance_aggregated_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::instance_aggregated_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::instance_aggregated_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::instance_aggregated_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::instance_aggregated_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance_aggregated_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::instance_aggregated_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::instance_aggregated_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "instances")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstanceAggregatedList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "instances")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.InstanceAggregatedList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.InstanceAggregatedList.warning.data]: crate::model::instance_aggregated_list::warning::Data
        #[cfg(feature = "instances")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instances")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::instance_aggregated_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::instance_aggregated_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::instance_aggregated_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::instance_aggregated_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instances")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstanceAggregatedList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.InstanceAggregatedList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.InstanceAggregatedList.warning.code]: crate::model::instance_aggregated_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instances")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instances")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instances")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instances")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.InstanceAggregatedList.warning.code",
                ))
            }
        }
    }
}

/// Represents an Instance Group resource.
///
/// Instance Groups can be used to configure a target forload
/// balancing.
///
/// Instance groups can either be managed or unmanaged.
///
/// To create
/// managed instance groups, use the instanceGroupManager orregionInstanceGroupManager resource instead.
///
/// Use zonal unmanaged instance groups if you need to applyload
/// balancing to groups of heterogeneous instances or if you need to manage
/// the instances yourself. You cannot create regional unmanaged instance groups.
///
/// For more information, readInstance
/// groups.
#[cfg(any(feature = "instance-groups", feature = "region-instance-groups",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroup {
    /// [Output Only] The creation timestamp for this instance group inRFC3339
    /// text format.
    pub creation_timestamp: std::option::Option<std::string::String>,

    /// An optional description of this resource. Provide this property when you
    /// create the resource.
    pub description: std::option::Option<std::string::String>,

    /// [Output Only] The fingerprint of the named ports. The system
    /// uses this fingerprint to detect conflicts when multiple users change the
    /// named ports concurrently.
    pub fingerprint: std::option::Option<::bytes::Bytes>,

    /// [Output Only] A unique identifier for this instance group, generated
    /// by the server.
    pub id: std::option::Option<u64>,

    /// [Output Only] The resource type, which is alwayscompute#instanceGroup for instance groups.
    pub kind: std::option::Option<std::string::String>,

    /// The name of the instance group. The name must be 1-63 characters
    /// long, and comply withRFC1035.
    pub name: std::option::Option<std::string::String>,

    /// Optional. Assigns a name to a port number. For example:{name: "http", port: 80}
    ///
    /// This
    /// allows the system to reference ports by the assigned name instead of a
    /// port number. Named ports can also contain multiple ports. For example:[{name: "app1", port: 8080}, {name:
    /// "app1", port: 8081}, {name: "app2", port:
    /// 8082}]
    ///
    /// Named ports apply to all instances in this instance group.
    pub named_ports: std::vec::Vec<crate::model::NamedPort>,

    /// [Output Only] The URL of the network to which all instances in the
    /// instance group belong. If your instance has multiple network interfaces,
    /// then the network and subnetwork fields only refer to the
    /// network and subnet used by your primary interface (nic0).
    pub network: std::option::Option<std::string::String>,

    /// [Output Only] The URL of theregion
    /// where the instance group is located (for regional resources).
    pub region: std::option::Option<std::string::String>,

    /// [Output Only] The URL for this instance group. The server generates
    /// this URL.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] The total number of instances in the instance group.
    pub size: std::option::Option<i32>,

    /// [Output Only] The URL of the subnetwork to which all instances in the
    /// instance group belong. If your instance has multiple network interfaces,
    /// then the network and subnetwork fields only refer to the
    /// network and subnet used by your primary interface (nic0).
    pub subnetwork: std::option::Option<std::string::String>,

    /// [Output Only] The URL of thezone
    /// where the instance group is located (for zonal resources).
    pub zone: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "instance-groups", feature = "region-instance-groups",))]
impl InstanceGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [creation_timestamp][crate::model::InstanceGroup::creation_timestamp].
    pub fn set_creation_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_timestamp][crate::model::InstanceGroup::creation_timestamp].
    pub fn set_or_clear_creation_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::InstanceGroup::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::InstanceGroup::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fingerprint][crate::model::InstanceGroup::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::InstanceGroup::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::InstanceGroup::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::InstanceGroup::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::InstanceGroup::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::InstanceGroup::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::InstanceGroup::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::InstanceGroup::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [named_ports][crate::model::InstanceGroup::named_ports].
    pub fn set_named_ports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NamedPort>,
    {
        use std::iter::Iterator;
        self.named_ports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [network][crate::model::InstanceGroup::network].
    pub fn set_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network][crate::model::InstanceGroup::network].
    pub fn set_or_clear_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [region][crate::model::InstanceGroup::region].
    pub fn set_region<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.region = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [region][crate::model::InstanceGroup::region].
    pub fn set_or_clear_region<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.region = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::InstanceGroup::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::InstanceGroup::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [size][crate::model::InstanceGroup::size].
    pub fn set_size<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.size = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [size][crate::model::InstanceGroup::size].
    pub fn set_or_clear_size<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.size = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subnetwork][crate::model::InstanceGroup::subnetwork].
    pub fn set_subnetwork<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subnetwork = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subnetwork][crate::model::InstanceGroup::subnetwork].
    pub fn set_or_clear_subnetwork<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subnetwork = v.map(|x| x.into());
        self
    }

    /// Sets the value of [zone][crate::model::InstanceGroup::zone].
    pub fn set_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [zone][crate::model::InstanceGroup::zone].
    pub fn set_or_clear_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "instance-groups", feature = "region-instance-groups",))]
impl wkt::message::Message for InstanceGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroup"
    }
}

#[cfg(feature = "instance-groups")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupAggregatedList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of InstanceGroupsScopedList resources.
    pub items:
        std::collections::HashMap<std::string::String, crate::model::InstanceGroupsScopedList>,

    /// [Output Only] The resource type, which is alwayscompute#instanceGroupAggregatedList for aggregated lists of
    /// instance groups.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Unreachable resources.
    pub unreachables: std::vec::Vec<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::instance_group_aggregated_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-groups")]
impl InstanceGroupAggregatedList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::InstanceGroupAggregatedList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::InstanceGroupAggregatedList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::InstanceGroupAggregatedList::items].
    pub fn set_items<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::InstanceGroupsScopedList>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [kind][crate::model::InstanceGroupAggregatedList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::InstanceGroupAggregatedList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstanceGroupAggregatedList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::InstanceGroupAggregatedList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::InstanceGroupAggregatedList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::InstanceGroupAggregatedList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [unreachables][crate::model::InstanceGroupAggregatedList::unreachables].
    pub fn set_unreachables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warning][crate::model::InstanceGroupAggregatedList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_aggregated_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::InstanceGroupAggregatedList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_aggregated_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-groups")]
impl wkt::message::Message for InstanceGroupAggregatedList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupAggregatedList"
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for InstanceGroupAggregatedList {
    type PageItem = (std::string::String, crate::model::InstanceGroupsScopedList);

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        use std::iter::{IntoIterator, Iterator};
        self.items.into_iter().collect()
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [InstanceGroupAggregatedList].
#[cfg(feature = "instance-groups")]
pub mod instance_group_aggregated_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.InstanceGroupAggregatedList.warning] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupAggregatedList.warning]: crate::model::instance_group_aggregated_list::Warning
    #[cfg(feature = "instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::instance_group_aggregated_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::instance_group_aggregated_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-groups")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::instance_group_aggregated_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::instance_group_aggregated_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::instance_group_aggregated_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::instance_group_aggregated_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::instance_group_aggregated_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance_group_aggregated_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::instance_group_aggregated_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::instance_group_aggregated_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "instance-groups")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstanceGroupAggregatedList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "instance-groups")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.InstanceGroupAggregatedList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupAggregatedList.warning.data]: crate::model::instance_group_aggregated_list::warning::Data
        #[cfg(feature = "instance-groups")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instance-groups")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::instance_group_aggregated_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::instance_group_aggregated_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::instance_group_aggregated_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::instance_group_aggregated_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instance-groups")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstanceGroupAggregatedList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.InstanceGroupAggregatedList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupAggregatedList.warning.code]: crate::model::instance_group_aggregated_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instance-groups")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instance-groups")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instance-groups")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instance-groups")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instance-groups")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instance-groups")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instance-groups")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instance-groups")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instance-groups")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.InstanceGroupAggregatedList.warning.code",
                ))
            }
        }
    }
}

/// A list of InstanceGroup resources.
#[cfg(feature = "instance-groups")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of InstanceGroup resources.
    pub items: std::vec::Vec<crate::model::InstanceGroup>,

    /// [Output Only] The resource type, which is alwayscompute#instanceGroupList for instance group lists.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::instance_group_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-groups")]
impl InstanceGroupList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::InstanceGroupList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::InstanceGroupList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::InstanceGroupList::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceGroup>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::InstanceGroupList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::InstanceGroupList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstanceGroupList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::InstanceGroupList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::InstanceGroupList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::InstanceGroupList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::InstanceGroupList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::InstanceGroupList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-groups")]
impl wkt::message::Message for InstanceGroupList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupList"
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for InstanceGroupList {
    type PageItem = crate::model::InstanceGroup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [InstanceGroupList].
#[cfg(feature = "instance-groups")]
pub mod instance_group_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.InstanceGroupList.warning] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupList.warning]: crate::model::instance_group_list::Warning
    #[cfg(feature = "instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::instance_group_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::instance_group_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-groups")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::instance_group_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::instance_group_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::instance_group_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::instance_group_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::instance_group_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance_group_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::instance_group_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::instance_group_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "instance-groups")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstanceGroupList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "instance-groups")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.InstanceGroupList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupList.warning.data]: crate::model::instance_group_list::warning::Data
        #[cfg(feature = "instance-groups")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instance-groups")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::instance_group_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::instance_group_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::instance_group_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::instance_group_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instance-groups")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstanceGroupList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.InstanceGroupList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupList.warning.code]: crate::model::instance_group_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instance-groups")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instance-groups")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instance-groups")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instance-groups")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instance-groups")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instance-groups")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instance-groups")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instance-groups")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instance-groups")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.InstanceGroupList.warning.code",
                ))
            }
        }
    }
}

/// Represents a Managed Instance Group resource.
///
/// An instance group is a collection of VM instances that you can manage as a
/// single entity. For more information, readInstance groups.
///
/// For zonal Managed Instance Group, use the instanceGroupManagers
/// resource.
///
/// For regional Managed Instance Group, use theregionInstanceGroupManagers resource.
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManager {
    /// Specifies configuration that overrides the instance template configuration
    /// for the group.
    pub all_instances_config:
        std::option::Option<crate::model::InstanceGroupManagerAllInstancesConfig>,

    /// The autohealing policy for this managed instance group. You can specify
    /// only one value.
    pub auto_healing_policies: std::vec::Vec<crate::model::InstanceGroupManagerAutoHealingPolicy>,

    /// The base instance name is a prefix that you want to attach to the names of
    /// all VMs in a MIG. The maximum character length is 58 and the name must
    /// comply with RFC1035 format.
    ///
    /// When a VM is created in the group, the MIG appends a hyphen and a random
    /// four-character string to the base instance name. If you want the MIG to
    /// assign sequential numbers instead of a random string, then end the base
    /// instance name with a hyphen followed by one or more hash symbols. The hash
    /// symbols indicate the number of digits. For example, a base instance name of
    /// "vm-###" results in "vm-001" as a VM name.
    /// @pattern
    /// [a-z](([-a-z0-9]{0,57})|([-a-z0-9]{0,51}-#{1,10}(\\[[0-9]{1,10}\\])?))
    pub base_instance_name: std::option::Option<std::string::String>,

    /// [Output Only] The creation timestamp for this managed instance group inRFC3339
    /// text format.
    pub creation_timestamp: std::option::Option<std::string::String>,

    /// [Output Only] The list of instance actions and the number of instances
    /// in this managed instance group that are scheduled for each of those
    /// actions.
    pub current_actions: std::option::Option<crate::model::InstanceGroupManagerActionsSummary>,

    /// An optional description of this resource.
    pub description: std::option::Option<std::string::String>,

    /// Policy specifying the intended distribution of managed instances across
    /// zones in a regional managed instance group.
    pub distribution_policy: std::option::Option<crate::model::DistributionPolicy>,

    /// Fingerprint of this resource. This field may be used in optimistic locking.
    /// It will be ignored when inserting an InstanceGroupManager. An up-to-date
    /// fingerprint must be provided in order to update the InstanceGroupManager,
    /// otherwise the request will fail with error412 conditionNotMet.
    ///
    /// To see the latest fingerprint, make a get() request to
    /// retrieve an InstanceGroupManager.
    pub fingerprint: std::option::Option<::bytes::Bytes>,

    /// [Output Only] A unique identifier for this resource type. The server
    /// generates this identifier.
    pub id: std::option::Option<u64>,

    /// Instance flexibility allowing MIG to create VMs from multiple
    /// types of machines.
    /// Instance flexibility configuration on MIG overrides instance
    /// template configuration.
    pub instance_flexibility_policy:
        std::option::Option<crate::model::InstanceGroupManagerInstanceFlexibilityPolicy>,

    /// [Output Only] The URL of the Instance Group resource.
    pub instance_group: std::option::Option<std::string::String>,

    /// The repair policy for this managed instance group.
    pub instance_lifecycle_policy:
        std::option::Option<crate::model::InstanceGroupManagerInstanceLifecyclePolicy>,

    /// The URL of the instance template that is specified for this managed
    /// instance group. The group uses this template to create all new instances
    /// in the managed instance group. The templates for existing instances in the
    /// group do not change unless you run recreateInstances, runapplyUpdatesToInstances, or set the group'supdatePolicy.type to PROACTIVE.
    pub instance_template: std::option::Option<std::string::String>,

    /// [Output Only] The resource type, which is alwayscompute#instanceGroupManager for managed instance groups.
    pub kind: std::option::Option<std::string::String>,

    /// Pagination behavior of the listManagedInstances API method for
    /// this managed instance group.
    pub list_managed_instances_results:
        std::option::Option<crate::model::instance_group_manager::ListManagedInstancesResults>,

    /// The name of the managed instance group. The name must be 1-63 characters
    /// long, and comply withRFC1035.
    pub name: std::option::Option<std::string::String>,

    /// [Output Only] Named ports configured on the Instance Groups complementary
    /// to this Instance Group Manager.
    pub named_ports: std::vec::Vec<crate::model::NamedPort>,

    /// [Output Only] The URL of theregion
    /// where the managed instance group resides (for regional resources).
    pub region: std::option::Option<std::string::String>,

    /// Resource policies for this managed instance group.
    pub resource_policies: std::option::Option<crate::model::InstanceGroupManagerResourcePolicies>,

    /// [Output Only] Reserved for future use.
    pub satisfies_pzi: std::option::Option<bool>,

    /// [Output Only] Reserved for future use.
    pub satisfies_pzs: std::option::Option<bool>,

    /// [Output Only] The URL for this managed instance group. The server defines
    /// this URL.
    pub self_link: std::option::Option<std::string::String>,

    /// Standby policy for stopped and suspended instances.
    pub standby_policy: std::option::Option<crate::model::InstanceGroupManagerStandbyPolicy>,

    /// Stateful configuration for this Instanced Group Manager
    pub stateful_policy: std::option::Option<crate::model::StatefulPolicy>,

    /// [Output Only] The status of this managed instance group.
    pub status: std::option::Option<crate::model::InstanceGroupManagerStatus>,

    /// The URLs for all TargetPool resources to which instances in theinstanceGroup field are added. The target pools automatically
    /// apply to all of the instances in the managed instance group.
    pub target_pools: std::vec::Vec<std::string::String>,

    /// The target number of running instances for this managed instance group.
    /// You can reduce this number by using the instanceGroupManager
    /// deleteInstances or abandonInstances methods. Resizing the group also
    /// changes this number.
    pub target_size: std::option::Option<i32>,

    /// The target number of stopped instances for this managed instance group.
    /// This number changes when you:
    ///
    /// - Stop instance using the stopInstances
    ///   method or start instances using the startInstances
    ///   method.
    /// - Manually change the targetStoppedSize using the update
    ///   method.
    pub target_stopped_size: std::option::Option<i32>,

    /// The target number of suspended instances for this managed instance group.
    /// This number changes when you:
    ///
    /// - Suspend instance using the suspendInstances
    ///   method or resume instances using the resumeInstances
    ///   method.
    /// - Manually change the targetSuspendedSize using the update
    ///   method.
    pub target_suspended_size: std::option::Option<i32>,

    /// The update policy for this managed instance group.
    pub update_policy: std::option::Option<crate::model::InstanceGroupManagerUpdatePolicy>,

    /// Specifies the instance templates used by this managed instance group to
    /// create instances.
    ///
    /// Each version is defined by an instanceTemplate and aname. Every version can appear at most once per instance
    /// group. This field overrides the top-level instanceTemplate
    /// field. Read more about therelationships
    /// between these fields. Exactly one version must leave thetargetSize field unset. That version will be applied to all
    /// remaining instances. For more information, read aboutcanary
    /// updates.
    pub versions: std::vec::Vec<crate::model::InstanceGroupManagerVersion>,

    /// [Output Only] The URL of azone
    /// where the managed instance group is located (for zonal resources).
    pub zone: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceGroupManager {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [all_instances_config][crate::model::InstanceGroupManager::all_instances_config].
    pub fn set_all_instances_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerAllInstancesConfig>,
    {
        self.all_instances_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [all_instances_config][crate::model::InstanceGroupManager::all_instances_config].
    pub fn set_or_clear_all_instances_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerAllInstancesConfig>,
    {
        self.all_instances_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [auto_healing_policies][crate::model::InstanceGroupManager::auto_healing_policies].
    pub fn set_auto_healing_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceGroupManagerAutoHealingPolicy>,
    {
        use std::iter::Iterator;
        self.auto_healing_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [base_instance_name][crate::model::InstanceGroupManager::base_instance_name].
    pub fn set_base_instance_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.base_instance_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [base_instance_name][crate::model::InstanceGroupManager::base_instance_name].
    pub fn set_or_clear_base_instance_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.base_instance_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creation_timestamp][crate::model::InstanceGroupManager::creation_timestamp].
    pub fn set_creation_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_timestamp][crate::model::InstanceGroupManager::creation_timestamp].
    pub fn set_or_clear_creation_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [current_actions][crate::model::InstanceGroupManager::current_actions].
    pub fn set_current_actions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerActionsSummary>,
    {
        self.current_actions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [current_actions][crate::model::InstanceGroupManager::current_actions].
    pub fn set_or_clear_current_actions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerActionsSummary>,
    {
        self.current_actions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::InstanceGroupManager::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::InstanceGroupManager::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [distribution_policy][crate::model::InstanceGroupManager::distribution_policy].
    pub fn set_distribution_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DistributionPolicy>,
    {
        self.distribution_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [distribution_policy][crate::model::InstanceGroupManager::distribution_policy].
    pub fn set_or_clear_distribution_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DistributionPolicy>,
    {
        self.distribution_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fingerprint][crate::model::InstanceGroupManager::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::InstanceGroupManager::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::InstanceGroupManager::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::InstanceGroupManager::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_flexibility_policy][crate::model::InstanceGroupManager::instance_flexibility_policy].
    pub fn set_instance_flexibility_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerInstanceFlexibilityPolicy>,
    {
        self.instance_flexibility_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_flexibility_policy][crate::model::InstanceGroupManager::instance_flexibility_policy].
    pub fn set_or_clear_instance_flexibility_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerInstanceFlexibilityPolicy>,
    {
        self.instance_flexibility_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_group][crate::model::InstanceGroupManager::instance_group].
    pub fn set_instance_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance_group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_group][crate::model::InstanceGroupManager::instance_group].
    pub fn set_or_clear_instance_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance_group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_lifecycle_policy][crate::model::InstanceGroupManager::instance_lifecycle_policy].
    pub fn set_instance_lifecycle_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerInstanceLifecyclePolicy>,
    {
        self.instance_lifecycle_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_lifecycle_policy][crate::model::InstanceGroupManager::instance_lifecycle_policy].
    pub fn set_or_clear_instance_lifecycle_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerInstanceLifecyclePolicy>,
    {
        self.instance_lifecycle_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_template][crate::model::InstanceGroupManager::instance_template].
    pub fn set_instance_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_template][crate::model::InstanceGroupManager::instance_template].
    pub fn set_or_clear_instance_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance_template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::InstanceGroupManager::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::InstanceGroupManager::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [list_managed_instances_results][crate::model::InstanceGroupManager::list_managed_instances_results].
    pub fn set_list_managed_instances_results<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_manager::ListManagedInstancesResults>,
    {
        self.list_managed_instances_results = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [list_managed_instances_results][crate::model::InstanceGroupManager::list_managed_instances_results].
    pub fn set_or_clear_list_managed_instances_results<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_manager::ListManagedInstancesResults>,
    {
        self.list_managed_instances_results = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::InstanceGroupManager::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::InstanceGroupManager::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [named_ports][crate::model::InstanceGroupManager::named_ports].
    pub fn set_named_ports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NamedPort>,
    {
        use std::iter::Iterator;
        self.named_ports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [region][crate::model::InstanceGroupManager::region].
    pub fn set_region<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.region = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [region][crate::model::InstanceGroupManager::region].
    pub fn set_or_clear_region<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.region = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_policies][crate::model::InstanceGroupManager::resource_policies].
    pub fn set_resource_policies<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerResourcePolicies>,
    {
        self.resource_policies = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_policies][crate::model::InstanceGroupManager::resource_policies].
    pub fn set_or_clear_resource_policies<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerResourcePolicies>,
    {
        self.resource_policies = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::InstanceGroupManager::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::InstanceGroupManager::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::InstanceGroupManager::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::InstanceGroupManager::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::InstanceGroupManager::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::InstanceGroupManager::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [standby_policy][crate::model::InstanceGroupManager::standby_policy].
    pub fn set_standby_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerStandbyPolicy>,
    {
        self.standby_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [standby_policy][crate::model::InstanceGroupManager::standby_policy].
    pub fn set_or_clear_standby_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerStandbyPolicy>,
    {
        self.standby_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stateful_policy][crate::model::InstanceGroupManager::stateful_policy].
    pub fn set_stateful_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StatefulPolicy>,
    {
        self.stateful_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stateful_policy][crate::model::InstanceGroupManager::stateful_policy].
    pub fn set_or_clear_stateful_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StatefulPolicy>,
    {
        self.stateful_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::InstanceGroupManager::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerStatus>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::InstanceGroupManager::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerStatus>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_pools][crate::model::InstanceGroupManager::target_pools].
    pub fn set_target_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_size][crate::model::InstanceGroupManager::target_size].
    pub fn set_target_size<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.target_size = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_size][crate::model::InstanceGroupManager::target_size].
    pub fn set_or_clear_target_size<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.target_size = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_stopped_size][crate::model::InstanceGroupManager::target_stopped_size].
    pub fn set_target_stopped_size<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.target_stopped_size = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_stopped_size][crate::model::InstanceGroupManager::target_stopped_size].
    pub fn set_or_clear_target_stopped_size<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.target_stopped_size = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_suspended_size][crate::model::InstanceGroupManager::target_suspended_size].
    pub fn set_target_suspended_size<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.target_suspended_size = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_suspended_size][crate::model::InstanceGroupManager::target_suspended_size].
    pub fn set_or_clear_target_suspended_size<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.target_suspended_size = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_policy][crate::model::InstanceGroupManager::update_policy].
    pub fn set_update_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerUpdatePolicy>,
    {
        self.update_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_policy][crate::model::InstanceGroupManager::update_policy].
    pub fn set_or_clear_update_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerUpdatePolicy>,
    {
        self.update_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [versions][crate::model::InstanceGroupManager::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceGroupManagerVersion>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [zone][crate::model::InstanceGroupManager::zone].
    pub fn set_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [zone][crate::model::InstanceGroupManager::zone].
    pub fn set_or_clear_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceGroupManager {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManager"
    }
}

/// Defines additional types related to [InstanceGroupManager].
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
pub mod instance_group_manager {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [listManagedInstancesResults][google.cloud.compute.v1.InstanceGroupManager.listManagedInstancesResults] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManager.listManagedInstancesResults]: crate::model::instance_group_manager::ListManagedInstancesResults
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ListManagedInstancesResults {
        /// (Default) Pagination is disabled for the group'slistManagedInstances API method. maxResults
        /// and pageToken query parameters are ignored and all
        /// instances are returned in a single response.
        Pageless,
        /// Pagination is enabled for the group's listManagedInstances
        /// API method. maxResults and pageToken query
        /// parameters are respected.
        Paginated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ListManagedInstancesResults::value] or
        /// [ListManagedInstancesResults::name].
        UnknownValue(list_managed_instances_results::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod list_managed_instances_results {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl ListManagedInstancesResults {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Pageless => std::option::Option::Some(0),
                Self::Paginated => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Pageless => std::option::Option::Some("PAGELESS"),
                Self::Paginated => std::option::Option::Some("PAGINATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for ListManagedInstancesResults {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for ListManagedInstancesResults {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for ListManagedInstancesResults {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Pageless,
                1 => Self::Paginated,
                _ => Self::UnknownValue(list_managed_instances_results::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for ListManagedInstancesResults {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PAGELESS" => Self::Pageless,
                "PAGINATED" => Self::Paginated,
                _ => Self::UnknownValue(list_managed_instances_results::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for ListManagedInstancesResults {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Pageless => serializer.serialize_str("PAGELESS"),
                Self::Paginated => serializer.serialize_str("PAGINATED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for ListManagedInstancesResults {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<ListManagedInstancesResults>::new(
                    ".google.cloud.compute.v1.InstanceGroupManager.listManagedInstancesResults",
                ),
            )
        }
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerActionsSummary {
    /// [Output Only] The total number of instances in the managed instance group
    /// that are scheduled to be abandoned. Abandoning an instance removes it
    /// from the managed instance group without deleting it.
    pub abandoning: std::option::Option<i32>,

    /// [Output Only] The number of instances in the managed instance group that
    /// are scheduled to be created or are currently being created. If the group
    /// fails to create any of these instances, it tries again until it creates
    /// the instance successfully.
    ///
    /// If you have disabled creation retries, this field will not be populated;
    /// instead, the creatingWithoutRetries field will be populated.
    pub creating: std::option::Option<i32>,

    /// [Output Only] The number of instances that the managed instance group
    /// will attempt to create. The group attempts to create each instance
    /// only once. If the group fails to create any of these instances, it
    /// decreases the group's targetSize value accordingly.
    pub creating_without_retries: std::option::Option<i32>,

    /// [Output Only] The number of instances in the managed instance group that
    /// are scheduled to be deleted or are currently being deleted.
    pub deleting: std::option::Option<i32>,

    /// [Output Only] The number of instances in the managed instance group that
    /// are running and have no scheduled actions.
    pub none: std::option::Option<i32>,

    /// [Output Only] The number of instances in the managed instance group that
    /// are scheduled to be recreated or are currently being being recreated.
    /// Recreating an instance deletes the existing root persistent disk
    /// and creates a new disk from the image that is defined in the
    /// instance template.
    pub recreating: std::option::Option<i32>,

    /// [Output Only] The number of instances in the managed instance group that
    /// are being reconfigured with properties that do not require a restart
    /// or a recreate action. For example, setting or removing target
    /// pools for the instance.
    pub refreshing: std::option::Option<i32>,

    /// [Output Only] The number of instances in the managed instance group that
    /// are scheduled to be restarted or are currently being restarted.
    pub restarting: std::option::Option<i32>,

    /// [Output Only] The number of instances in the managed instance group that
    /// are scheduled to be resumed or are currently being resumed.
    pub resuming: std::option::Option<i32>,

    /// [Output Only] The number of instances in the managed instance group that
    /// are scheduled to be started or are currently being started.
    pub starting: std::option::Option<i32>,

    /// [Output Only] The number of instances in the managed instance group that
    /// are scheduled to be stopped or are currently being stopped.
    pub stopping: std::option::Option<i32>,

    /// [Output Only] The number of instances in the managed instance group that
    /// are scheduled to be suspended or are currently being suspended.
    pub suspending: std::option::Option<i32>,

    /// [Output Only] The number of instances in the managed instance group that
    /// are being verified. See the managedInstances[].currentAction
    /// property in the listManagedInstances method documentation.
    pub verifying: std::option::Option<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceGroupManagerActionsSummary {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [abandoning][crate::model::InstanceGroupManagerActionsSummary::abandoning].
    pub fn set_abandoning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.abandoning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [abandoning][crate::model::InstanceGroupManagerActionsSummary::abandoning].
    pub fn set_or_clear_abandoning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.abandoning = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creating][crate::model::InstanceGroupManagerActionsSummary::creating].
    pub fn set_creating<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.creating = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creating][crate::model::InstanceGroupManagerActionsSummary::creating].
    pub fn set_or_clear_creating<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.creating = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creating_without_retries][crate::model::InstanceGroupManagerActionsSummary::creating_without_retries].
    pub fn set_creating_without_retries<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.creating_without_retries = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creating_without_retries][crate::model::InstanceGroupManagerActionsSummary::creating_without_retries].
    pub fn set_or_clear_creating_without_retries<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.creating_without_retries = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deleting][crate::model::InstanceGroupManagerActionsSummary::deleting].
    pub fn set_deleting<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.deleting = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleting][crate::model::InstanceGroupManagerActionsSummary::deleting].
    pub fn set_or_clear_deleting<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.deleting = v.map(|x| x.into());
        self
    }

    /// Sets the value of [none][crate::model::InstanceGroupManagerActionsSummary::none].
    pub fn set_none<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.none = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [none][crate::model::InstanceGroupManagerActionsSummary::none].
    pub fn set_or_clear_none<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.none = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recreating][crate::model::InstanceGroupManagerActionsSummary::recreating].
    pub fn set_recreating<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.recreating = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recreating][crate::model::InstanceGroupManagerActionsSummary::recreating].
    pub fn set_or_clear_recreating<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.recreating = v.map(|x| x.into());
        self
    }

    /// Sets the value of [refreshing][crate::model::InstanceGroupManagerActionsSummary::refreshing].
    pub fn set_refreshing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.refreshing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [refreshing][crate::model::InstanceGroupManagerActionsSummary::refreshing].
    pub fn set_or_clear_refreshing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.refreshing = v.map(|x| x.into());
        self
    }

    /// Sets the value of [restarting][crate::model::InstanceGroupManagerActionsSummary::restarting].
    pub fn set_restarting<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.restarting = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [restarting][crate::model::InstanceGroupManagerActionsSummary::restarting].
    pub fn set_or_clear_restarting<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.restarting = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resuming][crate::model::InstanceGroupManagerActionsSummary::resuming].
    pub fn set_resuming<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.resuming = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resuming][crate::model::InstanceGroupManagerActionsSummary::resuming].
    pub fn set_or_clear_resuming<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.resuming = v.map(|x| x.into());
        self
    }

    /// Sets the value of [starting][crate::model::InstanceGroupManagerActionsSummary::starting].
    pub fn set_starting<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.starting = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [starting][crate::model::InstanceGroupManagerActionsSummary::starting].
    pub fn set_or_clear_starting<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.starting = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stopping][crate::model::InstanceGroupManagerActionsSummary::stopping].
    pub fn set_stopping<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.stopping = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stopping][crate::model::InstanceGroupManagerActionsSummary::stopping].
    pub fn set_or_clear_stopping<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.stopping = v.map(|x| x.into());
        self
    }

    /// Sets the value of [suspending][crate::model::InstanceGroupManagerActionsSummary::suspending].
    pub fn set_suspending<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.suspending = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [suspending][crate::model::InstanceGroupManagerActionsSummary::suspending].
    pub fn set_or_clear_suspending<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.suspending = v.map(|x| x.into());
        self
    }

    /// Sets the value of [verifying][crate::model::InstanceGroupManagerActionsSummary::verifying].
    pub fn set_verifying<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.verifying = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [verifying][crate::model::InstanceGroupManagerActionsSummary::verifying].
    pub fn set_or_clear_verifying<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.verifying = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceGroupManagerActionsSummary {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerActionsSummary"
    }
}

#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerAggregatedList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of InstanceGroupManagersScopedList resources.
    pub items: std::collections::HashMap<
        std::string::String,
        crate::model::InstanceGroupManagersScopedList,
    >,

    /// [Output Only] The resource type, which is alwayscompute#instanceGroupManagerAggregatedList for an aggregated
    /// list of managed instance groups.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Unreachable resources.
    pub unreachables: std::vec::Vec<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::instance_group_manager_aggregated_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagerAggregatedList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::InstanceGroupManagerAggregatedList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::InstanceGroupManagerAggregatedList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::InstanceGroupManagerAggregatedList::items].
    pub fn set_items<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::InstanceGroupManagersScopedList>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [kind][crate::model::InstanceGroupManagerAggregatedList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::InstanceGroupManagerAggregatedList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstanceGroupManagerAggregatedList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::InstanceGroupManagerAggregatedList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::InstanceGroupManagerAggregatedList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::InstanceGroupManagerAggregatedList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [unreachables][crate::model::InstanceGroupManagerAggregatedList::unreachables].
    pub fn set_unreachables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warning][crate::model::InstanceGroupManagerAggregatedList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_manager_aggregated_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::InstanceGroupManagerAggregatedList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_manager_aggregated_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagerAggregatedList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerAggregatedList"
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for InstanceGroupManagerAggregatedList {
    type PageItem = (
        std::string::String,
        crate::model::InstanceGroupManagersScopedList,
    );

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        use std::iter::{IntoIterator, Iterator};
        self.items.into_iter().collect()
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [InstanceGroupManagerAggregatedList].
#[cfg(feature = "instance-group-managers")]
pub mod instance_group_manager_aggregated_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.InstanceGroupManagerAggregatedList.warning] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManagerAggregatedList.warning]: crate::model::instance_group_manager_aggregated_list::Warning
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<
            crate::model::instance_group_manager_aggregated_list::warning::Code,
        >,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data:
            std::vec::Vec<crate::model::instance_group_manager_aggregated_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::instance_group_manager_aggregated_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::instance_group_manager_aggregated_list::warning::Code,
                >,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::instance_group_manager_aggregated_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::instance_group_manager_aggregated_list::warning::Code,
                >,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::instance_group_manager_aggregated_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::instance_group_manager_aggregated_list::warning::Data,
                >,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::instance_group_manager_aggregated_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::instance_group_manager_aggregated_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "instance-group-managers")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerAggregatedList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "instance-group-managers")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.InstanceGroupManagerAggregatedList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupManagerAggregatedList.warning.data]: crate::model::instance_group_manager_aggregated_list::warning::Data
        #[cfg(feature = "instance-group-managers")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instance-group-managers")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::instance_group_manager_aggregated_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::instance_group_manager_aggregated_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::instance_group_manager_aggregated_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::instance_group_manager_aggregated_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerAggregatedList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.InstanceGroupManagerAggregatedList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupManagerAggregatedList.warning.code]: crate::model::instance_group_manager_aggregated_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instance-group-managers")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instance-group-managers")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instance-group-managers")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.InstanceGroupManagerAggregatedList.warning.code",
                ))
            }
        }
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerAllInstancesConfig {
    /// Properties to set on all instances in the group.
    ///
    /// You can add or modify properties using theinstanceGroupManagers.patch orregionInstanceGroupManagers.patch. After settingallInstancesConfig on the group, you must update the group's
    /// instances to apply the configuration. To apply the configuration, set the
    /// group's updatePolicy.type field to use proactive updates or
    /// use the applyUpdatesToInstances method.
    pub properties: std::option::Option<crate::model::InstancePropertiesPatch>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceGroupManagerAllInstancesConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [properties][crate::model::InstanceGroupManagerAllInstancesConfig::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancePropertiesPatch>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::InstanceGroupManagerAllInstancesConfig::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstancePropertiesPatch>,
    {
        self.properties = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceGroupManagerAllInstancesConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerAllInstancesConfig"
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerAutoHealingPolicy {
    /// The URL for the health check that signals autohealing.
    pub health_check: std::option::Option<std::string::String>,

    /// The initial delay is the number of seconds that a new VM takes to
    /// initialize and run its startup script. During a VM's initial delay
    /// period, the MIG ignores unsuccessful health checks because the VM might
    /// be in the startup process. This prevents the MIG from prematurely
    /// recreating a VM. If the health check receives a healthy response during
    /// the initial delay, it indicates that the startup process is complete and
    /// the VM is ready. The value of initial delay must be between 0 and 3600
    /// seconds. The default value is 0.
    pub initial_delay_sec: std::option::Option<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceGroupManagerAutoHealingPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [health_check][crate::model::InstanceGroupManagerAutoHealingPolicy::health_check].
    pub fn set_health_check<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.health_check = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [health_check][crate::model::InstanceGroupManagerAutoHealingPolicy::health_check].
    pub fn set_or_clear_health_check<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.health_check = v.map(|x| x.into());
        self
    }

    /// Sets the value of [initial_delay_sec][crate::model::InstanceGroupManagerAutoHealingPolicy::initial_delay_sec].
    pub fn set_initial_delay_sec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.initial_delay_sec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [initial_delay_sec][crate::model::InstanceGroupManagerAutoHealingPolicy::initial_delay_sec].
    pub fn set_or_clear_initial_delay_sec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.initial_delay_sec = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceGroupManagerAutoHealingPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerAutoHealingPolicy"
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerInstanceFlexibilityPolicy {
    /// Named instance selections configuring properties that the group will use
    /// when creating new VMs.
    pub instance_selections: std::collections::HashMap<
        std::string::String,
        crate::model::InstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection,
    >,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceGroupManagerInstanceFlexibilityPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_selections][crate::model::InstanceGroupManagerInstanceFlexibilityPolicy::instance_selections].
    pub fn set_instance_selections<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<
                crate::model::InstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection,
            >,
    {
        use std::iter::Iterator;
        self.instance_selections = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceGroupManagerInstanceFlexibilityPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerInstanceFlexibilityPolicy"
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection {
    /// Full machine-type names, e.g. "n1-standard-16".
    pub machine_types: std::vec::Vec<std::string::String>,

    /// Preference of this instance selection. Lower number means higher
    /// preference. MIG will first try to create a VM based on the machine-type
    /// with lowest rank and fallback to next rank based on availability.
    /// Machine types and instance selections with the same rank have the same
    /// preference.
    pub rank: std::option::Option<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_types][crate::model::InstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection::machine_types].
    pub fn set_machine_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.machine_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rank][crate::model::InstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection::rank].
    pub fn set_rank<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.rank = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rank][crate::model::InstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection::rank].
    pub fn set_or_clear_rank<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.rank = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerInstanceFlexibilityPolicyInstanceSelection"
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerInstanceLifecyclePolicy {
    /// The action that a MIG performs on a failed or an unhealthy VM.
    /// A VM is marked as unhealthy when the application running on that
    /// VM fails a health check.
    /// Valid values are
    ///
    /// - REPAIR (default): MIG automatically repairs a failed or
    ///   an unhealthy VM by recreating it. For more information, see About
    ///   repairing VMs in a MIG.
    /// - DO_NOTHING: MIG does not repair a failed or an unhealthy
    ///   VM.
    pub default_action_on_failure: std::option::Option<
        crate::model::instance_group_manager_instance_lifecycle_policy::DefaultActionOnFailure,
    >,

    /// A bit indicating whether to forcefully apply the group's latest
    /// configuration when repairing a VM. Valid options are:
    ///
    /// ```norust
    ///  -  NO (default): If configuration updates are available, they are not
    ///  forcefully applied during repair. Instead, configuration updates are
    ///  applied according to the group's update policy.
    ///
    ///  -  YES: If configuration updates are available, they are applied
    ///  during repair.
    /// ```
    pub force_update_on_repair: std::option::Option<
        crate::model::instance_group_manager_instance_lifecycle_policy::ForceUpdateOnRepair,
    >,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceGroupManagerInstanceLifecyclePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [default_action_on_failure][crate::model::InstanceGroupManagerInstanceLifecyclePolicy::default_action_on_failure].
    pub fn set_default_action_on_failure<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::instance_group_manager_instance_lifecycle_policy::DefaultActionOnFailure>
    {
        self.default_action_on_failure = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_action_on_failure][crate::model::InstanceGroupManagerInstanceLifecyclePolicy::default_action_on_failure].
    pub fn set_or_clear_default_action_on_failure<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::instance_group_manager_instance_lifecycle_policy::DefaultActionOnFailure>
    {
        self.default_action_on_failure = v.map(|x| x.into());
        self
    }

    /// Sets the value of [force_update_on_repair][crate::model::InstanceGroupManagerInstanceLifecyclePolicy::force_update_on_repair].
    pub fn set_force_update_on_repair<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::instance_group_manager_instance_lifecycle_policy::ForceUpdateOnRepair,
            >,
    {
        self.force_update_on_repair = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [force_update_on_repair][crate::model::InstanceGroupManagerInstanceLifecyclePolicy::force_update_on_repair].
    pub fn set_or_clear_force_update_on_repair<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::instance_group_manager_instance_lifecycle_policy::ForceUpdateOnRepair,
            >,
    {
        self.force_update_on_repair = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceGroupManagerInstanceLifecyclePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerInstanceLifecyclePolicy"
    }
}

/// Defines additional types related to [InstanceGroupManagerInstanceLifecyclePolicy].
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
pub mod instance_group_manager_instance_lifecycle_policy {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [defaultActionOnFailure][google.cloud.compute.v1.InstanceGroupManagerInstanceLifecyclePolicy.defaultActionOnFailure] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManagerInstanceLifecyclePolicy.defaultActionOnFailure]: crate::model::instance_group_manager_instance_lifecycle_policy::DefaultActionOnFailure
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DefaultActionOnFailure {
        /// MIG does not repair a failed or an unhealthy VM.
        DoNothing,
        /// (Default) MIG automatically repairs a failed or an unhealthy
        /// VM by recreating it. For more information, see About
        /// repairing VMs in a MIG.
        Repair,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DefaultActionOnFailure::value] or
        /// [DefaultActionOnFailure::name].
        UnknownValue(default_action_on_failure::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod default_action_on_failure {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl DefaultActionOnFailure {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::DoNothing => std::option::Option::Some(0),
                Self::Repair => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::DoNothing => std::option::Option::Some("DO_NOTHING"),
                Self::Repair => std::option::Option::Some("REPAIR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for DefaultActionOnFailure {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for DefaultActionOnFailure {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for DefaultActionOnFailure {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::DoNothing,
                1 => Self::Repair,
                _ => Self::UnknownValue(default_action_on_failure::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for DefaultActionOnFailure {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DO_NOTHING" => Self::DoNothing,
                "REPAIR" => Self::Repair,
                _ => Self::UnknownValue(default_action_on_failure::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for DefaultActionOnFailure {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::DoNothing => serializer.serialize_str("DO_NOTHING"),
                Self::Repair => serializer.serialize_str("REPAIR"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for DefaultActionOnFailure {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DefaultActionOnFailure>::new(
                ".google.cloud.compute.v1.InstanceGroupManagerInstanceLifecyclePolicy.defaultActionOnFailure"))
        }
    }

    /// The enumerated type for the [forceUpdateOnRepair][google.cloud.compute.v1.InstanceGroupManagerInstanceLifecyclePolicy.forceUpdateOnRepair] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManagerInstanceLifecyclePolicy.forceUpdateOnRepair]: crate::model::instance_group_manager_instance_lifecycle_policy::ForceUpdateOnRepair
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ForceUpdateOnRepair {
        No,
        Yes,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ForceUpdateOnRepair::value] or
        /// [ForceUpdateOnRepair::name].
        UnknownValue(force_update_on_repair::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod force_update_on_repair {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl ForceUpdateOnRepair {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::No => std::option::Option::Some(0),
                Self::Yes => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::No => std::option::Option::Some("NO"),
                Self::Yes => std::option::Option::Some("YES"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for ForceUpdateOnRepair {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for ForceUpdateOnRepair {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for ForceUpdateOnRepair {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::No,
                1 => Self::Yes,
                _ => Self::UnknownValue(force_update_on_repair::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for ForceUpdateOnRepair {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NO" => Self::No,
                "YES" => Self::Yes,
                _ => Self::UnknownValue(force_update_on_repair::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for ForceUpdateOnRepair {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::No => serializer.serialize_str("NO"),
                Self::Yes => serializer.serialize_str("YES"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for ForceUpdateOnRepair {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ForceUpdateOnRepair>::new(
                ".google.cloud.compute.v1.InstanceGroupManagerInstanceLifecyclePolicy.forceUpdateOnRepair"))
        }
    }
}

/// [Output Only] A list of managed instance groups.
#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of InstanceGroupManager resources.
    pub items: std::vec::Vec<crate::model::InstanceGroupManager>,

    /// [Output Only] The resource type, which is always
    /// compute#instanceGroupManagerList for a list of managed instance groups.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::instance_group_manager_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagerList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::InstanceGroupManagerList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::InstanceGroupManagerList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::InstanceGroupManagerList::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceGroupManager>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::InstanceGroupManagerList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::InstanceGroupManagerList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstanceGroupManagerList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::InstanceGroupManagerList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::InstanceGroupManagerList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::InstanceGroupManagerList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::InstanceGroupManagerList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_manager_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::InstanceGroupManagerList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_manager_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagerList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerList"
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for InstanceGroupManagerList {
    type PageItem = crate::model::InstanceGroupManager;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [InstanceGroupManagerList].
#[cfg(feature = "instance-group-managers")]
pub mod instance_group_manager_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.InstanceGroupManagerList.warning] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManagerList.warning]: crate::model::instance_group_manager_list::Warning
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::instance_group_manager_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::instance_group_manager_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::instance_group_manager_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::instance_group_manager_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::instance_group_manager_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::instance_group_manager_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::instance_group_manager_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance_group_manager_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::instance_group_manager_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::instance_group_manager_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "instance-group-managers")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "instance-group-managers")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.InstanceGroupManagerList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupManagerList.warning.data]: crate::model::instance_group_manager_list::warning::Data
        #[cfg(feature = "instance-group-managers")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instance-group-managers")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::instance_group_manager_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::instance_group_manager_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::instance_group_manager_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::instance_group_manager_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.InstanceGroupManagerList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupManagerList.warning.code]: crate::model::instance_group_manager_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instance-group-managers")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instance-group-managers")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instance-group-managers")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.InstanceGroupManagerList.warning.code",
                ))
            }
        }
    }
}

/// InstanceGroupManagerResizeRequest represents a request to create
/// a number of VMs: either immediately or by queuing the request for the
/// specified time. This resize request is nested under InstanceGroupManager
/// and the VMs created by this request are added to the owning
/// InstanceGroupManager.
#[cfg(feature = "instance-group-manager-resize-requests")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerResizeRequest {
    /// [Output Only] The creation timestamp for this resize request inRFC3339
    /// text format.
    pub creation_timestamp: std::option::Option<std::string::String>,

    /// An optional description of this resource.
    pub description: std::option::Option<std::string::String>,

    /// [Output Only] A unique identifier for this resource type. The server
    /// generates this identifier.
    pub id: std::option::Option<u64>,

    /// [Output Only] The resource type, which is alwayscompute#instanceGroupManagerResizeRequest for
    /// resize requests.
    pub kind: std::option::Option<std::string::String>,

    /// The name of this resize request. The name must be 1-63 characters
    /// long, and comply withRFC1035.
    pub name: std::option::Option<std::string::String>,

    /// Requested run duration for instances that will be created by this request.
    /// At the end of the run duration instance will be deleted.
    pub requested_run_duration: std::option::Option<crate::model::Duration>,

    /// The number of instances to be created by this resize request. The group's
    /// target size will be increased by this number. This field cannot be used
    /// together with 'instances'.
    pub resize_by: std::option::Option<i32>,

    /// [Output Only] The URL for this resize request. The server defines
    /// this URL.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource with the resource id.
    pub self_link_with_id: std::option::Option<std::string::String>,

    /// [Output only] Current state of the request.
    pub state: std::option::Option<crate::model::instance_group_manager_resize_request::State>,

    /// [Output only] Status of the request.
    pub status: std::option::Option<crate::model::InstanceGroupManagerResizeRequestStatus>,

    /// [Output Only] The URL of azone
    /// where the resize request is located. Populated only for zonal resize
    /// requests.
    pub zone: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl InstanceGroupManagerResizeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [creation_timestamp][crate::model::InstanceGroupManagerResizeRequest::creation_timestamp].
    pub fn set_creation_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_timestamp][crate::model::InstanceGroupManagerResizeRequest::creation_timestamp].
    pub fn set_or_clear_creation_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::InstanceGroupManagerResizeRequest::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::InstanceGroupManagerResizeRequest::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::InstanceGroupManagerResizeRequest::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::InstanceGroupManagerResizeRequest::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::InstanceGroupManagerResizeRequest::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::InstanceGroupManagerResizeRequest::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::InstanceGroupManagerResizeRequest::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::InstanceGroupManagerResizeRequest::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [requested_run_duration][crate::model::InstanceGroupManagerResizeRequest::requested_run_duration].
    pub fn set_requested_run_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Duration>,
    {
        self.requested_run_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requested_run_duration][crate::model::InstanceGroupManagerResizeRequest::requested_run_duration].
    pub fn set_or_clear_requested_run_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Duration>,
    {
        self.requested_run_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resize_by][crate::model::InstanceGroupManagerResizeRequest::resize_by].
    pub fn set_resize_by<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.resize_by = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resize_by][crate::model::InstanceGroupManagerResizeRequest::resize_by].
    pub fn set_or_clear_resize_by<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.resize_by = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::InstanceGroupManagerResizeRequest::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::InstanceGroupManagerResizeRequest::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link_with_id][crate::model::InstanceGroupManagerResizeRequest::self_link_with_id].
    pub fn set_self_link_with_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link_with_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link_with_id][crate::model::InstanceGroupManagerResizeRequest::self_link_with_id].
    pub fn set_or_clear_self_link_with_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link_with_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::InstanceGroupManagerResizeRequest::state].
    pub fn set_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_manager_resize_request::State>,
    {
        self.state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state][crate::model::InstanceGroupManagerResizeRequest::state].
    pub fn set_or_clear_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_manager_resize_request::State>,
    {
        self.state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::InstanceGroupManagerResizeRequest::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerResizeRequestStatus>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::InstanceGroupManagerResizeRequest::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerResizeRequestStatus>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [zone][crate::model::InstanceGroupManagerResizeRequest::zone].
    pub fn set_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [zone][crate::model::InstanceGroupManagerResizeRequest::zone].
    pub fn set_or_clear_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl wkt::message::Message for InstanceGroupManagerResizeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerResizeRequest"
    }
}

/// Defines additional types related to [InstanceGroupManagerResizeRequest].
#[cfg(feature = "instance-group-manager-resize-requests")]
pub mod instance_group_manager_resize_request {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [state][google.cloud.compute.v1.InstanceGroupManagerResizeRequest.state] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManagerResizeRequest.state]: crate::model::instance_group_manager_resize_request::State
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instance-group-manager-resize-requests")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The request was created successfully and was accepted for provisioning
        /// when the capacity becomes available.
        Accepted,
        /// The request is cancelled.
        Cancelled,
        /// Resize request is being created and may still fail creation.
        Creating,
        /// The request failed before or during provisioning. If the request fails
        /// during provisioning, any VMs that were created during provisioning are
        /// rolled back and removed from the MIG.
        Failed,
        /// Default value. This value should never be returned.
        Unspecified,
        /// The request succeeded.
        Succeeded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instance-group-manager-resize-requests")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instance-group-manager-resize-requests")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Accepted => std::option::Option::Some(0),
                Self::Cancelled => std::option::Option::Some(1),
                Self::Creating => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Unspecified => std::option::Option::Some(4),
                Self::Succeeded => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Accepted => std::option::Option::Some("ACCEPTED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instance-group-manager-resize-requests")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instance-group-manager-resize-requests")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instance-group-manager-resize-requests")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Accepted,
                1 => Self::Cancelled,
                2 => Self::Creating,
                3 => Self::Failed,
                4 => Self::Unspecified,
                5 => Self::Succeeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instance-group-manager-resize-requests")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACCEPTED" => Self::Accepted,
                "CANCELLED" => Self::Cancelled,
                "CREATING" => Self::Creating,
                "FAILED" => Self::Failed,
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "SUCCEEDED" => Self::Succeeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instance-group-manager-resize-requests")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Accepted => serializer.serialize_str("ACCEPTED"),
                Self::Cancelled => serializer.serialize_str("CANCELLED"),
                Self::Creating => serializer.serialize_str("CREATING"),
                Self::Failed => serializer.serialize_str("FAILED"),
                Self::Unspecified => serializer.serialize_str("STATE_UNSPECIFIED"),
                Self::Succeeded => serializer.serialize_str("SUCCEEDED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instance-group-manager-resize-requests")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.compute.v1.InstanceGroupManagerResizeRequest.state",
            ))
        }
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerResizeRequestStatus {
    /// [Output only] Fatal errors encountered during the queueing or
    /// provisioning phases of the ResizeRequest that caused the transition to
    /// the FAILED state. Contrary to the last_attempt errors, this field is
    /// final and errors are never removed from here, as the ResizeRequest is not
    /// going to retry.
    pub error:
        std::option::Option<crate::model::instance_group_manager_resize_request_status::Error>,

    /// [Output only] Information about the last attempt to fulfill the request.
    /// The value is temporary since the ResizeRequest can retry, as long as it's
    /// still active and the last attempt value can either be cleared or replaced
    /// with a different error. Since ResizeRequest retries infrequently, the
    /// value may be stale and no longer show an active problem. The value is
    /// cleared when ResizeRequest transitions to the final state (becomes
    /// inactive). If the final state is FAILED the error describing it will be
    /// storred in the "error" field only.
    pub last_attempt:
        std::option::Option<crate::model::InstanceGroupManagerResizeRequestStatusLastAttempt>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl InstanceGroupManagerResizeRequestStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error][crate::model::InstanceGroupManagerResizeRequestStatus::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_manager_resize_request_status::Error>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::InstanceGroupManagerResizeRequestStatus::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_manager_resize_request_status::Error>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_attempt][crate::model::InstanceGroupManagerResizeRequestStatus::last_attempt].
    pub fn set_last_attempt<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerResizeRequestStatusLastAttempt>,
    {
        self.last_attempt = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_attempt][crate::model::InstanceGroupManagerResizeRequestStatus::last_attempt].
    pub fn set_or_clear_last_attempt<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerResizeRequestStatusLastAttempt>,
    {
        self.last_attempt = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl wkt::message::Message for InstanceGroupManagerResizeRequestStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatus"
    }
}

/// Defines additional types related to [InstanceGroupManagerResizeRequestStatus].
#[cfg(feature = "instance-group-manager-resize-requests")]
pub mod instance_group_manager_resize_request_status {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [error][google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatus.error] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatus.error]: crate::model::instance_group_manager_resize_request_status::Error
    #[cfg(feature = "instance-group-manager-resize-requests")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Error {
        /// [Output Only] The array of errors encountered while processing this
        /// operation.
        pub errors: std::vec::Vec<
            crate::model::instance_group_manager_resize_request_status::error::Errors,
        >,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-manager-resize-requests")]
    impl Error {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [errors][crate::model::instance_group_manager_resize_request_status::Error::errors].
        pub fn set_errors<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::instance_group_manager_resize_request_status::error::Errors,
                >,
        {
            use std::iter::Iterator;
            self.errors = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "instance-group-manager-resize-requests")]
    impl wkt::message::Message for Error {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatus.error"
        }
    }

    /// Defines additional types related to [Error].
    #[cfg(feature = "instance-group-manager-resize-requests")]
    pub mod error {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [errors][google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatus.error.errors] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatus.error.errors]: crate::model::instance_group_manager_resize_request_status::error::Errors
        #[cfg(feature = "instance-group-manager-resize-requests")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Errors {

            /// [Output Only] The error type identifier for this error.
            pub code: std::option::Option<std::string::String>,

            /// [Output Only] An optional list of messages that contain the error
            /// details. There is a set of defined message types to use for providing
            /// details.The syntax depends on the error code. For example,
            /// QuotaExceededInfo will have details when the error code is
            /// QUOTA_EXCEEDED.
            pub error_details: std::vec::Vec<crate::model::instance_group_manager_resize_request_status::error::errors::ErrorDetails>,

            /// [Output Only] Indicates the field in the request that caused the error.
            /// This property is optional.
            pub location: std::option::Option<std::string::String>,

            /// [Output Only] An optional, human-readable error message.
            pub message: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instance-group-manager-resize-requests")]
        impl Errors {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [code][crate::model::instance_group_manager_resize_request_status::error::Errors::code].
            pub fn set_code<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.code = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [code][crate::model::instance_group_manager_resize_request_status::error::Errors::code].
            pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.code = v.map(|x| x.into());
                self
            }

            /// Sets the value of [error_details][crate::model::instance_group_manager_resize_request_status::error::Errors::error_details].
            pub fn set_error_details<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::instance_group_manager_resize_request_status::error::errors::ErrorDetails>
            {
                use std::iter::Iterator;
                self.error_details = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [location][crate::model::instance_group_manager_resize_request_status::error::Errors::location].
            pub fn set_location<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.location = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [location][crate::model::instance_group_manager_resize_request_status::error::Errors::location].
            pub fn set_or_clear_location<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.location = v.map(|x| x.into());
                self
            }

            /// Sets the value of [message][crate::model::instance_group_manager_resize_request_status::error::Errors::message].
            pub fn set_message<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.message = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [message][crate::model::instance_group_manager_resize_request_status::error::Errors::message].
            pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.message = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instance-group-manager-resize-requests")]
        impl wkt::message::Message for Errors {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatus.error.errors"
            }
        }

        /// Defines additional types related to [Errors].
        #[cfg(feature = "instance-group-manager-resize-requests")]
        pub mod errors {
            #[allow(unused_imports)]
            use super::*;

            /// The message type for the [errorDetails][google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatus.error.errors.errorDetails] field.
            ///
            /// [google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatus.error.errors.errorDetails]: crate::model::instance_group_manager_resize_request_status::error::errors::ErrorDetails
            #[cfg(feature = "instance-group-manager-resize-requests")]
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ErrorDetails {
                pub error_info: std::option::Option<crate::model::ErrorInfo>,

                pub help: std::option::Option<crate::model::Help>,

                pub localized_message: std::option::Option<crate::model::LocalizedMessage>,

                pub quota_info: std::option::Option<crate::model::QuotaExceededInfo>,

                pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(feature = "instance-group-manager-resize-requests")]
            impl ErrorDetails {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [error_info][crate::model::instance_group_manager_resize_request_status::error::errors::ErrorDetails::error_info].
                pub fn set_error_info<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::ErrorInfo>,
                {
                    self.error_info = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [error_info][crate::model::instance_group_manager_resize_request_status::error::errors::ErrorDetails::error_info].
                pub fn set_or_clear_error_info<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::ErrorInfo>,
                {
                    self.error_info = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [help][crate::model::instance_group_manager_resize_request_status::error::errors::ErrorDetails::help].
                pub fn set_help<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::Help>,
                {
                    self.help = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [help][crate::model::instance_group_manager_resize_request_status::error::errors::ErrorDetails::help].
                pub fn set_or_clear_help<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::Help>,
                {
                    self.help = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [localized_message][crate::model::instance_group_manager_resize_request_status::error::errors::ErrorDetails::localized_message].
                pub fn set_localized_message<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::LocalizedMessage>,
                {
                    self.localized_message = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [localized_message][crate::model::instance_group_manager_resize_request_status::error::errors::ErrorDetails::localized_message].
                pub fn set_or_clear_localized_message<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<crate::model::LocalizedMessage>,
                {
                    self.localized_message = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [quota_info][crate::model::instance_group_manager_resize_request_status::error::errors::ErrorDetails::quota_info].
                pub fn set_quota_info<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::QuotaExceededInfo>,
                {
                    self.quota_info = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [quota_info][crate::model::instance_group_manager_resize_request_status::error::errors::ErrorDetails::quota_info].
                pub fn set_or_clear_quota_info<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::QuotaExceededInfo>,
                {
                    self.quota_info = v.map(|x| x.into());
                    self
                }
            }

            #[cfg(feature = "instance-group-manager-resize-requests")]
            impl wkt::message::Message for ErrorDetails {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatus.error.errors.errorDetails"
                }
            }
        }
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerResizeRequestStatusLastAttempt {
    /// Errors that prevented the ResizeRequest to be fulfilled.
    pub error: std::option::Option<
        crate::model::instance_group_manager_resize_request_status_last_attempt::Error,
    >,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl InstanceGroupManagerResizeRequestStatusLastAttempt {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error][crate::model::InstanceGroupManagerResizeRequestStatusLastAttempt::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::instance_group_manager_resize_request_status_last_attempt::Error,
            >,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::InstanceGroupManagerResizeRequestStatusLastAttempt::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::instance_group_manager_resize_request_status_last_attempt::Error,
            >,
    {
        self.error = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl wkt::message::Message for InstanceGroupManagerResizeRequestStatusLastAttempt {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatusLastAttempt"
    }
}

/// Defines additional types related to [InstanceGroupManagerResizeRequestStatusLastAttempt].
#[cfg(feature = "instance-group-manager-resize-requests")]
pub mod instance_group_manager_resize_request_status_last_attempt {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [error][google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatusLastAttempt.error] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatusLastAttempt.error]: crate::model::instance_group_manager_resize_request_status_last_attempt::Error
    #[cfg(feature = "instance-group-manager-resize-requests")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Error {
        /// [Output Only] The array of errors encountered while processing this
        /// operation.
        pub errors: std::vec::Vec<
            crate::model::instance_group_manager_resize_request_status_last_attempt::error::Errors,
        >,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-manager-resize-requests")]
    impl Error {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [errors][crate::model::instance_group_manager_resize_request_status_last_attempt::Error::errors].
        pub fn set_errors<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance_group_manager_resize_request_status_last_attempt::error::Errors>
        {
            use std::iter::Iterator;
            self.errors = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "instance-group-manager-resize-requests")]
    impl wkt::message::Message for Error {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatusLastAttempt.error"
        }
    }

    /// Defines additional types related to [Error].
    #[cfg(feature = "instance-group-manager-resize-requests")]
    pub mod error {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [errors][google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatusLastAttempt.error.errors] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatusLastAttempt.error.errors]: crate::model::instance_group_manager_resize_request_status_last_attempt::error::Errors
        #[cfg(feature = "instance-group-manager-resize-requests")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Errors {

            /// [Output Only] The error type identifier for this error.
            pub code: std::option::Option<std::string::String>,

            /// [Output Only] An optional list of messages that contain the error
            /// details. There is a set of defined message types to use for providing
            /// details.The syntax depends on the error code. For example,
            /// QuotaExceededInfo will have details when the error code is
            /// QUOTA_EXCEEDED.
            pub error_details: std::vec::Vec<crate::model::instance_group_manager_resize_request_status_last_attempt::error::errors::ErrorDetails>,

            /// [Output Only] Indicates the field in the request that caused the error.
            /// This property is optional.
            pub location: std::option::Option<std::string::String>,

            /// [Output Only] An optional, human-readable error message.
            pub message: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instance-group-manager-resize-requests")]
        impl Errors {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [code][crate::model::instance_group_manager_resize_request_status_last_attempt::error::Errors::code].
            pub fn set_code<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.code = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [code][crate::model::instance_group_manager_resize_request_status_last_attempt::error::Errors::code].
            pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.code = v.map(|x| x.into());
                self
            }

            /// Sets the value of [error_details][crate::model::instance_group_manager_resize_request_status_last_attempt::error::Errors::error_details].
            pub fn set_error_details<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::instance_group_manager_resize_request_status_last_attempt::error::errors::ErrorDetails>
            {
                use std::iter::Iterator;
                self.error_details = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [location][crate::model::instance_group_manager_resize_request_status_last_attempt::error::Errors::location].
            pub fn set_location<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.location = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [location][crate::model::instance_group_manager_resize_request_status_last_attempt::error::Errors::location].
            pub fn set_or_clear_location<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.location = v.map(|x| x.into());
                self
            }

            /// Sets the value of [message][crate::model::instance_group_manager_resize_request_status_last_attempt::error::Errors::message].
            pub fn set_message<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.message = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [message][crate::model::instance_group_manager_resize_request_status_last_attempt::error::Errors::message].
            pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.message = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instance-group-manager-resize-requests")]
        impl wkt::message::Message for Errors {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatusLastAttempt.error.errors"
            }
        }

        /// Defines additional types related to [Errors].
        #[cfg(feature = "instance-group-manager-resize-requests")]
        pub mod errors {
            #[allow(unused_imports)]
            use super::*;

            /// The message type for the [errorDetails][google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatusLastAttempt.error.errors.errorDetails] field.
            ///
            /// [google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatusLastAttempt.error.errors.errorDetails]: crate::model::instance_group_manager_resize_request_status_last_attempt::error::errors::ErrorDetails
            #[cfg(feature = "instance-group-manager-resize-requests")]
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ErrorDetails {
                pub error_info: std::option::Option<crate::model::ErrorInfo>,

                pub help: std::option::Option<crate::model::Help>,

                pub localized_message: std::option::Option<crate::model::LocalizedMessage>,

                pub quota_info: std::option::Option<crate::model::QuotaExceededInfo>,

                pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(feature = "instance-group-manager-resize-requests")]
            impl ErrorDetails {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [error_info][crate::model::instance_group_manager_resize_request_status_last_attempt::error::errors::ErrorDetails::error_info].
                pub fn set_error_info<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::ErrorInfo>,
                {
                    self.error_info = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [error_info][crate::model::instance_group_manager_resize_request_status_last_attempt::error::errors::ErrorDetails::error_info].
                pub fn set_or_clear_error_info<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::ErrorInfo>,
                {
                    self.error_info = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [help][crate::model::instance_group_manager_resize_request_status_last_attempt::error::errors::ErrorDetails::help].
                pub fn set_help<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::Help>,
                {
                    self.help = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [help][crate::model::instance_group_manager_resize_request_status_last_attempt::error::errors::ErrorDetails::help].
                pub fn set_or_clear_help<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::Help>,
                {
                    self.help = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [localized_message][crate::model::instance_group_manager_resize_request_status_last_attempt::error::errors::ErrorDetails::localized_message].
                pub fn set_localized_message<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::LocalizedMessage>,
                {
                    self.localized_message = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [localized_message][crate::model::instance_group_manager_resize_request_status_last_attempt::error::errors::ErrorDetails::localized_message].
                pub fn set_or_clear_localized_message<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<crate::model::LocalizedMessage>,
                {
                    self.localized_message = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [quota_info][crate::model::instance_group_manager_resize_request_status_last_attempt::error::errors::ErrorDetails::quota_info].
                pub fn set_quota_info<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::QuotaExceededInfo>,
                {
                    self.quota_info = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [quota_info][crate::model::instance_group_manager_resize_request_status_last_attempt::error::errors::ErrorDetails::quota_info].
                pub fn set_or_clear_quota_info<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::QuotaExceededInfo>,
                {
                    self.quota_info = v.map(|x| x.into());
                    self
                }
            }

            #[cfg(feature = "instance-group-manager-resize-requests")]
            impl wkt::message::Message for ErrorDetails {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerResizeRequestStatusLastAttempt.error.errors.errorDetails"
                }
            }
        }
    }
}

/// [Output Only] A list of resize requests.
#[cfg(feature = "instance-group-manager-resize-requests")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerResizeRequestsListResponse {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of resize request resources.
    pub items: std::vec::Vec<crate::model::InstanceGroupManagerResizeRequest>,

    /// [Output Only] Type of the resource. Alwayscompute#instanceGroupManagerResizeRequestList for
    /// a list of resize requests.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<
        crate::model::instance_group_manager_resize_requests_list_response::Warning,
    >,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl InstanceGroupManagerResizeRequestsListResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::InstanceGroupManagerResizeRequestsListResponse::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::InstanceGroupManagerResizeRequestsListResponse::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::InstanceGroupManagerResizeRequestsListResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceGroupManagerResizeRequest>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::InstanceGroupManagerResizeRequestsListResponse::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::InstanceGroupManagerResizeRequestsListResponse::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstanceGroupManagerResizeRequestsListResponse::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::InstanceGroupManagerResizeRequestsListResponse::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::InstanceGroupManagerResizeRequestsListResponse::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::InstanceGroupManagerResizeRequestsListResponse::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::InstanceGroupManagerResizeRequestsListResponse::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::instance_group_manager_resize_requests_list_response::Warning,
            >,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::InstanceGroupManagerResizeRequestsListResponse::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::instance_group_manager_resize_requests_list_response::Warning,
            >,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl wkt::message::Message for InstanceGroupManagerResizeRequestsListResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerResizeRequestsListResponse"
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for InstanceGroupManagerResizeRequestsListResponse {
    type PageItem = crate::model::InstanceGroupManagerResizeRequest;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [InstanceGroupManagerResizeRequestsListResponse].
#[cfg(feature = "instance-group-manager-resize-requests")]
pub mod instance_group_manager_resize_requests_list_response {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.InstanceGroupManagerResizeRequestsListResponse.warning] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManagerResizeRequestsListResponse.warning]: crate::model::instance_group_manager_resize_requests_list_response::Warning
    #[cfg(feature = "instance-group-manager-resize-requests")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<
            crate::model::instance_group_manager_resize_requests_list_response::warning::Code,
        >,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<
            crate::model::instance_group_manager_resize_requests_list_response::warning::Data,
        >,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-manager-resize-requests")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::instance_group_manager_resize_requests_list_response::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::instance_group_manager_resize_requests_list_response::warning::Code>
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::instance_group_manager_resize_requests_list_response::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::instance_group_manager_resize_requests_list_response::warning::Code>
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::instance_group_manager_resize_requests_list_response::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance_group_manager_resize_requests_list_response::warning::Data>
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::instance_group_manager_resize_requests_list_response::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::instance_group_manager_resize_requests_list_response::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "instance-group-manager-resize-requests")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerResizeRequestsListResponse.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "instance-group-manager-resize-requests")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.InstanceGroupManagerResizeRequestsListResponse.warning.data] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupManagerResizeRequestsListResponse.warning.data]: crate::model::instance_group_manager_resize_requests_list_response::warning::Data
        #[cfg(feature = "instance-group-manager-resize-requests")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instance-group-manager-resize-requests")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::instance_group_manager_resize_requests_list_response::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::instance_group_manager_resize_requests_list_response::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::instance_group_manager_resize_requests_list_response::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::instance_group_manager_resize_requests_list_response::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instance-group-manager-resize-requests")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerResizeRequestsListResponse.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.InstanceGroupManagerResizeRequestsListResponse.warning.code] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupManagerResizeRequestsListResponse.warning.code]: crate::model::instance_group_manager_resize_requests_list_response::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instance-group-manager-resize-requests")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instance-group-manager-resize-requests")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instance-group-manager-resize-requests")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instance-group-manager-resize-requests")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instance-group-manager-resize-requests")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instance-group-manager-resize-requests")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instance-group-manager-resize-requests")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instance-group-manager-resize-requests")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instance-group-manager-resize-requests")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.InstanceGroupManagerResizeRequestsListResponse.warning.code"))
            }
        }
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerResourcePolicies {
    /// The URL of the workload policy that is specified for this managed
    /// instance group.
    /// It can be a full or partial URL. For example, the following are
    /// all valid URLs to a workload policy:
    ///
    /// ```norust
    ///   - https://www.googleapis.com/compute/v1/projects/project/regions/region/resourcePolicies/resourcePolicy
    ///   - projects/project/regions/region/resourcePolicies/resourcePolicy
    ///   - regions/region/resourcePolicies/resourcePolicy
    /// ```
    pub workload_policy: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceGroupManagerResourcePolicies {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workload_policy][crate::model::InstanceGroupManagerResourcePolicies::workload_policy].
    pub fn set_workload_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.workload_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workload_policy][crate::model::InstanceGroupManagerResourcePolicies::workload_policy].
    pub fn set_or_clear_workload_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.workload_policy = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceGroupManagerResourcePolicies {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerResourcePolicies"
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerStandbyPolicy {
    /// Specifies the number of seconds that the MIG should wait to suspend or
    /// stop a VM after that VM was created. The initial delay gives the
    /// initialization script the time to prepare your VM for a quick scale out.
    /// The value of initial delay must be between 0 and 3600 seconds. The
    /// default value is 0.
    pub initial_delay_sec: std::option::Option<i32>,

    /// Defines how a MIG resumes or starts VMs from a standby pool when the
    /// group scales out. The default mode is `MANUAL`.
    pub mode: std::option::Option<crate::model::instance_group_manager_standby_policy::Mode>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceGroupManagerStandbyPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [initial_delay_sec][crate::model::InstanceGroupManagerStandbyPolicy::initial_delay_sec].
    pub fn set_initial_delay_sec<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.initial_delay_sec = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [initial_delay_sec][crate::model::InstanceGroupManagerStandbyPolicy::initial_delay_sec].
    pub fn set_or_clear_initial_delay_sec<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.initial_delay_sec = v.map(|x| x.into());
        self
    }

    /// Sets the value of [mode][crate::model::InstanceGroupManagerStandbyPolicy::mode].
    pub fn set_mode<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_manager_standby_policy::Mode>,
    {
        self.mode = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mode][crate::model::InstanceGroupManagerStandbyPolicy::mode].
    pub fn set_or_clear_mode<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_manager_standby_policy::Mode>,
    {
        self.mode = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceGroupManagerStandbyPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerStandbyPolicy"
    }
}

/// Defines additional types related to [InstanceGroupManagerStandbyPolicy].
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
pub mod instance_group_manager_standby_policy {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [mode][google.cloud.compute.v1.InstanceGroupManagerStandbyPolicy.mode] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManagerStandbyPolicy.mode]: crate::model::instance_group_manager_standby_policy::Mode
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// MIG does not automatically resume or start VMs in the standby pool when
        /// the group scales out.
        Manual,
        /// MIG automatically resumes or starts VMs in the standby pool when the
        /// group scales out, and replenishes the standby pool afterwards.
        ScaleOutPool,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Manual => std::option::Option::Some(0),
                Self::ScaleOutPool => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Manual => std::option::Option::Some("MANUAL"),
                Self::ScaleOutPool => std::option::Option::Some("SCALE_OUT_POOL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Manual,
                1 => Self::ScaleOutPool,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MANUAL" => Self::Manual,
                "SCALE_OUT_POOL" => Self::ScaleOutPool,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Manual => serializer.serialize_str("MANUAL"),
                Self::ScaleOutPool => serializer.serialize_str("SCALE_OUT_POOL"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.cloud.compute.v1.InstanceGroupManagerStandbyPolicy.mode",
            ))
        }
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerStatus {
    /// [Output only] Status of all-instances configuration on the group.
    pub all_instances_config:
        std::option::Option<crate::model::InstanceGroupManagerStatusAllInstancesConfig>,

    /// [Output Only] The URL of theAutoscaler
    /// that targets this instance group manager.
    pub autoscaler: std::option::Option<std::string::String>,

    /// [Output Only] A bit indicating whether the managed instance group is in a
    /// stable state. A stable state means that: none of the instances in the
    /// managed instance group is currently undergoing any type of change (for
    /// example, creation, restart, or deletion); no future changes are scheduled
    /// for instances in the managed instance group; and the managed instance
    /// group itself is not being modified.
    pub is_stable: std::option::Option<bool>,

    /// [Output Only] Stateful status of the given Instance Group Manager.
    pub stateful: std::option::Option<crate::model::InstanceGroupManagerStatusStateful>,

    /// [Output Only] A status of consistency of Instances' versions with their
    /// target version specified by version field on Instance Group
    /// Manager.
    pub version_target: std::option::Option<crate::model::InstanceGroupManagerStatusVersionTarget>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceGroupManagerStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [all_instances_config][crate::model::InstanceGroupManagerStatus::all_instances_config].
    pub fn set_all_instances_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerStatusAllInstancesConfig>,
    {
        self.all_instances_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [all_instances_config][crate::model::InstanceGroupManagerStatus::all_instances_config].
    pub fn set_or_clear_all_instances_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerStatusAllInstancesConfig>,
    {
        self.all_instances_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [autoscaler][crate::model::InstanceGroupManagerStatus::autoscaler].
    pub fn set_autoscaler<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.autoscaler = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [autoscaler][crate::model::InstanceGroupManagerStatus::autoscaler].
    pub fn set_or_clear_autoscaler<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.autoscaler = v.map(|x| x.into());
        self
    }

    /// Sets the value of [is_stable][crate::model::InstanceGroupManagerStatus::is_stable].
    pub fn set_is_stable<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.is_stable = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [is_stable][crate::model::InstanceGroupManagerStatus::is_stable].
    pub fn set_or_clear_is_stable<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.is_stable = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stateful][crate::model::InstanceGroupManagerStatus::stateful].
    pub fn set_stateful<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerStatusStateful>,
    {
        self.stateful = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stateful][crate::model::InstanceGroupManagerStatus::stateful].
    pub fn set_or_clear_stateful<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerStatusStateful>,
    {
        self.stateful = v.map(|x| x.into());
        self
    }

    /// Sets the value of [version_target][crate::model::InstanceGroupManagerStatus::version_target].
    pub fn set_version_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerStatusVersionTarget>,
    {
        self.version_target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version_target][crate::model::InstanceGroupManagerStatus::version_target].
    pub fn set_or_clear_version_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerStatusVersionTarget>,
    {
        self.version_target = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceGroupManagerStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerStatus"
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerStatusAllInstancesConfig {
    /// [Output Only] Current all-instances configuration revision.
    /// This value is in RFC3339 text format.
    pub current_revision: std::option::Option<std::string::String>,

    /// [Output Only] A bit indicating whether this configuration has
    /// been applied to all managed instances in the group.
    pub effective: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceGroupManagerStatusAllInstancesConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [current_revision][crate::model::InstanceGroupManagerStatusAllInstancesConfig::current_revision].
    pub fn set_current_revision<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.current_revision = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [current_revision][crate::model::InstanceGroupManagerStatusAllInstancesConfig::current_revision].
    pub fn set_or_clear_current_revision<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.current_revision = v.map(|x| x.into());
        self
    }

    /// Sets the value of [effective][crate::model::InstanceGroupManagerStatusAllInstancesConfig::effective].
    pub fn set_effective<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.effective = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [effective][crate::model::InstanceGroupManagerStatusAllInstancesConfig::effective].
    pub fn set_or_clear_effective<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.effective = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceGroupManagerStatusAllInstancesConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerStatusAllInstancesConfig"
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerStatusStateful {
    /// [Output Only] A bit indicating whether the managed instance group
    /// has stateful configuration, that is, if you have configured any items
    /// in a stateful policy or in per-instance configs.
    /// The group might report that it has no stateful configuration even when
    /// there is still some preserved state on a managed instance, for example,
    /// if you have deleted all PICs but not yet applied those deletions.
    pub has_stateful_config: std::option::Option<bool>,

    /// [Output Only] Status of per-instance configurations on the instances.
    pub per_instance_configs:
        std::option::Option<crate::model::InstanceGroupManagerStatusStatefulPerInstanceConfigs>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceGroupManagerStatusStateful {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [has_stateful_config][crate::model::InstanceGroupManagerStatusStateful::has_stateful_config].
    pub fn set_has_stateful_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.has_stateful_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [has_stateful_config][crate::model::InstanceGroupManagerStatusStateful::has_stateful_config].
    pub fn set_or_clear_has_stateful_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.has_stateful_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [per_instance_configs][crate::model::InstanceGroupManagerStatusStateful::per_instance_configs].
    pub fn set_per_instance_configs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerStatusStatefulPerInstanceConfigs>,
    {
        self.per_instance_configs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [per_instance_configs][crate::model::InstanceGroupManagerStatusStateful::per_instance_configs].
    pub fn set_or_clear_per_instance_configs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceGroupManagerStatusStatefulPerInstanceConfigs>,
    {
        self.per_instance_configs = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceGroupManagerStatusStateful {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerStatusStateful"
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerStatusStatefulPerInstanceConfigs {
    /// A bit indicating if all of the group's per-instance configurations
    /// (listed in the output of a listPerInstanceConfigs API call) have
    /// status EFFECTIVE or there are no per-instance-configs.
    pub all_effective: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceGroupManagerStatusStatefulPerInstanceConfigs {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [all_effective][crate::model::InstanceGroupManagerStatusStatefulPerInstanceConfigs::all_effective].
    pub fn set_all_effective<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.all_effective = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [all_effective][crate::model::InstanceGroupManagerStatusStatefulPerInstanceConfigs::all_effective].
    pub fn set_or_clear_all_effective<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.all_effective = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceGroupManagerStatusStatefulPerInstanceConfigs {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerStatusStatefulPerInstanceConfigs"
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerStatusVersionTarget {
    /// [Output Only] A bit indicating whether version target has been reached
    /// in this managed instance group, i.e. all instances are in their target
    /// version. Instances' target version are specified byversion field on Instance Group Manager.
    pub is_reached: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceGroupManagerStatusVersionTarget {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [is_reached][crate::model::InstanceGroupManagerStatusVersionTarget::is_reached].
    pub fn set_is_reached<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.is_reached = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [is_reached][crate::model::InstanceGroupManagerStatusVersionTarget::is_reached].
    pub fn set_or_clear_is_reached<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.is_reached = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceGroupManagerStatusVersionTarget {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerStatusVersionTarget"
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerUpdatePolicy {
    /// The
    /// instance redistribution policy for regional managed instance groups.
    /// Valid values are:
    ///
    /// - PROACTIVE (default): The group attempts to maintain an
    ///   even distribution of VM instances across zones in the region.
    /// - NONE: For non-autoscaled groups, proactive
    ///   redistribution is disabled.
    pub instance_redistribution_type: std::option::Option<
        crate::model::instance_group_manager_update_policy::InstanceRedistributionType,
    >,

    /// The maximum number of instances that can be created above the specifiedtargetSize during the update process. This value can be
    /// either a fixed number or, if the group has 10 or more instances, a
    /// percentage. If you set a percentage, the number of instances is rounded
    /// if necessary.  The default value for maxSurge is a fixed
    /// value equal to the number of zones in which the managed instance group
    /// operates.
    ///
    /// At least one of either maxSurge ormaxUnavailable must be greater than 0. Learn more about maxSurge.
    pub max_surge: std::option::Option<crate::model::FixedOrPercent>,

    /// The maximum number of instances that can be unavailable during the update
    /// process. An instance is considered available if all of the following
    /// conditions are satisfied:
    ///
    /// ```norust
    ///  - The instance's status is
    ///  RUNNING.
    /// ```
    ///
    /// - If there is a health
    ///   check on the instance group, the instance's health check status
    ///   must be HEALTHY at least once. If there is no health check
    ///   on the group, then the instance only needs to have a status of
    ///   RUNNING to be considered available.
    ///
    /// This value can be either a fixed number or, if the group has 10 or more
    /// instances, a percentage. If you set a percentage, the number of instances
    /// is rounded if necessary. The default value formaxUnavailable is a fixed value equal to the number of zones
    /// in which the managed instance group operates.
    ///
    /// At least one of either maxSurge ormaxUnavailable must be greater than 0. Learn more about maxUnavailable.
    pub max_unavailable: std::option::Option<crate::model::FixedOrPercent>,

    /// Minimal action to be taken on an instance. Use this option to minimize
    /// disruption as much as possible or to apply a more disruptive action than
    /// is necessary.
    ///
    /// - To limit disruption as much as possible, set the minimal action toREFRESH. If your update requires a more disruptive action,
    ///   Compute Engine performs the necessary action to execute the update.
    /// - To apply a more disruptive action than is strictly necessary, set the
    ///   minimal action to RESTART or REPLACE. For
    ///   example, Compute Engine does not need to restart a VM to change its
    ///   metadata. But if your application reads instance metadata only when a VM
    ///   is restarted, you can set the minimal action to RESTART in
    ///   order to pick up metadata changes.
    pub minimal_action:
        std::option::Option<crate::model::instance_group_manager_update_policy::MinimalAction>,

    /// Most disruptive action that is allowed to be taken on an instance.
    /// You can specify either NONE to forbid any actions,REFRESH to avoid restarting the VM and to limit disruption
    /// as much as possible. RESTART to allow actions that can be
    /// applied without instance replacing or REPLACE to allow all
    /// possible actions. If the Updater determines that the minimal update
    /// action needed is more disruptive than most disruptive allowed action you
    /// specify it will not perform the update at all.
    pub most_disruptive_allowed_action: std::option::Option<
        crate::model::instance_group_manager_update_policy::MostDisruptiveAllowedAction,
    >,

    /// What action should be used to replace instances.
    /// See minimal_action.REPLACE
    pub replacement_method:
        std::option::Option<crate::model::instance_group_manager_update_policy::ReplacementMethod>,

    /// The type
    /// of update process. You can specify either PROACTIVE so
    /// that the MIG automatically updates VMs to the latest configurations orOPPORTUNISTIC so that you can select the VMs that you want
    /// to update.
    pub r#type: std::option::Option<crate::model::instance_group_manager_update_policy::Type>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceGroupManagerUpdatePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_redistribution_type][crate::model::InstanceGroupManagerUpdatePolicy::instance_redistribution_type].
    pub fn set_instance_redistribution_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::instance_group_manager_update_policy::InstanceRedistributionType,
            >,
    {
        self.instance_redistribution_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_redistribution_type][crate::model::InstanceGroupManagerUpdatePolicy::instance_redistribution_type].
    pub fn set_or_clear_instance_redistribution_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::instance_group_manager_update_policy::InstanceRedistributionType,
            >,
    {
        self.instance_redistribution_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_surge][crate::model::InstanceGroupManagerUpdatePolicy::max_surge].
    pub fn set_max_surge<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FixedOrPercent>,
    {
        self.max_surge = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_surge][crate::model::InstanceGroupManagerUpdatePolicy::max_surge].
    pub fn set_or_clear_max_surge<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FixedOrPercent>,
    {
        self.max_surge = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_unavailable][crate::model::InstanceGroupManagerUpdatePolicy::max_unavailable].
    pub fn set_max_unavailable<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FixedOrPercent>,
    {
        self.max_unavailable = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_unavailable][crate::model::InstanceGroupManagerUpdatePolicy::max_unavailable].
    pub fn set_or_clear_max_unavailable<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FixedOrPercent>,
    {
        self.max_unavailable = v.map(|x| x.into());
        self
    }

    /// Sets the value of [minimal_action][crate::model::InstanceGroupManagerUpdatePolicy::minimal_action].
    pub fn set_minimal_action<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_manager_update_policy::MinimalAction>,
    {
        self.minimal_action = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [minimal_action][crate::model::InstanceGroupManagerUpdatePolicy::minimal_action].
    pub fn set_or_clear_minimal_action<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_manager_update_policy::MinimalAction>,
    {
        self.minimal_action = v.map(|x| x.into());
        self
    }

    /// Sets the value of [most_disruptive_allowed_action][crate::model::InstanceGroupManagerUpdatePolicy::most_disruptive_allowed_action].
    pub fn set_most_disruptive_allowed_action<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::instance_group_manager_update_policy::MostDisruptiveAllowedAction,
            >,
    {
        self.most_disruptive_allowed_action = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [most_disruptive_allowed_action][crate::model::InstanceGroupManagerUpdatePolicy::most_disruptive_allowed_action].
    pub fn set_or_clear_most_disruptive_allowed_action<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<
                crate::model::instance_group_manager_update_policy::MostDisruptiveAllowedAction,
            >,
    {
        self.most_disruptive_allowed_action = v.map(|x| x.into());
        self
    }

    /// Sets the value of [replacement_method][crate::model::InstanceGroupManagerUpdatePolicy::replacement_method].
    pub fn set_replacement_method<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::instance_group_manager_update_policy::ReplacementMethod,
            >,
    {
        self.replacement_method = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replacement_method][crate::model::InstanceGroupManagerUpdatePolicy::replacement_method].
    pub fn set_or_clear_replacement_method<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::instance_group_manager_update_policy::ReplacementMethod,
            >,
    {
        self.replacement_method = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::InstanceGroupManagerUpdatePolicy::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_manager_update_policy::Type>,
    {
        self.r#type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#type][crate::model::InstanceGroupManagerUpdatePolicy::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_manager_update_policy::Type>,
    {
        self.r#type = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceGroupManagerUpdatePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy"
    }
}

/// Defines additional types related to [InstanceGroupManagerUpdatePolicy].
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
pub mod instance_group_manager_update_policy {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [instanceRedistributionType][google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.instanceRedistributionType] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.instanceRedistributionType]: crate::model::instance_group_manager_update_policy::InstanceRedistributionType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstanceRedistributionType {
        /// No action is being proactively performed in order to bring this IGM
        /// to its target instance distribution.
        None,
        /// This IGM will actively converge to its target instance distribution.
        Proactive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstanceRedistributionType::value] or
        /// [InstanceRedistributionType::name].
        UnknownValue(instance_redistribution_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod instance_redistribution_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl InstanceRedistributionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::None => std::option::Option::Some(0),
                Self::Proactive => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::None => std::option::Option::Some("NONE"),
                Self::Proactive => std::option::Option::Some("PROACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for InstanceRedistributionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for InstanceRedistributionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for InstanceRedistributionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::None,
                1 => Self::Proactive,
                _ => Self::UnknownValue(instance_redistribution_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for InstanceRedistributionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NONE" => Self::None,
                "PROACTIVE" => Self::Proactive,
                _ => Self::UnknownValue(instance_redistribution_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for InstanceRedistributionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::None => serializer.serialize_str("NONE"),
                Self::Proactive => serializer.serialize_str("PROACTIVE"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for InstanceRedistributionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InstanceRedistributionType>::new(
                ".google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.instanceRedistributionType"))
        }
    }

    /// The enumerated type for the [minimalAction][google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.minimalAction] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.minimalAction]: crate::model::instance_group_manager_update_policy::MinimalAction
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MinimalAction {
        /// Do not perform any action.
        None,
        /// Do not stop the instance.
        Refresh,
        /// (Default.) Replace the instance according to the replacement method
        /// option.
        Replace,
        /// Stop the instance and start it again.
        Restart,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MinimalAction::value] or
        /// [MinimalAction::name].
        UnknownValue(minimal_action::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod minimal_action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl MinimalAction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::None => std::option::Option::Some(0),
                Self::Refresh => std::option::Option::Some(1),
                Self::Replace => std::option::Option::Some(2),
                Self::Restart => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::None => std::option::Option::Some("NONE"),
                Self::Refresh => std::option::Option::Some("REFRESH"),
                Self::Replace => std::option::Option::Some("REPLACE"),
                Self::Restart => std::option::Option::Some("RESTART"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for MinimalAction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for MinimalAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for MinimalAction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::None,
                1 => Self::Refresh,
                2 => Self::Replace,
                3 => Self::Restart,
                _ => Self::UnknownValue(minimal_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for MinimalAction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NONE" => Self::None,
                "REFRESH" => Self::Refresh,
                "REPLACE" => Self::Replace,
                "RESTART" => Self::Restart,
                _ => Self::UnknownValue(minimal_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for MinimalAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::None => serializer.serialize_str("NONE"),
                Self::Refresh => serializer.serialize_str("REFRESH"),
                Self::Replace => serializer.serialize_str("REPLACE"),
                Self::Restart => serializer.serialize_str("RESTART"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for MinimalAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MinimalAction>::new(
                ".google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.minimalAction",
            ))
        }
    }

    /// The enumerated type for the [mostDisruptiveAllowedAction][google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.mostDisruptiveAllowedAction] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.mostDisruptiveAllowedAction]: crate::model::instance_group_manager_update_policy::MostDisruptiveAllowedAction
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MostDisruptiveAllowedAction {
        /// Do not perform any action.
        None,
        /// Do not stop the instance.
        Refresh,
        /// (Default.) Replace the instance according to the replacement method
        /// option.
        Replace,
        /// Stop the instance and start it again.
        Restart,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MostDisruptiveAllowedAction::value] or
        /// [MostDisruptiveAllowedAction::name].
        UnknownValue(most_disruptive_allowed_action::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod most_disruptive_allowed_action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl MostDisruptiveAllowedAction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::None => std::option::Option::Some(0),
                Self::Refresh => std::option::Option::Some(1),
                Self::Replace => std::option::Option::Some(2),
                Self::Restart => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::None => std::option::Option::Some("NONE"),
                Self::Refresh => std::option::Option::Some("REFRESH"),
                Self::Replace => std::option::Option::Some("REPLACE"),
                Self::Restart => std::option::Option::Some("RESTART"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for MostDisruptiveAllowedAction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for MostDisruptiveAllowedAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for MostDisruptiveAllowedAction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::None,
                1 => Self::Refresh,
                2 => Self::Replace,
                3 => Self::Restart,
                _ => Self::UnknownValue(most_disruptive_allowed_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for MostDisruptiveAllowedAction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NONE" => Self::None,
                "REFRESH" => Self::Refresh,
                "REPLACE" => Self::Replace,
                "RESTART" => Self::Restart,
                _ => Self::UnknownValue(most_disruptive_allowed_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for MostDisruptiveAllowedAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::None => serializer.serialize_str("NONE"),
                Self::Refresh => serializer.serialize_str("REFRESH"),
                Self::Replace => serializer.serialize_str("REPLACE"),
                Self::Restart => serializer.serialize_str("RESTART"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for MostDisruptiveAllowedAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MostDisruptiveAllowedAction>::new(
                ".google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.mostDisruptiveAllowedAction"))
        }
    }

    /// The enumerated type for the [replacementMethod][google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.replacementMethod] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.replacementMethod]: crate::model::instance_group_manager_update_policy::ReplacementMethod
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ReplacementMethod {
        /// Instances will be recreated (with the same name)
        Recreate,
        /// Default option: instances will be deleted and created (with a new name)
        Substitute,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ReplacementMethod::value] or
        /// [ReplacementMethod::name].
        UnknownValue(replacement_method::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod replacement_method {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl ReplacementMethod {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Recreate => std::option::Option::Some(0),
                Self::Substitute => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Recreate => std::option::Option::Some("RECREATE"),
                Self::Substitute => std::option::Option::Some("SUBSTITUTE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for ReplacementMethod {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for ReplacementMethod {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for ReplacementMethod {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Recreate,
                1 => Self::Substitute,
                _ => Self::UnknownValue(replacement_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for ReplacementMethod {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RECREATE" => Self::Recreate,
                "SUBSTITUTE" => Self::Substitute,
                _ => Self::UnknownValue(replacement_method::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for ReplacementMethod {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Recreate => serializer.serialize_str("RECREATE"),
                Self::Substitute => serializer.serialize_str("SUBSTITUTE"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for ReplacementMethod {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ReplacementMethod>::new(
                ".google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.replacementMethod",
            ))
        }
    }

    /// The enumerated type for the [type][google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.type] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.type]: crate::model::instance_group_manager_update_policy::Type
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// MIG will apply new configurations
        /// to existing VMs only when you selectively target specific or all VMs to
        /// be updated.
        Opportunistic,
        /// MIG will automatically apply new configurations
        /// to all or a subset of existing VMs and also to new VMs that are added
        /// to the group.
        Proactive,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Opportunistic => std::option::Option::Some(0),
                Self::Proactive => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Opportunistic => std::option::Option::Some("OPPORTUNISTIC"),
                Self::Proactive => std::option::Option::Some("PROACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Opportunistic,
                1 => Self::Proactive,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OPPORTUNISTIC" => Self::Opportunistic,
                "PROACTIVE" => Self::Proactive,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Opportunistic => serializer.serialize_str("OPPORTUNISTIC"),
                Self::Proactive => serializer.serialize_str("PROACTIVE"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.compute.v1.InstanceGroupManagerUpdatePolicy.type",
            ))
        }
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagerVersion {
    /// The URL of the instance template that is specified for this managed
    /// instance group. The group uses this template to create new instances in
    /// the managed instance group until the `targetSize` for this version is
    /// reached. The templates for existing instances in the group do not change
    /// unless you run recreateInstances, runapplyUpdatesToInstances, or set the group'supdatePolicy.type to PROACTIVE; in those cases,
    /// existing instances are updated until the `targetSize` for this version is
    /// reached.
    pub instance_template: std::option::Option<std::string::String>,

    /// Name of the version. Unique among all versions in the scope of this
    /// managed instance group.
    pub name: std::option::Option<std::string::String>,

    /// Specifies the intended number of instances to be created from theinstanceTemplate. The final number of instances created
    /// from the template will be equal to:
    ///
    /// ```norust
    ///  - If expressed as a fixed number, the minimum of either
    ///   targetSize.fixed or
    ///   instanceGroupManager.targetSize is used.
    ///  - if expressed as a percent, the targetSize
    ///  would be (targetSize.percent/100 *
    ///  InstanceGroupManager.targetSize) If there is a remainder, the
    ///  number is rounded.
    /// ```
    ///
    /// If unset, this version will update any remaining instances not
    /// updated by another version. ReadStarting
    /// a canary update for more information.
    pub target_size: std::option::Option<crate::model::FixedOrPercent>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceGroupManagerVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_template][crate::model::InstanceGroupManagerVersion::instance_template].
    pub fn set_instance_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_template][crate::model::InstanceGroupManagerVersion::instance_template].
    pub fn set_or_clear_instance_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance_template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::InstanceGroupManagerVersion::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::InstanceGroupManagerVersion::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_size][crate::model::InstanceGroupManagerVersion::target_size].
    pub fn set_target_size<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FixedOrPercent>,
    {
        self.target_size = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_size][crate::model::InstanceGroupManagerVersion::target_size].
    pub fn set_or_clear_target_size<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FixedOrPercent>,
    {
        self.target_size = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceGroupManagerVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagerVersion"
    }
}

#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagersAbandonInstancesRequest {
    /// The URLs of one or more instances to abandon. This can be a full URL or
    /// a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
    pub instances: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagersAbandonInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::InstanceGroupManagersAbandonInstancesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagersAbandonInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersAbandonInstancesRequest"
    }
}

/// InstanceGroupManagers.applyUpdatesToInstances
#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagersApplyUpdatesRequest {
    /// Flag to update all instances instead of specified list of instances.
    /// If the flag is set to true then the instances may not be specified
    /// in the request.
    pub all_instances: std::option::Option<bool>,

    /// The list of URLs of one or more instances for which you want to apply
    /// updates. Each URL can be a full URL or a partial URL, such aszones/[ZONE]/instances/[INSTANCE_NAME].
    pub instances: std::vec::Vec<std::string::String>,

    /// The minimal action that you want to perform on each instance during the
    /// update:
    ///
    /// ```norust
    ///  - REPLACE: At minimum, delete the instance and create it
    ///  again.
    /// ```
    ///
    /// - RESTART: Stop the instance and start it
    ///   again.
    /// - REFRESH: Do not stop the instance and limit
    ///   disruption as much as possible.
    /// - NONE: Do not
    ///   disrupt the instance at all.
    ///
    /// By default, the minimum action is NONE. If your update
    /// requires a more disruptive action than you set with this flag, the
    /// necessary action is performed to execute the update.
    pub minimal_action: std::option::Option<
        crate::model::instance_group_managers_apply_updates_request::MinimalAction,
    >,

    /// The most disruptive action that you want to perform on each instance during
    /// the update:
    ///
    /// ```norust
    ///  - REPLACE: Delete the instance and create it again.
    ///  - RESTART: Stop the instance and start it again.
    ///  - REFRESH: Do not stop the instance and limit disruption
    ///  as much as possible.
    /// ```
    ///
    /// - NONE: Do not disrupt the
    ///   instance at all.
    ///
    /// By default, the most disruptive allowed action is REPLACE. If
    /// your update requires a more disruptive action than you set with this flag,
    /// the update request will fail.
    pub most_disruptive_allowed_action: std::option::Option<
        crate::model::instance_group_managers_apply_updates_request::MostDisruptiveAllowedAction,
    >,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagersApplyUpdatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [all_instances][crate::model::InstanceGroupManagersApplyUpdatesRequest::all_instances].
    pub fn set_all_instances<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.all_instances = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [all_instances][crate::model::InstanceGroupManagersApplyUpdatesRequest::all_instances].
    pub fn set_or_clear_all_instances<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.all_instances = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instances][crate::model::InstanceGroupManagersApplyUpdatesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [minimal_action][crate::model::InstanceGroupManagersApplyUpdatesRequest::minimal_action].
    pub fn set_minimal_action<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::instance_group_managers_apply_updates_request::MinimalAction,
            >,
    {
        self.minimal_action = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [minimal_action][crate::model::InstanceGroupManagersApplyUpdatesRequest::minimal_action].
    pub fn set_or_clear_minimal_action<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::instance_group_managers_apply_updates_request::MinimalAction,
            >,
    {
        self.minimal_action = v.map(|x| x.into());
        self
    }

    /// Sets the value of [most_disruptive_allowed_action][crate::model::InstanceGroupManagersApplyUpdatesRequest::most_disruptive_allowed_action].
    pub fn set_most_disruptive_allowed_action<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::instance_group_managers_apply_updates_request::MostDisruptiveAllowedAction>
    {
        self.most_disruptive_allowed_action = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [most_disruptive_allowed_action][crate::model::InstanceGroupManagersApplyUpdatesRequest::most_disruptive_allowed_action].
    pub fn set_or_clear_most_disruptive_allowed_action<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::instance_group_managers_apply_updates_request::MostDisruptiveAllowedAction>
    {
        self.most_disruptive_allowed_action = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagersApplyUpdatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersApplyUpdatesRequest"
    }
}

/// Defines additional types related to [InstanceGroupManagersApplyUpdatesRequest].
#[cfg(feature = "instance-group-managers")]
pub mod instance_group_managers_apply_updates_request {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [minimalAction][google.cloud.compute.v1.InstanceGroupManagersApplyUpdatesRequest.minimalAction] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManagersApplyUpdatesRequest.minimalAction]: crate::model::instance_group_managers_apply_updates_request::MinimalAction
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MinimalAction {
        /// Do not perform any action.
        None,
        /// Do not stop the instance.
        Refresh,
        /// (Default.) Replace the instance according to the replacement method
        /// option.
        Replace,
        /// Stop the instance and start it again.
        Restart,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MinimalAction::value] or
        /// [MinimalAction::name].
        UnknownValue(minimal_action::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instance-group-managers")]
    pub mod minimal_action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instance-group-managers")]
    impl MinimalAction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::None => std::option::Option::Some(0),
                Self::Refresh => std::option::Option::Some(1),
                Self::Replace => std::option::Option::Some(2),
                Self::Restart => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::None => std::option::Option::Some("NONE"),
                Self::Refresh => std::option::Option::Some("REFRESH"),
                Self::Replace => std::option::Option::Some("REPLACE"),
                Self::Restart => std::option::Option::Some("RESTART"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instance-group-managers")]
    impl std::default::Default for MinimalAction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instance-group-managers")]
    impl std::fmt::Display for MinimalAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instance-group-managers")]
    impl std::convert::From<i32> for MinimalAction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::None,
                1 => Self::Refresh,
                2 => Self::Replace,
                3 => Self::Restart,
                _ => Self::UnknownValue(minimal_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instance-group-managers")]
    impl std::convert::From<&str> for MinimalAction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NONE" => Self::None,
                "REFRESH" => Self::Refresh,
                "REPLACE" => Self::Replace,
                "RESTART" => Self::Restart,
                _ => Self::UnknownValue(minimal_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instance-group-managers")]
    impl serde::ser::Serialize for MinimalAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::None => serializer.serialize_str("NONE"),
                Self::Refresh => serializer.serialize_str("REFRESH"),
                Self::Replace => serializer.serialize_str("REPLACE"),
                Self::Restart => serializer.serialize_str("RESTART"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instance-group-managers")]
    impl<'de> serde::de::Deserialize<'de> for MinimalAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MinimalAction>::new(
                ".google.cloud.compute.v1.InstanceGroupManagersApplyUpdatesRequest.minimalAction",
            ))
        }
    }

    /// The enumerated type for the [mostDisruptiveAllowedAction][google.cloud.compute.v1.InstanceGroupManagersApplyUpdatesRequest.mostDisruptiveAllowedAction] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManagersApplyUpdatesRequest.mostDisruptiveAllowedAction]: crate::model::instance_group_managers_apply_updates_request::MostDisruptiveAllowedAction
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MostDisruptiveAllowedAction {
        /// Do not perform any action.
        None,
        /// Do not stop the instance.
        Refresh,
        /// (Default.) Replace the instance according to the replacement method
        /// option.
        Replace,
        /// Stop the instance and start it again.
        Restart,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MostDisruptiveAllowedAction::value] or
        /// [MostDisruptiveAllowedAction::name].
        UnknownValue(most_disruptive_allowed_action::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instance-group-managers")]
    pub mod most_disruptive_allowed_action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instance-group-managers")]
    impl MostDisruptiveAllowedAction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::None => std::option::Option::Some(0),
                Self::Refresh => std::option::Option::Some(1),
                Self::Replace => std::option::Option::Some(2),
                Self::Restart => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::None => std::option::Option::Some("NONE"),
                Self::Refresh => std::option::Option::Some("REFRESH"),
                Self::Replace => std::option::Option::Some("REPLACE"),
                Self::Restart => std::option::Option::Some("RESTART"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instance-group-managers")]
    impl std::default::Default for MostDisruptiveAllowedAction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instance-group-managers")]
    impl std::fmt::Display for MostDisruptiveAllowedAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instance-group-managers")]
    impl std::convert::From<i32> for MostDisruptiveAllowedAction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::None,
                1 => Self::Refresh,
                2 => Self::Replace,
                3 => Self::Restart,
                _ => Self::UnknownValue(most_disruptive_allowed_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instance-group-managers")]
    impl std::convert::From<&str> for MostDisruptiveAllowedAction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NONE" => Self::None,
                "REFRESH" => Self::Refresh,
                "REPLACE" => Self::Replace,
                "RESTART" => Self::Restart,
                _ => Self::UnknownValue(most_disruptive_allowed_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instance-group-managers")]
    impl serde::ser::Serialize for MostDisruptiveAllowedAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::None => serializer.serialize_str("NONE"),
                Self::Refresh => serializer.serialize_str("REFRESH"),
                Self::Replace => serializer.serialize_str("REPLACE"),
                Self::Restart => serializer.serialize_str("RESTART"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instance-group-managers")]
    impl<'de> serde::de::Deserialize<'de> for MostDisruptiveAllowedAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MostDisruptiveAllowedAction>::new(
                ".google.cloud.compute.v1.InstanceGroupManagersApplyUpdatesRequest.mostDisruptiveAllowedAction"))
        }
    }
}

/// InstanceGroupManagers.createInstances
#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagersCreateInstancesRequest {
    /// [Required] List of specifications of per-instance configs.
    pub instances: std::vec::Vec<crate::model::PerInstanceConfig>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagersCreateInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::InstanceGroupManagersCreateInstancesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PerInstanceConfig>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagersCreateInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersCreateInstancesRequest"
    }
}

#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagersDeleteInstancesRequest {
    /// The URLs of one or more instances to delete. This can be a full URL or
    /// a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
    /// Queued instances do not have URL and can be deleted only by name.
    /// One cannot specify both URLs and names in a single request.
    pub instances: std::vec::Vec<std::string::String>,

    /// Specifies whether the request should proceed despite the inclusion of
    /// instances that are not members of the group or that are already in the
    /// process of being deleted or abandoned. If this field is set to `false` and
    /// such an instance is specified in the request, the operation fails. The
    /// operation always fails if the request contains a malformed instance URL or
    /// a reference to an instance that exists in a zone or region other than the
    /// group's zone or region.
    pub skip_instances_on_validation_error: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagersDeleteInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::InstanceGroupManagersDeleteInstancesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [skip_instances_on_validation_error][crate::model::InstanceGroupManagersDeleteInstancesRequest::skip_instances_on_validation_error].
    pub fn set_skip_instances_on_validation_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.skip_instances_on_validation_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [skip_instances_on_validation_error][crate::model::InstanceGroupManagersDeleteInstancesRequest::skip_instances_on_validation_error].
    pub fn set_or_clear_skip_instances_on_validation_error<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.skip_instances_on_validation_error = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagersDeleteInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersDeleteInstancesRequest"
    }
}

/// InstanceGroupManagers.deletePerInstanceConfigs
#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagersDeletePerInstanceConfigsReq {
    /// The list of instance names for which we want to delete per-instance configs
    /// on this managed instance group.
    pub names: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagersDeletePerInstanceConfigsReq {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [names][crate::model::InstanceGroupManagersDeletePerInstanceConfigsReq::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagersDeletePerInstanceConfigsReq {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersDeletePerInstanceConfigsReq"
    }
}

#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagersListErrorsResponse {
    /// [Output Only] The list of errors of the managed instance group.
    pub items: std::vec::Vec<crate::model::InstanceManagedByIgmError>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagersListErrorsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [items][crate::model::InstanceGroupManagersListErrorsResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceManagedByIgmError>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstanceGroupManagersListErrorsResponse::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::InstanceGroupManagersListErrorsResponse::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagersListErrorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersListErrorsResponse"
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for InstanceGroupManagersListErrorsResponse {
    type PageItem = crate::model::InstanceManagedByIgmError;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagersListManagedInstancesResponse {
    /// [Output Only] The list of instances in the managed instance group.
    pub managed_instances: std::vec::Vec<crate::model::ManagedInstance>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagersListManagedInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [managed_instances][crate::model::InstanceGroupManagersListManagedInstancesResponse::managed_instances].
    pub fn set_managed_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ManagedInstance>,
    {
        use std::iter::Iterator;
        self.managed_instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstanceGroupManagersListManagedInstancesResponse::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::InstanceGroupManagersListManagedInstancesResponse::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagersListManagedInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersListManagedInstancesResponse"
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse
    for InstanceGroupManagersListManagedInstancesResponse
{
    type PageItem = crate::model::ManagedInstance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.managed_instances
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagersListPerInstanceConfigsResp {
    /// [Output Only] The list of PerInstanceConfig.
    pub items: std::vec::Vec<crate::model::PerInstanceConfig>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<
        crate::model::instance_group_managers_list_per_instance_configs_resp::Warning,
    >,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagersListPerInstanceConfigsResp {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [items][crate::model::InstanceGroupManagersListPerInstanceConfigsResp::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PerInstanceConfig>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstanceGroupManagersListPerInstanceConfigsResp::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::InstanceGroupManagersListPerInstanceConfigsResp::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::InstanceGroupManagersListPerInstanceConfigsResp::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::instance_group_managers_list_per_instance_configs_resp::Warning,
            >,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::InstanceGroupManagersListPerInstanceConfigsResp::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::instance_group_managers_list_per_instance_configs_resp::Warning,
            >,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagersListPerInstanceConfigsResp {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersListPerInstanceConfigsResp"
    }
}

#[cfg(feature = "instance-group-managers")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse
    for InstanceGroupManagersListPerInstanceConfigsResp
{
    type PageItem = crate::model::PerInstanceConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [InstanceGroupManagersListPerInstanceConfigsResp].
#[cfg(feature = "instance-group-managers")]
pub mod instance_group_managers_list_per_instance_configs_resp {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.InstanceGroupManagersListPerInstanceConfigsResp.warning] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManagersListPerInstanceConfigsResp.warning]: crate::model::instance_group_managers_list_per_instance_configs_resp::Warning
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<
            crate::model::instance_group_managers_list_per_instance_configs_resp::warning::Code,
        >,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<
            crate::model::instance_group_managers_list_per_instance_configs_resp::warning::Data,
        >,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::instance_group_managers_list_per_instance_configs_resp::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::instance_group_managers_list_per_instance_configs_resp::warning::Code>
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::instance_group_managers_list_per_instance_configs_resp::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::instance_group_managers_list_per_instance_configs_resp::warning::Code>
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::instance_group_managers_list_per_instance_configs_resp::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance_group_managers_list_per_instance_configs_resp::warning::Data>
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::instance_group_managers_list_per_instance_configs_resp::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::instance_group_managers_list_per_instance_configs_resp::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "instance-group-managers")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersListPerInstanceConfigsResp.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "instance-group-managers")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.InstanceGroupManagersListPerInstanceConfigsResp.warning.data] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupManagersListPerInstanceConfigsResp.warning.data]: crate::model::instance_group_managers_list_per_instance_configs_resp::warning::Data
        #[cfg(feature = "instance-group-managers")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instance-group-managers")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::instance_group_managers_list_per_instance_configs_resp::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::instance_group_managers_list_per_instance_configs_resp::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::instance_group_managers_list_per_instance_configs_resp::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::instance_group_managers_list_per_instance_configs_resp::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersListPerInstanceConfigsResp.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.InstanceGroupManagersListPerInstanceConfigsResp.warning.code] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupManagersListPerInstanceConfigsResp.warning.code]: crate::model::instance_group_managers_list_per_instance_configs_resp::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instance-group-managers")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instance-group-managers")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instance-group-managers")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.InstanceGroupManagersListPerInstanceConfigsResp.warning.code"))
            }
        }
    }
}

/// InstanceGroupManagers.patchPerInstanceConfigs
#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagersPatchPerInstanceConfigsReq {
    /// The list of per-instance configurations to insert or patch on this managed
    /// instance group.
    pub per_instance_configs: std::vec::Vec<crate::model::PerInstanceConfig>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagersPatchPerInstanceConfigsReq {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [per_instance_configs][crate::model::InstanceGroupManagersPatchPerInstanceConfigsReq::per_instance_configs].
    pub fn set_per_instance_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PerInstanceConfig>,
    {
        use std::iter::Iterator;
        self.per_instance_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagersPatchPerInstanceConfigsReq {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersPatchPerInstanceConfigsReq"
    }
}

#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagersRecreateInstancesRequest {
    /// The URLs of one or more instances to recreate. This can be a full URL or
    /// a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
    pub instances: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagersRecreateInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::InstanceGroupManagersRecreateInstancesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagersRecreateInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersRecreateInstancesRequest"
    }
}

#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagersResumeInstancesRequest {
    /// The URLs of one or more instances to resume. This can be a full URL or
    /// a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
    pub instances: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagersResumeInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::InstanceGroupManagersResumeInstancesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagersResumeInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersResumeInstancesRequest"
    }
}

#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagersScopedList {
    /// [Output Only] The list of managed instance groups that are contained in
    /// the specified project and zone.
    pub instance_group_managers: std::vec::Vec<crate::model::InstanceGroupManager>,

    /// [Output Only] The warning that replaces the list of managed instance
    /// groups when the list is empty.
    pub warning: std::option::Option<crate::model::instance_group_managers_scoped_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagersScopedList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_group_managers][crate::model::InstanceGroupManagersScopedList::instance_group_managers].
    pub fn set_instance_group_managers<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceGroupManager>,
    {
        use std::iter::Iterator;
        self.instance_group_managers = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warning][crate::model::InstanceGroupManagersScopedList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_managers_scoped_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::InstanceGroupManagersScopedList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_group_managers_scoped_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagersScopedList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersScopedList"
    }
}

/// Defines additional types related to [InstanceGroupManagersScopedList].
#[cfg(feature = "instance-group-managers")]
pub mod instance_group_managers_scoped_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.InstanceGroupManagersScopedList.warning] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupManagersScopedList.warning]: crate::model::instance_group_managers_scoped_list::Warning
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code:
            std::option::Option<crate::model::instance_group_managers_scoped_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::instance_group_managers_scoped_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::instance_group_managers_scoped_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::instance_group_managers_scoped_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::instance_group_managers_scoped_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::instance_group_managers_scoped_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::instance_group_managers_scoped_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance_group_managers_scoped_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::instance_group_managers_scoped_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::instance_group_managers_scoped_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "instance-group-managers")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersScopedList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "instance-group-managers")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.InstanceGroupManagersScopedList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupManagersScopedList.warning.data]: crate::model::instance_group_managers_scoped_list::warning::Data
        #[cfg(feature = "instance-group-managers")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instance-group-managers")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::instance_group_managers_scoped_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::instance_group_managers_scoped_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::instance_group_managers_scoped_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::instance_group_managers_scoped_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersScopedList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.InstanceGroupManagersScopedList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupManagersScopedList.warning.code]: crate::model::instance_group_managers_scoped_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instance-group-managers")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instance-group-managers")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instance-group-managers")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instance-group-managers")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.InstanceGroupManagersScopedList.warning.code",
                ))
            }
        }
    }
}

#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagersSetInstanceTemplateRequest {
    /// The URL of the instance template that is specified for this managed
    /// instance group. The group uses this template to create all new instances
    /// in the managed instance group. The templates for existing instances in the
    /// group do not change unless you run recreateInstances, runapplyUpdatesToInstances, or set the group'supdatePolicy.type to PROACTIVE.
    pub instance_template: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagersSetInstanceTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_template][crate::model::InstanceGroupManagersSetInstanceTemplateRequest::instance_template].
    pub fn set_instance_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_template][crate::model::InstanceGroupManagersSetInstanceTemplateRequest::instance_template].
    pub fn set_or_clear_instance_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance_template = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagersSetInstanceTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersSetInstanceTemplateRequest"
    }
}

#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagersSetTargetPoolsRequest {
    /// The fingerprint of the target pools information. Use this optional
    /// property to prevent conflicts when multiple users change the target pools
    /// settings concurrently. Obtain the fingerprint with theinstanceGroupManagers.get
    /// method. Then, include the fingerprint in your request to ensure that you
    /// do not overwrite changes that were applied from another
    /// concurrent request.
    pub fingerprint: std::option::Option<::bytes::Bytes>,

    /// The list of target pool URLs that instances in this managed instance group
    /// belong to. The managed instance group applies these target pools to all
    /// of the instances in the group. Existing instances and new instances in the
    /// group all receive these target pool settings.
    pub target_pools: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagersSetTargetPoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fingerprint][crate::model::InstanceGroupManagersSetTargetPoolsRequest::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::InstanceGroupManagersSetTargetPoolsRequest::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_pools][crate::model::InstanceGroupManagersSetTargetPoolsRequest::target_pools].
    pub fn set_target_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagersSetTargetPoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersSetTargetPoolsRequest"
    }
}

#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagersStartInstancesRequest {
    /// The URLs of one or more instances to start. This can be a full URL or
    /// a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
    pub instances: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagersStartInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::InstanceGroupManagersStartInstancesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagersStartInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersStartInstancesRequest"
    }
}

#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagersStopInstancesRequest {
    /// If this flag is set to true, the Instance Group Manager will proceed to
    /// stop the instances, skipping initialization on them.
    pub force_stop: std::option::Option<bool>,

    /// The URLs of one or more instances to stop. This can be a full URL or
    /// a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
    pub instances: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagersStopInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [force_stop][crate::model::InstanceGroupManagersStopInstancesRequest::force_stop].
    pub fn set_force_stop<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.force_stop = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [force_stop][crate::model::InstanceGroupManagersStopInstancesRequest::force_stop].
    pub fn set_or_clear_force_stop<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.force_stop = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instances][crate::model::InstanceGroupManagersStopInstancesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagersStopInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersStopInstancesRequest"
    }
}

#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagersSuspendInstancesRequest {
    /// If this flag is set to true, the Instance Group Manager will proceed to
    /// suspend the instances, skipping initialization on them.
    pub force_suspend: std::option::Option<bool>,

    /// The URLs of one or more instances to suspend. This can be a full URL or
    /// a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
    pub instances: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagersSuspendInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [force_suspend][crate::model::InstanceGroupManagersSuspendInstancesRequest::force_suspend].
    pub fn set_force_suspend<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.force_suspend = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [force_suspend][crate::model::InstanceGroupManagersSuspendInstancesRequest::force_suspend].
    pub fn set_or_clear_force_suspend<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.force_suspend = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instances][crate::model::InstanceGroupManagersSuspendInstancesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagersSuspendInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersSuspendInstancesRequest"
    }
}

/// InstanceGroupManagers.updatePerInstanceConfigs
#[cfg(feature = "instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupManagersUpdatePerInstanceConfigsReq {
    /// The list of per-instance configurations to insert or patch on this managed
    /// instance group.
    pub per_instance_configs: std::vec::Vec<crate::model::PerInstanceConfig>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagersUpdatePerInstanceConfigsReq {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [per_instance_configs][crate::model::InstanceGroupManagersUpdatePerInstanceConfigsReq::per_instance_configs].
    pub fn set_per_instance_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PerInstanceConfig>,
    {
        use std::iter::Iterator;
        self.per_instance_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instance-group-managers")]
impl wkt::message::Message for InstanceGroupManagersUpdatePerInstanceConfigsReq {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupManagersUpdatePerInstanceConfigsReq"
    }
}

#[cfg(feature = "instance-groups")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupsAddInstancesRequest {
    /// The list of instances to add to the instance group.
    pub instances: std::vec::Vec<crate::model::InstanceReference>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-groups")]
impl InstanceGroupsAddInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::InstanceGroupsAddInstancesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceReference>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instance-groups")]
impl wkt::message::Message for InstanceGroupsAddInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupsAddInstancesRequest"
    }
}

#[cfg(feature = "instance-groups")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupsListInstances {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of InstanceWithNamedPorts resources.
    pub items: std::vec::Vec<crate::model::InstanceWithNamedPorts>,

    /// [Output Only] The resource type, which is alwayscompute#instanceGroupsListInstances for the list of instances
    /// in the specified instance group.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::instance_groups_list_instances::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-groups")]
impl InstanceGroupsListInstances {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::InstanceGroupsListInstances::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::InstanceGroupsListInstances::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::InstanceGroupsListInstances::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceWithNamedPorts>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::InstanceGroupsListInstances::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::InstanceGroupsListInstances::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstanceGroupsListInstances::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::InstanceGroupsListInstances::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::InstanceGroupsListInstances::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::InstanceGroupsListInstances::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::InstanceGroupsListInstances::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_groups_list_instances::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::InstanceGroupsListInstances::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_groups_list_instances::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-groups")]
impl wkt::message::Message for InstanceGroupsListInstances {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupsListInstances"
    }
}

#[cfg(feature = "instance-groups")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for InstanceGroupsListInstances {
    type PageItem = crate::model::InstanceWithNamedPorts;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [InstanceGroupsListInstances].
#[cfg(feature = "instance-groups")]
pub mod instance_groups_list_instances {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.InstanceGroupsListInstances.warning] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupsListInstances.warning]: crate::model::instance_groups_list_instances::Warning
    #[cfg(feature = "instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::instance_groups_list_instances::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::instance_groups_list_instances::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-groups")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::instance_groups_list_instances::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::instance_groups_list_instances::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::instance_groups_list_instances::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::instance_groups_list_instances::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::instance_groups_list_instances::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance_groups_list_instances::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::instance_groups_list_instances::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::instance_groups_list_instances::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "instance-groups")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstanceGroupsListInstances.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "instance-groups")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.InstanceGroupsListInstances.warning.data] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupsListInstances.warning.data]: crate::model::instance_groups_list_instances::warning::Data
        #[cfg(feature = "instance-groups")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instance-groups")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::instance_groups_list_instances::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::instance_groups_list_instances::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::instance_groups_list_instances::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::instance_groups_list_instances::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instance-groups")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstanceGroupsListInstances.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.InstanceGroupsListInstances.warning.code] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupsListInstances.warning.code]: crate::model::instance_groups_list_instances::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instance-groups")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instance-groups")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instance-groups")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instance-groups")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instance-groups")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instance-groups")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instance-groups")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instance-groups")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instance-groups")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.InstanceGroupsListInstances.warning.code",
                ))
            }
        }
    }
}

#[cfg(feature = "instance-groups")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupsListInstancesRequest {
    /// A filter for the state of the instances in the instance group. Valid
    /// options are ALL or RUNNING. If you do not specify
    /// this parameter the list includes all instances regardless of their state.
    pub instance_state:
        std::option::Option<crate::model::instance_groups_list_instances_request::InstanceState>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-groups")]
impl InstanceGroupsListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_state][crate::model::InstanceGroupsListInstancesRequest::instance_state].
    pub fn set_instance_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_groups_list_instances_request::InstanceState>,
    {
        self.instance_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_state][crate::model::InstanceGroupsListInstancesRequest::instance_state].
    pub fn set_or_clear_instance_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_groups_list_instances_request::InstanceState>,
    {
        self.instance_state = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-groups")]
impl wkt::message::Message for InstanceGroupsListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupsListInstancesRequest"
    }
}

/// Defines additional types related to [InstanceGroupsListInstancesRequest].
#[cfg(feature = "instance-groups")]
pub mod instance_groups_list_instances_request {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [instanceState][google.cloud.compute.v1.InstanceGroupsListInstancesRequest.instanceState] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupsListInstancesRequest.instanceState]: crate::model::instance_groups_list_instances_request::InstanceState
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instance-groups")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstanceState {
        /// Includes all instances in the generated list regardless of their state.
        All,
        /// Includes instances in the generated list only if they have a RUNNING
        /// state.
        Running,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstanceState::value] or
        /// [InstanceState::name].
        UnknownValue(instance_state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instance-groups")]
    pub mod instance_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instance-groups")]
    impl InstanceState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::All => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::All => std::option::Option::Some("ALL"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instance-groups")]
    impl std::default::Default for InstanceState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instance-groups")]
    impl std::fmt::Display for InstanceState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instance-groups")]
    impl std::convert::From<i32> for InstanceState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::All,
                1 => Self::Running,
                _ => Self::UnknownValue(instance_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instance-groups")]
    impl std::convert::From<&str> for InstanceState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ALL" => Self::All,
                "RUNNING" => Self::Running,
                _ => Self::UnknownValue(instance_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instance-groups")]
    impl serde::ser::Serialize for InstanceState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::All => serializer.serialize_str("ALL"),
                Self::Running => serializer.serialize_str("RUNNING"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instance-groups")]
    impl<'de> serde::de::Deserialize<'de> for InstanceState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InstanceState>::new(
                ".google.cloud.compute.v1.InstanceGroupsListInstancesRequest.instanceState",
            ))
        }
    }
}

#[cfg(feature = "instance-groups")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupsRemoveInstancesRequest {
    /// The list of instances to remove from the instance group.
    pub instances: std::vec::Vec<crate::model::InstanceReference>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-groups")]
impl InstanceGroupsRemoveInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::InstanceGroupsRemoveInstancesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceReference>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instance-groups")]
impl wkt::message::Message for InstanceGroupsRemoveInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupsRemoveInstancesRequest"
    }
}

#[cfg(feature = "instance-groups")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupsScopedList {
    /// [Output Only] The list ofinstance
    /// groups that are contained in this scope.
    pub instance_groups: std::vec::Vec<crate::model::InstanceGroup>,

    /// [Output Only] An informational warning that replaces the list of
    /// instance groups when the list is empty.
    pub warning: std::option::Option<crate::model::instance_groups_scoped_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-groups")]
impl InstanceGroupsScopedList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_groups][crate::model::InstanceGroupsScopedList::instance_groups].
    pub fn set_instance_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceGroup>,
    {
        use std::iter::Iterator;
        self.instance_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warning][crate::model::InstanceGroupsScopedList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_groups_scoped_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::InstanceGroupsScopedList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_groups_scoped_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-groups")]
impl wkt::message::Message for InstanceGroupsScopedList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupsScopedList"
    }
}

/// Defines additional types related to [InstanceGroupsScopedList].
#[cfg(feature = "instance-groups")]
pub mod instance_groups_scoped_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.InstanceGroupsScopedList.warning] field.
    ///
    /// [google.cloud.compute.v1.InstanceGroupsScopedList.warning]: crate::model::instance_groups_scoped_list::Warning
    #[cfg(feature = "instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::instance_groups_scoped_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::instance_groups_scoped_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-groups")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::instance_groups_scoped_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::instance_groups_scoped_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::instance_groups_scoped_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::instance_groups_scoped_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::instance_groups_scoped_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance_groups_scoped_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::instance_groups_scoped_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::instance_groups_scoped_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "instance-groups")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstanceGroupsScopedList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "instance-groups")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.InstanceGroupsScopedList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupsScopedList.warning.data]: crate::model::instance_groups_scoped_list::warning::Data
        #[cfg(feature = "instance-groups")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instance-groups")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::instance_groups_scoped_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::instance_groups_scoped_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::instance_groups_scoped_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::instance_groups_scoped_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instance-groups")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstanceGroupsScopedList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.InstanceGroupsScopedList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.InstanceGroupsScopedList.warning.code]: crate::model::instance_groups_scoped_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instance-groups")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instance-groups")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instance-groups")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instance-groups")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instance-groups")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instance-groups")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instance-groups")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instance-groups")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instance-groups")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.InstanceGroupsScopedList.warning.code",
                ))
            }
        }
    }
}

#[cfg(feature = "instance-groups")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceGroupsSetNamedPortsRequest {
    /// The fingerprint of the named ports information for this instance group.
    /// Use this optional property to prevent conflicts when multiple users change
    /// the named ports settings concurrently. Obtain the fingerprint with theinstanceGroups.get
    /// method. Then, include the fingerprint in your request to ensure that you
    /// do not overwrite changes that were applied from another concurrent request.
    /// A request with an incorrect fingerprint will fail with error412 conditionNotMet.
    pub fingerprint: std::option::Option<::bytes::Bytes>,

    /// The list of named ports to set for this instance group.
    pub named_ports: std::vec::Vec<crate::model::NamedPort>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-groups")]
impl InstanceGroupsSetNamedPortsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fingerprint][crate::model::InstanceGroupsSetNamedPortsRequest::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::InstanceGroupsSetNamedPortsRequest::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [named_ports][crate::model::InstanceGroupsSetNamedPortsRequest::named_ports].
    pub fn set_named_ports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NamedPort>,
    {
        use std::iter::Iterator;
        self.named_ports = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instance-groups")]
impl wkt::message::Message for InstanceGroupsSetNamedPortsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceGroupsSetNamedPortsRequest"
    }
}

/// Contains a list of instances.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of Instance resources.
    pub items: std::vec::Vec<crate::model::Instance>,

    /// [Output Only] Type of resource. Always compute#instanceList
    /// for lists of Instance resources.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::instance_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstanceList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::InstanceList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::InstanceList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::InstanceList::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::InstanceList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::InstanceList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstanceList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::InstanceList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::InstanceList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::InstanceList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::InstanceList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::InstanceList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstanceList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceList"
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for InstanceList {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [InstanceList].
#[cfg(feature = "instances")]
pub mod instance_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.InstanceList.warning] field.
    ///
    /// [google.cloud.compute.v1.InstanceList.warning]: crate::model::instance_list::Warning
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::instance_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::instance_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::instance_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::instance_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::instance_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::instance_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::instance_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::instance_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::instance_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "instances")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstanceList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "instances")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.InstanceList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.InstanceList.warning.data]: crate::model::instance_list::warning::Data
        #[cfg(feature = "instances")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instances")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::instance_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::instance_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::instance_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::instance_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instances")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstanceList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.InstanceList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.InstanceList.warning.code]: crate::model::instance_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instances")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instances")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instances")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instances")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.InstanceList.warning.code",
                ))
            }
        }
    }
}

/// Contains a list of instance referrers.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceListReferrers {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of Reference resources.
    pub items: std::vec::Vec<crate::model::Reference>,

    /// [Output Only] Type of resource. Alwayscompute#instanceListReferrers for lists of Instance referrers.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::instance_list_referrers::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstanceListReferrers {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::InstanceListReferrers::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::InstanceListReferrers::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::InstanceListReferrers::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Reference>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::InstanceListReferrers::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::InstanceListReferrers::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstanceListReferrers::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::InstanceListReferrers::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::InstanceListReferrers::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::InstanceListReferrers::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::InstanceListReferrers::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_list_referrers::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::InstanceListReferrers::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_list_referrers::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstanceListReferrers {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceListReferrers"
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for InstanceListReferrers {
    type PageItem = crate::model::Reference;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [InstanceListReferrers].
#[cfg(feature = "instances")]
pub mod instance_list_referrers {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.InstanceListReferrers.warning] field.
    ///
    /// [google.cloud.compute.v1.InstanceListReferrers.warning]: crate::model::instance_list_referrers::Warning
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::instance_list_referrers::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::instance_list_referrers::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::instance_list_referrers::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::instance_list_referrers::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::instance_list_referrers::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::instance_list_referrers::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::instance_list_referrers::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance_list_referrers::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::instance_list_referrers::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::instance_list_referrers::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "instances")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstanceListReferrers.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "instances")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.InstanceListReferrers.warning.data] field.
        ///
        /// [google.cloud.compute.v1.InstanceListReferrers.warning.data]: crate::model::instance_list_referrers::warning::Data
        #[cfg(feature = "instances")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instances")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::instance_list_referrers::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::instance_list_referrers::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::instance_list_referrers::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::instance_list_referrers::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instances")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstanceListReferrers.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.InstanceListReferrers.warning.code] field.
        ///
        /// [google.cloud.compute.v1.InstanceListReferrers.warning.code]: crate::model::instance_list_referrers::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instances")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instances")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instances")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instances")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.InstanceListReferrers.warning.code",
                ))
            }
        }
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceManagedByIgmError {
    /// [Output Only] Contents of the error.
    pub error: std::option::Option<crate::model::InstanceManagedByIgmErrorManagedInstanceError>,

    /// [Output Only] Details of the instance action that triggered this error.
    /// May be null, if the error was not caused by an action on an instance.
    /// This field is optional.
    pub instance_action_details:
        std::option::Option<crate::model::InstanceManagedByIgmErrorInstanceActionDetails>,

    /// [Output Only] The time that this error occurred.
    /// This value is in RFC3339 text format.
    pub timestamp: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceManagedByIgmError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error][crate::model::InstanceManagedByIgmError::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceManagedByIgmErrorManagedInstanceError>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::InstanceManagedByIgmError::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceManagedByIgmErrorManagedInstanceError>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_action_details][crate::model::InstanceManagedByIgmError::instance_action_details].
    pub fn set_instance_action_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceManagedByIgmErrorInstanceActionDetails>,
    {
        self.instance_action_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_action_details][crate::model::InstanceManagedByIgmError::instance_action_details].
    pub fn set_or_clear_instance_action_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceManagedByIgmErrorInstanceActionDetails>,
    {
        self.instance_action_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timestamp][crate::model::InstanceManagedByIgmError::timestamp].
    pub fn set_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timestamp][crate::model::InstanceManagedByIgmError::timestamp].
    pub fn set_or_clear_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.timestamp = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceManagedByIgmError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceManagedByIgmError"
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceManagedByIgmErrorInstanceActionDetails {
    /// [Output Only] Action that managed instance group was executing on
    /// the instance when the error occurred. Possible values:
    pub action: std::option::Option<
        crate::model::instance_managed_by_igm_error_instance_action_details::Action,
    >,

    /// [Output Only] The URL of the instance.
    /// The URL can be set even if the instance has not yet been created.
    pub instance: std::option::Option<std::string::String>,

    /// [Output Only] Version this instance was created from, or was being
    /// created from, but the creation failed. Corresponds to one of the versions
    /// that were set on the Instance Group Manager resource at the time this
    /// instance was being created.
    pub version: std::option::Option<crate::model::ManagedInstanceVersion>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceManagedByIgmErrorInstanceActionDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [action][crate::model::InstanceManagedByIgmErrorInstanceActionDetails::action].
    pub fn set_action<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::instance_managed_by_igm_error_instance_action_details::Action,
            >,
    {
        self.action = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [action][crate::model::InstanceManagedByIgmErrorInstanceActionDetails::action].
    pub fn set_or_clear_action<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::instance_managed_by_igm_error_instance_action_details::Action,
            >,
    {
        self.action = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance][crate::model::InstanceManagedByIgmErrorInstanceActionDetails::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::InstanceManagedByIgmErrorInstanceActionDetails::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [version][crate::model::InstanceManagedByIgmErrorInstanceActionDetails::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManagedInstanceVersion>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::InstanceManagedByIgmErrorInstanceActionDetails::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ManagedInstanceVersion>,
    {
        self.version = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceManagedByIgmErrorInstanceActionDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceManagedByIgmErrorInstanceActionDetails"
    }
}

/// Defines additional types related to [InstanceManagedByIgmErrorInstanceActionDetails].
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
pub mod instance_managed_by_igm_error_instance_action_details {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [action][google.cloud.compute.v1.InstanceManagedByIgmErrorInstanceActionDetails.action] field.
    ///
    /// [google.cloud.compute.v1.InstanceManagedByIgmErrorInstanceActionDetails.action]: crate::model::instance_managed_by_igm_error_instance_action_details::Action
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Action {
        /// The managed instance group is abandoning this instance. The instance
        /// will be removed from the instance group and from any target pools that
        /// are associated with this group.
        Abandoning,
        /// The managed instance group is creating this instance. If the group
        /// fails to create this instance, it will try again until it is
        /// successful.
        Creating,
        /// The managed instance group is attempting to create this instance
        /// only once. If the group fails to create this instance, it does
        /// not try again and the group's targetSize value is
        /// decreased.
        CreatingWithoutRetries,
        /// The managed instance group is permanently deleting this instance.
        Deleting,
        /// The managed instance group has not scheduled any actions for this
        /// instance.
        None,
        /// The managed instance group is recreating this instance.
        Recreating,
        /// The managed instance group is applying configuration changes to the
        /// instance without stopping it. For example, the group can update the
        /// target pool list for an instance without stopping that instance.
        Refreshing,
        /// The managed instance group is restarting this instance.
        Restarting,
        /// The managed instance group is resuming this instance.
        Resuming,
        /// The managed instance group is starting this instance.
        Starting,
        /// The managed instance group is stopping this instance.
        Stopping,
        /// The managed instance group is suspending this instance.
        Suspending,
        /// The managed instance group is verifying this already created instance.
        /// Verification happens every time the instance is (re)created or restarted
        /// and consists of:
        ///
        /// 1. Waiting until health check specified as part of this managed instance
        ///    group's autohealing policy reports HEALTHY.
        ///    Note: Applies only if autohealing policy has a health check specified
        /// 1. Waiting for addition verification steps performed as post-instance
        ///    creation (subject to future extensions).
        Verifying,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Action::value] or
        /// [Action::name].
        UnknownValue(action::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl Action {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Abandoning => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::CreatingWithoutRetries => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::None => std::option::Option::Some(4),
                Self::Recreating => std::option::Option::Some(5),
                Self::Refreshing => std::option::Option::Some(6),
                Self::Restarting => std::option::Option::Some(7),
                Self::Resuming => std::option::Option::Some(8),
                Self::Starting => std::option::Option::Some(9),
                Self::Stopping => std::option::Option::Some(10),
                Self::Suspending => std::option::Option::Some(11),
                Self::Verifying => std::option::Option::Some(12),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Abandoning => std::option::Option::Some("ABANDONING"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::CreatingWithoutRetries => {
                    std::option::Option::Some("CREATING_WITHOUT_RETRIES")
                }
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::None => std::option::Option::Some("NONE"),
                Self::Recreating => std::option::Option::Some("RECREATING"),
                Self::Refreshing => std::option::Option::Some("REFRESHING"),
                Self::Restarting => std::option::Option::Some("RESTARTING"),
                Self::Resuming => std::option::Option::Some("RESUMING"),
                Self::Starting => std::option::Option::Some("STARTING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Suspending => std::option::Option::Some("SUSPENDING"),
                Self::Verifying => std::option::Option::Some("VERIFYING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for Action {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for Action {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for Action {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Abandoning,
                1 => Self::Creating,
                2 => Self::CreatingWithoutRetries,
                3 => Self::Deleting,
                4 => Self::None,
                5 => Self::Recreating,
                6 => Self::Refreshing,
                7 => Self::Restarting,
                8 => Self::Resuming,
                9 => Self::Starting,
                10 => Self::Stopping,
                11 => Self::Suspending,
                12 => Self::Verifying,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for Action {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ABANDONING" => Self::Abandoning,
                "CREATING" => Self::Creating,
                "CREATING_WITHOUT_RETRIES" => Self::CreatingWithoutRetries,
                "DELETING" => Self::Deleting,
                "NONE" => Self::None,
                "RECREATING" => Self::Recreating,
                "REFRESHING" => Self::Refreshing,
                "RESTARTING" => Self::Restarting,
                "RESUMING" => Self::Resuming,
                "STARTING" => Self::Starting,
                "STOPPING" => Self::Stopping,
                "SUSPENDING" => Self::Suspending,
                "VERIFYING" => Self::Verifying,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for Action {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Abandoning => serializer.serialize_str("ABANDONING"),
                Self::Creating => serializer.serialize_str("CREATING"),
                Self::CreatingWithoutRetries => {
                    serializer.serialize_str("CREATING_WITHOUT_RETRIES")
                }
                Self::Deleting => serializer.serialize_str("DELETING"),
                Self::None => serializer.serialize_str("NONE"),
                Self::Recreating => serializer.serialize_str("RECREATING"),
                Self::Refreshing => serializer.serialize_str("REFRESHING"),
                Self::Restarting => serializer.serialize_str("RESTARTING"),
                Self::Resuming => serializer.serialize_str("RESUMING"),
                Self::Starting => serializer.serialize_str("STARTING"),
                Self::Stopping => serializer.serialize_str("STOPPING"),
                Self::Suspending => serializer.serialize_str("SUSPENDING"),
                Self::Verifying => serializer.serialize_str("VERIFYING"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Action {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Action>::new(
                ".google.cloud.compute.v1.InstanceManagedByIgmErrorInstanceActionDetails.action",
            ))
        }
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceManagedByIgmErrorManagedInstanceError {
    /// [Output Only] Error code.
    pub code: std::option::Option<std::string::String>,

    /// [Output Only] Error message.
    pub message: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstanceManagedByIgmErrorManagedInstanceError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::InstanceManagedByIgmErrorManagedInstanceError::code].
    pub fn set_code<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.code = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [code][crate::model::InstanceManagedByIgmErrorManagedInstanceError::code].
    pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.code = v.map(|x| x.into());
        self
    }

    /// Sets the value of [message][crate::model::InstanceManagedByIgmErrorManagedInstanceError::message].
    pub fn set_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.message = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [message][crate::model::InstanceManagedByIgmErrorManagedInstanceError::message].
    pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.message = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstanceManagedByIgmErrorManagedInstanceError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceManagedByIgmErrorManagedInstanceError"
    }
}

/// Additional instance params.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceParams {
    /// Relative deadline for waiting for capacity. Relevant only for
    /// Instances.Insert API.
    pub request_valid_for_duration: std::option::Option<crate::model::Duration>,

    /// Resource manager tags to be bound to the instance. Tag keys and values
    /// have the same definition as resource
    /// manager tags. Keys must be in the format `tagKeys/{tag_key_id}`, and
    /// values are in the format `tagValues/456`. The field is ignored (both PUT &
    /// PATCH) when empty.
    pub resource_manager_tags: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstanceParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request_valid_for_duration][crate::model::InstanceParams::request_valid_for_duration].
    pub fn set_request_valid_for_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Duration>,
    {
        self.request_valid_for_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_valid_for_duration][crate::model::InstanceParams::request_valid_for_duration].
    pub fn set_or_clear_request_valid_for_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Duration>,
    {
        self.request_valid_for_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_manager_tags][crate::model::InstanceParams::resource_manager_tags].
    pub fn set_resource_manager_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_manager_tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstanceParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceParams"
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceProperties {
    /// Controls for advanced machine-related behavior features.
    /// Note that for MachineImage, this is not supported yet.
    pub advanced_machine_features: std::option::Option<crate::model::AdvancedMachineFeatures>,

    /// Enables instances created based on these properties to send packets with
    /// source IP addresses other than their own and receive packets with
    /// destination IP addresses other than their own. If these instances will be
    /// used as an IP gateway or it will be set as the next-hop in a Route
    /// resource, specify true. If unsure, leave this set tofalse. See theEnable IP forwarding
    /// documentation for more information.
    pub can_ip_forward: std::option::Option<bool>,

    /// Specifies the Confidential Instance options.
    /// Note that for MachineImage, this is not supported yet.
    pub confidential_instance_config: std::option::Option<crate::model::ConfidentialInstanceConfig>,

    /// An optional text description for the instances that are created from these
    /// properties.
    pub description: std::option::Option<std::string::String>,

    /// An array of disks that are associated with the instances that are created
    /// from these properties.
    pub disks: std::vec::Vec<crate::model::AttachedDisk>,

    /// A list of guest accelerator cards' type and count to use for instances
    /// created from these properties.
    pub guest_accelerators: std::vec::Vec<crate::model::AcceleratorConfig>,

    /// KeyRevocationActionType of the instance. Supported options are "STOP" and
    /// "NONE". The default value is "NONE" if it is not specified.
    pub key_revocation_action_type:
        std::option::Option<crate::model::instance_properties::KeyRevocationActionType>,

    /// Labels to apply to instances that are created from these properties.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The machine type to use for instances that are created from these
    /// properties.
    /// This field only accepts a machine type name, for example `n2-standard-4`.
    /// If you use the machine type full or partial URL, for example
    /// `projects/my-l7ilb-project/zones/us-central1-a/machineTypes/n2-standard-4`,
    /// the request will result in an `INTERNAL_ERROR`.
    pub machine_type: std::option::Option<std::string::String>,

    /// The metadata key/value pairs to assign to instances that are created from
    /// these properties. These pairs can consist of custom metadata or predefined
    /// keys. SeeProject and
    /// instance metadata for more information.
    pub metadata: std::option::Option<crate::model::Metadata>,

    /// Minimum cpu/platform to be used by instances. The instance may be
    /// scheduled on the specified or newer cpu/platform. Applicable values are the
    /// friendly names of CPU platforms, such asminCpuPlatform: "Intel Haswell" orminCpuPlatform: "Intel Sandy Bridge". For more
    /// information, read Specifying a
    /// Minimum CPU Platform.
    pub min_cpu_platform: std::option::Option<std::string::String>,

    /// An array of network access configurations for this interface.
    pub network_interfaces: std::vec::Vec<crate::model::NetworkInterface>,

    /// Note that for MachineImage, this is not supported yet.
    pub network_performance_config: std::option::Option<crate::model::NetworkPerformanceConfig>,

    /// The private IPv6 google access type for VMs.
    /// If not specified, use  INHERIT_FROM_SUBNETWORK as default.
    /// Note that for MachineImage, this is not supported yet.
    pub private_ipv_6_google_access:
        std::option::Option<crate::model::instance_properties::PrivateIpv6GoogleAccess>,

    /// Specifies the reservations that instances can consume from.
    /// Note that for MachineImage, this is not supported yet.
    pub reservation_affinity: std::option::Option<crate::model::ReservationAffinity>,

    /// Resource manager tags to be bound to the instance. Tag keys and values
    /// have the same definition as resource
    /// manager tags. Keys must be in the format `tagKeys/{tag_key_id}`, and
    /// values are in the format `tagValues/456`. The field is ignored (both PUT &
    /// PATCH) when empty.
    pub resource_manager_tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Resource policies (names, not URLs) applied to instances created from
    /// these properties.
    /// Note that for MachineImage, this is not supported yet.
    pub resource_policies: std::vec::Vec<std::string::String>,

    /// Specifies the scheduling options for the instances that are created from
    /// these properties.
    pub scheduling: std::option::Option<crate::model::Scheduling>,

    /// A list of service accounts with specified scopes. Access tokens for these
    /// service accounts are available to the instances that are created from
    /// these properties. Use metadata queries to obtain the access tokens for
    /// these instances.
    pub service_accounts: std::vec::Vec<crate::model::ServiceAccount>,

    /// Note that for MachineImage, this is not supported yet.
    pub shielded_instance_config: std::option::Option<crate::model::ShieldedInstanceConfig>,

    /// A list of tags to apply to the instances that are created from these
    /// properties. The tags identify valid sources or targets for network
    /// firewalls. The setTags method can modify this list of tags. Each tag within
    /// the list must comply with RFC1035.
    pub tags: std::option::Option<crate::model::Tags>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl InstanceProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [advanced_machine_features][crate::model::InstanceProperties::advanced_machine_features].
    pub fn set_advanced_machine_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedMachineFeatures>,
    {
        self.advanced_machine_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [advanced_machine_features][crate::model::InstanceProperties::advanced_machine_features].
    pub fn set_or_clear_advanced_machine_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedMachineFeatures>,
    {
        self.advanced_machine_features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [can_ip_forward][crate::model::InstanceProperties::can_ip_forward].
    pub fn set_can_ip_forward<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.can_ip_forward = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [can_ip_forward][crate::model::InstanceProperties::can_ip_forward].
    pub fn set_or_clear_can_ip_forward<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.can_ip_forward = v.map(|x| x.into());
        self
    }

    /// Sets the value of [confidential_instance_config][crate::model::InstanceProperties::confidential_instance_config].
    pub fn set_confidential_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialInstanceConfig>,
    {
        self.confidential_instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [confidential_instance_config][crate::model::InstanceProperties::confidential_instance_config].
    pub fn set_or_clear_confidential_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialInstanceConfig>,
    {
        self.confidential_instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::InstanceProperties::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::InstanceProperties::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disks][crate::model::InstanceProperties::disks].
    pub fn set_disks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedDisk>,
    {
        use std::iter::Iterator;
        self.disks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [guest_accelerators][crate::model::InstanceProperties::guest_accelerators].
    pub fn set_guest_accelerators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AcceleratorConfig>,
    {
        use std::iter::Iterator;
        self.guest_accelerators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [key_revocation_action_type][crate::model::InstanceProperties::key_revocation_action_type].
    pub fn set_key_revocation_action_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_properties::KeyRevocationActionType>,
    {
        self.key_revocation_action_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key_revocation_action_type][crate::model::InstanceProperties::key_revocation_action_type].
    pub fn set_or_clear_key_revocation_action_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_properties::KeyRevocationActionType>,
    {
        self.key_revocation_action_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::InstanceProperties::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [machine_type][crate::model::InstanceProperties::machine_type].
    pub fn set_machine_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.machine_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [machine_type][crate::model::InstanceProperties::machine_type].
    pub fn set_or_clear_machine_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.machine_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::InstanceProperties::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::InstanceProperties::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [min_cpu_platform][crate::model::InstanceProperties::min_cpu_platform].
    pub fn set_min_cpu_platform<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.min_cpu_platform = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_cpu_platform][crate::model::InstanceProperties::min_cpu_platform].
    pub fn set_or_clear_min_cpu_platform<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.min_cpu_platform = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_interfaces][crate::model::InstanceProperties::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [network_performance_config][crate::model::InstanceProperties::network_performance_config].
    pub fn set_network_performance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPerformanceConfig>,
    {
        self.network_performance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_performance_config][crate::model::InstanceProperties::network_performance_config].
    pub fn set_or_clear_network_performance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPerformanceConfig>,
    {
        self.network_performance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_ipv_6_google_access][crate::model::InstanceProperties::private_ipv_6_google_access].
    pub fn set_private_ipv_6_google_access<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_properties::PrivateIpv6GoogleAccess>,
    {
        self.private_ipv_6_google_access = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_ipv_6_google_access][crate::model::InstanceProperties::private_ipv_6_google_access].
    pub fn set_or_clear_private_ipv_6_google_access<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_properties::PrivateIpv6GoogleAccess>,
    {
        self.private_ipv_6_google_access = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reservation_affinity][crate::model::InstanceProperties::reservation_affinity].
    pub fn set_reservation_affinity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReservationAffinity>,
    {
        self.reservation_affinity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reservation_affinity][crate::model::InstanceProperties::reservation_affinity].
    pub fn set_or_clear_reservation_affinity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReservationAffinity>,
    {
        self.reservation_affinity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_manager_tags][crate::model::InstanceProperties::resource_manager_tags].
    pub fn set_resource_manager_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_manager_tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [resource_policies][crate::model::InstanceProperties::resource_policies].
    pub fn set_resource_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [scheduling][crate::model::InstanceProperties::scheduling].
    pub fn set_scheduling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Scheduling>,
    {
        self.scheduling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scheduling][crate::model::InstanceProperties::scheduling].
    pub fn set_or_clear_scheduling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Scheduling>,
    {
        self.scheduling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_accounts][crate::model::InstanceProperties::service_accounts].
    pub fn set_service_accounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ServiceAccount>,
    {
        use std::iter::Iterator;
        self.service_accounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [shielded_instance_config][crate::model::InstanceProperties::shielded_instance_config].
    pub fn set_shielded_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
    {
        self.shielded_instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shielded_instance_config][crate::model::InstanceProperties::shielded_instance_config].
    pub fn set_or_clear_shielded_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
    {
        self.shielded_instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tags][crate::model::InstanceProperties::tags].
    pub fn set_tags<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Tags>,
    {
        self.tags = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tags][crate::model::InstanceProperties::tags].
    pub fn set_or_clear_tags<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Tags>,
    {
        self.tags = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for InstanceProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceProperties"
    }
}

/// Defines additional types related to [InstanceProperties].
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
pub mod instance_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [keyRevocationActionType][google.cloud.compute.v1.InstanceProperties.keyRevocationActionType] field.
    ///
    /// [google.cloud.compute.v1.InstanceProperties.keyRevocationActionType]: crate::model::instance_properties::KeyRevocationActionType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum KeyRevocationActionType {
        /// Default value. This value is unused.
        Unspecified,
        /// Indicates user chose no operation.
        None,
        /// Indicates user chose to opt for VM shutdown on key revocation.
        Stop,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [KeyRevocationActionType::value] or
        /// [KeyRevocationActionType::name].
        UnknownValue(key_revocation_action_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod key_revocation_action_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl KeyRevocationActionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Stop => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED")
                }
                Self::None => std::option::Option::Some("NONE"),
                Self::Stop => std::option::Option::Some("STOP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for KeyRevocationActionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for KeyRevocationActionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for KeyRevocationActionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Stop,
                _ => Self::UnknownValue(key_revocation_action_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for KeyRevocationActionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "STOP" => Self::Stop,
                _ => Self::UnknownValue(key_revocation_action_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for KeyRevocationActionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => {
                    serializer.serialize_str("KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED")
                }
                Self::None => serializer.serialize_str("NONE"),
                Self::Stop => serializer.serialize_str("STOP"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for KeyRevocationActionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<KeyRevocationActionType>::new(
                    ".google.cloud.compute.v1.InstanceProperties.keyRevocationActionType",
                ),
            )
        }
    }

    /// The enumerated type for the [privateIpv6GoogleAccess][google.cloud.compute.v1.InstanceProperties.privateIpv6GoogleAccess] field.
    ///
    /// [google.cloud.compute.v1.InstanceProperties.privateIpv6GoogleAccess]: crate::model::instance_properties::PrivateIpv6GoogleAccess
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrivateIpv6GoogleAccess {
        /// Bidirectional private IPv6 access to/from Google services. If
        /// specified, the subnetwork who is attached to the instance's default network
        /// interface will be assigned an internal IPv6 prefix if it doesn't have
        /// before.
        EnableBidirectionalAccessToGoogle,
        /// Outbound private IPv6 access from VMs in this subnet to Google services. If
        /// specified, the subnetwork who is attached to the instance's default network
        /// interface will be assigned an internal IPv6 prefix if it doesn't have
        /// before.
        EnableOutboundVmAccessToGoogle,
        /// Each network interface inherits PrivateIpv6GoogleAccess from its
        /// subnetwork.
        InheritFromSubnetwork,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PrivateIpv6GoogleAccess::value] or
        /// [PrivateIpv6GoogleAccess::name].
        UnknownValue(private_ipv_6_google_access::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod private_ipv_6_google_access {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl PrivateIpv6GoogleAccess {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::EnableBidirectionalAccessToGoogle => std::option::Option::Some(0),
                Self::EnableOutboundVmAccessToGoogle => std::option::Option::Some(1),
                Self::InheritFromSubnetwork => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::EnableBidirectionalAccessToGoogle => {
                    std::option::Option::Some("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE")
                }
                Self::EnableOutboundVmAccessToGoogle => {
                    std::option::Option::Some("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE")
                }
                Self::InheritFromSubnetwork => std::option::Option::Some("INHERIT_FROM_SUBNETWORK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for PrivateIpv6GoogleAccess {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for PrivateIpv6GoogleAccess {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for PrivateIpv6GoogleAccess {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::EnableBidirectionalAccessToGoogle,
                1 => Self::EnableOutboundVmAccessToGoogle,
                2 => Self::InheritFromSubnetwork,
                _ => Self::UnknownValue(private_ipv_6_google_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for PrivateIpv6GoogleAccess {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE" => Self::EnableBidirectionalAccessToGoogle,
                "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE" => Self::EnableOutboundVmAccessToGoogle,
                "INHERIT_FROM_SUBNETWORK" => Self::InheritFromSubnetwork,
                _ => Self::UnknownValue(private_ipv_6_google_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for PrivateIpv6GoogleAccess {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::EnableBidirectionalAccessToGoogle => {
                    serializer.serialize_str("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE")
                }
                Self::EnableOutboundVmAccessToGoogle => {
                    serializer.serialize_str("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE")
                }
                Self::InheritFromSubnetwork => serializer.serialize_str("INHERIT_FROM_SUBNETWORK"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for PrivateIpv6GoogleAccess {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<PrivateIpv6GoogleAccess>::new(
                    ".google.cloud.compute.v1.InstanceProperties.privateIpv6GoogleAccess",
                ),
            )
        }
    }
}

/// Represents the change that you want to make to the instance properties.
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancePropertiesPatch {
    /// The label key-value pairs that you want to patch onto the instance.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The metadata key-value pairs that you want to patch onto the instance. For
    /// more information, see Project and
    /// instance metadata.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl InstancePropertiesPatch {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [labels][crate::model::InstancePropertiesPatch::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::InstancePropertiesPatch::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for InstancePropertiesPatch {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancePropertiesPatch"
    }
}

#[cfg(feature = "instance-groups")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceReference {
    /// The URL for a specific instance.
    /// @required compute.instancegroups.addInstances/removeInstances
    pub instance: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instance-groups")]
impl InstanceReference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::InstanceReference::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::InstanceReference::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instance-groups")]
impl wkt::message::Message for InstanceReference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceReference"
    }
}

/// Represents an Instance Template resource.
///
/// Google Compute Engine has two Instance Template resources:
///
/// * [Global](/compute/docs/reference/rest/v1/instanceTemplates)
/// * [Regional](/compute/docs/reference/rest/v1/regionInstanceTemplates)
///
/// You can reuse a global instance template in
/// different regions whereas you can use a regional instance template in a
/// specified region only. If you want to reduce cross-region dependency or
/// achieve data residency, use a regional instance template.
///
/// To create VMs, managed instance groups, and reservations, you can use either
/// global or regional instance templates.
///
/// For more information, readInstance Templates.
#[cfg(feature = "region-instance-templates")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceTemplate {
    /// [Output Only] The creation timestamp for this instance template inRFC3339
    /// text format.
    pub creation_timestamp: std::option::Option<std::string::String>,

    /// An optional description of this resource. Provide this property when you
    /// create the resource.
    pub description: std::option::Option<std::string::String>,

    /// [Output Only] A unique identifier for this instance template. The server
    /// defines this identifier.
    pub id: std::option::Option<u64>,

    /// [Output Only] The resource type, which is alwayscompute#instanceTemplate for instance templates.
    pub kind: std::option::Option<std::string::String>,

    /// Name of the resource; provided by the client when the resource is created.
    /// The name must be 1-63 characters long, and comply withRFC1035.
    /// Specifically, the name must be 1-63 characters long and match the regular
    /// expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first
    /// character must be a lowercase letter, and all following characters must be
    /// a dash, lowercase letter, or digit, except the last character, which cannot
    /// be a dash.
    pub name: std::option::Option<std::string::String>,

    /// The instance properties for this instance template.
    pub properties: std::option::Option<crate::model::InstanceProperties>,

    /// [Output Only] URL of the region where the instance template resides. Only
    /// applicable for regional resources.
    pub region: std::option::Option<std::string::String>,

    /// [Output Only] The URL for this instance template. The server defines this
    /// URL.
    pub self_link: std::option::Option<std::string::String>,

    /// The source instance used to create the template. You can provide this as a
    /// partial or full URL to the resource. For example, the following are valid
    /// values:
    ///
    /// ```norust
    ///  - https://www.googleapis.com/compute/v1/projects/project/zones/zone/instances/instance
    /// ```
    ///
    /// - projects/project/zones/zone/instances/instance
    pub source_instance: std::option::Option<std::string::String>,

    /// The source instance params to use to create this instance template.
    pub source_instance_params: std::option::Option<crate::model::SourceInstanceParams>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-templates")]
impl InstanceTemplate {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [creation_timestamp][crate::model::InstanceTemplate::creation_timestamp].
    pub fn set_creation_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_timestamp][crate::model::InstanceTemplate::creation_timestamp].
    pub fn set_or_clear_creation_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::InstanceTemplate::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::InstanceTemplate::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::InstanceTemplate::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::InstanceTemplate::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::InstanceTemplate::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::InstanceTemplate::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::InstanceTemplate::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::InstanceTemplate::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [properties][crate::model::InstanceTemplate::properties].
    pub fn set_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceProperties>,
    {
        self.properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties][crate::model::InstanceTemplate::properties].
    pub fn set_or_clear_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceProperties>,
    {
        self.properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [region][crate::model::InstanceTemplate::region].
    pub fn set_region<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.region = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [region][crate::model::InstanceTemplate::region].
    pub fn set_or_clear_region<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.region = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::InstanceTemplate::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::InstanceTemplate::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_instance][crate::model::InstanceTemplate::source_instance].
    pub fn set_source_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_instance][crate::model::InstanceTemplate::source_instance].
    pub fn set_or_clear_source_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_instance_params][crate::model::InstanceTemplate::source_instance_params].
    pub fn set_source_instance_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SourceInstanceParams>,
    {
        self.source_instance_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_instance_params][crate::model::InstanceTemplate::source_instance_params].
    pub fn set_or_clear_source_instance_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SourceInstanceParams>,
    {
        self.source_instance_params = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "region-instance-templates")]
impl wkt::message::Message for InstanceTemplate {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceTemplate"
    }
}

/// A list of instance templates.
#[cfg(feature = "region-instance-templates")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceTemplateList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of InstanceTemplate resources.
    pub items: std::vec::Vec<crate::model::InstanceTemplate>,

    /// [Output Only] The resource type, which is alwayscompute#instanceTemplatesListResponse for instance template
    /// lists.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::instance_template_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-templates")]
impl InstanceTemplateList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::InstanceTemplateList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::InstanceTemplateList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::InstanceTemplateList::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceTemplate>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::InstanceTemplateList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::InstanceTemplateList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstanceTemplateList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::InstanceTemplateList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::InstanceTemplateList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::InstanceTemplateList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::InstanceTemplateList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_template_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::InstanceTemplateList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_template_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "region-instance-templates")]
impl wkt::message::Message for InstanceTemplateList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceTemplateList"
    }
}

#[cfg(feature = "region-instance-templates")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for InstanceTemplateList {
    type PageItem = crate::model::InstanceTemplate;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [InstanceTemplateList].
#[cfg(feature = "region-instance-templates")]
pub mod instance_template_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.InstanceTemplateList.warning] field.
    ///
    /// [google.cloud.compute.v1.InstanceTemplateList.warning]: crate::model::instance_template_list::Warning
    #[cfg(feature = "region-instance-templates")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::instance_template_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::instance_template_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-templates")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::instance_template_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::instance_template_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::instance_template_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::instance_template_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::instance_template_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance_template_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::instance_template_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::instance_template_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "region-instance-templates")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstanceTemplateList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "region-instance-templates")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.InstanceTemplateList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.InstanceTemplateList.warning.data]: crate::model::instance_template_list::warning::Data
        #[cfg(feature = "region-instance-templates")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "region-instance-templates")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::instance_template_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::instance_template_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::instance_template_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::instance_template_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "region-instance-templates")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstanceTemplateList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.InstanceTemplateList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.InstanceTemplateList.warning.code]: crate::model::instance_template_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "region-instance-templates")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "region-instance-templates")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "region-instance-templates")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "region-instance-templates")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "region-instance-templates")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "region-instance-templates")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "region-instance-templates")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "region-instance-templates")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "region-instance-templates")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.InstanceTemplateList.warning.code",
                ))
            }
        }
    }
}

#[cfg(any(feature = "instance-groups", feature = "region-instance-groups",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceWithNamedPorts {
    /// [Output Only] The URL of the instance.
    pub instance: std::option::Option<std::string::String>,

    /// [Output Only] The named ports that belong to this instance group.
    pub named_ports: std::vec::Vec<crate::model::NamedPort>,

    /// [Output Only] The status of the instance.
    pub status: std::option::Option<crate::model::instance_with_named_ports::Status>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "instance-groups", feature = "region-instance-groups",))]
impl InstanceWithNamedPorts {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::InstanceWithNamedPorts::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::InstanceWithNamedPorts::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [named_ports][crate::model::InstanceWithNamedPorts::named_ports].
    pub fn set_named_ports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NamedPort>,
    {
        use std::iter::Iterator;
        self.named_ports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [status][crate::model::InstanceWithNamedPorts::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_with_named_ports::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::InstanceWithNamedPorts::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_with_named_ports::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "instance-groups", feature = "region-instance-groups",))]
impl wkt::message::Message for InstanceWithNamedPorts {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceWithNamedPorts"
    }
}

/// Defines additional types related to [InstanceWithNamedPorts].
#[cfg(any(feature = "instance-groups", feature = "region-instance-groups",))]
pub mod instance_with_named_ports {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [status][google.cloud.compute.v1.InstanceWithNamedPorts.status] field.
    ///
    /// [google.cloud.compute.v1.InstanceWithNamedPorts.status]: crate::model::instance_with_named_ports::Status
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "instance-groups", feature = "region-instance-groups",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// The instance is halted and we are performing tear down tasks like network
        /// deprogramming, releasing quota, IP, tearing down disks etc.
        Deprovisioning,
        /// For Flex Start provisioning instance is waiting for available capacity
        /// from Dynamic Workload Scheduler (DWS).
        Pending,
        /// Resources are being allocated for the instance.
        Provisioning,
        /// The instance is in repair.
        Repairing,
        /// The instance is running.
        Running,
        /// All required resources have been allocated and the instance
        /// is being started.
        Staging,
        /// The instance has stopped successfully.
        Stopped,
        /// The instance is currently stopping (either being deleted or killed).
        Stopping,
        /// The instance has suspended.
        Suspended,
        /// The instance is suspending.
        Suspending,
        /// The instance has stopped (either by explicit action or underlying
        /// failure).
        Terminated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "instance-groups", feature = "region-instance-groups",))]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "instance-groups", feature = "region-instance-groups",))]
    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Deprovisioning => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Provisioning => std::option::Option::Some(2),
                Self::Repairing => std::option::Option::Some(3),
                Self::Running => std::option::Option::Some(4),
                Self::Staging => std::option::Option::Some(5),
                Self::Stopped => std::option::Option::Some(6),
                Self::Stopping => std::option::Option::Some(7),
                Self::Suspended => std::option::Option::Some(8),
                Self::Suspending => std::option::Option::Some(9),
                Self::Terminated => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Deprovisioning => std::option::Option::Some("DEPROVISIONING"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Repairing => std::option::Option::Some("REPAIRING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Staging => std::option::Option::Some("STAGING"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Suspended => std::option::Option::Some("SUSPENDED"),
                Self::Suspending => std::option::Option::Some("SUSPENDING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "instance-groups", feature = "region-instance-groups",))]
    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "instance-groups", feature = "region-instance-groups",))]
    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "instance-groups", feature = "region-instance-groups",))]
    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Deprovisioning,
                1 => Self::Pending,
                2 => Self::Provisioning,
                3 => Self::Repairing,
                4 => Self::Running,
                5 => Self::Staging,
                6 => Self::Stopped,
                7 => Self::Stopping,
                8 => Self::Suspended,
                9 => Self::Suspending,
                10 => Self::Terminated,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "instance-groups", feature = "region-instance-groups",))]
    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DEPROVISIONING" => Self::Deprovisioning,
                "PENDING" => Self::Pending,
                "PROVISIONING" => Self::Provisioning,
                "REPAIRING" => Self::Repairing,
                "RUNNING" => Self::Running,
                "STAGING" => Self::Staging,
                "STOPPED" => Self::Stopped,
                "STOPPING" => Self::Stopping,
                "SUSPENDED" => Self::Suspended,
                "SUSPENDING" => Self::Suspending,
                "TERMINATED" => Self::Terminated,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "instance-groups", feature = "region-instance-groups",))]
    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Deprovisioning => serializer.serialize_str("DEPROVISIONING"),
                Self::Pending => serializer.serialize_str("PENDING"),
                Self::Provisioning => serializer.serialize_str("PROVISIONING"),
                Self::Repairing => serializer.serialize_str("REPAIRING"),
                Self::Running => serializer.serialize_str("RUNNING"),
                Self::Staging => serializer.serialize_str("STAGING"),
                Self::Stopped => serializer.serialize_str("STOPPED"),
                Self::Stopping => serializer.serialize_str("STOPPING"),
                Self::Suspended => serializer.serialize_str("SUSPENDED"),
                Self::Suspending => serializer.serialize_str("SUSPENDING"),
                Self::Terminated => serializer.serialize_str("TERMINATED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "instance-groups", feature = "region-instance-groups",))]
    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.cloud.compute.v1.InstanceWithNamedPorts.status",
            ))
        }
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesAddResourcePoliciesRequest {
    /// Resource policies to be added to this instance.
    pub resource_policies: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesAddResourcePoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_policies][crate::model::InstancesAddResourcePoliciesRequest::resource_policies].
    pub fn set_resource_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesAddResourcePoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesAddResourcePoliciesRequest"
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesBulkInsertOperationMetadata {
    /// Status information per location (location name is key).
    /// Example key: zones/us-central1-a
    pub per_location_status:
        std::collections::HashMap<std::string::String, crate::model::BulkInsertOperationStatus>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl InstancesBulkInsertOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [per_location_status][crate::model::InstancesBulkInsertOperationMetadata::per_location_status].
    pub fn set_per_location_status<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::BulkInsertOperationStatus>,
    {
        use std::iter::Iterator;
        self.per_location_status = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl wkt::message::Message for InstancesBulkInsertOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesBulkInsertOperationMetadata"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesGetEffectiveFirewallsResponse {
    /// [Output Only] Effective firewalls from firewall policies.
    pub firewall_policys:
        std::vec::Vec<crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy>,

    /// Effective firewalls on the instance.
    pub firewalls: std::vec::Vec<crate::model::Firewall>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesGetEffectiveFirewallsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [firewall_policys][crate::model::InstancesGetEffectiveFirewallsResponse::firewall_policys].
    pub fn set_firewall_policys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy,
            >,
    {
        use std::iter::Iterator;
        self.firewall_policys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [firewalls][crate::model::InstancesGetEffectiveFirewallsResponse::firewalls].
    pub fn set_firewalls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Firewall>,
    {
        use std::iter::Iterator;
        self.firewalls = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesGetEffectiveFirewallsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesGetEffectiveFirewallsResponse"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy {
    /// [Output Only] Deprecated, please use short name instead. The display name
    /// of the firewall policy.
    #[deprecated]
    pub display_name: std::option::Option<std::string::String>,

    /// [Output Only] The name of the firewall policy.
    pub name: std::option::Option<std::string::String>,

    /// [Output Only] The packet mirroring rules that apply to the instance.
    pub packet_mirroring_rules: std::vec::Vec<crate::model::FirewallPolicyRule>,

    /// [Output only] Priority of firewall policy association. Not applicable for
    /// type=HIERARCHY.
    pub priority: std::option::Option<i32>,

    /// [Output Only] The rules that apply to the instance. Only rules that
    /// target the specific VM instance are returned if target service accounts
    /// or target secure tags are specified in the rules.
    pub rules: std::vec::Vec<crate::model::FirewallPolicyRule>,

    /// [Output Only] The short name of the firewall policy.
    pub short_name: std::option::Option<std::string::String>,

    /// [Output Only] The type of the firewall policy. Can be one of HIERARCHY,
    /// NETWORK, NETWORK_REGIONAL, SYSTEM_GLOBAL, SYSTEM_REGIONAL.
    pub r#type: std::option::Option<
        crate::model::instances_get_effective_firewalls_response_effective_firewall_policy::Type,
    >,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::display_name].
    #[deprecated]
    pub fn set_display_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.display_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [display_name][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::display_name].
    #[deprecated]
    pub fn set_or_clear_display_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.display_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [packet_mirroring_rules][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::packet_mirroring_rules].
    pub fn set_packet_mirroring_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallPolicyRule>,
    {
        use std::iter::Iterator;
        self.packet_mirroring_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [priority][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::priority].
    pub fn set_priority<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.priority = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [priority][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::priority].
    pub fn set_or_clear_priority<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.priority = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rules][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallPolicyRule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [short_name][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::short_name].
    pub fn set_short_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.short_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [short_name][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::short_name].
    pub fn set_or_clear_short_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.short_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::instances_get_effective_firewalls_response_effective_firewall_policy::Type>
    {
        self.r#type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#type][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::instances_get_effective_firewalls_response_effective_firewall_policy::Type>
    {
        self.r#type = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy"
    }
}

/// Defines additional types related to [InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy].
#[cfg(feature = "instances")]
pub mod instances_get_effective_firewalls_response_effective_firewall_policy {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [type][google.cloud.compute.v1.InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy.type] field.
    ///
    /// [google.cloud.compute.v1.InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy.type]: crate::model::instances_get_effective_firewalls_response_effective_firewall_policy::Type
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        Hierarchy,
        Network,
        NetworkRegional,
        SystemGlobal,
        SystemRegional,
        Unspecified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Hierarchy => std::option::Option::Some(0),
                Self::Network => std::option::Option::Some(1),
                Self::NetworkRegional => std::option::Option::Some(2),
                Self::SystemGlobal => std::option::Option::Some(3),
                Self::SystemRegional => std::option::Option::Some(4),
                Self::Unspecified => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Hierarchy => std::option::Option::Some("HIERARCHY"),
                Self::Network => std::option::Option::Some("NETWORK"),
                Self::NetworkRegional => std::option::Option::Some("NETWORK_REGIONAL"),
                Self::SystemGlobal => std::option::Option::Some("SYSTEM_GLOBAL"),
                Self::SystemRegional => std::option::Option::Some("SYSTEM_REGIONAL"),
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Hierarchy,
                1 => Self::Network,
                2 => Self::NetworkRegional,
                3 => Self::SystemGlobal,
                4 => Self::SystemRegional,
                5 => Self::Unspecified,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HIERARCHY" => Self::Hierarchy,
                "NETWORK" => Self::Network,
                "NETWORK_REGIONAL" => Self::NetworkRegional,
                "SYSTEM_GLOBAL" => Self::SystemGlobal,
                "SYSTEM_REGIONAL" => Self::SystemRegional,
                "UNSPECIFIED" => Self::Unspecified,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Hierarchy => serializer.serialize_str("HIERARCHY"),
                Self::Network => serializer.serialize_str("NETWORK"),
                Self::NetworkRegional => serializer.serialize_str("NETWORK_REGIONAL"),
                Self::SystemGlobal => serializer.serialize_str("SYSTEM_GLOBAL"),
                Self::SystemRegional => serializer.serialize_str("SYSTEM_REGIONAL"),
                Self::Unspecified => serializer.serialize_str("UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.compute.v1.InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy.type"))
        }
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesRemoveResourcePoliciesRequest {
    /// Resource policies to be removed from this instance.
    pub resource_policies: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesRemoveResourcePoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_policies][crate::model::InstancesRemoveResourcePoliciesRequest::resource_policies].
    pub fn set_resource_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesRemoveResourcePoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesRemoveResourcePoliciesRequest"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesReportHostAsFaultyRequest {
    /// The disruption schedule for the VM. Required field, only allows IMMEDIATE.
    pub disruption_schedule: std::option::Option<
        crate::model::instances_report_host_as_faulty_request::DisruptionSchedule,
    >,

    pub fault_reasons: std::vec::Vec<crate::model::InstancesReportHostAsFaultyRequestFaultReason>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesReportHostAsFaultyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disruption_schedule][crate::model::InstancesReportHostAsFaultyRequest::disruption_schedule].
    pub fn set_disruption_schedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::instances_report_host_as_faulty_request::DisruptionSchedule,
            >,
    {
        self.disruption_schedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disruption_schedule][crate::model::InstancesReportHostAsFaultyRequest::disruption_schedule].
    pub fn set_or_clear_disruption_schedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::instances_report_host_as_faulty_request::DisruptionSchedule,
            >,
    {
        self.disruption_schedule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fault_reasons][crate::model::InstancesReportHostAsFaultyRequest::fault_reasons].
    pub fn set_fault_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstancesReportHostAsFaultyRequestFaultReason>,
    {
        use std::iter::Iterator;
        self.fault_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesReportHostAsFaultyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesReportHostAsFaultyRequest"
    }
}

/// Defines additional types related to [InstancesReportHostAsFaultyRequest].
#[cfg(feature = "instances")]
pub mod instances_report_host_as_faulty_request {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [disruptionSchedule][google.cloud.compute.v1.InstancesReportHostAsFaultyRequest.disruptionSchedule] field.
    ///
    /// [google.cloud.compute.v1.InstancesReportHostAsFaultyRequest.disruptionSchedule]: crate::model::instances_report_host_as_faulty_request::DisruptionSchedule
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DisruptionSchedule {
        /// Not used. Required as per aip/126.
        Unspecified,
        /// Delay disruption for caller control. Will be default soon.
        Future,
        /// Default value. Disrupt the VM immediately.
        Immediate,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DisruptionSchedule::value] or
        /// [DisruptionSchedule::name].
        UnknownValue(disruption_schedule::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod disruption_schedule {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl DisruptionSchedule {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Future => std::option::Option::Some(1),
                Self::Immediate => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DISRUPTION_SCHEDULE_UNSPECIFIED"),
                Self::Future => std::option::Option::Some("FUTURE"),
                Self::Immediate => std::option::Option::Some("IMMEDIATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for DisruptionSchedule {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for DisruptionSchedule {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for DisruptionSchedule {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Future,
                2 => Self::Immediate,
                _ => Self::UnknownValue(disruption_schedule::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for DisruptionSchedule {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISRUPTION_SCHEDULE_UNSPECIFIED" => Self::Unspecified,
                "FUTURE" => Self::Future,
                "IMMEDIATE" => Self::Immediate,
                _ => Self::UnknownValue(disruption_schedule::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for DisruptionSchedule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_str("DISRUPTION_SCHEDULE_UNSPECIFIED"),
                Self::Future => serializer.serialize_str("FUTURE"),
                Self::Immediate => serializer.serialize_str("IMMEDIATE"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for DisruptionSchedule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DisruptionSchedule>::new(
                ".google.cloud.compute.v1.InstancesReportHostAsFaultyRequest.disruptionSchedule",
            ))
        }
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesReportHostAsFaultyRequestFaultReason {
    pub behavior: std::option::Option<
        crate::model::instances_report_host_as_faulty_request_fault_reason::Behavior,
    >,

    pub description: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesReportHostAsFaultyRequestFaultReason {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [behavior][crate::model::InstancesReportHostAsFaultyRequestFaultReason::behavior].
    pub fn set_behavior<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::instances_report_host_as_faulty_request_fault_reason::Behavior,
            >,
    {
        self.behavior = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [behavior][crate::model::InstancesReportHostAsFaultyRequestFaultReason::behavior].
    pub fn set_or_clear_behavior<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::instances_report_host_as_faulty_request_fault_reason::Behavior,
            >,
    {
        self.behavior = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::InstancesReportHostAsFaultyRequestFaultReason::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::InstancesReportHostAsFaultyRequestFaultReason::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesReportHostAsFaultyRequestFaultReason {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesReportHostAsFaultyRequestFaultReason"
    }
}

/// Defines additional types related to [InstancesReportHostAsFaultyRequestFaultReason].
#[cfg(feature = "instances")]
pub mod instances_report_host_as_faulty_request_fault_reason {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [behavior][google.cloud.compute.v1.InstancesReportHostAsFaultyRequestFaultReason.behavior] field.
    ///
    /// [google.cloud.compute.v1.InstancesReportHostAsFaultyRequestFaultReason.behavior]: crate::model::instances_report_host_as_faulty_request_fault_reason::Behavior
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Behavior {
        /// Public reportable behaviors
        Unspecified,
        Performance,
        SilentDataCorruption,
        UnrecoverableGpuError,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Behavior::value] or
        /// [Behavior::name].
        UnknownValue(behavior::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod behavior {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Behavior {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Performance => std::option::Option::Some(1),
                Self::SilentDataCorruption => std::option::Option::Some(2),
                Self::UnrecoverableGpuError => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BEHAVIOR_UNSPECIFIED"),
                Self::Performance => std::option::Option::Some("PERFORMANCE"),
                Self::SilentDataCorruption => std::option::Option::Some("SILENT_DATA_CORRUPTION"),
                Self::UnrecoverableGpuError => std::option::Option::Some("UNRECOVERABLE_GPU_ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Behavior {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Behavior {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Behavior {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Performance,
                2 => Self::SilentDataCorruption,
                3 => Self::UnrecoverableGpuError,
                _ => Self::UnknownValue(behavior::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Behavior {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BEHAVIOR_UNSPECIFIED" => Self::Unspecified,
                "PERFORMANCE" => Self::Performance,
                "SILENT_DATA_CORRUPTION" => Self::SilentDataCorruption,
                "UNRECOVERABLE_GPU_ERROR" => Self::UnrecoverableGpuError,
                _ => Self::UnknownValue(behavior::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Behavior {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_str("BEHAVIOR_UNSPECIFIED"),
                Self::Performance => serializer.serialize_str("PERFORMANCE"),
                Self::SilentDataCorruption => serializer.serialize_str("SILENT_DATA_CORRUPTION"),
                Self::UnrecoverableGpuError => serializer.serialize_str("UNRECOVERABLE_GPU_ERROR"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Behavior {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Behavior>::new(
                ".google.cloud.compute.v1.InstancesReportHostAsFaultyRequestFaultReason.behavior",
            ))
        }
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesScopedList {
    /// [Output Only] A list of instances contained in this scope.
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// [Output Only] Informational warning which replaces the list of instances
    /// when the list is empty.
    pub warning: std::option::Option<crate::model::instances_scoped_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesScopedList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::InstancesScopedList::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warning][crate::model::InstancesScopedList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instances_scoped_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::InstancesScopedList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instances_scoped_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesScopedList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesScopedList"
    }
}

/// Defines additional types related to [InstancesScopedList].
#[cfg(feature = "instances")]
pub mod instances_scoped_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.InstancesScopedList.warning] field.
    ///
    /// [google.cloud.compute.v1.InstancesScopedList.warning]: crate::model::instances_scoped_list::Warning
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::instances_scoped_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::instances_scoped_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::instances_scoped_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::instances_scoped_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::instances_scoped_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::instances_scoped_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::instances_scoped_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instances_scoped_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::instances_scoped_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::instances_scoped_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "instances")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstancesScopedList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "instances")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.InstancesScopedList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.InstancesScopedList.warning.data]: crate::model::instances_scoped_list::warning::Data
        #[cfg(feature = "instances")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instances")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::instances_scoped_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::instances_scoped_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::instances_scoped_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::instances_scoped_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instances")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstancesScopedList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.InstancesScopedList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.InstancesScopedList.warning.code]: crate::model::instances_scoped_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instances")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instances")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instances")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instances")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.InstancesScopedList.warning.code",
                ))
            }
        }
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesSetLabelsRequest {
    /// Fingerprint of the previous set of labels for this resource,
    /// used to prevent conflicts. Provide the latest fingerprint value when making
    /// a request to add or change labels.
    pub label_fingerprint: std::option::Option<::bytes::Bytes>,

    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesSetLabelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [label_fingerprint][crate::model::InstancesSetLabelsRequest::label_fingerprint].
    pub fn set_label_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.label_fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [label_fingerprint][crate::model::InstancesSetLabelsRequest::label_fingerprint].
    pub fn set_or_clear_label_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.label_fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::InstancesSetLabelsRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesSetLabelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesSetLabelsRequest"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesSetMachineResourcesRequest {
    /// A list of the type and count of accelerator cards attached to the instance.
    pub guest_accelerators: std::vec::Vec<crate::model::AcceleratorConfig>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesSetMachineResourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [guest_accelerators][crate::model::InstancesSetMachineResourcesRequest::guest_accelerators].
    pub fn set_guest_accelerators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AcceleratorConfig>,
    {
        use std::iter::Iterator;
        self.guest_accelerators = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesSetMachineResourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesSetMachineResourcesRequest"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesSetMachineTypeRequest {
    /// Full or partial URL of the machine type resource. See Machine Types for a full list of
    /// machine types. For example:zones/us-central1-f/machineTypes/n1-standard-1
    pub machine_type: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesSetMachineTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_type][crate::model::InstancesSetMachineTypeRequest::machine_type].
    pub fn set_machine_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.machine_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [machine_type][crate::model::InstancesSetMachineTypeRequest::machine_type].
    pub fn set_or_clear_machine_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.machine_type = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesSetMachineTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesSetMachineTypeRequest"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesSetMinCpuPlatformRequest {
    /// Minimum cpu/platform this instance should be started at.
    pub min_cpu_platform: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesSetMinCpuPlatformRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_cpu_platform][crate::model::InstancesSetMinCpuPlatformRequest::min_cpu_platform].
    pub fn set_min_cpu_platform<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.min_cpu_platform = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_cpu_platform][crate::model::InstancesSetMinCpuPlatformRequest::min_cpu_platform].
    pub fn set_or_clear_min_cpu_platform<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.min_cpu_platform = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesSetMinCpuPlatformRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesSetMinCpuPlatformRequest"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesSetNameRequest {
    /// The current name of this resource, used to prevent conflicts. Provide the
    /// latest name when making a request to change name.
    pub current_name: std::option::Option<std::string::String>,

    /// The name to be applied to the instance. Needs to be RFC 1035 compliant.
    pub name: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesSetNameRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [current_name][crate::model::InstancesSetNameRequest::current_name].
    pub fn set_current_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.current_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [current_name][crate::model::InstancesSetNameRequest::current_name].
    pub fn set_or_clear_current_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.current_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::InstancesSetNameRequest::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::InstancesSetNameRequest::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesSetNameRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesSetNameRequest"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesSetSecurityPolicyRequest {
    /// The network interfaces that the security policy will be applied to. Network
    /// interfaces use the nicN naming format. You can only set a
    /// security policy for network interfaces with an access config.
    pub network_interfaces: std::vec::Vec<std::string::String>,

    /// A full or partial URL to a security policy to add to this instance.
    /// If this field is set to an empty string it will remove the associated
    /// security policy.
    pub security_policy: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesSetSecurityPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_interfaces][crate::model::InstancesSetSecurityPolicyRequest::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [security_policy][crate::model::InstancesSetSecurityPolicyRequest::security_policy].
    pub fn set_security_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.security_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [security_policy][crate::model::InstancesSetSecurityPolicyRequest::security_policy].
    pub fn set_or_clear_security_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.security_policy = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesSetSecurityPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesSetSecurityPolicyRequest"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesSetServiceAccountRequest {
    /// Email address of the service account.
    pub email: std::option::Option<std::string::String>,

    /// The list of scopes to be made available for this service account.
    pub scopes: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesSetServiceAccountRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [email][crate::model::InstancesSetServiceAccountRequest::email].
    pub fn set_email<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.email = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [email][crate::model::InstancesSetServiceAccountRequest::email].
    pub fn set_or_clear_email<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.email = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scopes][crate::model::InstancesSetServiceAccountRequest::scopes].
    pub fn set_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesSetServiceAccountRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesSetServiceAccountRequest"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesStartWithEncryptionKeyRequest {
    /// Array of disks associated with this instance that are protected with acustomer-supplied
    /// encryption key.
    ///
    /// In order to start the instance, the disk url and its corresponding key must
    /// be provided.
    ///
    /// If the disk is not protected with a customer-supplied encryption key it
    /// should not be specified.
    pub disks: std::vec::Vec<crate::model::CustomerEncryptionKeyProtectedDisk>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesStartWithEncryptionKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disks][crate::model::InstancesStartWithEncryptionKeyRequest::disks].
    pub fn set_disks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomerEncryptionKeyProtectedDisk>,
    {
        use std::iter::Iterator;
        self.disks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesStartWithEncryptionKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesStartWithEncryptionKeyRequest"
    }
}

/// Provides a localized error message that is safe to return to the user
/// which can be attached to an RPC error.
#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocalizedMessage {
    /// The locale used following the specification defined at
    /// <https://www.rfc-editor.org/rfc/bcp/bcp47.txt>.
    /// Examples are: "en-US", "fr-CH", "es-MX"
    pub locale: std::option::Option<std::string::String>,

    /// The localized error message in the above locale.
    pub message: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl LocalizedMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [locale][crate::model::LocalizedMessage::locale].
    pub fn set_locale<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.locale = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [locale][crate::model::LocalizedMessage::locale].
    pub fn set_or_clear_locale<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.locale = v.map(|x| x.into());
        self
    }

    /// Sets the value of [message][crate::model::LocalizedMessage::message].
    pub fn set_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.message = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [message][crate::model::LocalizedMessage::message].
    pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.message = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl wkt::message::Message for LocalizedMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.LocalizedMessage"
    }
}

/// Configuration for location policy among multiple possible locations
/// (e.g. preferences for zone selection among zones in a single region).
#[cfg(any(feature = "instances", feature = "region-instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationPolicy {
    /// Location configurations mapped by location name.
    /// Currently only zone names are supported and must be represented as valid
    /// internal URLs, such as zones/us-central1-a.
    pub locations:
        std::collections::HashMap<std::string::String, crate::model::LocationPolicyLocation>,

    /// Strategy for distributing VMs across zones in a region.
    pub target_shape: std::option::Option<crate::model::location_policy::TargetShape>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "instances", feature = "region-instances",))]
impl LocationPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [locations][crate::model::LocationPolicy::locations].
    pub fn set_locations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::LocationPolicyLocation>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [target_shape][crate::model::LocationPolicy::target_shape].
    pub fn set_target_shape<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::location_policy::TargetShape>,
    {
        self.target_shape = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_shape][crate::model::LocationPolicy::target_shape].
    pub fn set_or_clear_target_shape<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::location_policy::TargetShape>,
    {
        self.target_shape = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "instances", feature = "region-instances",))]
impl wkt::message::Message for LocationPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.LocationPolicy"
    }
}

/// Defines additional types related to [LocationPolicy].
#[cfg(any(feature = "instances", feature = "region-instances",))]
pub mod location_policy {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [targetShape][google.cloud.compute.v1.LocationPolicy.targetShape] field.
    ///
    /// [google.cloud.compute.v1.LocationPolicy.targetShape]: crate::model::location_policy::TargetShape
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "instances", feature = "region-instances",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetShape {
        /// GCE picks zones for creating VM instances to fulfill the requested
        /// number of VMs within present resource constraints and to maximize
        /// utilization of unused zonal reservations. Recommended for batch workloads
        /// that do not require high availability.
        Any,
        /// GCE always selects a single zone for all the VMs, optimizing for resource
        /// quotas, available reservations and general capacity. Recommended for
        /// batch workloads that cannot tollerate distribution over multiple zones.
        /// This the default shape in Bulk Insert and Capacity Advisor APIs.
        AnySingleZone,
        /// GCE prioritizes acquisition of resources, scheduling VMs in zones
        /// where resources are available while distributing VMs as evenly as
        /// possible across allowed zones to minimize the impact of zonal failure.
        /// Recommended for highly available serving workloads.
        Balanced,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TargetShape::value] or
        /// [TargetShape::name].
        UnknownValue(target_shape::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "instances", feature = "region-instances",))]
    pub mod target_shape {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "instances", feature = "region-instances",))]
    impl TargetShape {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Any => std::option::Option::Some(0),
                Self::AnySingleZone => std::option::Option::Some(1),
                Self::Balanced => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Any => std::option::Option::Some("ANY"),
                Self::AnySingleZone => std::option::Option::Some("ANY_SINGLE_ZONE"),
                Self::Balanced => std::option::Option::Some("BALANCED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "instances", feature = "region-instances",))]
    impl std::default::Default for TargetShape {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "instances", feature = "region-instances",))]
    impl std::fmt::Display for TargetShape {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "instances", feature = "region-instances",))]
    impl std::convert::From<i32> for TargetShape {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Any,
                1 => Self::AnySingleZone,
                2 => Self::Balanced,
                _ => Self::UnknownValue(target_shape::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "instances", feature = "region-instances",))]
    impl std::convert::From<&str> for TargetShape {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANY" => Self::Any,
                "ANY_SINGLE_ZONE" => Self::AnySingleZone,
                "BALANCED" => Self::Balanced,
                _ => Self::UnknownValue(target_shape::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "instances", feature = "region-instances",))]
    impl serde::ser::Serialize for TargetShape {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Any => serializer.serialize_str("ANY"),
                Self::AnySingleZone => serializer.serialize_str("ANY_SINGLE_ZONE"),
                Self::Balanced => serializer.serialize_str("BALANCED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "instances", feature = "region-instances",))]
    impl<'de> serde::de::Deserialize<'de> for TargetShape {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TargetShape>::new(
                ".google.cloud.compute.v1.LocationPolicy.targetShape",
            ))
        }
    }
}

#[cfg(any(feature = "instances", feature = "region-instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationPolicyLocation {
    /// Constraints that the caller requires on the result distribution
    /// in this zone.
    pub constraints: std::option::Option<crate::model::LocationPolicyLocationConstraints>,

    /// Preference for a given location. Set to either ALLOW orDENY.
    pub preference: std::option::Option<crate::model::location_policy_location::Preference>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "instances", feature = "region-instances",))]
impl LocationPolicyLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [constraints][crate::model::LocationPolicyLocation::constraints].
    pub fn set_constraints<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LocationPolicyLocationConstraints>,
    {
        self.constraints = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [constraints][crate::model::LocationPolicyLocation::constraints].
    pub fn set_or_clear_constraints<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LocationPolicyLocationConstraints>,
    {
        self.constraints = v.map(|x| x.into());
        self
    }

    /// Sets the value of [preference][crate::model::LocationPolicyLocation::preference].
    pub fn set_preference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::location_policy_location::Preference>,
    {
        self.preference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [preference][crate::model::LocationPolicyLocation::preference].
    pub fn set_or_clear_preference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::location_policy_location::Preference>,
    {
        self.preference = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "instances", feature = "region-instances",))]
impl wkt::message::Message for LocationPolicyLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.LocationPolicyLocation"
    }
}

/// Defines additional types related to [LocationPolicyLocation].
#[cfg(any(feature = "instances", feature = "region-instances",))]
pub mod location_policy_location {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [preference][google.cloud.compute.v1.LocationPolicyLocation.preference] field.
    ///
    /// [google.cloud.compute.v1.LocationPolicyLocation.preference]: crate::model::location_policy_location::Preference
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "instances", feature = "region-instances",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Preference {
        /// Location is allowed for use.
        Allow,
        /// Location is prohibited.
        Deny,
        /// Default value, unused.
        Unspecified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Preference::value] or
        /// [Preference::name].
        UnknownValue(preference::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "instances", feature = "region-instances",))]
    pub mod preference {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "instances", feature = "region-instances",))]
    impl Preference {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Allow => std::option::Option::Some(0),
                Self::Deny => std::option::Option::Some(1),
                Self::Unspecified => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Allow => std::option::Option::Some("ALLOW"),
                Self::Deny => std::option::Option::Some("DENY"),
                Self::Unspecified => std::option::Option::Some("PREFERENCE_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "instances", feature = "region-instances",))]
    impl std::default::Default for Preference {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "instances", feature = "region-instances",))]
    impl std::fmt::Display for Preference {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "instances", feature = "region-instances",))]
    impl std::convert::From<i32> for Preference {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Allow,
                1 => Self::Deny,
                2 => Self::Unspecified,
                _ => Self::UnknownValue(preference::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "instances", feature = "region-instances",))]
    impl std::convert::From<&str> for Preference {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ALLOW" => Self::Allow,
                "DENY" => Self::Deny,
                "PREFERENCE_UNSPECIFIED" => Self::Unspecified,
                _ => Self::UnknownValue(preference::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "instances", feature = "region-instances",))]
    impl serde::ser::Serialize for Preference {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Allow => serializer.serialize_str("ALLOW"),
                Self::Deny => serializer.serialize_str("DENY"),
                Self::Unspecified => serializer.serialize_str("PREFERENCE_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "instances", feature = "region-instances",))]
    impl<'de> serde::de::Deserialize<'de> for Preference {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Preference>::new(
                ".google.cloud.compute.v1.LocationPolicyLocation.preference",
            ))
        }
    }
}

/// Per-zone constraints on location policy for this zone.
#[cfg(any(feature = "instances", feature = "region-instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationPolicyLocationConstraints {
    /// Maximum number of items that are allowed to be placed in this zone.
    /// The value must be non-negative.
    pub max_count: std::option::Option<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "instances", feature = "region-instances",))]
impl LocationPolicyLocationConstraints {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_count][crate::model::LocationPolicyLocationConstraints::max_count].
    pub fn set_max_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.max_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_count][crate::model::LocationPolicyLocationConstraints::max_count].
    pub fn set_or_clear_max_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.max_count = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "instances", feature = "region-instances",))]
impl wkt::message::Message for LocationPolicyLocationConstraints {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.LocationPolicyLocationConstraints"
    }
}

/// Represents a Machine Type resource.
///
/// You can use specific machine types for your VM instances based on performance
/// and pricing requirements. For more information, readMachine Types.
#[cfg(feature = "machine-types")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MachineType {
    /// [Output Only] A list of accelerator configurations assigned to this
    /// machine type.
    pub accelerators: std::vec::Vec<crate::model::machine_type::Accelerators>,

    /// [Output Only] The architecture of the machine type.
    pub architecture: std::option::Option<crate::model::machine_type::Architecture>,

    /// [Output Only] Creation timestamp inRFC3339
    /// text format.
    pub creation_timestamp: std::option::Option<std::string::String>,

    /// [Output Only] The deprecation status associated with this machine type.
    /// Only applicable if the machine type is unavailable.
    pub deprecated: std::option::Option<crate::model::DeprecationStatus>,

    /// [Output Only] An optional textual description of the resource.
    pub description: std::option::Option<std::string::String>,

    /// [Output Only] The number of virtual CPUs that are available to the
    /// instance.
    pub guest_cpus: std::option::Option<i32>,

    /// [Output Only] The unique identifier for the resource. This identifier is
    /// defined by the server.
    pub id: std::option::Option<u64>,

    /// [Deprecated] This property is deprecated and will never be populated with
    /// any relevant values.
    pub image_space_gb: std::option::Option<i32>,

    /// [Output Only] Whether this machine type has a shared CPU. SeeShared-core machine
    /// types for more information.
    pub is_shared_cpu: std::option::Option<bool>,

    /// [Output Only] The type of the resource. Alwayscompute#machineType for machine types.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] Maximum persistent disks allowed.
    pub maximum_persistent_disks: std::option::Option<i32>,

    /// [Output Only] Maximum total persistent disks size (GB) allowed.
    pub maximum_persistent_disks_size_gb: std::option::Option<i64>,

    /// [Output Only] The amount of physical memory available to the instance,
    /// defined in MB.
    pub memory_mb: std::option::Option<i32>,

    /// [Output Only] Name of the resource.
    pub name: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for the resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] The name of the zone where the machine type resides,
    /// such as us-central1-a.
    pub zone: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "machine-types")]
impl MachineType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [accelerators][crate::model::MachineType::accelerators].
    pub fn set_accelerators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::machine_type::Accelerators>,
    {
        use std::iter::Iterator;
        self.accelerators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [architecture][crate::model::MachineType::architecture].
    pub fn set_architecture<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::machine_type::Architecture>,
    {
        self.architecture = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [architecture][crate::model::MachineType::architecture].
    pub fn set_or_clear_architecture<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::machine_type::Architecture>,
    {
        self.architecture = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creation_timestamp][crate::model::MachineType::creation_timestamp].
    pub fn set_creation_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_timestamp][crate::model::MachineType::creation_timestamp].
    pub fn set_or_clear_creation_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deprecated][crate::model::MachineType::deprecated].
    pub fn set_deprecated<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeprecationStatus>,
    {
        self.deprecated = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deprecated][crate::model::MachineType::deprecated].
    pub fn set_or_clear_deprecated<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeprecationStatus>,
    {
        self.deprecated = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::MachineType::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::MachineType::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [guest_cpus][crate::model::MachineType::guest_cpus].
    pub fn set_guest_cpus<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.guest_cpus = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [guest_cpus][crate::model::MachineType::guest_cpus].
    pub fn set_or_clear_guest_cpus<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.guest_cpus = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::MachineType::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::MachineType::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [image_space_gb][crate::model::MachineType::image_space_gb].
    pub fn set_image_space_gb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.image_space_gb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [image_space_gb][crate::model::MachineType::image_space_gb].
    pub fn set_or_clear_image_space_gb<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.image_space_gb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [is_shared_cpu][crate::model::MachineType::is_shared_cpu].
    pub fn set_is_shared_cpu<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.is_shared_cpu = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [is_shared_cpu][crate::model::MachineType::is_shared_cpu].
    pub fn set_or_clear_is_shared_cpu<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.is_shared_cpu = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::MachineType::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::MachineType::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maximum_persistent_disks][crate::model::MachineType::maximum_persistent_disks].
    pub fn set_maximum_persistent_disks<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.maximum_persistent_disks = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maximum_persistent_disks][crate::model::MachineType::maximum_persistent_disks].
    pub fn set_or_clear_maximum_persistent_disks<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.maximum_persistent_disks = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maximum_persistent_disks_size_gb][crate::model::MachineType::maximum_persistent_disks_size_gb].
    pub fn set_maximum_persistent_disks_size_gb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.maximum_persistent_disks_size_gb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maximum_persistent_disks_size_gb][crate::model::MachineType::maximum_persistent_disks_size_gb].
    pub fn set_or_clear_maximum_persistent_disks_size_gb<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.maximum_persistent_disks_size_gb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [memory_mb][crate::model::MachineType::memory_mb].
    pub fn set_memory_mb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.memory_mb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [memory_mb][crate::model::MachineType::memory_mb].
    pub fn set_or_clear_memory_mb<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.memory_mb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::MachineType::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::MachineType::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::MachineType::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::MachineType::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [zone][crate::model::MachineType::zone].
    pub fn set_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [zone][crate::model::MachineType::zone].
    pub fn set_or_clear_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "machine-types")]
impl wkt::message::Message for MachineType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.MachineType"
    }
}

/// Defines additional types related to [MachineType].
#[cfg(feature = "machine-types")]
pub mod machine_type {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [accelerators][google.cloud.compute.v1.MachineType.accelerators] field.
    ///
    /// [google.cloud.compute.v1.MachineType.accelerators]: crate::model::machine_type::Accelerators
    #[cfg(feature = "machine-types")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Accelerators {
        /// Number of accelerator cards exposed to the guest.
        pub guest_accelerator_count: std::option::Option<i32>,

        /// The accelerator type resource name, not a full URL, e.g.nvidia-tesla-t4.
        pub guest_accelerator_type: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "machine-types")]
    impl Accelerators {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [guest_accelerator_count][crate::model::machine_type::Accelerators::guest_accelerator_count].
        pub fn set_guest_accelerator_count<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.guest_accelerator_count = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [guest_accelerator_count][crate::model::machine_type::Accelerators::guest_accelerator_count].
        pub fn set_or_clear_guest_accelerator_count<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.guest_accelerator_count = v.map(|x| x.into());
            self
        }

        /// Sets the value of [guest_accelerator_type][crate::model::machine_type::Accelerators::guest_accelerator_type].
        pub fn set_guest_accelerator_type<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.guest_accelerator_type = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [guest_accelerator_type][crate::model::machine_type::Accelerators::guest_accelerator_type].
        pub fn set_or_clear_guest_accelerator_type<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.guest_accelerator_type = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "machine-types")]
    impl wkt::message::Message for Accelerators {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.MachineType.accelerators"
        }
    }

    /// The enumerated type for the [architecture][google.cloud.compute.v1.MachineType.architecture] field.
    ///
    /// [google.cloud.compute.v1.MachineType.architecture]: crate::model::machine_type::Architecture
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "machine-types")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Architecture {
        /// Default value indicating Architecture is not set.
        Unspecified,
        /// Machines with architecture ARM64
        Arm64,
        /// Machines with architecture X86_64
        X8664,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Architecture::value] or
        /// [Architecture::name].
        UnknownValue(architecture::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "machine-types")]
    pub mod architecture {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "machine-types")]
    impl Architecture {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Arm64 => std::option::Option::Some(1),
                Self::X8664 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ARCHITECTURE_UNSPECIFIED"),
                Self::Arm64 => std::option::Option::Some("ARM64"),
                Self::X8664 => std::option::Option::Some("X86_64"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "machine-types")]
    impl std::default::Default for Architecture {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "machine-types")]
    impl std::fmt::Display for Architecture {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "machine-types")]
    impl std::convert::From<i32> for Architecture {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Arm64,
                2 => Self::X8664,
                _ => Self::UnknownValue(architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "machine-types")]
    impl std::convert::From<&str> for Architecture {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
                "ARM64" => Self::Arm64,
                "X86_64" => Self::X8664,
                _ => Self::UnknownValue(architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "machine-types")]
    impl serde::ser::Serialize for Architecture {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_str("ARCHITECTURE_UNSPECIFIED"),
                Self::Arm64 => serializer.serialize_str("ARM64"),
                Self::X8664 => serializer.serialize_str("X86_64"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "machine-types")]
    impl<'de> serde::de::Deserialize<'de> for Architecture {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Architecture>::new(
                ".google.cloud.compute.v1.MachineType.architecture",
            ))
        }
    }
}

#[cfg(feature = "machine-types")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MachineTypeAggregatedList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of MachineTypesScopedList resources.
    pub items: std::collections::HashMap<std::string::String, crate::model::MachineTypesScopedList>,

    /// [Output Only] Type of resource. Alwayscompute#machineTypeAggregatedList for aggregated lists of
    /// machine types.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Unreachable resources.
    pub unreachables: std::vec::Vec<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::machine_type_aggregated_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "machine-types")]
impl MachineTypeAggregatedList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::MachineTypeAggregatedList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::MachineTypeAggregatedList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::MachineTypeAggregatedList::items].
    pub fn set_items<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::MachineTypesScopedList>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [kind][crate::model::MachineTypeAggregatedList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::MachineTypeAggregatedList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::MachineTypeAggregatedList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::MachineTypeAggregatedList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::MachineTypeAggregatedList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::MachineTypeAggregatedList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [unreachables][crate::model::MachineTypeAggregatedList::unreachables].
    pub fn set_unreachables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warning][crate::model::MachineTypeAggregatedList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::machine_type_aggregated_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::MachineTypeAggregatedList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::machine_type_aggregated_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "machine-types")]
impl wkt::message::Message for MachineTypeAggregatedList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.MachineTypeAggregatedList"
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for MachineTypeAggregatedList {
    type PageItem = (std::string::String, crate::model::MachineTypesScopedList);

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        use std::iter::{IntoIterator, Iterator};
        self.items.into_iter().collect()
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [MachineTypeAggregatedList].
#[cfg(feature = "machine-types")]
pub mod machine_type_aggregated_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.MachineTypeAggregatedList.warning] field.
    ///
    /// [google.cloud.compute.v1.MachineTypeAggregatedList.warning]: crate::model::machine_type_aggregated_list::Warning
    #[cfg(feature = "machine-types")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::machine_type_aggregated_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::machine_type_aggregated_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "machine-types")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::machine_type_aggregated_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::machine_type_aggregated_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::machine_type_aggregated_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::machine_type_aggregated_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::machine_type_aggregated_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::machine_type_aggregated_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::machine_type_aggregated_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::machine_type_aggregated_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "machine-types")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.MachineTypeAggregatedList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "machine-types")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.MachineTypeAggregatedList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.MachineTypeAggregatedList.warning.data]: crate::model::machine_type_aggregated_list::warning::Data
        #[cfg(feature = "machine-types")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "machine-types")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::machine_type_aggregated_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::machine_type_aggregated_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::machine_type_aggregated_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::machine_type_aggregated_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "machine-types")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.MachineTypeAggregatedList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.MachineTypeAggregatedList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.MachineTypeAggregatedList.warning.code]: crate::model::machine_type_aggregated_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "machine-types")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "machine-types")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "machine-types")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.MachineTypeAggregatedList.warning.code",
                ))
            }
        }
    }
}

/// Contains a list of machine types.
#[cfg(feature = "machine-types")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MachineTypeList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of MachineType resources.
    pub items: std::vec::Vec<crate::model::MachineType>,

    /// [Output Only] Type of resource. Always compute#machineTypeList
    /// for lists of machine types.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::machine_type_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "machine-types")]
impl MachineTypeList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::MachineTypeList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::MachineTypeList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::MachineTypeList::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MachineType>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::MachineTypeList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::MachineTypeList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::MachineTypeList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::MachineTypeList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::MachineTypeList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::MachineTypeList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::MachineTypeList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::machine_type_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::MachineTypeList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::machine_type_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "machine-types")]
impl wkt::message::Message for MachineTypeList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.MachineTypeList"
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for MachineTypeList {
    type PageItem = crate::model::MachineType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [MachineTypeList].
#[cfg(feature = "machine-types")]
pub mod machine_type_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.MachineTypeList.warning] field.
    ///
    /// [google.cloud.compute.v1.MachineTypeList.warning]: crate::model::machine_type_list::Warning
    #[cfg(feature = "machine-types")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::machine_type_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::machine_type_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "machine-types")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::machine_type_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::machine_type_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::machine_type_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::machine_type_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::machine_type_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::machine_type_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::machine_type_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::machine_type_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "machine-types")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.MachineTypeList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "machine-types")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.MachineTypeList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.MachineTypeList.warning.data]: crate::model::machine_type_list::warning::Data
        #[cfg(feature = "machine-types")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "machine-types")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::machine_type_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::machine_type_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::machine_type_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::machine_type_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "machine-types")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.MachineTypeList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.MachineTypeList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.MachineTypeList.warning.code]: crate::model::machine_type_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "machine-types")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "machine-types")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "machine-types")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.MachineTypeList.warning.code",
                ))
            }
        }
    }
}

#[cfg(feature = "machine-types")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MachineTypesScopedList {
    /// [Output Only] A list of machine types contained in this scope.
    pub machine_types: std::vec::Vec<crate::model::MachineType>,

    /// [Output Only] An informational warning that appears when the machine types
    /// list is empty.
    pub warning: std::option::Option<crate::model::machine_types_scoped_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "machine-types")]
impl MachineTypesScopedList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_types][crate::model::MachineTypesScopedList::machine_types].
    pub fn set_machine_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MachineType>,
    {
        use std::iter::Iterator;
        self.machine_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warning][crate::model::MachineTypesScopedList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::machine_types_scoped_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::MachineTypesScopedList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::machine_types_scoped_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "machine-types")]
impl wkt::message::Message for MachineTypesScopedList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.MachineTypesScopedList"
    }
}

/// Defines additional types related to [MachineTypesScopedList].
#[cfg(feature = "machine-types")]
pub mod machine_types_scoped_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.MachineTypesScopedList.warning] field.
    ///
    /// [google.cloud.compute.v1.MachineTypesScopedList.warning]: crate::model::machine_types_scoped_list::Warning
    #[cfg(feature = "machine-types")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::machine_types_scoped_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::machine_types_scoped_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "machine-types")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::machine_types_scoped_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::machine_types_scoped_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::machine_types_scoped_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::machine_types_scoped_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::machine_types_scoped_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::machine_types_scoped_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::machine_types_scoped_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::machine_types_scoped_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "machine-types")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.MachineTypesScopedList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "machine-types")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.MachineTypesScopedList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.MachineTypesScopedList.warning.data]: crate::model::machine_types_scoped_list::warning::Data
        #[cfg(feature = "machine-types")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "machine-types")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::machine_types_scoped_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::machine_types_scoped_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::machine_types_scoped_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::machine_types_scoped_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "machine-types")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.MachineTypesScopedList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.MachineTypesScopedList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.MachineTypesScopedList.warning.code]: crate::model::machine_types_scoped_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "machine-types")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "machine-types")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "machine-types")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.MachineTypesScopedList.warning.code",
                ))
            }
        }
    }
}

/// A Managed Instance resource.
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ManagedInstance {
    /// [Output Only] The current action that the managed instance group has
    /// scheduled for the instance. Possible values:
    ///
    /// - NONE The instance is running, and the managed
    ///   instance group does not have any scheduled actions for this instance.
    /// - CREATING The managed instance group is creating this
    ///   instance. If the group fails to create this instance, it will try again
    ///   until it is successful.
    /// - CREATING_WITHOUT_RETRIES The managed instance group
    ///   is attempting to create this instance only once. If the group fails
    ///   to create this instance, it does not try again and the group'stargetSize value is decreased instead.
    /// - RECREATING The managed instance group is recreating
    ///   this instance.
    /// - DELETING The managed instance group is permanently
    ///   deleting this instance.
    /// - ABANDONING The managed instance group is abandoning
    ///   this instance. The instance will be removed from the instance group
    ///   and from any target pools that are associated with this group.
    /// - RESTARTING The managed instance group is restarting
    ///   the instance.
    /// - REFRESHING The managed instance group is applying
    ///   configuration changes to the instance without stopping it. For example,
    ///   the group can update the target pool list for an instance without
    ///   stopping that instance.
    /// - VERIFYING The managed instance group has created the
    ///   instance and it is in the process of being verified.
    pub current_action: std::option::Option<crate::model::managed_instance::CurrentAction>,

    /// [Output only] The unique identifier for this resource. This field is empty
    /// when instance does not exist.
    pub id: std::option::Option<u64>,

    /// [Output Only] The URL of the instance. The URL can exist even if the
    /// instance has not yet been created.
    pub instance: std::option::Option<std::string::String>,

    /// [Output Only] Health state of the instance per health-check.
    pub instance_health: std::vec::Vec<crate::model::ManagedInstanceInstanceHealth>,

    /// [Output Only] The status of the instance. This field is empty when
    /// the instance does not exist.
    pub instance_status: std::option::Option<crate::model::managed_instance::InstanceStatus>,

    /// [Output Only] Information about the last attempt to create or delete
    /// the instance.
    pub last_attempt: std::option::Option<crate::model::ManagedInstanceLastAttempt>,

    /// [Output Only] The name of the instance. The name always exists even if the
    /// instance has not yet been created.
    pub name: std::option::Option<std::string::String>,

    /// [Output Only] Preserved state applied from per-instance config
    /// for this instance.
    pub preserved_state_from_config: std::option::Option<crate::model::PreservedState>,

    /// [Output Only] Preserved state generated based on stateful policy
    /// for this instance.
    pub preserved_state_from_policy: std::option::Option<crate::model::PreservedState>,

    /// [Output Only] Instance properties selected for this instance resulting from
    /// InstanceFlexibilityPolicy.
    pub properties_from_flexibility_policy:
        std::option::Option<crate::model::ManagedInstancePropertiesFromFlexibilityPolicy>,

    /// [Output Only] Intended version of this instance.
    pub version: std::option::Option<crate::model::ManagedInstanceVersion>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl ManagedInstance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [current_action][crate::model::ManagedInstance::current_action].
    pub fn set_current_action<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::managed_instance::CurrentAction>,
    {
        self.current_action = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [current_action][crate::model::ManagedInstance::current_action].
    pub fn set_or_clear_current_action<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::managed_instance::CurrentAction>,
    {
        self.current_action = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::ManagedInstance::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::ManagedInstance::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance][crate::model::ManagedInstance::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::ManagedInstance::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_health][crate::model::ManagedInstance::instance_health].
    pub fn set_instance_health<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ManagedInstanceInstanceHealth>,
    {
        use std::iter::Iterator;
        self.instance_health = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [instance_status][crate::model::ManagedInstance::instance_status].
    pub fn set_instance_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::managed_instance::InstanceStatus>,
    {
        self.instance_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_status][crate::model::ManagedInstance::instance_status].
    pub fn set_or_clear_instance_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::managed_instance::InstanceStatus>,
    {
        self.instance_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_attempt][crate::model::ManagedInstance::last_attempt].
    pub fn set_last_attempt<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManagedInstanceLastAttempt>,
    {
        self.last_attempt = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_attempt][crate::model::ManagedInstance::last_attempt].
    pub fn set_or_clear_last_attempt<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ManagedInstanceLastAttempt>,
    {
        self.last_attempt = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::ManagedInstance::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::ManagedInstance::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [preserved_state_from_config][crate::model::ManagedInstance::preserved_state_from_config].
    pub fn set_preserved_state_from_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PreservedState>,
    {
        self.preserved_state_from_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [preserved_state_from_config][crate::model::ManagedInstance::preserved_state_from_config].
    pub fn set_or_clear_preserved_state_from_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PreservedState>,
    {
        self.preserved_state_from_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [preserved_state_from_policy][crate::model::ManagedInstance::preserved_state_from_policy].
    pub fn set_preserved_state_from_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PreservedState>,
    {
        self.preserved_state_from_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [preserved_state_from_policy][crate::model::ManagedInstance::preserved_state_from_policy].
    pub fn set_or_clear_preserved_state_from_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PreservedState>,
    {
        self.preserved_state_from_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [properties_from_flexibility_policy][crate::model::ManagedInstance::properties_from_flexibility_policy].
    pub fn set_properties_from_flexibility_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManagedInstancePropertiesFromFlexibilityPolicy>,
    {
        self.properties_from_flexibility_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [properties_from_flexibility_policy][crate::model::ManagedInstance::properties_from_flexibility_policy].
    pub fn set_or_clear_properties_from_flexibility_policy<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::ManagedInstancePropertiesFromFlexibilityPolicy>,
    {
        self.properties_from_flexibility_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [version][crate::model::ManagedInstance::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ManagedInstanceVersion>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::ManagedInstance::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ManagedInstanceVersion>,
    {
        self.version = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for ManagedInstance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ManagedInstance"
    }
}

/// Defines additional types related to [ManagedInstance].
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
pub mod managed_instance {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [currentAction][google.cloud.compute.v1.ManagedInstance.currentAction] field.
    ///
    /// [google.cloud.compute.v1.ManagedInstance.currentAction]: crate::model::managed_instance::CurrentAction
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CurrentAction {
        /// The managed instance group is abandoning this instance. The instance
        /// will be removed from the instance group and from any target pools that
        /// are associated with this group.
        Abandoning,
        /// The managed instance group is creating this instance. If the group
        /// fails to create this instance, it will try again until it is
        /// successful.
        Creating,
        /// The managed instance group is attempting to create this instance
        /// only once. If the group fails to create this instance, it does
        /// not try again and the group's targetSize value is
        /// decreased.
        CreatingWithoutRetries,
        /// The managed instance group is permanently deleting this instance.
        Deleting,
        /// The managed instance group has not scheduled any actions for this
        /// instance.
        None,
        /// The managed instance group is recreating this instance.
        Recreating,
        /// The managed instance group is applying configuration changes to the
        /// instance without stopping it. For example, the group can update the
        /// target pool list for an instance without stopping that instance.
        Refreshing,
        /// The managed instance group is restarting this instance.
        Restarting,
        /// The managed instance group is resuming this instance.
        Resuming,
        /// The managed instance group is starting this instance.
        Starting,
        /// The managed instance group is stopping this instance.
        Stopping,
        /// The managed instance group is suspending this instance.
        Suspending,
        /// The managed instance group is verifying this already created instance.
        /// Verification happens every time the instance is (re)created or restarted
        /// and consists of:
        ///
        /// 1. Waiting until health check specified as part of this managed instance
        ///    group's autohealing policy reports HEALTHY.
        ///    Note: Applies only if autohealing policy has a health check specified
        /// 1. Waiting for addition verification steps performed as post-instance
        ///    creation (subject to future extensions).
        Verifying,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CurrentAction::value] or
        /// [CurrentAction::name].
        UnknownValue(current_action::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod current_action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl CurrentAction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Abandoning => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::CreatingWithoutRetries => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::None => std::option::Option::Some(4),
                Self::Recreating => std::option::Option::Some(5),
                Self::Refreshing => std::option::Option::Some(6),
                Self::Restarting => std::option::Option::Some(7),
                Self::Resuming => std::option::Option::Some(8),
                Self::Starting => std::option::Option::Some(9),
                Self::Stopping => std::option::Option::Some(10),
                Self::Suspending => std::option::Option::Some(11),
                Self::Verifying => std::option::Option::Some(12),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Abandoning => std::option::Option::Some("ABANDONING"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::CreatingWithoutRetries => {
                    std::option::Option::Some("CREATING_WITHOUT_RETRIES")
                }
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::None => std::option::Option::Some("NONE"),
                Self::Recreating => std::option::Option::Some("RECREATING"),
                Self::Refreshing => std::option::Option::Some("REFRESHING"),
                Self::Restarting => std::option::Option::Some("RESTARTING"),
                Self::Resuming => std::option::Option::Some("RESUMING"),
                Self::Starting => std::option::Option::Some("STARTING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Suspending => std::option::Option::Some("SUSPENDING"),
                Self::Verifying => std::option::Option::Some("VERIFYING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for CurrentAction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for CurrentAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for CurrentAction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Abandoning,
                1 => Self::Creating,
                2 => Self::CreatingWithoutRetries,
                3 => Self::Deleting,
                4 => Self::None,
                5 => Self::Recreating,
                6 => Self::Refreshing,
                7 => Self::Restarting,
                8 => Self::Resuming,
                9 => Self::Starting,
                10 => Self::Stopping,
                11 => Self::Suspending,
                12 => Self::Verifying,
                _ => Self::UnknownValue(current_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for CurrentAction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ABANDONING" => Self::Abandoning,
                "CREATING" => Self::Creating,
                "CREATING_WITHOUT_RETRIES" => Self::CreatingWithoutRetries,
                "DELETING" => Self::Deleting,
                "NONE" => Self::None,
                "RECREATING" => Self::Recreating,
                "REFRESHING" => Self::Refreshing,
                "RESTARTING" => Self::Restarting,
                "RESUMING" => Self::Resuming,
                "STARTING" => Self::Starting,
                "STOPPING" => Self::Stopping,
                "SUSPENDING" => Self::Suspending,
                "VERIFYING" => Self::Verifying,
                _ => Self::UnknownValue(current_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for CurrentAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Abandoning => serializer.serialize_str("ABANDONING"),
                Self::Creating => serializer.serialize_str("CREATING"),
                Self::CreatingWithoutRetries => {
                    serializer.serialize_str("CREATING_WITHOUT_RETRIES")
                }
                Self::Deleting => serializer.serialize_str("DELETING"),
                Self::None => serializer.serialize_str("NONE"),
                Self::Recreating => serializer.serialize_str("RECREATING"),
                Self::Refreshing => serializer.serialize_str("REFRESHING"),
                Self::Restarting => serializer.serialize_str("RESTARTING"),
                Self::Resuming => serializer.serialize_str("RESUMING"),
                Self::Starting => serializer.serialize_str("STARTING"),
                Self::Stopping => serializer.serialize_str("STOPPING"),
                Self::Suspending => serializer.serialize_str("SUSPENDING"),
                Self::Verifying => serializer.serialize_str("VERIFYING"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for CurrentAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CurrentAction>::new(
                ".google.cloud.compute.v1.ManagedInstance.currentAction",
            ))
        }
    }

    /// The enumerated type for the [instanceStatus][google.cloud.compute.v1.ManagedInstance.instanceStatus] field.
    ///
    /// [google.cloud.compute.v1.ManagedInstance.instanceStatus]: crate::model::managed_instance::InstanceStatus
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstanceStatus {
        /// The instance is halted and we are performing tear down tasks like network
        /// deprogramming, releasing quota, IP, tearing down disks etc.
        Deprovisioning,
        /// For Flex Start provisioning instance is waiting for available capacity
        /// from Dynamic Workload Scheduler (DWS).
        Pending,
        /// Resources are being allocated for the instance.
        Provisioning,
        /// The instance is in repair.
        Repairing,
        /// The instance is running.
        Running,
        /// All required resources have been allocated and the instance
        /// is being started.
        Staging,
        /// The instance has stopped successfully.
        Stopped,
        /// The instance is currently stopping (either being deleted or killed).
        Stopping,
        /// The instance has suspended.
        Suspended,
        /// The instance is suspending.
        Suspending,
        /// The instance has stopped (either by explicit action or underlying
        /// failure).
        Terminated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstanceStatus::value] or
        /// [InstanceStatus::name].
        UnknownValue(instance_status::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod instance_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl InstanceStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Deprovisioning => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Provisioning => std::option::Option::Some(2),
                Self::Repairing => std::option::Option::Some(3),
                Self::Running => std::option::Option::Some(4),
                Self::Staging => std::option::Option::Some(5),
                Self::Stopped => std::option::Option::Some(6),
                Self::Stopping => std::option::Option::Some(7),
                Self::Suspended => std::option::Option::Some(8),
                Self::Suspending => std::option::Option::Some(9),
                Self::Terminated => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Deprovisioning => std::option::Option::Some("DEPROVISIONING"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Repairing => std::option::Option::Some("REPAIRING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Staging => std::option::Option::Some("STAGING"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Suspended => std::option::Option::Some("SUSPENDED"),
                Self::Suspending => std::option::Option::Some("SUSPENDING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for InstanceStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for InstanceStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for InstanceStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Deprovisioning,
                1 => Self::Pending,
                2 => Self::Provisioning,
                3 => Self::Repairing,
                4 => Self::Running,
                5 => Self::Staging,
                6 => Self::Stopped,
                7 => Self::Stopping,
                8 => Self::Suspended,
                9 => Self::Suspending,
                10 => Self::Terminated,
                _ => Self::UnknownValue(instance_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for InstanceStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DEPROVISIONING" => Self::Deprovisioning,
                "PENDING" => Self::Pending,
                "PROVISIONING" => Self::Provisioning,
                "REPAIRING" => Self::Repairing,
                "RUNNING" => Self::Running,
                "STAGING" => Self::Staging,
                "STOPPED" => Self::Stopped,
                "STOPPING" => Self::Stopping,
                "SUSPENDED" => Self::Suspended,
                "SUSPENDING" => Self::Suspending,
                "TERMINATED" => Self::Terminated,
                _ => Self::UnknownValue(instance_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for InstanceStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Deprovisioning => serializer.serialize_str("DEPROVISIONING"),
                Self::Pending => serializer.serialize_str("PENDING"),
                Self::Provisioning => serializer.serialize_str("PROVISIONING"),
                Self::Repairing => serializer.serialize_str("REPAIRING"),
                Self::Running => serializer.serialize_str("RUNNING"),
                Self::Staging => serializer.serialize_str("STAGING"),
                Self::Stopped => serializer.serialize_str("STOPPED"),
                Self::Stopping => serializer.serialize_str("STOPPING"),
                Self::Suspended => serializer.serialize_str("SUSPENDED"),
                Self::Suspending => serializer.serialize_str("SUSPENDING"),
                Self::Terminated => serializer.serialize_str("TERMINATED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for InstanceStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InstanceStatus>::new(
                ".google.cloud.compute.v1.ManagedInstance.instanceStatus",
            ))
        }
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ManagedInstanceInstanceHealth {
    /// [Output Only] The current detailed instance health state.
    pub detailed_health_state:
        std::option::Option<crate::model::managed_instance_instance_health::DetailedHealthState>,

    /// [Output Only] The URL for the health check that verifies whether the
    /// instance is healthy.
    pub health_check: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl ManagedInstanceInstanceHealth {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [detailed_health_state][crate::model::ManagedInstanceInstanceHealth::detailed_health_state].
    pub fn set_detailed_health_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::managed_instance_instance_health::DetailedHealthState>,
    {
        self.detailed_health_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [detailed_health_state][crate::model::ManagedInstanceInstanceHealth::detailed_health_state].
    pub fn set_or_clear_detailed_health_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::managed_instance_instance_health::DetailedHealthState>,
    {
        self.detailed_health_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [health_check][crate::model::ManagedInstanceInstanceHealth::health_check].
    pub fn set_health_check<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.health_check = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [health_check][crate::model::ManagedInstanceInstanceHealth::health_check].
    pub fn set_or_clear_health_check<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.health_check = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for ManagedInstanceInstanceHealth {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ManagedInstanceInstanceHealth"
    }
}

/// Defines additional types related to [ManagedInstanceInstanceHealth].
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
pub mod managed_instance_instance_health {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [detailedHealthState][google.cloud.compute.v1.ManagedInstanceInstanceHealth.detailedHealthState] field.
    ///
    /// [google.cloud.compute.v1.ManagedInstanceInstanceHealth.detailedHealthState]: crate::model::managed_instance_instance_health::DetailedHealthState
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DetailedHealthState {
        /// The instance is being drained. The existing connections to the instance
        /// have time to complete, but the new ones are being refused.
        Draining,
        /// The instance is reachable i.e. a connection to the application health
        /// checking endpoint can be established, and conforms to the requirements
        /// defined by the health check.
        Healthy,
        /// The instance is unreachable i.e. a connection to the application health
        /// checking endpoint cannot be established, or the server does not respond
        /// within the specified timeout.
        Timeout,
        /// The instance is reachable, but does not conform to the requirements
        /// defined by the health check.
        Unhealthy,
        /// The health checking system is aware of the instance but its health is
        /// not known at the moment.
        Unknown,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DetailedHealthState::value] or
        /// [DetailedHealthState::name].
        UnknownValue(detailed_health_state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod detailed_health_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl DetailedHealthState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Draining => std::option::Option::Some(0),
                Self::Healthy => std::option::Option::Some(1),
                Self::Timeout => std::option::Option::Some(2),
                Self::Unhealthy => std::option::Option::Some(3),
                Self::Unknown => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Draining => std::option::Option::Some("DRAINING"),
                Self::Healthy => std::option::Option::Some("HEALTHY"),
                Self::Timeout => std::option::Option::Some("TIMEOUT"),
                Self::Unhealthy => std::option::Option::Some("UNHEALTHY"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for DetailedHealthState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for DetailedHealthState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for DetailedHealthState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Draining,
                1 => Self::Healthy,
                2 => Self::Timeout,
                3 => Self::Unhealthy,
                4 => Self::Unknown,
                _ => Self::UnknownValue(detailed_health_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for DetailedHealthState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DRAINING" => Self::Draining,
                "HEALTHY" => Self::Healthy,
                "TIMEOUT" => Self::Timeout,
                "UNHEALTHY" => Self::Unhealthy,
                "UNKNOWN" => Self::Unknown,
                _ => Self::UnknownValue(detailed_health_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for DetailedHealthState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Draining => serializer.serialize_str("DRAINING"),
                Self::Healthy => serializer.serialize_str("HEALTHY"),
                Self::Timeout => serializer.serialize_str("TIMEOUT"),
                Self::Unhealthy => serializer.serialize_str("UNHEALTHY"),
                Self::Unknown => serializer.serialize_str("UNKNOWN"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for DetailedHealthState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DetailedHealthState>::new(
                ".google.cloud.compute.v1.ManagedInstanceInstanceHealth.detailedHealthState",
            ))
        }
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ManagedInstanceLastAttempt {
    /// [Output Only] Encountered errors during the last attempt to create or
    /// delete the instance.
    pub errors: std::option::Option<crate::model::managed_instance_last_attempt::Errors>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl ManagedInstanceLastAttempt {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [errors][crate::model::ManagedInstanceLastAttempt::errors].
    pub fn set_errors<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::managed_instance_last_attempt::Errors>,
    {
        self.errors = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [errors][crate::model::ManagedInstanceLastAttempt::errors].
    pub fn set_or_clear_errors<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::managed_instance_last_attempt::Errors>,
    {
        self.errors = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for ManagedInstanceLastAttempt {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ManagedInstanceLastAttempt"
    }
}

/// Defines additional types related to [ManagedInstanceLastAttempt].
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
pub mod managed_instance_last_attempt {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [errors][google.cloud.compute.v1.ManagedInstanceLastAttempt.errors] field.
    ///
    /// [google.cloud.compute.v1.ManagedInstanceLastAttempt.errors]: crate::model::managed_instance_last_attempt::Errors
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Errors {
        /// [Output Only] The array of errors encountered while processing this
        /// operation.
        pub errors: std::vec::Vec<crate::model::managed_instance_last_attempt::errors::Errors>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl Errors {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [errors][crate::model::managed_instance_last_attempt::Errors::errors].
        pub fn set_errors<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::managed_instance_last_attempt::errors::Errors>,
        {
            use std::iter::Iterator;
            self.errors = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl wkt::message::Message for Errors {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.ManagedInstanceLastAttempt.errors"
        }
    }

    /// Defines additional types related to [Errors].
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod errors {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [errors][google.cloud.compute.v1.ManagedInstanceLastAttempt.errors.errors] field.
        ///
        /// [google.cloud.compute.v1.ManagedInstanceLastAttempt.errors.errors]: crate::model::managed_instance_last_attempt::errors::Errors
        #[cfg(any(
            feature = "instance-group-managers",
            feature = "region-instance-group-managers",
        ))]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Errors {
            /// [Output Only] The error type identifier for this error.
            pub code: std::option::Option<std::string::String>,

            /// [Output Only] An optional list of messages that contain the error
            /// details. There is a set of defined message types to use for providing
            /// details.The syntax depends on the error code. For example,
            /// QuotaExceededInfo will have details when the error code is
            /// QUOTA_EXCEEDED.
            pub error_details: std::vec::Vec<
                crate::model::managed_instance_last_attempt::errors::errors::ErrorDetails,
            >,

            /// [Output Only] Indicates the field in the request that caused the error.
            /// This property is optional.
            pub location: std::option::Option<std::string::String>,

            /// [Output Only] An optional, human-readable error message.
            pub message: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "instance-group-managers",
            feature = "region-instance-group-managers",
        ))]
        impl Errors {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [code][crate::model::managed_instance_last_attempt::errors::Errors::code].
            pub fn set_code<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.code = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [code][crate::model::managed_instance_last_attempt::errors::Errors::code].
            pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.code = v.map(|x| x.into());
                self
            }

            /// Sets the value of [error_details][crate::model::managed_instance_last_attempt::errors::Errors::error_details].
            pub fn set_error_details<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<
                        crate::model::managed_instance_last_attempt::errors::errors::ErrorDetails,
                    >,
            {
                use std::iter::Iterator;
                self.error_details = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [location][crate::model::managed_instance_last_attempt::errors::Errors::location].
            pub fn set_location<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.location = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [location][crate::model::managed_instance_last_attempt::errors::Errors::location].
            pub fn set_or_clear_location<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.location = v.map(|x| x.into());
                self
            }

            /// Sets the value of [message][crate::model::managed_instance_last_attempt::errors::Errors::message].
            pub fn set_message<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.message = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [message][crate::model::managed_instance_last_attempt::errors::Errors::message].
            pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.message = v.map(|x| x.into());
                self
            }
        }

        #[cfg(any(
            feature = "instance-group-managers",
            feature = "region-instance-group-managers",
        ))]
        impl wkt::message::Message for Errors {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.ManagedInstanceLastAttempt.errors.errors"
            }
        }

        /// Defines additional types related to [Errors].
        #[cfg(any(
            feature = "instance-group-managers",
            feature = "region-instance-group-managers",
        ))]
        pub mod errors {
            #[allow(unused_imports)]
            use super::*;

            /// The message type for the [errorDetails][google.cloud.compute.v1.ManagedInstanceLastAttempt.errors.errors.errorDetails] field.
            ///
            /// [google.cloud.compute.v1.ManagedInstanceLastAttempt.errors.errors.errorDetails]: crate::model::managed_instance_last_attempt::errors::errors::ErrorDetails
            #[cfg(any(
                feature = "instance-group-managers",
                feature = "region-instance-group-managers",
            ))]
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ErrorDetails {
                pub error_info: std::option::Option<crate::model::ErrorInfo>,

                pub help: std::option::Option<crate::model::Help>,

                pub localized_message: std::option::Option<crate::model::LocalizedMessage>,

                pub quota_info: std::option::Option<crate::model::QuotaExceededInfo>,

                pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(any(
                feature = "instance-group-managers",
                feature = "region-instance-group-managers",
            ))]
            impl ErrorDetails {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [error_info][crate::model::managed_instance_last_attempt::errors::errors::ErrorDetails::error_info].
                pub fn set_error_info<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::ErrorInfo>,
                {
                    self.error_info = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [error_info][crate::model::managed_instance_last_attempt::errors::errors::ErrorDetails::error_info].
                pub fn set_or_clear_error_info<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::ErrorInfo>,
                {
                    self.error_info = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [help][crate::model::managed_instance_last_attempt::errors::errors::ErrorDetails::help].
                pub fn set_help<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::Help>,
                {
                    self.help = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [help][crate::model::managed_instance_last_attempt::errors::errors::ErrorDetails::help].
                pub fn set_or_clear_help<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::Help>,
                {
                    self.help = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [localized_message][crate::model::managed_instance_last_attempt::errors::errors::ErrorDetails::localized_message].
                pub fn set_localized_message<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::LocalizedMessage>,
                {
                    self.localized_message = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [localized_message][crate::model::managed_instance_last_attempt::errors::errors::ErrorDetails::localized_message].
                pub fn set_or_clear_localized_message<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<crate::model::LocalizedMessage>,
                {
                    self.localized_message = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [quota_info][crate::model::managed_instance_last_attempt::errors::errors::ErrorDetails::quota_info].
                pub fn set_quota_info<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::QuotaExceededInfo>,
                {
                    self.quota_info = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [quota_info][crate::model::managed_instance_last_attempt::errors::errors::ErrorDetails::quota_info].
                pub fn set_or_clear_quota_info<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::QuotaExceededInfo>,
                {
                    self.quota_info = v.map(|x| x.into());
                    self
                }
            }

            #[cfg(any(
                feature = "instance-group-managers",
                feature = "region-instance-group-managers",
            ))]
            impl wkt::message::Message for ErrorDetails {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.compute.v1.ManagedInstanceLastAttempt.errors.errors.errorDetails"
                }
            }
        }
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ManagedInstancePropertiesFromFlexibilityPolicy {
    /// The machine type to be used for this instance.
    pub machine_type: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl ManagedInstancePropertiesFromFlexibilityPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_type][crate::model::ManagedInstancePropertiesFromFlexibilityPolicy::machine_type].
    pub fn set_machine_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.machine_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [machine_type][crate::model::ManagedInstancePropertiesFromFlexibilityPolicy::machine_type].
    pub fn set_or_clear_machine_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.machine_type = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for ManagedInstancePropertiesFromFlexibilityPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ManagedInstancePropertiesFromFlexibilityPolicy"
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ManagedInstanceVersion {
    /// [Output Only] The intended template of the instance. This field is empty
    /// when current_action is one of { DELETING, ABANDONING }.
    pub instance_template: std::option::Option<std::string::String>,

    /// [Output Only] Name of the version.
    pub name: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl ManagedInstanceVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_template][crate::model::ManagedInstanceVersion::instance_template].
    pub fn set_instance_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_template][crate::model::ManagedInstanceVersion::instance_template].
    pub fn set_or_clear_instance_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance_template = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::ManagedInstanceVersion::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::ManagedInstanceVersion::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for ManagedInstanceVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ManagedInstanceVersion"
    }
}

/// A metadata key/value entry.
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Metadata {
    /// Specifies a fingerprint for this request, which is essentially a hash of
    /// the metadata's contents and used for optimistic locking. The
    /// fingerprint is initially generated by Compute Engine and changes after
    /// every request to modify or update metadata. You must always provide an
    /// up-to-date fingerprint hash in order to update or change metadata,
    /// otherwise the request will fail with error412 conditionNotMet.
    ///
    /// To see the latest fingerprint, make a get() request to
    /// retrieve the resource.
    pub fingerprint: std::option::Option<::bytes::Bytes>,

    /// Array of key/value pairs. The total size of all keys and values must be
    /// less than 512 KB.
    pub items: std::vec::Vec<crate::model::metadata::Items>,

    /// [Output Only] Type of the resource. Always compute#metadata
    /// for metadata.
    pub kind: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl Metadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fingerprint][crate::model::Metadata::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::Metadata::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::Metadata::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::metadata::Items>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::Metadata::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::Metadata::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for Metadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Metadata"
    }
}

/// Defines additional types related to [Metadata].
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
pub mod metadata {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [items][google.cloud.compute.v1.Metadata.items] field.
    ///
    /// [google.cloud.compute.v1.Metadata.items]: crate::model::metadata::Items
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Items {
        /// Key for the metadata entry. Keys must conform to the following
        /// regexp: [a-zA-Z0-9-_]+, and be less than 128 bytes in length.
        /// This is reflected as part of a URL in the metadata server. Additionally, to
        /// avoid ambiguity, keys must not conflict with any other metadata keys
        /// for the project.
        pub key: std::option::Option<std::string::String>,

        /// Value for the metadata entry. These are free-form strings, and only
        /// have meaning as interpreted by the image running in the instance. The
        /// only restriction placed on values is that their size must be less than
        /// or equal to 262144 bytes (256 KiB).
        pub value: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl Items {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::metadata::Items::key].
        pub fn set_key<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.key = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [key][crate::model::metadata::Items::key].
        pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.key = v.map(|x| x.into());
            self
        }

        /// Sets the value of [value][crate::model::metadata::Items::value].
        pub fn set_value<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [value][crate::model::metadata::Items::value].
        pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.value = v.map(|x| x.into());
            self
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl wkt::message::Message for Items {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.Metadata.items"
        }
    }
}

/// The named port. For example: <"http", 80>.
#[cfg(any(
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NamedPort {
    /// The name for this named port.
    /// The name must be 1-63 characters long, and comply withRFC1035.
    pub name: std::option::Option<std::string::String>,

    /// The port number, which can be a value between 1 and 65535.
    pub port: std::option::Option<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
))]
impl NamedPort {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NamedPort::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::NamedPort::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [port][crate::model::NamedPort::port].
    pub fn set_port<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.port = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [port][crate::model::NamedPort::port].
    pub fn set_or_clear_port<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.port = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
))]
impl wkt::message::Message for NamedPort {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.NamedPort"
    }
}

/// A network interface resource attached to an instance.
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkInterface {
    /// An array of configurations for this interface. Currently, only one access
    /// config, ONE_TO_ONE_NAT, is supported. If there are noaccessConfigs specified, then this instance will have
    /// no external internet access.
    pub access_configs: std::vec::Vec<crate::model::AccessConfig>,

    /// An array of alias IP ranges for this network interface.
    /// You can only specify this field for network interfaces in VPC networks.
    pub alias_ip_ranges: std::vec::Vec<crate::model::AliasIpRange>,

    /// Fingerprint hash of contents stored in this network interface.
    /// This field will be ignored when inserting an Instance or
    /// adding a NetworkInterface. An up-to-date
    /// fingerprint must be provided in order to update theNetworkInterface. The request will fail with error400 Bad Request if the fingerprint is not provided, or412 Precondition Failed if the fingerprint is out of date.
    pub fingerprint: std::option::Option<::bytes::Bytes>,

    /// The prefix length of the primary internal IPv6 range.
    pub internal_ipv_6_prefix_length: std::option::Option<i32>,

    /// An array of IPv6 access configurations for this interface. Currently, only
    /// one IPv6 access config, DIRECT_IPV6, is supported. If there
    /// is no ipv6AccessConfig specified, then this instance will
    /// have no external IPv6 Internet access.
    pub ipv_6_access_configs: std::vec::Vec<crate::model::AccessConfig>,

    /// [Output Only] One of EXTERNAL, INTERNAL to indicate whether the IP can be
    /// accessed from the Internet. This field is always inherited from its
    /// subnetwork.
    ///
    /// Valid only if stackType is IPV4_IPV6.
    pub ipv_6_access_type: std::option::Option<crate::model::network_interface::Ipv6AccessType>,

    /// An IPv6 internal network address for this network interface. To
    /// use a static internal IP address, it must be unused and in the same region
    /// as the instance's zone. If not specified, Google Cloud will automatically
    /// assign an internal IPv6 address from the instance's subnetwork.
    pub ipv_6_address: std::option::Option<std::string::String>,

    /// [Output Only] Type of the resource. Alwayscompute#networkInterface for network interfaces.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] The name of the network interface, which is generated by the
    /// server. For a VM, the network interface uses the nicN naming
    /// format. Where N is a value between 0 and7. The default interface value is nic0.
    pub name: std::option::Option<std::string::String>,

    /// URL of the VPC network resource for this instance. When creating an
    /// instance, if neither the network nor the subnetwork is specified, the
    /// default network global/networks/default is used. If the
    /// selected project doesn't have the default network, you must specify a
    /// network or subnet. If the network is not specified but the subnetwork is
    /// specified, the network is inferred.
    ///
    /// If you specify this property, you can specify the network as
    /// a full or partial URL. For example, the following are all valid URLs:
    ///
    /// ```norust
    ///   - https://www.googleapis.com/compute/v1/projects/project/global/networks/network
    ///   - projects/project/global/networks/network
    ///   - global/networks/default
    /// ```
    pub network: std::option::Option<std::string::String>,

    /// The URL of the network attachment that this interface should connect
    /// to in the following format:
    /// projects/{project_number}/regions/{region_name}/networkAttachments/{network_attachment_name}.
    pub network_attachment: std::option::Option<std::string::String>,

    /// An IPv4 internal IP address to assign to the instance for this network
    /// interface. If not specified by the user, an unused internal IP is
    /// assigned by the system.
    pub network_ip: std::option::Option<std::string::String>,

    /// The type of vNIC to be used on this interface. This may be gVNIC or
    /// VirtioNet.
    pub nic_type: std::option::Option<crate::model::network_interface::NicType>,

    /// Name of the parent network interface of a dynamic network interface.
    pub parent_nic_name: std::option::Option<std::string::String>,

    /// The networking queue count that's specified by users for the network
    /// interface. Both Rx and Tx queues will be set to this number. It'll be empty
    /// if not specified by the users.
    pub queue_count: std::option::Option<i32>,

    /// The stack type for this network interface. To assign only IPv4 addresses,
    /// use IPV4_ONLY. To assign both IPv4 and IPv6 addresses, useIPV4_IPV6. If not specified, IPV4_ONLY is used.
    ///
    /// This field can be both set at instance creation and update network
    /// interface operations.
    pub stack_type: std::option::Option<crate::model::network_interface::StackType>,

    /// The URL of the Subnetwork resource for this instance. If the network
    /// resource is inlegacy
    /// mode, do not specify this field. If the network is in auto subnet
    /// mode, specifying the subnetwork is optional. If the network is in custom
    /// subnet mode, specifying the subnetwork is required. If you specify this
    /// field, you can specify the subnetwork as a full or partial URL. For
    /// example, the following are all valid URLs:
    ///
    /// ```norust
    ///   - https://www.googleapis.com/compute/v1/projects/project/regions/region/subnetworks/subnetwork
    /// ```
    ///
    /// - regions/region/subnetworks/subnetwork
    pub subnetwork: std::option::Option<std::string::String>,

    /// VLAN tag of a dynamic network interface, must be  an integer in the range
    /// from 2 to 255 inclusively.
    pub vlan: std::option::Option<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl NetworkInterface {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_configs][crate::model::NetworkInterface::access_configs].
    pub fn set_access_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AccessConfig>,
    {
        use std::iter::Iterator;
        self.access_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [alias_ip_ranges][crate::model::NetworkInterface::alias_ip_ranges].
    pub fn set_alias_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AliasIpRange>,
    {
        use std::iter::Iterator;
        self.alias_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [fingerprint][crate::model::NetworkInterface::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::NetworkInterface::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [internal_ipv_6_prefix_length][crate::model::NetworkInterface::internal_ipv_6_prefix_length].
    pub fn set_internal_ipv_6_prefix_length<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.internal_ipv_6_prefix_length = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [internal_ipv_6_prefix_length][crate::model::NetworkInterface::internal_ipv_6_prefix_length].
    pub fn set_or_clear_internal_ipv_6_prefix_length<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.internal_ipv_6_prefix_length = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ipv_6_access_configs][crate::model::NetworkInterface::ipv_6_access_configs].
    pub fn set_ipv_6_access_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AccessConfig>,
    {
        use std::iter::Iterator;
        self.ipv_6_access_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ipv_6_access_type][crate::model::NetworkInterface::ipv_6_access_type].
    pub fn set_ipv_6_access_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::network_interface::Ipv6AccessType>,
    {
        self.ipv_6_access_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ipv_6_access_type][crate::model::NetworkInterface::ipv_6_access_type].
    pub fn set_or_clear_ipv_6_access_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::network_interface::Ipv6AccessType>,
    {
        self.ipv_6_access_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ipv_6_address][crate::model::NetworkInterface::ipv_6_address].
    pub fn set_ipv_6_address<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ipv_6_address = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ipv_6_address][crate::model::NetworkInterface::ipv_6_address].
    pub fn set_or_clear_ipv_6_address<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ipv_6_address = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::NetworkInterface::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::NetworkInterface::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::NetworkInterface::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::NetworkInterface::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network][crate::model::NetworkInterface::network].
    pub fn set_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network][crate::model::NetworkInterface::network].
    pub fn set_or_clear_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_attachment][crate::model::NetworkInterface::network_attachment].
    pub fn set_network_attachment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network_attachment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_attachment][crate::model::NetworkInterface::network_attachment].
    pub fn set_or_clear_network_attachment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network_attachment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_ip][crate::model::NetworkInterface::network_ip].
    pub fn set_network_ip<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network_ip = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_ip][crate::model::NetworkInterface::network_ip].
    pub fn set_or_clear_network_ip<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network_ip = v.map(|x| x.into());
        self
    }

    /// Sets the value of [nic_type][crate::model::NetworkInterface::nic_type].
    pub fn set_nic_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::network_interface::NicType>,
    {
        self.nic_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nic_type][crate::model::NetworkInterface::nic_type].
    pub fn set_or_clear_nic_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::network_interface::NicType>,
    {
        self.nic_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [parent_nic_name][crate::model::NetworkInterface::parent_nic_name].
    pub fn set_parent_nic_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.parent_nic_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [parent_nic_name][crate::model::NetworkInterface::parent_nic_name].
    pub fn set_or_clear_parent_nic_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.parent_nic_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [queue_count][crate::model::NetworkInterface::queue_count].
    pub fn set_queue_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.queue_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [queue_count][crate::model::NetworkInterface::queue_count].
    pub fn set_or_clear_queue_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.queue_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stack_type][crate::model::NetworkInterface::stack_type].
    pub fn set_stack_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::network_interface::StackType>,
    {
        self.stack_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stack_type][crate::model::NetworkInterface::stack_type].
    pub fn set_or_clear_stack_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::network_interface::StackType>,
    {
        self.stack_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subnetwork][crate::model::NetworkInterface::subnetwork].
    pub fn set_subnetwork<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subnetwork = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subnetwork][crate::model::NetworkInterface::subnetwork].
    pub fn set_or_clear_subnetwork<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subnetwork = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vlan][crate::model::NetworkInterface::vlan].
    pub fn set_vlan<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.vlan = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vlan][crate::model::NetworkInterface::vlan].
    pub fn set_or_clear_vlan<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.vlan = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for NetworkInterface {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.NetworkInterface"
    }
}

/// Defines additional types related to [NetworkInterface].
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
pub mod network_interface {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [ipv6AccessType][google.cloud.compute.v1.NetworkInterface.ipv6AccessType] field.
    ///
    /// [google.cloud.compute.v1.NetworkInterface.ipv6AccessType]: crate::model::network_interface::Ipv6AccessType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Ipv6AccessType {
        /// This network interface can have external IPv6.
        External,
        /// This network interface can have internal IPv6.
        Internal,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Ipv6AccessType::value] or
        /// [Ipv6AccessType::name].
        UnknownValue(ipv_6_access_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod ipv_6_access_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl Ipv6AccessType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::External => std::option::Option::Some(0),
                Self::Internal => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::External => std::option::Option::Some("EXTERNAL"),
                Self::Internal => std::option::Option::Some("INTERNAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for Ipv6AccessType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for Ipv6AccessType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for Ipv6AccessType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::External,
                1 => Self::Internal,
                _ => Self::UnknownValue(ipv_6_access_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for Ipv6AccessType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXTERNAL" => Self::External,
                "INTERNAL" => Self::Internal,
                _ => Self::UnknownValue(ipv_6_access_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for Ipv6AccessType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::External => serializer.serialize_str("EXTERNAL"),
                Self::Internal => serializer.serialize_str("INTERNAL"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Ipv6AccessType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Ipv6AccessType>::new(
                ".google.cloud.compute.v1.NetworkInterface.ipv6AccessType",
            ))
        }
    }

    /// The enumerated type for the [nicType][google.cloud.compute.v1.NetworkInterface.nicType] field.
    ///
    /// [google.cloud.compute.v1.NetworkInterface.nicType]: crate::model::network_interface::NicType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NicType {
        /// GVNIC
        Gvnic,
        /// IDPF
        Idpf,
        /// IRDMA
        Irdma,
        /// MRDMA
        Mrdma,
        /// No type specified.
        UnspecifiedNicType,
        /// VIRTIO
        VirtioNet,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NicType::value] or
        /// [NicType::name].
        UnknownValue(nic_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod nic_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl NicType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Gvnic => std::option::Option::Some(0),
                Self::Idpf => std::option::Option::Some(1),
                Self::Irdma => std::option::Option::Some(2),
                Self::Mrdma => std::option::Option::Some(3),
                Self::UnspecifiedNicType => std::option::Option::Some(4),
                Self::VirtioNet => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Gvnic => std::option::Option::Some("GVNIC"),
                Self::Idpf => std::option::Option::Some("IDPF"),
                Self::Irdma => std::option::Option::Some("IRDMA"),
                Self::Mrdma => std::option::Option::Some("MRDMA"),
                Self::UnspecifiedNicType => std::option::Option::Some("UNSPECIFIED_NIC_TYPE"),
                Self::VirtioNet => std::option::Option::Some("VIRTIO_NET"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for NicType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for NicType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for NicType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Gvnic,
                1 => Self::Idpf,
                2 => Self::Irdma,
                3 => Self::Mrdma,
                4 => Self::UnspecifiedNicType,
                5 => Self::VirtioNet,
                _ => Self::UnknownValue(nic_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for NicType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "GVNIC" => Self::Gvnic,
                "IDPF" => Self::Idpf,
                "IRDMA" => Self::Irdma,
                "MRDMA" => Self::Mrdma,
                "UNSPECIFIED_NIC_TYPE" => Self::UnspecifiedNicType,
                "VIRTIO_NET" => Self::VirtioNet,
                _ => Self::UnknownValue(nic_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for NicType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Gvnic => serializer.serialize_str("GVNIC"),
                Self::Idpf => serializer.serialize_str("IDPF"),
                Self::Irdma => serializer.serialize_str("IRDMA"),
                Self::Mrdma => serializer.serialize_str("MRDMA"),
                Self::UnspecifiedNicType => serializer.serialize_str("UNSPECIFIED_NIC_TYPE"),
                Self::VirtioNet => serializer.serialize_str("VIRTIO_NET"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for NicType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NicType>::new(
                ".google.cloud.compute.v1.NetworkInterface.nicType",
            ))
        }
    }

    /// The enumerated type for the [stackType][google.cloud.compute.v1.NetworkInterface.stackType] field.
    ///
    /// [google.cloud.compute.v1.NetworkInterface.stackType]: crate::model::network_interface::StackType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StackType {
        /// The network interface can have both IPv4 and IPv6 addresses.
        Ipv4Ipv6,
        /// The network interface will only be assigned IPv4 addresses.
        Ipv4Only,
        /// The network interface will only be assigned IPv6 addresses.
        Ipv6Only,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StackType::value] or
        /// [StackType::name].
        UnknownValue(stack_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod stack_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl StackType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Ipv4Ipv6 => std::option::Option::Some(0),
                Self::Ipv4Only => std::option::Option::Some(1),
                Self::Ipv6Only => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Ipv4Ipv6 => std::option::Option::Some("IPV4_IPV6"),
                Self::Ipv4Only => std::option::Option::Some("IPV4_ONLY"),
                Self::Ipv6Only => std::option::Option::Some("IPV6_ONLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for StackType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for StackType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for StackType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Ipv4Ipv6,
                1 => Self::Ipv4Only,
                2 => Self::Ipv6Only,
                _ => Self::UnknownValue(stack_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for StackType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IPV4_IPV6" => Self::Ipv4Ipv6,
                "IPV4_ONLY" => Self::Ipv4Only,
                "IPV6_ONLY" => Self::Ipv6Only,
                _ => Self::UnknownValue(stack_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for StackType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Ipv4Ipv6 => serializer.serialize_str("IPV4_IPV6"),
                Self::Ipv4Only => serializer.serialize_str("IPV4_ONLY"),
                Self::Ipv6Only => serializer.serialize_str("IPV6_ONLY"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for StackType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StackType>::new(
                ".google.cloud.compute.v1.NetworkInterface.stackType",
            ))
        }
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkPerformanceConfig {
    pub total_egress_bandwidth_tier:
        std::option::Option<crate::model::network_performance_config::TotalEgressBandwidthTier>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl NetworkPerformanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_egress_bandwidth_tier][crate::model::NetworkPerformanceConfig::total_egress_bandwidth_tier].
    pub fn set_total_egress_bandwidth_tier<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::network_performance_config::TotalEgressBandwidthTier>,
    {
        self.total_egress_bandwidth_tier = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [total_egress_bandwidth_tier][crate::model::NetworkPerformanceConfig::total_egress_bandwidth_tier].
    pub fn set_or_clear_total_egress_bandwidth_tier<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::network_performance_config::TotalEgressBandwidthTier>,
    {
        self.total_egress_bandwidth_tier = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for NetworkPerformanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.NetworkPerformanceConfig"
    }
}

/// Defines additional types related to [NetworkPerformanceConfig].
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
pub mod network_performance_config {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [totalEgressBandwidthTier][google.cloud.compute.v1.NetworkPerformanceConfig.totalEgressBandwidthTier] field.
    ///
    /// [google.cloud.compute.v1.NetworkPerformanceConfig.totalEgressBandwidthTier]: crate::model::network_performance_config::TotalEgressBandwidthTier
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TotalEgressBandwidthTier {
        Default,
        Tier1,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TotalEgressBandwidthTier::value] or
        /// [TotalEgressBandwidthTier::name].
        UnknownValue(total_egress_bandwidth_tier::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod total_egress_bandwidth_tier {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl TotalEgressBandwidthTier {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Default => std::option::Option::Some(0),
                Self::Tier1 => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Default => std::option::Option::Some("DEFAULT"),
                Self::Tier1 => std::option::Option::Some("TIER_1"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for TotalEgressBandwidthTier {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for TotalEgressBandwidthTier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for TotalEgressBandwidthTier {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Default,
                1 => Self::Tier1,
                _ => Self::UnknownValue(total_egress_bandwidth_tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for TotalEgressBandwidthTier {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DEFAULT" => Self::Default,
                "TIER_1" => Self::Tier1,
                _ => Self::UnknownValue(total_egress_bandwidth_tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for TotalEgressBandwidthTier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Default => serializer.serialize_str("DEFAULT"),
                Self::Tier1 => serializer.serialize_str("TIER_1"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for TotalEgressBandwidthTier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<TotalEgressBandwidthTier>::new(
                    ".google.cloud.compute.v1.NetworkPerformanceConfig.totalEgressBandwidthTier",
                ),
            )
        }
    }
}

/// Represents an Operation resource.
///
/// Google Compute Engine has three Operation resources:
///
/// * [Global](/compute/docs/reference/rest/v1/globalOperations)
/// * [Regional](/compute/docs/reference/rest/v1/regionOperations)
/// * [Zonal](/compute/docs/reference/rest/v1/zoneOperations)
///
/// You can use an operation resource to manage asynchronous API requests.
/// For more information, readHandling
/// API responses.
///
/// Operations can be global, regional or zonal.
///
/// - For global operations, use the `globalOperations`
///   resource.
/// - For regional operations, use the
///   `regionOperations` resource.
/// - For zonal operations, use
///   the `zoneOperations` resource.
///
/// For more information, read
/// Global, Regional, and Zonal Resources.
///
/// Note that completed Operation resources have a limited
/// retention period.
#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Operation {
    /// [Output Only] The value of `requestId` if you provided it in the request.
    /// Not present otherwise.
    pub client_operation_id: std::option::Option<std::string::String>,

    /// [Deprecated] This field is deprecated.
    pub creation_timestamp: std::option::Option<std::string::String>,

    /// [Output Only] A textual description of the operation, which is
    /// set when the operation is created.
    pub description: std::option::Option<std::string::String>,

    /// [Output Only] The time that this operation was completed. This value is inRFC3339
    /// text format.
    pub end_time: std::option::Option<std::string::String>,

    /// [Output Only] If errors are generated during processing of the operation,
    /// this field will be populated.
    pub error: std::option::Option<crate::model::operation::Error>,

    /// [Output Only] If the operation fails, this field contains the HTTP error
    /// message that was returned, such as `NOT FOUND`.
    pub http_error_message: std::option::Option<std::string::String>,

    /// [Output Only] If the operation fails, this field contains the HTTP error
    /// status code that was returned. For example, a `404` means the
    /// resource was not found.
    pub http_error_status_code: std::option::Option<i32>,

    /// [Output Only] The unique identifier for the operation. This identifier is
    /// defined by the server.
    pub id: std::option::Option<u64>,

    /// [Output Only] The time that this operation was requested.
    /// This value is inRFC3339
    /// text format.
    pub insert_time: std::option::Option<std::string::String>,

    pub instances_bulk_insert_operation_metadata:
        std::option::Option<crate::model::InstancesBulkInsertOperationMetadata>,

    /// [Output Only] Type of the resource. Always `compute#operation` for
    /// Operation resources.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] Name of the operation.
    pub name: std::option::Option<std::string::String>,

    /// [Output Only] An ID that represents a group of operations, such as when a
    /// group of operations results from a `bulkInsert` API request.
    pub operation_group_id: std::option::Option<std::string::String>,

    /// [Output Only] The type of operation, such as `insert`,
    /// `update`, or `delete`, and so on.
    pub operation_type: std::option::Option<std::string::String>,

    /// [Output Only] An optional progress indicator that ranges from 0 to 100.
    /// There is no requirement that this be linear or support any granularity of
    /// operations. This should not be used to guess when the operation will be
    /// complete. This number should monotonically increase as the operation
    /// progresses.
    pub progress: std::option::Option<i32>,

    /// [Output Only] The URL of the region where the operation resides. Only
    /// applicable when performing regional operations.
    pub region: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for the resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] If the operation is for projects.setCommonInstanceMetadata,
    /// this field will contain information on all underlying zonal actions and
    /// their state.
    pub set_common_instance_metadata_operation_metadata:
        std::option::Option<crate::model::SetCommonInstanceMetadataOperationMetadata>,

    /// [Output Only] The time that this operation was started by the server.
    /// This value is inRFC3339
    /// text format.
    pub start_time: std::option::Option<std::string::String>,

    /// [Output Only] The status of the operation, which can be one of the
    /// following:
    /// `PENDING`, `RUNNING`, or `DONE`.
    pub status: std::option::Option<crate::model::operation::Status>,

    /// [Output Only] An optional textual description of the current status of the
    /// operation.
    pub status_message: std::option::Option<std::string::String>,

    /// [Output Only] The unique target ID, which identifies a specific incarnation
    /// of the target resource.
    pub target_id: std::option::Option<u64>,

    /// [Output Only] The URL of the resource that the operation modifies. For
    /// operations related to creating a snapshot, this points to the disk
    /// that the snapshot was created from.
    pub target_link: std::option::Option<std::string::String>,

    /// [Output Only] User who requested the operation, for example:
    /// `user@example.com` or
    /// `alice_smith_identifier (global/workforcePools/example-com-us-employees)`.
    pub user: std::option::Option<std::string::String>,

    /// [Output Only] If warning messages are generated during processing of the
    /// operation, this field will be populated.
    pub warnings: std::vec::Vec<crate::model::operation::Warnings>,

    /// [Output Only] The URL of the zone where the operation resides. Only
    /// applicable when performing per-zone operations.
    pub zone: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl Operation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [client_operation_id][crate::model::Operation::client_operation_id].
    pub fn set_client_operation_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.client_operation_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_operation_id][crate::model::Operation::client_operation_id].
    pub fn set_or_clear_client_operation_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.client_operation_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creation_timestamp][crate::model::Operation::creation_timestamp].
    pub fn set_creation_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_timestamp][crate::model::Operation::creation_timestamp].
    pub fn set_or_clear_creation_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::Operation::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::Operation::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::Operation::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::Operation::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::Operation::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::operation::Error>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::Operation::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::operation::Error>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [http_error_message][crate::model::Operation::http_error_message].
    pub fn set_http_error_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.http_error_message = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [http_error_message][crate::model::Operation::http_error_message].
    pub fn set_or_clear_http_error_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.http_error_message = v.map(|x| x.into());
        self
    }

    /// Sets the value of [http_error_status_code][crate::model::Operation::http_error_status_code].
    pub fn set_http_error_status_code<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.http_error_status_code = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [http_error_status_code][crate::model::Operation::http_error_status_code].
    pub fn set_or_clear_http_error_status_code<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.http_error_status_code = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::Operation::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::Operation::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [insert_time][crate::model::Operation::insert_time].
    pub fn set_insert_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.insert_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [insert_time][crate::model::Operation::insert_time].
    pub fn set_or_clear_insert_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.insert_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instances_bulk_insert_operation_metadata][crate::model::Operation::instances_bulk_insert_operation_metadata].
    pub fn set_instances_bulk_insert_operation_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancesBulkInsertOperationMetadata>,
    {
        self.instances_bulk_insert_operation_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instances_bulk_insert_operation_metadata][crate::model::Operation::instances_bulk_insert_operation_metadata].
    pub fn set_or_clear_instances_bulk_insert_operation_metadata<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::InstancesBulkInsertOperationMetadata>,
    {
        self.instances_bulk_insert_operation_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::Operation::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::Operation::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::Operation::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::Operation::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operation_group_id][crate::model::Operation::operation_group_id].
    pub fn set_operation_group_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.operation_group_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [operation_group_id][crate::model::Operation::operation_group_id].
    pub fn set_or_clear_operation_group_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.operation_group_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operation_type][crate::model::Operation::operation_type].
    pub fn set_operation_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.operation_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [operation_type][crate::model::Operation::operation_type].
    pub fn set_or_clear_operation_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.operation_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress][crate::model::Operation::progress].
    pub fn set_progress<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.progress = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress][crate::model::Operation::progress].
    pub fn set_or_clear_progress<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.progress = v.map(|x| x.into());
        self
    }

    /// Sets the value of [region][crate::model::Operation::region].
    pub fn set_region<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.region = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [region][crate::model::Operation::region].
    pub fn set_or_clear_region<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.region = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::Operation::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::Operation::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [set_common_instance_metadata_operation_metadata][crate::model::Operation::set_common_instance_metadata_operation_metadata].
    pub fn set_set_common_instance_metadata_operation_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SetCommonInstanceMetadataOperationMetadata>,
    {
        self.set_common_instance_metadata_operation_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [set_common_instance_metadata_operation_metadata][crate::model::Operation::set_common_instance_metadata_operation_metadata].
    pub fn set_or_clear_set_common_instance_metadata_operation_metadata<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::SetCommonInstanceMetadataOperationMetadata>,
    {
        self.set_common_instance_metadata_operation_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::Operation::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Operation::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::Operation::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::operation::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::Operation::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::operation::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status_message][crate::model::Operation::status_message].
    pub fn set_status_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.status_message = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status_message][crate::model::Operation::status_message].
    pub fn set_or_clear_status_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.status_message = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_id][crate::model::Operation::target_id].
    pub fn set_target_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.target_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_id][crate::model::Operation::target_id].
    pub fn set_or_clear_target_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.target_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_link][crate::model::Operation::target_link].
    pub fn set_target_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.target_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_link][crate::model::Operation::target_link].
    pub fn set_or_clear_target_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.target_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user][crate::model::Operation::user].
    pub fn set_user<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.user = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user][crate::model::Operation::user].
    pub fn set_or_clear_user<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.user = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warnings][crate::model::Operation::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::operation::Warnings>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [zone][crate::model::Operation::zone].
    pub fn set_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [zone][crate::model::Operation::zone].
    pub fn set_or_clear_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl wkt::message::Message for Operation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Operation"
    }
}

/// Defines additional types related to [Operation].
#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
pub mod operation {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [error][google.cloud.compute.v1.Operation.error] field.
    ///
    /// [google.cloud.compute.v1.Operation.error]: crate::model::operation::Error
    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Error {
        /// [Output Only] The array of errors encountered while processing this
        /// operation.
        pub errors: std::vec::Vec<crate::model::operation::error::Errors>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl Error {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [errors][crate::model::operation::Error::errors].
        pub fn set_errors<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::operation::error::Errors>,
        {
            use std::iter::Iterator;
            self.errors = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl wkt::message::Message for Error {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.Operation.error"
        }
    }

    /// Defines additional types related to [Error].
    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    pub mod error {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [errors][google.cloud.compute.v1.Operation.error.errors] field.
        ///
        /// [google.cloud.compute.v1.Operation.error.errors]: crate::model::operation::error::Errors
        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "images",
            feature = "instance-group-manager-resize-requests",
            feature = "instance-group-managers",
            feature = "instance-groups",
            feature = "instances",
            feature = "region-instance-group-managers",
            feature = "region-instance-groups",
            feature = "region-instance-templates",
            feature = "region-instances",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Errors {
            /// [Output Only] The error type identifier for this error.
            pub code: std::option::Option<std::string::String>,

            /// [Output Only] An optional list of messages that contain the error
            /// details. There is a set of defined message types to use for providing
            /// details.The syntax depends on the error code. For example,
            /// QuotaExceededInfo will have details when the error code is
            /// QUOTA_EXCEEDED.
            pub error_details: std::vec::Vec<crate::model::operation::error::errors::ErrorDetails>,

            /// [Output Only] Indicates the field in the request that caused the error.
            /// This property is optional.
            pub location: std::option::Option<std::string::String>,

            /// [Output Only] An optional, human-readable error message.
            pub message: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "images",
            feature = "instance-group-manager-resize-requests",
            feature = "instance-group-managers",
            feature = "instance-groups",
            feature = "instances",
            feature = "region-instance-group-managers",
            feature = "region-instance-groups",
            feature = "region-instance-templates",
            feature = "region-instances",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl Errors {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [code][crate::model::operation::error::Errors::code].
            pub fn set_code<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.code = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [code][crate::model::operation::error::Errors::code].
            pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.code = v.map(|x| x.into());
                self
            }

            /// Sets the value of [error_details][crate::model::operation::error::Errors::error_details].
            pub fn set_error_details<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::operation::error::errors::ErrorDetails>,
            {
                use std::iter::Iterator;
                self.error_details = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [location][crate::model::operation::error::Errors::location].
            pub fn set_location<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.location = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [location][crate::model::operation::error::Errors::location].
            pub fn set_or_clear_location<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.location = v.map(|x| x.into());
                self
            }

            /// Sets the value of [message][crate::model::operation::error::Errors::message].
            pub fn set_message<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.message = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [message][crate::model::operation::error::Errors::message].
            pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.message = v.map(|x| x.into());
                self
            }
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "images",
            feature = "instance-group-manager-resize-requests",
            feature = "instance-group-managers",
            feature = "instance-groups",
            feature = "instances",
            feature = "region-instance-group-managers",
            feature = "region-instance-groups",
            feature = "region-instance-templates",
            feature = "region-instances",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl wkt::message::Message for Errors {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.Operation.error.errors"
            }
        }

        /// Defines additional types related to [Errors].
        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "images",
            feature = "instance-group-manager-resize-requests",
            feature = "instance-group-managers",
            feature = "instance-groups",
            feature = "instances",
            feature = "region-instance-group-managers",
            feature = "region-instance-groups",
            feature = "region-instance-templates",
            feature = "region-instances",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        pub mod errors {
            #[allow(unused_imports)]
            use super::*;

            /// The message type for the [errorDetails][google.cloud.compute.v1.Operation.error.errors.errorDetails] field.
            ///
            /// [google.cloud.compute.v1.Operation.error.errors.errorDetails]: crate::model::operation::error::errors::ErrorDetails
            #[cfg(any(
                feature = "global-operations",
                feature = "global-organization-operations",
                feature = "images",
                feature = "instance-group-manager-resize-requests",
                feature = "instance-group-managers",
                feature = "instance-groups",
                feature = "instances",
                feature = "region-instance-group-managers",
                feature = "region-instance-groups",
                feature = "region-instance-templates",
                feature = "region-instances",
                feature = "region-operations",
                feature = "zone-operations",
            ))]
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ErrorDetails {
                pub error_info: std::option::Option<crate::model::ErrorInfo>,

                pub help: std::option::Option<crate::model::Help>,

                pub localized_message: std::option::Option<crate::model::LocalizedMessage>,

                pub quota_info: std::option::Option<crate::model::QuotaExceededInfo>,

                pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(any(
                feature = "global-operations",
                feature = "global-organization-operations",
                feature = "images",
                feature = "instance-group-manager-resize-requests",
                feature = "instance-group-managers",
                feature = "instance-groups",
                feature = "instances",
                feature = "region-instance-group-managers",
                feature = "region-instance-groups",
                feature = "region-instance-templates",
                feature = "region-instances",
                feature = "region-operations",
                feature = "zone-operations",
            ))]
            impl ErrorDetails {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [error_info][crate::model::operation::error::errors::ErrorDetails::error_info].
                pub fn set_error_info<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::ErrorInfo>,
                {
                    self.error_info = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [error_info][crate::model::operation::error::errors::ErrorDetails::error_info].
                pub fn set_or_clear_error_info<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::ErrorInfo>,
                {
                    self.error_info = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [help][crate::model::operation::error::errors::ErrorDetails::help].
                pub fn set_help<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::Help>,
                {
                    self.help = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [help][crate::model::operation::error::errors::ErrorDetails::help].
                pub fn set_or_clear_help<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::Help>,
                {
                    self.help = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [localized_message][crate::model::operation::error::errors::ErrorDetails::localized_message].
                pub fn set_localized_message<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::LocalizedMessage>,
                {
                    self.localized_message = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [localized_message][crate::model::operation::error::errors::ErrorDetails::localized_message].
                pub fn set_or_clear_localized_message<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<crate::model::LocalizedMessage>,
                {
                    self.localized_message = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [quota_info][crate::model::operation::error::errors::ErrorDetails::quota_info].
                pub fn set_quota_info<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::QuotaExceededInfo>,
                {
                    self.quota_info = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [quota_info][crate::model::operation::error::errors::ErrorDetails::quota_info].
                pub fn set_or_clear_quota_info<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::QuotaExceededInfo>,
                {
                    self.quota_info = v.map(|x| x.into());
                    self
                }
            }

            #[cfg(any(
                feature = "global-operations",
                feature = "global-organization-operations",
                feature = "images",
                feature = "instance-group-manager-resize-requests",
                feature = "instance-group-managers",
                feature = "instance-groups",
                feature = "instances",
                feature = "region-instance-group-managers",
                feature = "region-instance-groups",
                feature = "region-instance-templates",
                feature = "region-instances",
                feature = "region-operations",
                feature = "zone-operations",
            ))]
            impl wkt::message::Message for ErrorDetails {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.compute.v1.Operation.error.errors.errorDetails"
                }
            }
        }
    }

    /// The message type for the [warnings][google.cloud.compute.v1.Operation.warnings] field.
    ///
    /// [google.cloud.compute.v1.Operation.warnings]: crate::model::operation::Warnings
    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warnings {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::operation::warnings::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::operation::warnings::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl Warnings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::operation::Warnings::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::operation::warnings::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::operation::Warnings::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::operation::warnings::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::operation::Warnings::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::operation::warnings::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::operation::Warnings::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::operation::Warnings::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl wkt::message::Message for Warnings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.Operation.warnings"
        }
    }

    /// Defines additional types related to [Warnings].
    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    pub mod warnings {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.Operation.warnings.data] field.
        ///
        /// [google.cloud.compute.v1.Operation.warnings.data]: crate::model::operation::warnings::Data
        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "images",
            feature = "instance-group-manager-resize-requests",
            feature = "instance-group-managers",
            feature = "instance-groups",
            feature = "instances",
            feature = "region-instance-group-managers",
            feature = "region-instance-groups",
            feature = "region-instance-templates",
            feature = "region-instances",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "images",
            feature = "instance-group-manager-resize-requests",
            feature = "instance-group-managers",
            feature = "instance-groups",
            feature = "instances",
            feature = "region-instance-group-managers",
            feature = "region-instance-groups",
            feature = "region-instance-templates",
            feature = "region-instances",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::operation::warnings::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::operation::warnings::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::operation::warnings::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::operation::warnings::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "images",
            feature = "instance-group-manager-resize-requests",
            feature = "instance-group-managers",
            feature = "instance-groups",
            feature = "instances",
            feature = "region-instance-group-managers",
            feature = "region-instance-groups",
            feature = "region-instance-templates",
            feature = "region-instances",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.Operation.warnings.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.Operation.warnings.code] field.
        ///
        /// [google.cloud.compute.v1.Operation.warnings.code]: crate::model::operation::warnings::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "images",
            feature = "instance-group-manager-resize-requests",
            feature = "instance-group-managers",
            feature = "instance-groups",
            feature = "instances",
            feature = "region-instance-group-managers",
            feature = "region-instance-groups",
            feature = "region-instance-templates",
            feature = "region-instances",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "images",
            feature = "instance-group-manager-resize-requests",
            feature = "instance-group-managers",
            feature = "instance-groups",
            feature = "instances",
            feature = "region-instance-group-managers",
            feature = "region-instance-groups",
            feature = "region-instance-templates",
            feature = "region-instances",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "images",
            feature = "instance-group-manager-resize-requests",
            feature = "instance-group-managers",
            feature = "instance-groups",
            feature = "instances",
            feature = "region-instance-group-managers",
            feature = "region-instance-groups",
            feature = "region-instance-templates",
            feature = "region-instances",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "images",
            feature = "instance-group-manager-resize-requests",
            feature = "instance-group-managers",
            feature = "instance-groups",
            feature = "instances",
            feature = "region-instance-group-managers",
            feature = "region-instance-groups",
            feature = "region-instance-templates",
            feature = "region-instances",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "images",
            feature = "instance-group-manager-resize-requests",
            feature = "instance-group-managers",
            feature = "instance-groups",
            feature = "instances",
            feature = "region-instance-group-managers",
            feature = "region-instance-groups",
            feature = "region-instance-templates",
            feature = "region-instances",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "images",
            feature = "instance-group-manager-resize-requests",
            feature = "instance-group-managers",
            feature = "instance-groups",
            feature = "instances",
            feature = "region-instance-group-managers",
            feature = "region-instance-groups",
            feature = "region-instance-templates",
            feature = "region-instances",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "images",
            feature = "instance-group-manager-resize-requests",
            feature = "instance-group-managers",
            feature = "instance-groups",
            feature = "instances",
            feature = "region-instance-group-managers",
            feature = "region-instance-groups",
            feature = "region-instance-templates",
            feature = "region-instances",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "images",
            feature = "instance-group-manager-resize-requests",
            feature = "instance-group-managers",
            feature = "instance-groups",
            feature = "instances",
            feature = "region-instance-group-managers",
            feature = "region-instance-groups",
            feature = "region-instance-templates",
            feature = "region-instances",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "images",
            feature = "instance-group-manager-resize-requests",
            feature = "instance-group-managers",
            feature = "instance-groups",
            feature = "instances",
            feature = "region-instance-group-managers",
            feature = "region-instance-groups",
            feature = "region-instance-templates",
            feature = "region-instances",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.Operation.warnings.code",
                ))
            }
        }
    }

    /// The enumerated type for the [status][google.cloud.compute.v1.Operation.status] field.
    ///
    /// [google.cloud.compute.v1.Operation.status]: crate::model::operation::Status
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        Done,
        Pending,
        Running,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Done => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Done => std::option::Option::Some("DONE"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Done,
                1 => Self::Pending,
                2 => Self::Running,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DONE" => Self::Done,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Done => serializer.serialize_str("DONE"),
                Self::Pending => serializer.serialize_str("PENDING"),
                Self::Running => serializer.serialize_str("RUNNING"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.cloud.compute.v1.Operation.status",
            ))
        }
    }
}

#[cfg(feature = "global-operations")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationAggregatedList {
    /// [Output Only] The unique identifier for the resource. This identifier is
    /// defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// [Output Only] A map of scoped operation lists.
    pub items: std::collections::HashMap<std::string::String, crate::model::OperationsScopedList>,

    /// [Output Only] Type of resource. Always `compute#operationAggregatedList`
    /// for aggregated lists of operations.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger than
    /// `maxResults`, use the `nextPageToken` as a value for
    /// the query parameter `pageToken` in the next list request.
    /// Subsequent list requests will have their own `nextPageToken` to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Unreachable resources.
    pub unreachables: std::vec::Vec<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::operation_aggregated_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "global-operations")]
impl OperationAggregatedList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::OperationAggregatedList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::OperationAggregatedList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::OperationAggregatedList::items].
    pub fn set_items<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::OperationsScopedList>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [kind][crate::model::OperationAggregatedList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::OperationAggregatedList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::OperationAggregatedList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::OperationAggregatedList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::OperationAggregatedList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::OperationAggregatedList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [unreachables][crate::model::OperationAggregatedList::unreachables].
    pub fn set_unreachables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warning][crate::model::OperationAggregatedList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::operation_aggregated_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::OperationAggregatedList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::operation_aggregated_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "global-operations")]
impl wkt::message::Message for OperationAggregatedList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.OperationAggregatedList"
    }
}

#[cfg(feature = "global-operations")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for OperationAggregatedList {
    type PageItem = (std::string::String, crate::model::OperationsScopedList);

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        use std::iter::{IntoIterator, Iterator};
        self.items.into_iter().collect()
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [OperationAggregatedList].
#[cfg(feature = "global-operations")]
pub mod operation_aggregated_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.OperationAggregatedList.warning] field.
    ///
    /// [google.cloud.compute.v1.OperationAggregatedList.warning]: crate::model::operation_aggregated_list::Warning
    #[cfg(feature = "global-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::operation_aggregated_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::operation_aggregated_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "global-operations")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::operation_aggregated_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::operation_aggregated_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::operation_aggregated_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::operation_aggregated_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::operation_aggregated_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::operation_aggregated_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::operation_aggregated_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::operation_aggregated_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "global-operations")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.OperationAggregatedList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "global-operations")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.OperationAggregatedList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.OperationAggregatedList.warning.data]: crate::model::operation_aggregated_list::warning::Data
        #[cfg(feature = "global-operations")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "global-operations")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::operation_aggregated_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::operation_aggregated_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::operation_aggregated_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::operation_aggregated_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "global-operations")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.OperationAggregatedList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.OperationAggregatedList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.OperationAggregatedList.warning.code]: crate::model::operation_aggregated_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "global-operations")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "global-operations")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "global-operations")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "global-operations")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "global-operations")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "global-operations")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "global-operations")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "global-operations")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "global-operations")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.OperationAggregatedList.warning.code",
                ))
            }
        }
    }
}

/// Contains a list of Operation resources.
#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "region-operations",
    feature = "zone-operations",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationList {
    /// [Output Only] The unique identifier for the resource. This identifier is
    /// defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// [Output Only] A list of Operation resources.
    pub items: std::vec::Vec<crate::model::Operation>,

    /// [Output Only] Type of resource. Always `compute#operations` for Operations
    /// resource.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger than
    /// `maxResults`, use the `nextPageToken` as a value for
    /// the query parameter `pageToken` in the next list request.
    /// Subsequent list requests will have their own `nextPageToken` to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::operation_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl OperationList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::OperationList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::OperationList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::OperationList::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Operation>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::OperationList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::OperationList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::OperationList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::OperationList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::OperationList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::OperationList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::OperationList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::operation_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::OperationList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::operation_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl wkt::message::Message for OperationList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.OperationList"
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "region-operations",
    feature = "zone-operations",
))]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for OperationList {
    type PageItem = crate::model::Operation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [OperationList].
#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "region-operations",
    feature = "zone-operations",
))]
pub mod operation_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.OperationList.warning] field.
    ///
    /// [google.cloud.compute.v1.OperationList.warning]: crate::model::operation_list::Warning
    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::operation_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::operation_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::operation_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::operation_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::operation_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::operation_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::operation_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::operation_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::operation_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::operation_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.OperationList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.OperationList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.OperationList.warning.data]: crate::model::operation_list::warning::Data
        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::operation_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::operation_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::operation_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::operation_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.OperationList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.OperationList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.OperationList.warning.code]: crate::model::operation_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(any(
            feature = "global-operations",
            feature = "global-organization-operations",
            feature = "region-operations",
            feature = "zone-operations",
        ))]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.OperationList.warning.code",
                ))
            }
        }
    }
}

#[cfg(feature = "global-operations")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationsScopedList {
    /// [Output Only] A list of operations contained in this scope.
    pub operations: std::vec::Vec<crate::model::Operation>,

    /// [Output Only] Informational warning which replaces the list of operations
    /// when the list is empty.
    pub warning: std::option::Option<crate::model::operations_scoped_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "global-operations")]
impl OperationsScopedList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [operations][crate::model::OperationsScopedList::operations].
    pub fn set_operations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Operation>,
    {
        use std::iter::Iterator;
        self.operations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warning][crate::model::OperationsScopedList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::operations_scoped_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::OperationsScopedList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::operations_scoped_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "global-operations")]
impl wkt::message::Message for OperationsScopedList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.OperationsScopedList"
    }
}

/// Defines additional types related to [OperationsScopedList].
#[cfg(feature = "global-operations")]
pub mod operations_scoped_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.OperationsScopedList.warning] field.
    ///
    /// [google.cloud.compute.v1.OperationsScopedList.warning]: crate::model::operations_scoped_list::Warning
    #[cfg(feature = "global-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::operations_scoped_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::operations_scoped_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "global-operations")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::operations_scoped_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::operations_scoped_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::operations_scoped_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::operations_scoped_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::operations_scoped_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::operations_scoped_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::operations_scoped_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::operations_scoped_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "global-operations")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.OperationsScopedList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "global-operations")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.OperationsScopedList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.OperationsScopedList.warning.data]: crate::model::operations_scoped_list::warning::Data
        #[cfg(feature = "global-operations")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "global-operations")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::operations_scoped_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::operations_scoped_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::operations_scoped_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::operations_scoped_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "global-operations")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.OperationsScopedList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.OperationsScopedList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.OperationsScopedList.warning.code]: crate::model::operations_scoped_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "global-operations")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "global-operations")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "global-operations")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "global-operations")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "global-operations")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "global-operations")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "global-operations")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "global-operations")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "global-operations")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.OperationsScopedList.warning.code",
                ))
            }
        }
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PerInstanceConfig {
    /// Fingerprint of this per-instance config. This field can be used in
    /// optimistic locking. It is ignored when inserting a per-instance
    /// config. An up-to-date fingerprint must be provided in order to update an
    /// existing per-instance configuration or the field needs to be unset.
    pub fingerprint: std::option::Option<::bytes::Bytes>,

    /// The name of a per-instance configuration and its corresponding instance.
    /// Serves as a merge key during UpdatePerInstanceConfigs
    /// operations, that is, if a per-instance configuration with the same name
    /// exists then it will be updated, otherwise a new one will be created for the
    /// VM instance with the same name. An attempt to create a per-instance
    /// configuration for a VM instance that either doesn't exist or is not part
    /// of the group will result in an error.
    pub name: std::option::Option<std::string::String>,

    /// The intended preserved state for the given instance. Does not contain
    /// preserved state generated from a stateful policy.
    pub preserved_state: std::option::Option<crate::model::PreservedState>,

    /// The status of applying this per-instance configuration on the corresponding
    /// managed instance.
    pub status: std::option::Option<crate::model::per_instance_config::Status>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl PerInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fingerprint][crate::model::PerInstanceConfig::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::PerInstanceConfig::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::PerInstanceConfig::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::PerInstanceConfig::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [preserved_state][crate::model::PerInstanceConfig::preserved_state].
    pub fn set_preserved_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PreservedState>,
    {
        self.preserved_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [preserved_state][crate::model::PerInstanceConfig::preserved_state].
    pub fn set_or_clear_preserved_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PreservedState>,
    {
        self.preserved_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::PerInstanceConfig::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::per_instance_config::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::PerInstanceConfig::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::per_instance_config::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for PerInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.PerInstanceConfig"
    }
}

/// Defines additional types related to [PerInstanceConfig].
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
pub mod per_instance_config {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [status][google.cloud.compute.v1.PerInstanceConfig.status] field.
    ///
    /// [google.cloud.compute.v1.PerInstanceConfig.status]: crate::model::per_instance_config::Status
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// The per-instance configuration is being applied to the instance, but is
        /// not yet effective, possibly waiting for the instance to, for example,REFRESH.
        Applying,
        /// The per-instance configuration deletion is being applied on the instance,
        /// possibly waiting for the instance to, for example, REFRESH.
        Deleting,
        /// The per-instance configuration is effective on the instance, meaning that
        /// all disks, ips and metadata specified in this configuration are attached
        /// or set on the instance.
        Effective,
        /// *[Default]* The default status, when no per-instance configuration
        /// exists.
        None,
        /// The per-instance configuration is set on an instance but not been applied
        /// yet.
        Unapplied,
        /// The per-instance configuration has been deleted, but the deletion is not
        /// yet applied.
        UnappliedDeletion,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Applying => std::option::Option::Some(0),
                Self::Deleting => std::option::Option::Some(1),
                Self::Effective => std::option::Option::Some(2),
                Self::None => std::option::Option::Some(3),
                Self::Unapplied => std::option::Option::Some(4),
                Self::UnappliedDeletion => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Applying => std::option::Option::Some("APPLYING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Effective => std::option::Option::Some("EFFECTIVE"),
                Self::None => std::option::Option::Some("NONE"),
                Self::Unapplied => std::option::Option::Some("UNAPPLIED"),
                Self::UnappliedDeletion => std::option::Option::Some("UNAPPLIED_DELETION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Applying,
                1 => Self::Deleting,
                2 => Self::Effective,
                3 => Self::None,
                4 => Self::Unapplied,
                5 => Self::UnappliedDeletion,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "APPLYING" => Self::Applying,
                "DELETING" => Self::Deleting,
                "EFFECTIVE" => Self::Effective,
                "NONE" => Self::None,
                "UNAPPLIED" => Self::Unapplied,
                "UNAPPLIED_DELETION" => Self::UnappliedDeletion,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Applying => serializer.serialize_str("APPLYING"),
                Self::Deleting => serializer.serialize_str("DELETING"),
                Self::Effective => serializer.serialize_str("EFFECTIVE"),
                Self::None => serializer.serialize_str("NONE"),
                Self::Unapplied => serializer.serialize_str("UNAPPLIED"),
                Self::UnappliedDeletion => serializer.serialize_str("UNAPPLIED_DELETION"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.cloud.compute.v1.PerInstanceConfig.status",
            ))
        }
    }
}

/// An Identity and Access Management (IAM) policy, which specifies access
/// controls for Google Cloud resources.
///
/// A `Policy` is a collection of `bindings`. A `binding` binds one or more
/// `members`, or principals, to a single `role`. Principals can be user
/// accounts, service accounts, Google groups, and domains (such as G Suite). A
/// `role` is a named list of permissions; each `role` can be an IAM predefined
/// role or a user-created custom role.
///
/// For some types of Google Cloud resources, a `binding` can also specify a
/// `condition`, which is a logical expression that allows access to a resource
/// only if the expression evaluates to `true`. A condition can add constraints
/// based on attributes of the request, the resource, or both. To learn which
/// resources support conditions in their IAM policies, see the
/// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
///
/// **JSON example:**
///
/// ```norust
///     {
///       "bindings": [
///         {
///           "role": "roles/resourcemanager.organizationAdmin",
///           "members": [
///             "user:mike@example.com",
///             "group:admins@example.com",
///             "domain:google.com",
///             "serviceAccount:my-project-id@appspot.gserviceaccount.com"
///           ]
///         },
///         {
///           "role": "roles/resourcemanager.organizationViewer",
///           "members": [
///             "user:eve@example.com"
///           ],
///           "condition": {
///             "title": "expirable access",
///             "description": "Does not grant access after Sep 2020",
///             "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')",
///           }
///         }
///       ],
///       "etag": "BwWWja0YfJA=",
///       "version": 3
///     }
/// ```
///
/// **YAML example:**
///
/// ```norust
///     bindings:
///     - members:
///       - user:mike@example.com
///       - group:admins@example.com
///       - domain:google.com
///       - serviceAccount:my-project-id@appspot.gserviceaccount.com
///       role: roles/resourcemanager.organizationAdmin
///     - members:
///       - user:eve@example.com
///       role: roles/resourcemanager.organizationViewer
///       condition:
///         title: expirable access
///         description: Does not grant access after Sep 2020
///         expression: request.time < timestamp('2020-10-01T00:00:00.000Z')
///     etag: BwWWja0YfJA=
///     version: 3
/// ```
///
/// For a description of IAM and its features, see the
/// [IAM documentation](https://cloud.google.com/iam/docs/).
#[cfg(any(feature = "images", feature = "instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Policy {
    /// Specifies cloud audit logging configuration for this policy.
    pub audit_configs: std::vec::Vec<crate::model::AuditConfig>,

    /// Associates a list of `members`, or principals, with a `role`. Optionally,
    /// may specify a `condition` that determines how and when the `bindings` are
    /// applied. Each of the `bindings` must contain at least one principal.
    ///
    /// The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250
    /// of these principals can be Google groups. Each occurrence of a principal
    /// counts towards these limits. For example, if the `bindings` grant 50
    /// different roles to `user:alice@example.com`, and not to any other
    /// principal, then you can add another 1,450 principals to the `bindings` in
    /// the `Policy`.
    pub bindings: std::vec::Vec<crate::model::Binding>,

    /// `etag` is used for optimistic concurrency control as a way to help
    /// prevent simultaneous updates of a policy from overwriting each other.
    /// It is strongly suggested that systems make use of the `etag` in the
    /// read-modify-write cycle to perform policy updates in order to avoid race
    /// conditions: An `etag` is returned in the response to `getIamPolicy`, and
    /// systems are expected to put that etag in the request to `setIamPolicy` to
    /// ensure that their change will be applied to the same version of the policy.
    ///
    /// **Important:** If you use IAM Conditions, you must include the `etag` field
    /// whenever you call `setIamPolicy`. If you omit this field, then IAM allows
    /// you to overwrite a version `3` policy with a version `1` policy, and all of
    /// the conditions in the version `3` policy are lost.
    pub etag: std::option::Option<::bytes::Bytes>,

    /// Specifies the format of the policy.
    ///
    /// Valid values are `0`, `1`, and `3`. Requests that specify an invalid value
    /// are rejected.
    ///
    /// Any operation that affects conditional role bindings must specify version
    /// `3`. This requirement applies to the following operations:
    ///
    /// * Getting a policy that includes a conditional role binding
    /// * Adding a conditional role binding to a policy
    /// * Changing a conditional role binding in a policy
    /// * Removing any role binding, with or without a condition, from a policy
    ///   that includes conditions
    ///
    /// **Important:** If you use IAM Conditions, you must include the `etag` field
    /// whenever you call `setIamPolicy`. If you omit this field, then IAM allows
    /// you to overwrite a version `3` policy with a version `1` policy, and all of
    /// the conditions in the version `3` policy are lost.
    ///
    /// If a policy does not include any conditions, operations on that policy may
    /// specify any valid version or leave the field unset.
    ///
    /// To learn which resources support conditions in their IAM policies, see the
    /// [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
    pub version: std::option::Option<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances",))]
impl Policy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audit_configs][crate::model::Policy::audit_configs].
    pub fn set_audit_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AuditConfig>,
    {
        use std::iter::Iterator;
        self.audit_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [bindings][crate::model::Policy::bindings].
    pub fn set_bindings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Binding>,
    {
        use std::iter::Iterator;
        self.bindings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [etag][crate::model::Policy::etag].
    pub fn set_etag<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.etag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [etag][crate::model::Policy::etag].
    pub fn set_or_clear_etag<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.etag = v.map(|x| x.into());
        self
    }

    /// Sets the value of [version][crate::model::Policy::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::Policy::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.version = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
impl wkt::message::Message for Policy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Policy"
    }
}

/// Preserved state for a given instance.
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PreservedState {
    /// Preserved disks defined for this instance.
    /// This map is keyed with the device names of the disks.
    pub disks:
        std::collections::HashMap<std::string::String, crate::model::PreservedStatePreservedDisk>,

    /// Preserved external IPs defined for this instance.
    /// This map is keyed with the name of the network interface.
    pub external_i_ps: std::collections::HashMap<
        std::string::String,
        crate::model::PreservedStatePreservedNetworkIp,
    >,

    /// Preserved internal IPs defined for this instance.
    /// This map is keyed with the name of the network interface.
    pub internal_i_ps: std::collections::HashMap<
        std::string::String,
        crate::model::PreservedStatePreservedNetworkIp,
    >,

    /// Preserved metadata defined for this instance.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl PreservedState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disks][crate::model::PreservedState::disks].
    pub fn set_disks<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::PreservedStatePreservedDisk>,
    {
        use std::iter::Iterator;
        self.disks = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [external_i_ps][crate::model::PreservedState::external_i_ps].
    pub fn set_external_i_ps<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::PreservedStatePreservedNetworkIp>,
    {
        use std::iter::Iterator;
        self.external_i_ps = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [internal_i_ps][crate::model::PreservedState::internal_i_ps].
    pub fn set_internal_i_ps<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::PreservedStatePreservedNetworkIp>,
    {
        use std::iter::Iterator;
        self.internal_i_ps = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::PreservedState::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for PreservedState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.PreservedState"
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PreservedStatePreservedDisk {
    /// These stateful disks will never be deleted during autohealing,
    /// update, instance recreate operations. This flag is used to configure
    /// if the disk should be deleted after it is no longer used by the group,
    /// e.g. when the given instance or the whole MIG is deleted.
    /// Note: disks attached in READ_ONLY mode cannot be
    /// auto-deleted.
    pub auto_delete: std::option::Option<crate::model::preserved_state_preserved_disk::AutoDelete>,

    /// The mode in which to attach this disk, either READ_WRITE orREAD_ONLY. If not specified, the default is to attach the
    /// disk in READ_WRITE mode.
    pub mode: std::option::Option<crate::model::preserved_state_preserved_disk::Mode>,

    /// The URL of the disk resource that is stateful and should be attached
    /// to the VM instance.
    pub source: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl PreservedStatePreservedDisk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auto_delete][crate::model::PreservedStatePreservedDisk::auto_delete].
    pub fn set_auto_delete<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::preserved_state_preserved_disk::AutoDelete>,
    {
        self.auto_delete = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [auto_delete][crate::model::PreservedStatePreservedDisk::auto_delete].
    pub fn set_or_clear_auto_delete<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::preserved_state_preserved_disk::AutoDelete>,
    {
        self.auto_delete = v.map(|x| x.into());
        self
    }

    /// Sets the value of [mode][crate::model::PreservedStatePreservedDisk::mode].
    pub fn set_mode<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::preserved_state_preserved_disk::Mode>,
    {
        self.mode = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mode][crate::model::PreservedStatePreservedDisk::mode].
    pub fn set_or_clear_mode<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::preserved_state_preserved_disk::Mode>,
    {
        self.mode = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::PreservedStatePreservedDisk::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::PreservedStatePreservedDisk::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for PreservedStatePreservedDisk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.PreservedStatePreservedDisk"
    }
}

/// Defines additional types related to [PreservedStatePreservedDisk].
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
pub mod preserved_state_preserved_disk {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [autoDelete][google.cloud.compute.v1.PreservedStatePreservedDisk.autoDelete] field.
    ///
    /// [google.cloud.compute.v1.PreservedStatePreservedDisk.autoDelete]: crate::model::preserved_state_preserved_disk::AutoDelete
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AutoDelete {
        Never,
        OnPermanentInstanceDeletion,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AutoDelete::value] or
        /// [AutoDelete::name].
        UnknownValue(auto_delete::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod auto_delete {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl AutoDelete {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Never => std::option::Option::Some(0),
                Self::OnPermanentInstanceDeletion => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Never => std::option::Option::Some("NEVER"),
                Self::OnPermanentInstanceDeletion => {
                    std::option::Option::Some("ON_PERMANENT_INSTANCE_DELETION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for AutoDelete {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for AutoDelete {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for AutoDelete {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Never,
                1 => Self::OnPermanentInstanceDeletion,
                _ => Self::UnknownValue(auto_delete::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for AutoDelete {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NEVER" => Self::Never,
                "ON_PERMANENT_INSTANCE_DELETION" => Self::OnPermanentInstanceDeletion,
                _ => Self::UnknownValue(auto_delete::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for AutoDelete {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Never => serializer.serialize_str("NEVER"),
                Self::OnPermanentInstanceDeletion => {
                    serializer.serialize_str("ON_PERMANENT_INSTANCE_DELETION")
                }
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for AutoDelete {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AutoDelete>::new(
                ".google.cloud.compute.v1.PreservedStatePreservedDisk.autoDelete",
            ))
        }
    }

    /// The enumerated type for the [mode][google.cloud.compute.v1.PreservedStatePreservedDisk.mode] field.
    ///
    /// [google.cloud.compute.v1.PreservedStatePreservedDisk.mode]: crate::model::preserved_state_preserved_disk::Mode
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Attaches this disk in read-only mode. Multiple VM instances can use
        /// a disk in READ_ONLY mode at a time.
        ReadOnly,
        /// *[Default]* Attaches this disk in READ_WRITE mode. Only
        /// one VM instance at a time can be attached to a disk inREAD_WRITE mode.
        ReadWrite,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::ReadOnly => std::option::Option::Some(0),
                Self::ReadWrite => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::ReadOnly => std::option::Option::Some("READ_ONLY"),
                Self::ReadWrite => std::option::Option::Some("READ_WRITE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::ReadOnly,
                1 => Self::ReadWrite,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "READ_ONLY" => Self::ReadOnly,
                "READ_WRITE" => Self::ReadWrite,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::ReadOnly => serializer.serialize_str("READ_ONLY"),
                Self::ReadWrite => serializer.serialize_str("READ_WRITE"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.cloud.compute.v1.PreservedStatePreservedDisk.mode",
            ))
        }
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PreservedStatePreservedNetworkIp {
    /// These stateful IPs will never be released during autohealing,
    /// update or VM instance recreate operations.
    /// This flag is used to configure if the IP reservation should be deleted
    /// after it is no longer used by the group, e.g. when the given instance
    /// or the whole group is deleted.
    pub auto_delete:
        std::option::Option<crate::model::preserved_state_preserved_network_ip::AutoDelete>,

    /// Ip address representation
    pub ip_address: std::option::Option<crate::model::PreservedStatePreservedNetworkIpIpAddress>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl PreservedStatePreservedNetworkIp {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auto_delete][crate::model::PreservedStatePreservedNetworkIp::auto_delete].
    pub fn set_auto_delete<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::preserved_state_preserved_network_ip::AutoDelete>,
    {
        self.auto_delete = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [auto_delete][crate::model::PreservedStatePreservedNetworkIp::auto_delete].
    pub fn set_or_clear_auto_delete<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::preserved_state_preserved_network_ip::AutoDelete>,
    {
        self.auto_delete = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ip_address][crate::model::PreservedStatePreservedNetworkIp::ip_address].
    pub fn set_ip_address<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PreservedStatePreservedNetworkIpIpAddress>,
    {
        self.ip_address = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ip_address][crate::model::PreservedStatePreservedNetworkIp::ip_address].
    pub fn set_or_clear_ip_address<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PreservedStatePreservedNetworkIpIpAddress>,
    {
        self.ip_address = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for PreservedStatePreservedNetworkIp {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.PreservedStatePreservedNetworkIp"
    }
}

/// Defines additional types related to [PreservedStatePreservedNetworkIp].
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
pub mod preserved_state_preserved_network_ip {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [autoDelete][google.cloud.compute.v1.PreservedStatePreservedNetworkIp.autoDelete] field.
    ///
    /// [google.cloud.compute.v1.PreservedStatePreservedNetworkIp.autoDelete]: crate::model::preserved_state_preserved_network_ip::AutoDelete
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AutoDelete {
        Never,
        OnPermanentInstanceDeletion,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AutoDelete::value] or
        /// [AutoDelete::name].
        UnknownValue(auto_delete::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod auto_delete {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl AutoDelete {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Never => std::option::Option::Some(0),
                Self::OnPermanentInstanceDeletion => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Never => std::option::Option::Some("NEVER"),
                Self::OnPermanentInstanceDeletion => {
                    std::option::Option::Some("ON_PERMANENT_INSTANCE_DELETION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for AutoDelete {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for AutoDelete {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for AutoDelete {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Never,
                1 => Self::OnPermanentInstanceDeletion,
                _ => Self::UnknownValue(auto_delete::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for AutoDelete {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NEVER" => Self::Never,
                "ON_PERMANENT_INSTANCE_DELETION" => Self::OnPermanentInstanceDeletion,
                _ => Self::UnknownValue(auto_delete::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for AutoDelete {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Never => serializer.serialize_str("NEVER"),
                Self::OnPermanentInstanceDeletion => {
                    serializer.serialize_str("ON_PERMANENT_INSTANCE_DELETION")
                }
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for AutoDelete {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AutoDelete>::new(
                ".google.cloud.compute.v1.PreservedStatePreservedNetworkIp.autoDelete",
            ))
        }
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PreservedStatePreservedNetworkIpIpAddress {
    /// The URL of the reservation for this IP address.
    pub address: std::option::Option<std::string::String>,

    /// An IPv4 internal network address to assign to the instance for this
    /// network interface.
    pub literal: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl PreservedStatePreservedNetworkIpIpAddress {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [address][crate::model::PreservedStatePreservedNetworkIpIpAddress::address].
    pub fn set_address<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.address = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [address][crate::model::PreservedStatePreservedNetworkIpIpAddress::address].
    pub fn set_or_clear_address<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.address = v.map(|x| x.into());
        self
    }

    /// Sets the value of [literal][crate::model::PreservedStatePreservedNetworkIpIpAddress::literal].
    pub fn set_literal<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.literal = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [literal][crate::model::PreservedStatePreservedNetworkIpIpAddress::literal].
    pub fn set_or_clear_literal<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.literal = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for PreservedStatePreservedNetworkIpIpAddress {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.PreservedStatePreservedNetworkIpIpAddress"
    }
}

/// Additional details for quota exceeded error for resource quota.
#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct QuotaExceededInfo {
    /// The map holding related quota dimensions.
    pub dimensions: std::collections::HashMap<std::string::String, std::string::String>,

    /// Future quota limit being rolled out. The limit's unit depends on the quota
    /// type or metric.
    pub future_limit: std::option::Option<f64>,

    /// Current effective quota limit. The limit's unit depends on the quota type
    /// or metric.
    pub limit: std::option::Option<f64>,

    /// The name of the quota limit.
    pub limit_name: std::option::Option<std::string::String>,

    /// The Compute Engine quota metric name.
    pub metric_name: std::option::Option<std::string::String>,

    /// Rollout status of the future quota limit.
    pub rollout_status: std::option::Option<crate::model::quota_exceeded_info::RolloutStatus>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl QuotaExceededInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dimensions][crate::model::QuotaExceededInfo::dimensions].
    pub fn set_dimensions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dimensions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [future_limit][crate::model::QuotaExceededInfo::future_limit].
    pub fn set_future_limit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.future_limit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [future_limit][crate::model::QuotaExceededInfo::future_limit].
    pub fn set_or_clear_future_limit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.future_limit = v.map(|x| x.into());
        self
    }

    /// Sets the value of [limit][crate::model::QuotaExceededInfo::limit].
    pub fn set_limit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.limit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [limit][crate::model::QuotaExceededInfo::limit].
    pub fn set_or_clear_limit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.limit = v.map(|x| x.into());
        self
    }

    /// Sets the value of [limit_name][crate::model::QuotaExceededInfo::limit_name].
    pub fn set_limit_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.limit_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [limit_name][crate::model::QuotaExceededInfo::limit_name].
    pub fn set_or_clear_limit_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.limit_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metric_name][crate::model::QuotaExceededInfo::metric_name].
    pub fn set_metric_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.metric_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metric_name][crate::model::QuotaExceededInfo::metric_name].
    pub fn set_or_clear_metric_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.metric_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rollout_status][crate::model::QuotaExceededInfo::rollout_status].
    pub fn set_rollout_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::quota_exceeded_info::RolloutStatus>,
    {
        self.rollout_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollout_status][crate::model::QuotaExceededInfo::rollout_status].
    pub fn set_or_clear_rollout_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::quota_exceeded_info::RolloutStatus>,
    {
        self.rollout_status = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl wkt::message::Message for QuotaExceededInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.QuotaExceededInfo"
    }
}

/// Defines additional types related to [QuotaExceededInfo].
#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
pub mod quota_exceeded_info {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [rolloutStatus][google.cloud.compute.v1.QuotaExceededInfo.rolloutStatus] field.
    ///
    /// [google.cloud.compute.v1.QuotaExceededInfo.rolloutStatus]: crate::model::quota_exceeded_info::RolloutStatus
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RolloutStatus {
        /// IN_PROGRESS - A rollout is in process which will change the limit value
        /// to future limit.
        InProgress,
        /// ROLLOUT_STATUS_UNSPECIFIED - Rollout status is not specified. The default
        /// value.
        Unspecified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RolloutStatus::value] or
        /// [RolloutStatus::name].
        UnknownValue(rollout_status::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    pub mod rollout_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl RolloutStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::InProgress => std::option::Option::Some(0),
                Self::Unspecified => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Unspecified => std::option::Option::Some("ROLLOUT_STATUS_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl std::default::Default for RolloutStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl std::fmt::Display for RolloutStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl std::convert::From<i32> for RolloutStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::InProgress,
                1 => Self::Unspecified,
                _ => Self::UnknownValue(rollout_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl std::convert::From<&str> for RolloutStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IN_PROGRESS" => Self::InProgress,
                "ROLLOUT_STATUS_UNSPECIFIED" => Self::Unspecified,
                _ => Self::UnknownValue(rollout_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl serde::ser::Serialize for RolloutStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::InProgress => serializer.serialize_str("IN_PROGRESS"),
                Self::Unspecified => serializer.serialize_str("ROLLOUT_STATUS_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl<'de> serde::de::Deserialize<'de> for RolloutStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RolloutStatus>::new(
                ".google.cloud.compute.v1.QuotaExceededInfo.rolloutStatus",
            ))
        }
    }
}

/// Represents a reference to a resource.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Reference {
    /// [Output Only] Type of the resource. Always compute#reference
    /// for references.
    pub kind: std::option::Option<std::string::String>,

    /// A description of the reference type with no implied semantics. Possible
    /// values include:
    ///
    /// ```norust
    /// 1. MEMBER_OF
    /// ```
    pub reference_type: std::option::Option<std::string::String>,

    /// URL of the resource which refers to the target.
    pub referrer: std::option::Option<std::string::String>,

    /// URL of the resource to which this reference points.
    pub target: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl Reference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::Reference::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::Reference::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reference_type][crate::model::Reference::reference_type].
    pub fn set_reference_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.reference_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reference_type][crate::model::Reference::reference_type].
    pub fn set_or_clear_reference_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.reference_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [referrer][crate::model::Reference::referrer].
    pub fn set_referrer<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.referrer = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [referrer][crate::model::Reference::referrer].
    pub fn set_or_clear_referrer<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.referrer = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::Reference::target].
    pub fn set_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target][crate::model::Reference::target].
    pub fn set_or_clear_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.target = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for Reference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Reference"
    }
}

/// Contains a list of InstanceGroup resources.
#[cfg(feature = "region-instance-groups")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of InstanceGroup resources.
    pub items: std::vec::Vec<crate::model::InstanceGroup>,

    /// The resource type.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::region_instance_group_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-groups")]
impl RegionInstanceGroupList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::RegionInstanceGroupList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::RegionInstanceGroupList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::RegionInstanceGroupList::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceGroup>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::RegionInstanceGroupList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::RegionInstanceGroupList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::RegionInstanceGroupList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::RegionInstanceGroupList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::RegionInstanceGroupList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::RegionInstanceGroupList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::RegionInstanceGroupList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::region_instance_group_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::RegionInstanceGroupList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::region_instance_group_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "region-instance-groups")]
impl wkt::message::Message for RegionInstanceGroupList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupList"
    }
}

#[cfg(feature = "region-instance-groups")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for RegionInstanceGroupList {
    type PageItem = crate::model::InstanceGroup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [RegionInstanceGroupList].
#[cfg(feature = "region-instance-groups")]
pub mod region_instance_group_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.RegionInstanceGroupList.warning] field.
    ///
    /// [google.cloud.compute.v1.RegionInstanceGroupList.warning]: crate::model::region_instance_group_list::Warning
    #[cfg(feature = "region-instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::region_instance_group_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::region_instance_group_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-groups")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::region_instance_group_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::region_instance_group_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::region_instance_group_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::region_instance_group_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::region_instance_group_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::region_instance_group_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::region_instance_group_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::region_instance_group_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "region-instance-groups")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "region-instance-groups")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.RegionInstanceGroupList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.RegionInstanceGroupList.warning.data]: crate::model::region_instance_group_list::warning::Data
        #[cfg(feature = "region-instance-groups")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "region-instance-groups")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::region_instance_group_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::region_instance_group_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::region_instance_group_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::region_instance_group_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "region-instance-groups")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.RegionInstanceGroupList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.RegionInstanceGroupList.warning.code]: crate::model::region_instance_group_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "region-instance-groups")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "region-instance-groups")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "region-instance-groups")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "region-instance-groups")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "region-instance-groups")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "region-instance-groups")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "region-instance-groups")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "region-instance-groups")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "region-instance-groups")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.RegionInstanceGroupList.warning.code",
                ))
            }
        }
    }
}

/// RegionInstanceGroupManagers.deletePerInstanceConfigs
#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupManagerDeleteInstanceConfigReq {
    /// The list of instance names for which we want to delete per-instance configs
    /// on this managed instance group.
    pub names: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagerDeleteInstanceConfigReq {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [names][crate::model::RegionInstanceGroupManagerDeleteInstanceConfigReq::names].
    pub fn set_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.names = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl wkt::message::Message for RegionInstanceGroupManagerDeleteInstanceConfigReq {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagerDeleteInstanceConfigReq"
    }
}

/// Contains a list of managed instance groups.
#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupManagerList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of InstanceGroupManager resources.
    pub items: std::vec::Vec<crate::model::InstanceGroupManager>,

    /// [Output Only] The resource type, which is always
    /// compute#instanceGroupManagerList for a list of managed instance groups that
    /// exist in th regional scope.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::region_instance_group_manager_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagerList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::RegionInstanceGroupManagerList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::RegionInstanceGroupManagerList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::RegionInstanceGroupManagerList::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceGroupManager>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::RegionInstanceGroupManagerList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::RegionInstanceGroupManagerList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::RegionInstanceGroupManagerList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::RegionInstanceGroupManagerList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::RegionInstanceGroupManagerList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::RegionInstanceGroupManagerList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::RegionInstanceGroupManagerList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::region_instance_group_manager_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::RegionInstanceGroupManagerList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::region_instance_group_manager_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl wkt::message::Message for RegionInstanceGroupManagerList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagerList"
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for RegionInstanceGroupManagerList {
    type PageItem = crate::model::InstanceGroupManager;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [RegionInstanceGroupManagerList].
#[cfg(feature = "region-instance-group-managers")]
pub mod region_instance_group_manager_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.RegionInstanceGroupManagerList.warning] field.
    ///
    /// [google.cloud.compute.v1.RegionInstanceGroupManagerList.warning]: crate::model::region_instance_group_manager_list::Warning
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code:
            std::option::Option<crate::model::region_instance_group_manager_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::region_instance_group_manager_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::region_instance_group_manager_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::region_instance_group_manager_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::region_instance_group_manager_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::region_instance_group_manager_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::region_instance_group_manager_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::region_instance_group_manager_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::region_instance_group_manager_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::region_instance_group_manager_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagerList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "region-instance-group-managers")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.RegionInstanceGroupManagerList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.RegionInstanceGroupManagerList.warning.data]: crate::model::region_instance_group_manager_list::warning::Data
        #[cfg(feature = "region-instance-group-managers")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "region-instance-group-managers")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::region_instance_group_manager_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::region_instance_group_manager_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::region_instance_group_manager_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::region_instance_group_manager_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "region-instance-group-managers")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagerList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.RegionInstanceGroupManagerList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.RegionInstanceGroupManagerList.warning.code]: crate::model::region_instance_group_manager_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "region-instance-group-managers")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "region-instance-group-managers")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "region-instance-group-managers")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "region-instance-group-managers")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "region-instance-group-managers")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "region-instance-group-managers")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "region-instance-group-managers")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "region-instance-group-managers")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "region-instance-group-managers")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.RegionInstanceGroupManagerList.warning.code",
                ))
            }
        }
    }
}

/// RegionInstanceGroupManagers.patchPerInstanceConfigs
#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupManagerPatchInstanceConfigReq {
    /// The list of per-instance configurations to insert or patch on this managed
    /// instance group.
    pub per_instance_configs: std::vec::Vec<crate::model::PerInstanceConfig>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagerPatchInstanceConfigReq {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [per_instance_configs][crate::model::RegionInstanceGroupManagerPatchInstanceConfigReq::per_instance_configs].
    pub fn set_per_instance_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PerInstanceConfig>,
    {
        use std::iter::Iterator;
        self.per_instance_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl wkt::message::Message for RegionInstanceGroupManagerPatchInstanceConfigReq {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagerPatchInstanceConfigReq"
    }
}

/// RegionInstanceGroupManagers.updatePerInstanceConfigs
#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupManagerUpdateInstanceConfigReq {
    /// The list of per-instance configurations to insert or patch on this managed
    /// instance group.
    pub per_instance_configs: std::vec::Vec<crate::model::PerInstanceConfig>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagerUpdateInstanceConfigReq {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [per_instance_configs][crate::model::RegionInstanceGroupManagerUpdateInstanceConfigReq::per_instance_configs].
    pub fn set_per_instance_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PerInstanceConfig>,
    {
        use std::iter::Iterator;
        self.per_instance_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl wkt::message::Message for RegionInstanceGroupManagerUpdateInstanceConfigReq {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagerUpdateInstanceConfigReq"
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupManagersAbandonInstancesRequest {
    /// The URLs of one or more instances to abandon. This can be a full URL or
    /// a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
    pub instances: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagersAbandonInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::RegionInstanceGroupManagersAbandonInstancesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl wkt::message::Message for RegionInstanceGroupManagersAbandonInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagersAbandonInstancesRequest"
    }
}

/// RegionInstanceGroupManagers.applyUpdatesToInstances
#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupManagersApplyUpdatesRequest {

    /// Flag to update all instances instead of specified list of instances.
    /// If the flag is set to true then the instances may not be specified
    /// in the request.
    pub all_instances: std::option::Option<bool>,

    /// The list of URLs of one or more instances for which you want to apply
    /// updates. Each URL can be a full URL or a partial URL, such aszones/[ZONE]/instances/[INSTANCE_NAME].
    pub instances: std::vec::Vec<std::string::String>,

    /// The minimal action that you want to perform on each instance during the
    /// update:
    ///
    /// ```norust
    ///  - REPLACE: At minimum, delete the instance and create it
    ///  again.
    /// ```
    ///
    /// - RESTART: Stop the instance and start it
    ///   again.
    /// - REFRESH: Do not stop the instance and limit
    ///   disruption as much as possible.
    /// - NONE: Do not
    ///   disrupt the instance at all.
    ///
    /// By default, the minimum action is NONE. If your update
    /// requires a more disruptive action than you set with this flag, the
    /// necessary action is performed to execute the update.
    pub minimal_action: std::option::Option<crate::model::region_instance_group_managers_apply_updates_request::MinimalAction>,

    /// The most disruptive action that you want to perform on each instance during
    /// the update:
    ///
    /// ```norust
    ///  - REPLACE: Delete the instance and create it again.
    ///  - RESTART: Stop the instance and start it again.
    ///  - REFRESH: Do not stop the instance and limit disruption
    ///  as much as possible.
    /// ```
    ///
    /// - NONE: Do not disrupt the
    ///   instance at all.
    ///
    /// By default, the most disruptive allowed action is REPLACE. If
    /// your update requires a more disruptive action than you set with this flag,
    /// the update request will fail.
    pub most_disruptive_allowed_action: std::option::Option<crate::model::region_instance_group_managers_apply_updates_request::MostDisruptiveAllowedAction>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagersApplyUpdatesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [all_instances][crate::model::RegionInstanceGroupManagersApplyUpdatesRequest::all_instances].
    pub fn set_all_instances<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.all_instances = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [all_instances][crate::model::RegionInstanceGroupManagersApplyUpdatesRequest::all_instances].
    pub fn set_or_clear_all_instances<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.all_instances = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instances][crate::model::RegionInstanceGroupManagersApplyUpdatesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [minimal_action][crate::model::RegionInstanceGroupManagersApplyUpdatesRequest::minimal_action].
    pub fn set_minimal_action<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::region_instance_group_managers_apply_updates_request::MinimalAction,
            >,
    {
        self.minimal_action = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [minimal_action][crate::model::RegionInstanceGroupManagersApplyUpdatesRequest::minimal_action].
    pub fn set_or_clear_minimal_action<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::region_instance_group_managers_apply_updates_request::MinimalAction,
            >,
    {
        self.minimal_action = v.map(|x| x.into());
        self
    }

    /// Sets the value of [most_disruptive_allowed_action][crate::model::RegionInstanceGroupManagersApplyUpdatesRequest::most_disruptive_allowed_action].
    pub fn set_most_disruptive_allowed_action<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::region_instance_group_managers_apply_updates_request::MostDisruptiveAllowedAction>
    {
        self.most_disruptive_allowed_action = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [most_disruptive_allowed_action][crate::model::RegionInstanceGroupManagersApplyUpdatesRequest::most_disruptive_allowed_action].
    pub fn set_or_clear_most_disruptive_allowed_action<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::region_instance_group_managers_apply_updates_request::MostDisruptiveAllowedAction>
    {
        self.most_disruptive_allowed_action = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl wkt::message::Message for RegionInstanceGroupManagersApplyUpdatesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagersApplyUpdatesRequest"
    }
}

/// Defines additional types related to [RegionInstanceGroupManagersApplyUpdatesRequest].
#[cfg(feature = "region-instance-group-managers")]
pub mod region_instance_group_managers_apply_updates_request {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [minimalAction][google.cloud.compute.v1.RegionInstanceGroupManagersApplyUpdatesRequest.minimalAction] field.
    ///
    /// [google.cloud.compute.v1.RegionInstanceGroupManagersApplyUpdatesRequest.minimalAction]: crate::model::region_instance_group_managers_apply_updates_request::MinimalAction
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MinimalAction {
        /// Do not perform any action.
        None,
        /// Do not stop the instance.
        Refresh,
        /// (Default.) Replace the instance according to the replacement method
        /// option.
        Replace,
        /// Stop the instance and start it again.
        Restart,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MinimalAction::value] or
        /// [MinimalAction::name].
        UnknownValue(minimal_action::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "region-instance-group-managers")]
    pub mod minimal_action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl MinimalAction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::None => std::option::Option::Some(0),
                Self::Refresh => std::option::Option::Some(1),
                Self::Replace => std::option::Option::Some(2),
                Self::Restart => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::None => std::option::Option::Some("NONE"),
                Self::Refresh => std::option::Option::Some("REFRESH"),
                Self::Replace => std::option::Option::Some("REPLACE"),
                Self::Restart => std::option::Option::Some("RESTART"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl std::default::Default for MinimalAction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl std::fmt::Display for MinimalAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl std::convert::From<i32> for MinimalAction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::None,
                1 => Self::Refresh,
                2 => Self::Replace,
                3 => Self::Restart,
                _ => Self::UnknownValue(minimal_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl std::convert::From<&str> for MinimalAction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NONE" => Self::None,
                "REFRESH" => Self::Refresh,
                "REPLACE" => Self::Replace,
                "RESTART" => Self::Restart,
                _ => Self::UnknownValue(minimal_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl serde::ser::Serialize for MinimalAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::None => serializer.serialize_str("NONE"),
                Self::Refresh => serializer.serialize_str("REFRESH"),
                Self::Replace => serializer.serialize_str("REPLACE"),
                Self::Restart => serializer.serialize_str("RESTART"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl<'de> serde::de::Deserialize<'de> for MinimalAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MinimalAction>::new(
                ".google.cloud.compute.v1.RegionInstanceGroupManagersApplyUpdatesRequest.minimalAction"))
        }
    }

    /// The enumerated type for the [mostDisruptiveAllowedAction][google.cloud.compute.v1.RegionInstanceGroupManagersApplyUpdatesRequest.mostDisruptiveAllowedAction] field.
    ///
    /// [google.cloud.compute.v1.RegionInstanceGroupManagersApplyUpdatesRequest.mostDisruptiveAllowedAction]: crate::model::region_instance_group_managers_apply_updates_request::MostDisruptiveAllowedAction
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MostDisruptiveAllowedAction {
        /// Do not perform any action.
        None,
        /// Do not stop the instance.
        Refresh,
        /// (Default.) Replace the instance according to the replacement method
        /// option.
        Replace,
        /// Stop the instance and start it again.
        Restart,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MostDisruptiveAllowedAction::value] or
        /// [MostDisruptiveAllowedAction::name].
        UnknownValue(most_disruptive_allowed_action::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "region-instance-group-managers")]
    pub mod most_disruptive_allowed_action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl MostDisruptiveAllowedAction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::None => std::option::Option::Some(0),
                Self::Refresh => std::option::Option::Some(1),
                Self::Replace => std::option::Option::Some(2),
                Self::Restart => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::None => std::option::Option::Some("NONE"),
                Self::Refresh => std::option::Option::Some("REFRESH"),
                Self::Replace => std::option::Option::Some("REPLACE"),
                Self::Restart => std::option::Option::Some("RESTART"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl std::default::Default for MostDisruptiveAllowedAction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl std::fmt::Display for MostDisruptiveAllowedAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl std::convert::From<i32> for MostDisruptiveAllowedAction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::None,
                1 => Self::Refresh,
                2 => Self::Replace,
                3 => Self::Restart,
                _ => Self::UnknownValue(most_disruptive_allowed_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl std::convert::From<&str> for MostDisruptiveAllowedAction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NONE" => Self::None,
                "REFRESH" => Self::Refresh,
                "REPLACE" => Self::Replace,
                "RESTART" => Self::Restart,
                _ => Self::UnknownValue(most_disruptive_allowed_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl serde::ser::Serialize for MostDisruptiveAllowedAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::None => serializer.serialize_str("NONE"),
                Self::Refresh => serializer.serialize_str("REFRESH"),
                Self::Replace => serializer.serialize_str("REPLACE"),
                Self::Restart => serializer.serialize_str("RESTART"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl<'de> serde::de::Deserialize<'de> for MostDisruptiveAllowedAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MostDisruptiveAllowedAction>::new(
                ".google.cloud.compute.v1.RegionInstanceGroupManagersApplyUpdatesRequest.mostDisruptiveAllowedAction"))
        }
    }
}

/// RegionInstanceGroupManagers.createInstances
#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupManagersCreateInstancesRequest {
    /// [Required] List of specifications of per-instance configs.
    pub instances: std::vec::Vec<crate::model::PerInstanceConfig>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagersCreateInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::RegionInstanceGroupManagersCreateInstancesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PerInstanceConfig>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl wkt::message::Message for RegionInstanceGroupManagersCreateInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagersCreateInstancesRequest"
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupManagersDeleteInstancesRequest {
    /// The URLs of one or more instances to delete. This can be a full URL or
    /// a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
    pub instances: std::vec::Vec<std::string::String>,

    /// Specifies whether the request should proceed despite the inclusion of
    /// instances that are not members of the group or that are already in the
    /// process of being deleted or abandoned. If this field is set to `false` and
    /// such an instance is specified in the request, the operation fails. The
    /// operation always fails if the request contains a malformed instance URL or
    /// a reference to an instance that exists in a zone or region other than the
    /// group's zone or region.
    pub skip_instances_on_validation_error: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagersDeleteInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::RegionInstanceGroupManagersDeleteInstancesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [skip_instances_on_validation_error][crate::model::RegionInstanceGroupManagersDeleteInstancesRequest::skip_instances_on_validation_error].
    pub fn set_skip_instances_on_validation_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.skip_instances_on_validation_error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [skip_instances_on_validation_error][crate::model::RegionInstanceGroupManagersDeleteInstancesRequest::skip_instances_on_validation_error].
    pub fn set_or_clear_skip_instances_on_validation_error<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.skip_instances_on_validation_error = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl wkt::message::Message for RegionInstanceGroupManagersDeleteInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagersDeleteInstancesRequest"
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupManagersListErrorsResponse {
    /// [Output Only] The list of errors of the managed instance group.
    pub items: std::vec::Vec<crate::model::InstanceManagedByIgmError>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagersListErrorsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [items][crate::model::RegionInstanceGroupManagersListErrorsResponse::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceManagedByIgmError>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::RegionInstanceGroupManagersListErrorsResponse::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::RegionInstanceGroupManagersListErrorsResponse::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl wkt::message::Message for RegionInstanceGroupManagersListErrorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagersListErrorsResponse"
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for RegionInstanceGroupManagersListErrorsResponse {
    type PageItem = crate::model::InstanceManagedByIgmError;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupManagersListInstanceConfigsResp {
    /// [Output Only] The list of PerInstanceConfig.
    pub items: std::vec::Vec<crate::model::PerInstanceConfig>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<
        crate::model::region_instance_group_managers_list_instance_configs_resp::Warning,
    >,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagersListInstanceConfigsResp {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [items][crate::model::RegionInstanceGroupManagersListInstanceConfigsResp::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PerInstanceConfig>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::RegionInstanceGroupManagersListInstanceConfigsResp::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::RegionInstanceGroupManagersListInstanceConfigsResp::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::RegionInstanceGroupManagersListInstanceConfigsResp::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::region_instance_group_managers_list_instance_configs_resp::Warning,
            >,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::RegionInstanceGroupManagersListInstanceConfigsResp::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::region_instance_group_managers_list_instance_configs_resp::Warning,
            >,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl wkt::message::Message for RegionInstanceGroupManagersListInstanceConfigsResp {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagersListInstanceConfigsResp"
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse
    for RegionInstanceGroupManagersListInstanceConfigsResp
{
    type PageItem = crate::model::PerInstanceConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [RegionInstanceGroupManagersListInstanceConfigsResp].
#[cfg(feature = "region-instance-group-managers")]
pub mod region_instance_group_managers_list_instance_configs_resp {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.RegionInstanceGroupManagersListInstanceConfigsResp.warning] field.
    ///
    /// [google.cloud.compute.v1.RegionInstanceGroupManagersListInstanceConfigsResp.warning]: crate::model::region_instance_group_managers_list_instance_configs_resp::Warning
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<
            crate::model::region_instance_group_managers_list_instance_configs_resp::warning::Code,
        >,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<
            crate::model::region_instance_group_managers_list_instance_configs_resp::warning::Data,
        >,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::region_instance_group_managers_list_instance_configs_resp::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::region_instance_group_managers_list_instance_configs_resp::warning::Code>
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::region_instance_group_managers_list_instance_configs_resp::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::region_instance_group_managers_list_instance_configs_resp::warning::Code>
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::region_instance_group_managers_list_instance_configs_resp::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::region_instance_group_managers_list_instance_configs_resp::warning::Data>
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::region_instance_group_managers_list_instance_configs_resp::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::region_instance_group_managers_list_instance_configs_resp::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagersListInstanceConfigsResp.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "region-instance-group-managers")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.RegionInstanceGroupManagersListInstanceConfigsResp.warning.data] field.
        ///
        /// [google.cloud.compute.v1.RegionInstanceGroupManagersListInstanceConfigsResp.warning.data]: crate::model::region_instance_group_managers_list_instance_configs_resp::warning::Data
        #[cfg(feature = "region-instance-group-managers")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "region-instance-group-managers")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::region_instance_group_managers_list_instance_configs_resp::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::region_instance_group_managers_list_instance_configs_resp::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::region_instance_group_managers_list_instance_configs_resp::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::region_instance_group_managers_list_instance_configs_resp::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "region-instance-group-managers")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagersListInstanceConfigsResp.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.RegionInstanceGroupManagersListInstanceConfigsResp.warning.code] field.
        ///
        /// [google.cloud.compute.v1.RegionInstanceGroupManagersListInstanceConfigsResp.warning.code]: crate::model::region_instance_group_managers_list_instance_configs_resp::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "region-instance-group-managers")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "region-instance-group-managers")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "region-instance-group-managers")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "region-instance-group-managers")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "region-instance-group-managers")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "region-instance-group-managers")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "region-instance-group-managers")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "region-instance-group-managers")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "region-instance-group-managers")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.RegionInstanceGroupManagersListInstanceConfigsResp.warning.code"))
            }
        }
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupManagersListInstancesResponse {
    /// A list of managed instances.
    pub managed_instances: std::vec::Vec<crate::model::ManagedInstance>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagersListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [managed_instances][crate::model::RegionInstanceGroupManagersListInstancesResponse::managed_instances].
    pub fn set_managed_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ManagedInstance>,
    {
        use std::iter::Iterator;
        self.managed_instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::RegionInstanceGroupManagersListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::RegionInstanceGroupManagersListInstancesResponse::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl wkt::message::Message for RegionInstanceGroupManagersListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagersListInstancesResponse"
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse
    for RegionInstanceGroupManagersListInstancesResponse
{
    type PageItem = crate::model::ManagedInstance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.managed_instances
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupManagersRecreateRequest {
    /// The URLs of one or more instances to recreate. This can be a full URL or
    /// a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
    pub instances: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagersRecreateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::RegionInstanceGroupManagersRecreateRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl wkt::message::Message for RegionInstanceGroupManagersRecreateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagersRecreateRequest"
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupManagersResumeInstancesRequest {
    /// The URLs of one or more instances to resume. This can be a full URL or
    /// a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
    pub instances: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagersResumeInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::RegionInstanceGroupManagersResumeInstancesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl wkt::message::Message for RegionInstanceGroupManagersResumeInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagersResumeInstancesRequest"
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupManagersSetTargetPoolsRequest {
    /// Fingerprint of the target pools information, which is a hash of the
    /// contents. This field is used for optimistic locking when you update the
    /// target pool entries. This field is optional.
    pub fingerprint: std::option::Option<::bytes::Bytes>,

    /// The URL of all TargetPool resources to which instances in theinstanceGroup field are added. The target pools automatically
    /// apply to all of the instances in the managed instance group.
    pub target_pools: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagersSetTargetPoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fingerprint][crate::model::RegionInstanceGroupManagersSetTargetPoolsRequest::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::RegionInstanceGroupManagersSetTargetPoolsRequest::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_pools][crate::model::RegionInstanceGroupManagersSetTargetPoolsRequest::target_pools].
    pub fn set_target_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl wkt::message::Message for RegionInstanceGroupManagersSetTargetPoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagersSetTargetPoolsRequest"
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupManagersSetTemplateRequest {
    /// URL of the InstanceTemplate resource from which all new instances will be
    /// created.
    pub instance_template: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagersSetTemplateRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_template][crate::model::RegionInstanceGroupManagersSetTemplateRequest::instance_template].
    pub fn set_instance_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_template][crate::model::RegionInstanceGroupManagersSetTemplateRequest::instance_template].
    pub fn set_or_clear_instance_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.instance_template = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl wkt::message::Message for RegionInstanceGroupManagersSetTemplateRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagersSetTemplateRequest"
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupManagersStartInstancesRequest {
    /// The URLs of one or more instances to start. This can be a full URL or
    /// a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
    pub instances: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagersStartInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::RegionInstanceGroupManagersStartInstancesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl wkt::message::Message for RegionInstanceGroupManagersStartInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagersStartInstancesRequest"
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupManagersStopInstancesRequest {
    /// If this flag is set to true, the Instance Group Manager will proceed to
    /// stop the instances, skipping initialization on them.
    pub force_stop: std::option::Option<bool>,

    /// The URLs of one or more instances to stop. This can be a full URL or
    /// a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
    pub instances: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagersStopInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [force_stop][crate::model::RegionInstanceGroupManagersStopInstancesRequest::force_stop].
    pub fn set_force_stop<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.force_stop = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [force_stop][crate::model::RegionInstanceGroupManagersStopInstancesRequest::force_stop].
    pub fn set_or_clear_force_stop<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.force_stop = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instances][crate::model::RegionInstanceGroupManagersStopInstancesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl wkt::message::Message for RegionInstanceGroupManagersStopInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagersStopInstancesRequest"
    }
}

#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupManagersSuspendInstancesRequest {
    /// If this flag is set to true, the Instance Group Manager will proceed to
    /// suspend the instances, skipping initialization on them.
    pub force_suspend: std::option::Option<bool>,

    /// The URLs of one or more instances to suspend. This can be a full URL or
    /// a partial URL, such as zones/[ZONE]/instances/[INSTANCE_NAME].
    pub instances: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagersSuspendInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [force_suspend][crate::model::RegionInstanceGroupManagersSuspendInstancesRequest::force_suspend].
    pub fn set_force_suspend<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.force_suspend = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [force_suspend][crate::model::RegionInstanceGroupManagersSuspendInstancesRequest::force_suspend].
    pub fn set_or_clear_force_suspend<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.force_suspend = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instances][crate::model::RegionInstanceGroupManagersSuspendInstancesRequest::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl wkt::message::Message for RegionInstanceGroupManagersSuspendInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupManagersSuspendInstancesRequest"
    }
}

#[cfg(feature = "region-instance-groups")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupsListInstances {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of InstanceWithNamedPorts resources.
    pub items: std::vec::Vec<crate::model::InstanceWithNamedPorts>,

    /// The resource type.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::region_instance_groups_list_instances::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-groups")]
impl RegionInstanceGroupsListInstances {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::RegionInstanceGroupsListInstances::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::RegionInstanceGroupsListInstances::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::RegionInstanceGroupsListInstances::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstanceWithNamedPorts>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::RegionInstanceGroupsListInstances::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::RegionInstanceGroupsListInstances::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::RegionInstanceGroupsListInstances::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::RegionInstanceGroupsListInstances::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::RegionInstanceGroupsListInstances::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::RegionInstanceGroupsListInstances::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::RegionInstanceGroupsListInstances::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::region_instance_groups_list_instances::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::RegionInstanceGroupsListInstances::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::region_instance_groups_list_instances::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "region-instance-groups")]
impl wkt::message::Message for RegionInstanceGroupsListInstances {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupsListInstances"
    }
}

#[cfg(feature = "region-instance-groups")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for RegionInstanceGroupsListInstances {
    type PageItem = crate::model::InstanceWithNamedPorts;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [RegionInstanceGroupsListInstances].
#[cfg(feature = "region-instance-groups")]
pub mod region_instance_groups_list_instances {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.RegionInstanceGroupsListInstances.warning] field.
    ///
    /// [google.cloud.compute.v1.RegionInstanceGroupsListInstances.warning]: crate::model::region_instance_groups_list_instances::Warning
    #[cfg(feature = "region-instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code:
            std::option::Option<crate::model::region_instance_groups_list_instances::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::region_instance_groups_list_instances::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-groups")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::region_instance_groups_list_instances::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::region_instance_groups_list_instances::warning::Code,
                >,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::region_instance_groups_list_instances::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::region_instance_groups_list_instances::warning::Code,
                >,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::region_instance_groups_list_instances::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::region_instance_groups_list_instances::warning::Data,
                >,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::region_instance_groups_list_instances::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::region_instance_groups_list_instances::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "region-instance-groups")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupsListInstances.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "region-instance-groups")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.RegionInstanceGroupsListInstances.warning.data] field.
        ///
        /// [google.cloud.compute.v1.RegionInstanceGroupsListInstances.warning.data]: crate::model::region_instance_groups_list_instances::warning::Data
        #[cfg(feature = "region-instance-groups")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "region-instance-groups")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::region_instance_groups_list_instances::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::region_instance_groups_list_instances::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::region_instance_groups_list_instances::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::region_instance_groups_list_instances::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "region-instance-groups")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupsListInstances.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.RegionInstanceGroupsListInstances.warning.code] field.
        ///
        /// [google.cloud.compute.v1.RegionInstanceGroupsListInstances.warning.code]: crate::model::region_instance_groups_list_instances::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "region-instance-groups")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "region-instance-groups")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "region-instance-groups")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "region-instance-groups")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "region-instance-groups")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "region-instance-groups")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "region-instance-groups")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "region-instance-groups")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "region-instance-groups")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.RegionInstanceGroupsListInstances.warning.code",
                ))
            }
        }
    }
}

#[cfg(feature = "region-instance-groups")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupsListInstancesRequest {
    /// Instances in which state should be returned. Valid options are:
    /// 'ALL', 'RUNNING'. By default, it lists all instances.
    pub instance_state: std::option::Option<
        crate::model::region_instance_groups_list_instances_request::InstanceState,
    >,

    /// Name of port user is interested in. It is optional. If it is set, only
    /// information about this ports will be returned. If it is not set, all the
    /// named ports will be returned.
    /// Always lists all instances.
    pub port_name: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-groups")]
impl RegionInstanceGroupsListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance_state][crate::model::RegionInstanceGroupsListInstancesRequest::instance_state].
    pub fn set_instance_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::region_instance_groups_list_instances_request::InstanceState,
            >,
    {
        self.instance_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_state][crate::model::RegionInstanceGroupsListInstancesRequest::instance_state].
    pub fn set_or_clear_instance_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::region_instance_groups_list_instances_request::InstanceState,
            >,
    {
        self.instance_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [port_name][crate::model::RegionInstanceGroupsListInstancesRequest::port_name].
    pub fn set_port_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.port_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [port_name][crate::model::RegionInstanceGroupsListInstancesRequest::port_name].
    pub fn set_or_clear_port_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.port_name = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "region-instance-groups")]
impl wkt::message::Message for RegionInstanceGroupsListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupsListInstancesRequest"
    }
}

/// Defines additional types related to [RegionInstanceGroupsListInstancesRequest].
#[cfg(feature = "region-instance-groups")]
pub mod region_instance_groups_list_instances_request {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [instanceState][google.cloud.compute.v1.RegionInstanceGroupsListInstancesRequest.instanceState] field.
    ///
    /// [google.cloud.compute.v1.RegionInstanceGroupsListInstancesRequest.instanceState]: crate::model::region_instance_groups_list_instances_request::InstanceState
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "region-instance-groups")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstanceState {
        /// Matches any status of the instances, running, non-running and others.
        All,
        /// Instance is in RUNNING state if it is running.
        Running,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstanceState::value] or
        /// [InstanceState::name].
        UnknownValue(instance_state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "region-instance-groups")]
    pub mod instance_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "region-instance-groups")]
    impl InstanceState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::All => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::All => std::option::Option::Some("ALL"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "region-instance-groups")]
    impl std::default::Default for InstanceState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "region-instance-groups")]
    impl std::fmt::Display for InstanceState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "region-instance-groups")]
    impl std::convert::From<i32> for InstanceState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::All,
                1 => Self::Running,
                _ => Self::UnknownValue(instance_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "region-instance-groups")]
    impl std::convert::From<&str> for InstanceState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ALL" => Self::All,
                "RUNNING" => Self::Running,
                _ => Self::UnknownValue(instance_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "region-instance-groups")]
    impl serde::ser::Serialize for InstanceState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::All => serializer.serialize_str("ALL"),
                Self::Running => serializer.serialize_str("RUNNING"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "region-instance-groups")]
    impl<'de> serde::de::Deserialize<'de> for InstanceState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<InstanceState>::new(
                ".google.cloud.compute.v1.RegionInstanceGroupsListInstancesRequest.instanceState",
            ))
        }
    }
}

#[cfg(feature = "region-instance-groups")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RegionInstanceGroupsSetNamedPortsRequest {
    /// The fingerprint of the named ports information for this instance group.
    /// Use this optional property to prevent conflicts when multiple users change
    /// the named ports settings concurrently. Obtain the fingerprint with theinstanceGroups.get
    /// method. Then, include the fingerprint in your request to ensure that you
    /// do not overwrite changes that were applied from another
    /// concurrent request.
    pub fingerprint: std::option::Option<::bytes::Bytes>,

    /// The list of named ports to set for this instance group.
    pub named_ports: std::vec::Vec<crate::model::NamedPort>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-groups")]
impl RegionInstanceGroupsSetNamedPortsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fingerprint][crate::model::RegionInstanceGroupsSetNamedPortsRequest::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::RegionInstanceGroupsSetNamedPortsRequest::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [named_ports][crate::model::RegionInstanceGroupsSetNamedPortsRequest::named_ports].
    pub fn set_named_ports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NamedPort>,
    {
        use std::iter::Iterator;
        self.named_ports = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "region-instance-groups")]
impl wkt::message::Message for RegionInstanceGroupsSetNamedPortsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.RegionInstanceGroupsSetNamedPortsRequest"
    }
}

/// Specifies the reservations that this instance can consume from.
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReservationAffinity {
    /// Specifies the type of reservation from which this instance can consume
    /// resources: ANY_RESERVATION (default),SPECIFIC_RESERVATION, or NO_RESERVATION. See
    /// Consuming reserved instances for examples.
    pub consume_reservation_type:
        std::option::Option<crate::model::reservation_affinity::ConsumeReservationType>,

    /// Corresponds to the label key of a reservation resource. To target aSPECIFIC_RESERVATION by name, specifygoogleapis.com/reservation-name as the key and specify
    /// the name of your reservation as its value.
    pub key: std::option::Option<std::string::String>,

    /// Corresponds to the label values of a reservation resource. This can be
    /// either a name to a reservation in the same project or
    /// "projects/different-project/reservations/some-reservation-name" to target a
    /// shared reservation in the same zone but in a different project.
    pub values: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl ReservationAffinity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [consume_reservation_type][crate::model::ReservationAffinity::consume_reservation_type].
    pub fn set_consume_reservation_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::reservation_affinity::ConsumeReservationType>,
    {
        self.consume_reservation_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [consume_reservation_type][crate::model::ReservationAffinity::consume_reservation_type].
    pub fn set_or_clear_consume_reservation_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::reservation_affinity::ConsumeReservationType>,
    {
        self.consume_reservation_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [key][crate::model::ReservationAffinity::key].
    pub fn set_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key][crate::model::ReservationAffinity::key].
    pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [values][crate::model::ReservationAffinity::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for ReservationAffinity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ReservationAffinity"
    }
}

/// Defines additional types related to [ReservationAffinity].
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
pub mod reservation_affinity {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [consumeReservationType][google.cloud.compute.v1.ReservationAffinity.consumeReservationType] field.
    ///
    /// [google.cloud.compute.v1.ReservationAffinity.consumeReservationType]: crate::model::reservation_affinity::ConsumeReservationType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConsumeReservationType {
        /// Consume any allocation available.
        AnyReservation,
        /// Do not consume from any allocated capacity.
        NoReservation,
        /// Must consume from a specific reservation. Must specify key value fields
        /// for specifying the reservations.
        SpecificReservation,
        Unspecified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConsumeReservationType::value] or
        /// [ConsumeReservationType::name].
        UnknownValue(consume_reservation_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod consume_reservation_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl ConsumeReservationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::AnyReservation => std::option::Option::Some(0),
                Self::NoReservation => std::option::Option::Some(1),
                Self::SpecificReservation => std::option::Option::Some(2),
                Self::Unspecified => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::AnyReservation => std::option::Option::Some("ANY_RESERVATION"),
                Self::NoReservation => std::option::Option::Some("NO_RESERVATION"),
                Self::SpecificReservation => std::option::Option::Some("SPECIFIC_RESERVATION"),
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for ConsumeReservationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for ConsumeReservationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for ConsumeReservationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::AnyReservation,
                1 => Self::NoReservation,
                2 => Self::SpecificReservation,
                3 => Self::Unspecified,
                _ => Self::UnknownValue(consume_reservation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for ConsumeReservationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANY_RESERVATION" => Self::AnyReservation,
                "NO_RESERVATION" => Self::NoReservation,
                "SPECIFIC_RESERVATION" => Self::SpecificReservation,
                "UNSPECIFIED" => Self::Unspecified,
                _ => Self::UnknownValue(consume_reservation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for ConsumeReservationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::AnyReservation => serializer.serialize_str("ANY_RESERVATION"),
                Self::NoReservation => serializer.serialize_str("NO_RESERVATION"),
                Self::SpecificReservation => serializer.serialize_str("SPECIFIC_RESERVATION"),
                Self::Unspecified => serializer.serialize_str("UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for ConsumeReservationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConsumeReservationType>::new(
                ".google.cloud.compute.v1.ReservationAffinity.consumeReservationType",
            ))
        }
    }
}

/// Contains output only fields.
/// Use this sub-message for actual values set on Instance attributes as compared
/// to the value requested by the user (intent) in their instance CRUD calls.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceStatus {
    /// [Output Only] Effective metadata is a field that consolidates project,
    /// zonal instance settings, and instance-level predefined metadata keys to
    /// provide the overridden value for those metadata keys at the instance level.
    pub effective_instance_metadata:
        std::option::Option<crate::model::ResourceStatusEffectiveInstanceMetadata>,

    /// [Output Only] The precise location of your instance within the zone's data
    /// center, including the block, sub-block, and host. The field is formatted as
    /// follows: blockId/subBlockId/hostId.
    pub physical_host: std::option::Option<std::string::String>,

    /// [Output Only] A series of fields containing the global name of the Compute
    /// Engine cluster, as well as the ID of the block, sub-block, and host on
    /// which the running instance is located.
    pub physical_host_topology:
        std::option::Option<crate::model::ResourceStatusPhysicalHostTopology>,

    /// [Output Only] Reservation information that the instance is consuming from.
    pub reservation_consumption_info:
        std::option::Option<crate::model::ResourceStatusReservationConsumptionInfo>,

    pub scheduling: std::option::Option<crate::model::ResourceStatusScheduling>,

    pub upcoming_maintenance: std::option::Option<crate::model::UpcomingMaintenance>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ResourceStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [effective_instance_metadata][crate::model::ResourceStatus::effective_instance_metadata].
    pub fn set_effective_instance_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceStatusEffectiveInstanceMetadata>,
    {
        self.effective_instance_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [effective_instance_metadata][crate::model::ResourceStatus::effective_instance_metadata].
    pub fn set_or_clear_effective_instance_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourceStatusEffectiveInstanceMetadata>,
    {
        self.effective_instance_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [physical_host][crate::model::ResourceStatus::physical_host].
    pub fn set_physical_host<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.physical_host = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [physical_host][crate::model::ResourceStatus::physical_host].
    pub fn set_or_clear_physical_host<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.physical_host = v.map(|x| x.into());
        self
    }

    /// Sets the value of [physical_host_topology][crate::model::ResourceStatus::physical_host_topology].
    pub fn set_physical_host_topology<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceStatusPhysicalHostTopology>,
    {
        self.physical_host_topology = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [physical_host_topology][crate::model::ResourceStatus::physical_host_topology].
    pub fn set_or_clear_physical_host_topology<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourceStatusPhysicalHostTopology>,
    {
        self.physical_host_topology = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reservation_consumption_info][crate::model::ResourceStatus::reservation_consumption_info].
    pub fn set_reservation_consumption_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceStatusReservationConsumptionInfo>,
    {
        self.reservation_consumption_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reservation_consumption_info][crate::model::ResourceStatus::reservation_consumption_info].
    pub fn set_or_clear_reservation_consumption_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourceStatusReservationConsumptionInfo>,
    {
        self.reservation_consumption_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scheduling][crate::model::ResourceStatus::scheduling].
    pub fn set_scheduling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceStatusScheduling>,
    {
        self.scheduling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scheduling][crate::model::ResourceStatus::scheduling].
    pub fn set_or_clear_scheduling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourceStatusScheduling>,
    {
        self.scheduling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [upcoming_maintenance][crate::model::ResourceStatus::upcoming_maintenance].
    pub fn set_upcoming_maintenance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UpcomingMaintenance>,
    {
        self.upcoming_maintenance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [upcoming_maintenance][crate::model::ResourceStatus::upcoming_maintenance].
    pub fn set_or_clear_upcoming_maintenance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UpcomingMaintenance>,
    {
        self.upcoming_maintenance = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ResourceStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ResourceStatus"
    }
}

/// Effective values of predefined metadata keys for an instance.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceStatusEffectiveInstanceMetadata {
    /// Effective block-project-ssh-keys value at Instance level.
    pub block_project_ssh_keys_metadata_value: std::option::Option<bool>,

    /// Effective enable-guest-attributes value at Instance level.
    pub enable_guest_attributes_metadata_value: std::option::Option<bool>,

    /// Effective enable-os-inventory value at Instance level.
    pub enable_os_inventory_metadata_value: std::option::Option<bool>,

    /// Effective enable-osconfig value at Instance level.
    pub enable_osconfig_metadata_value: std::option::Option<bool>,

    /// Effective enable-oslogin value at Instance level.
    pub enable_oslogin_metadata_value: std::option::Option<bool>,

    /// Effective serial-port-enable value at Instance level.
    pub serial_port_enable_metadata_value: std::option::Option<bool>,

    /// Effective serial-port-logging-enable value at Instance level.
    pub serial_port_logging_enable_metadata_value: std::option::Option<bool>,

    /// Effective VM DNS setting at Instance level.
    pub vm_dns_setting_metadata_value: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ResourceStatusEffectiveInstanceMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [block_project_ssh_keys_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::block_project_ssh_keys_metadata_value].
    pub fn set_block_project_ssh_keys_metadata_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.block_project_ssh_keys_metadata_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [block_project_ssh_keys_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::block_project_ssh_keys_metadata_value].
    pub fn set_or_clear_block_project_ssh_keys_metadata_value<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.block_project_ssh_keys_metadata_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_guest_attributes_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::enable_guest_attributes_metadata_value].
    pub fn set_enable_guest_attributes_metadata_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_guest_attributes_metadata_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_guest_attributes_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::enable_guest_attributes_metadata_value].
    pub fn set_or_clear_enable_guest_attributes_metadata_value<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_guest_attributes_metadata_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_os_inventory_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::enable_os_inventory_metadata_value].
    pub fn set_enable_os_inventory_metadata_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_os_inventory_metadata_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_os_inventory_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::enable_os_inventory_metadata_value].
    pub fn set_or_clear_enable_os_inventory_metadata_value<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_os_inventory_metadata_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_osconfig_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::enable_osconfig_metadata_value].
    pub fn set_enable_osconfig_metadata_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_osconfig_metadata_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_osconfig_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::enable_osconfig_metadata_value].
    pub fn set_or_clear_enable_osconfig_metadata_value<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_osconfig_metadata_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_oslogin_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::enable_oslogin_metadata_value].
    pub fn set_enable_oslogin_metadata_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_oslogin_metadata_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_oslogin_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::enable_oslogin_metadata_value].
    pub fn set_or_clear_enable_oslogin_metadata_value<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_oslogin_metadata_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [serial_port_enable_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::serial_port_enable_metadata_value].
    pub fn set_serial_port_enable_metadata_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.serial_port_enable_metadata_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [serial_port_enable_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::serial_port_enable_metadata_value].
    pub fn set_or_clear_serial_port_enable_metadata_value<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.serial_port_enable_metadata_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [serial_port_logging_enable_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::serial_port_logging_enable_metadata_value].
    pub fn set_serial_port_logging_enable_metadata_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.serial_port_logging_enable_metadata_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [serial_port_logging_enable_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::serial_port_logging_enable_metadata_value].
    pub fn set_or_clear_serial_port_logging_enable_metadata_value<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.serial_port_logging_enable_metadata_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vm_dns_setting_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::vm_dns_setting_metadata_value].
    pub fn set_vm_dns_setting_metadata_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.vm_dns_setting_metadata_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vm_dns_setting_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::vm_dns_setting_metadata_value].
    pub fn set_or_clear_vm_dns_setting_metadata_value<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.vm_dns_setting_metadata_value = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ResourceStatusEffectiveInstanceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ResourceStatusEffectiveInstanceMetadata"
    }
}

/// Represents the physical host topology of the host on which the VM is
/// running.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceStatusPhysicalHostTopology {
    /// [Output Only] The ID of the block in which the running instance is
    /// located. Instances within the same block experience low network latency.
    pub block: std::option::Option<std::string::String>,

    /// [Output Only] The global name of the Compute Engine cluster where the
    /// running instance is located.
    pub cluster: std::option::Option<std::string::String>,

    /// [Output Only] The ID of the host on which the running instance is located.
    /// Instances on the same host experience the lowest possible network
    /// latency.
    pub host: std::option::Option<std::string::String>,

    /// [Output Only] The ID of the sub-block in which the running instance is
    /// located. Instances in the same sub-block experience lower network latency
    /// than instances in the same block.
    pub subblock: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ResourceStatusPhysicalHostTopology {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [block][crate::model::ResourceStatusPhysicalHostTopology::block].
    pub fn set_block<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.block = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [block][crate::model::ResourceStatusPhysicalHostTopology::block].
    pub fn set_or_clear_block<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.block = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cluster][crate::model::ResourceStatusPhysicalHostTopology::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::ResourceStatusPhysicalHostTopology::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [host][crate::model::ResourceStatusPhysicalHostTopology::host].
    pub fn set_host<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.host = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [host][crate::model::ResourceStatusPhysicalHostTopology::host].
    pub fn set_or_clear_host<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.host = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subblock][crate::model::ResourceStatusPhysicalHostTopology::subblock].
    pub fn set_subblock<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subblock = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subblock][crate::model::ResourceStatusPhysicalHostTopology::subblock].
    pub fn set_or_clear_subblock<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subblock = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ResourceStatusPhysicalHostTopology {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ResourceStatusPhysicalHostTopology"
    }
}

/// Reservation consumption information that the instance is consuming from.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceStatusReservationConsumptionInfo {
    /// [Output Only] The full resource name of the reservation that this
    /// instance is consuming from.
    pub consumed_reservation: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ResourceStatusReservationConsumptionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [consumed_reservation][crate::model::ResourceStatusReservationConsumptionInfo::consumed_reservation].
    pub fn set_consumed_reservation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.consumed_reservation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [consumed_reservation][crate::model::ResourceStatusReservationConsumptionInfo::consumed_reservation].
    pub fn set_or_clear_consumed_reservation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.consumed_reservation = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ResourceStatusReservationConsumptionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ResourceStatusReservationConsumptionInfo"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceStatusScheduling {
    /// Specifies the availability domain to place the instance in. The value
    /// must be a number between 1 and the number of availability domains
    /// specified in the spread placement policy attached to the instance.
    pub availability_domain: std::option::Option<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ResourceStatusScheduling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [availability_domain][crate::model::ResourceStatusScheduling::availability_domain].
    pub fn set_availability_domain<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.availability_domain = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [availability_domain][crate::model::ResourceStatusScheduling::availability_domain].
    pub fn set_or_clear_availability_domain<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.availability_domain = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ResourceStatusScheduling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ResourceStatusScheduling"
    }
}

/// Sets the scheduling options for an Instance.
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Scheduling {
    /// Specifies whether the instance should be automatically restarted if it is
    /// terminated by Compute Engine (not terminated by a user). You can only set
    /// the automatic restart option for standard instances.Preemptible instances
    /// cannot be automatically restarted.
    ///
    /// By default, this is set to true so an instance is
    /// automatically restarted if it is terminated by Compute Engine.
    pub automatic_restart: std::option::Option<bool>,

    /// Specifies the availability domain to place the instance in. The value
    /// must be a number between 1 and the number of availability domains
    /// specified in the spread placement policy attached to the instance.
    pub availability_domain: std::option::Option<i32>,

    /// Specify the time in seconds for host error detection, the value must be
    /// within the range of [90, 330] with the increment of 30, if unset, the
    /// default behavior of host error recovery will be used.
    pub host_error_timeout_seconds: std::option::Option<i32>,

    /// Specifies the termination action for the instance.
    pub instance_termination_action:
        std::option::Option<crate::model::scheduling::InstanceTerminationAction>,

    /// Specifies the maximum amount of time a Local Ssd Vm should wait while
    /// recovery of the Local Ssd state is attempted. Its value should be in
    /// between 0 and 168 hours with hour granularity and the default value being 1
    /// hour.
    pub local_ssd_recovery_timeout: std::option::Option<crate::model::Duration>,

    /// An opaque location hint used to place the instance close to other
    /// resources.
    /// This field is for use by internal tools that use the public API.
    pub location_hint: std::option::Option<std::string::String>,

    /// Specifies the max run duration for the given instance. If specified,
    /// the instance termination action will be performed at the end of the run
    /// duration.
    pub max_run_duration: std::option::Option<crate::model::Duration>,

    /// The minimum number of virtual CPUs this instance will consume when running
    /// on a sole-tenant node.
    pub min_node_cpus: std::option::Option<i32>,

    /// A set of node affinity and anti-affinity configurations. Refer toConfiguring node
    /// affinity for more information.
    /// Overrides reservationAffinity.
    pub node_affinities: std::vec::Vec<crate::model::SchedulingNodeAffinity>,

    /// Defines the maintenance behavior for this instance. For standard instances,
    /// the default behavior is MIGRATE. Forpreemptible instances,
    /// the default and only possible behavior is TERMINATE. For more
    /// information, see
    /// Set
    /// VM host maintenance policy.
    pub on_host_maintenance: std::option::Option<crate::model::scheduling::OnHostMaintenance>,

    pub on_instance_stop_action: std::option::Option<crate::model::SchedulingOnInstanceStopAction>,

    /// Defines whether the instance is preemptible. This can only be set during
    /// instance creation or while the instance isstopped and
    /// therefore, in a `TERMINATED` state. SeeInstance Life
    /// Cycle for more information on the possible instance states.
    pub preemptible: std::option::Option<bool>,

    /// Specifies the provisioning model of the instance.
    pub provisioning_model: std::option::Option<crate::model::scheduling::ProvisioningModel>,

    /// Default is false and there will be 120 seconds between GCE ACPI G2 Soft
    /// Off and ACPI G3 Mechanical
    /// Off for Standard VMs and 30 seconds for Spot VMs.
    pub skip_guest_os_shutdown: std::option::Option<bool>,

    /// Specifies the timestamp, when the instance will be terminated, inRFC3339 text format. If specified, the instance
    /// termination action will be performed at the termination time.
    pub termination_time: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl Scheduling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [automatic_restart][crate::model::Scheduling::automatic_restart].
    pub fn set_automatic_restart<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.automatic_restart = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automatic_restart][crate::model::Scheduling::automatic_restart].
    pub fn set_or_clear_automatic_restart<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.automatic_restart = v.map(|x| x.into());
        self
    }

    /// Sets the value of [availability_domain][crate::model::Scheduling::availability_domain].
    pub fn set_availability_domain<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.availability_domain = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [availability_domain][crate::model::Scheduling::availability_domain].
    pub fn set_or_clear_availability_domain<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.availability_domain = v.map(|x| x.into());
        self
    }

    /// Sets the value of [host_error_timeout_seconds][crate::model::Scheduling::host_error_timeout_seconds].
    pub fn set_host_error_timeout_seconds<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.host_error_timeout_seconds = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [host_error_timeout_seconds][crate::model::Scheduling::host_error_timeout_seconds].
    pub fn set_or_clear_host_error_timeout_seconds<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.host_error_timeout_seconds = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_termination_action][crate::model::Scheduling::instance_termination_action].
    pub fn set_instance_termination_action<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::scheduling::InstanceTerminationAction>,
    {
        self.instance_termination_action = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_termination_action][crate::model::Scheduling::instance_termination_action].
    pub fn set_or_clear_instance_termination_action<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::scheduling::InstanceTerminationAction>,
    {
        self.instance_termination_action = v.map(|x| x.into());
        self
    }

    /// Sets the value of [local_ssd_recovery_timeout][crate::model::Scheduling::local_ssd_recovery_timeout].
    pub fn set_local_ssd_recovery_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Duration>,
    {
        self.local_ssd_recovery_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [local_ssd_recovery_timeout][crate::model::Scheduling::local_ssd_recovery_timeout].
    pub fn set_or_clear_local_ssd_recovery_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Duration>,
    {
        self.local_ssd_recovery_timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [location_hint][crate::model::Scheduling::location_hint].
    pub fn set_location_hint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.location_hint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [location_hint][crate::model::Scheduling::location_hint].
    pub fn set_or_clear_location_hint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.location_hint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_run_duration][crate::model::Scheduling::max_run_duration].
    pub fn set_max_run_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Duration>,
    {
        self.max_run_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_run_duration][crate::model::Scheduling::max_run_duration].
    pub fn set_or_clear_max_run_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Duration>,
    {
        self.max_run_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [min_node_cpus][crate::model::Scheduling::min_node_cpus].
    pub fn set_min_node_cpus<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.min_node_cpus = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_node_cpus][crate::model::Scheduling::min_node_cpus].
    pub fn set_or_clear_min_node_cpus<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.min_node_cpus = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_affinities][crate::model::Scheduling::node_affinities].
    pub fn set_node_affinities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SchedulingNodeAffinity>,
    {
        use std::iter::Iterator;
        self.node_affinities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [on_host_maintenance][crate::model::Scheduling::on_host_maintenance].
    pub fn set_on_host_maintenance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::scheduling::OnHostMaintenance>,
    {
        self.on_host_maintenance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [on_host_maintenance][crate::model::Scheduling::on_host_maintenance].
    pub fn set_or_clear_on_host_maintenance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::scheduling::OnHostMaintenance>,
    {
        self.on_host_maintenance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [on_instance_stop_action][crate::model::Scheduling::on_instance_stop_action].
    pub fn set_on_instance_stop_action<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SchedulingOnInstanceStopAction>,
    {
        self.on_instance_stop_action = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [on_instance_stop_action][crate::model::Scheduling::on_instance_stop_action].
    pub fn set_or_clear_on_instance_stop_action<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SchedulingOnInstanceStopAction>,
    {
        self.on_instance_stop_action = v.map(|x| x.into());
        self
    }

    /// Sets the value of [preemptible][crate::model::Scheduling::preemptible].
    pub fn set_preemptible<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.preemptible = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [preemptible][crate::model::Scheduling::preemptible].
    pub fn set_or_clear_preemptible<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.preemptible = v.map(|x| x.into());
        self
    }

    /// Sets the value of [provisioning_model][crate::model::Scheduling::provisioning_model].
    pub fn set_provisioning_model<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::scheduling::ProvisioningModel>,
    {
        self.provisioning_model = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provisioning_model][crate::model::Scheduling::provisioning_model].
    pub fn set_or_clear_provisioning_model<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::scheduling::ProvisioningModel>,
    {
        self.provisioning_model = v.map(|x| x.into());
        self
    }

    /// Sets the value of [skip_guest_os_shutdown][crate::model::Scheduling::skip_guest_os_shutdown].
    pub fn set_skip_guest_os_shutdown<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.skip_guest_os_shutdown = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [skip_guest_os_shutdown][crate::model::Scheduling::skip_guest_os_shutdown].
    pub fn set_or_clear_skip_guest_os_shutdown<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.skip_guest_os_shutdown = v.map(|x| x.into());
        self
    }

    /// Sets the value of [termination_time][crate::model::Scheduling::termination_time].
    pub fn set_termination_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.termination_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [termination_time][crate::model::Scheduling::termination_time].
    pub fn set_or_clear_termination_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.termination_time = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for Scheduling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Scheduling"
    }
}

/// Defines additional types related to [Scheduling].
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
pub mod scheduling {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [instanceTerminationAction][google.cloud.compute.v1.Scheduling.instanceTerminationAction] field.
    ///
    /// [google.cloud.compute.v1.Scheduling.instanceTerminationAction]: crate::model::scheduling::InstanceTerminationAction
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstanceTerminationAction {
        /// Delete the VM.
        Delete,
        /// Default value. This value is unused.
        Unspecified,
        /// Stop the VM without storing in-memory content. default action.
        Stop,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstanceTerminationAction::value] or
        /// [InstanceTerminationAction::name].
        UnknownValue(instance_termination_action::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod instance_termination_action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl InstanceTerminationAction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Delete => std::option::Option::Some(0),
                Self::Unspecified => std::option::Option::Some(1),
                Self::Stop => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::Unspecified => {
                    std::option::Option::Some("INSTANCE_TERMINATION_ACTION_UNSPECIFIED")
                }
                Self::Stop => std::option::Option::Some("STOP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for InstanceTerminationAction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for InstanceTerminationAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for InstanceTerminationAction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Delete,
                1 => Self::Unspecified,
                2 => Self::Stop,
                _ => Self::UnknownValue(instance_termination_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for InstanceTerminationAction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DELETE" => Self::Delete,
                "INSTANCE_TERMINATION_ACTION_UNSPECIFIED" => Self::Unspecified,
                "STOP" => Self::Stop,
                _ => Self::UnknownValue(instance_termination_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for InstanceTerminationAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Delete => serializer.serialize_str("DELETE"),
                Self::Unspecified => {
                    serializer.serialize_str("INSTANCE_TERMINATION_ACTION_UNSPECIFIED")
                }
                Self::Stop => serializer.serialize_str("STOP"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for InstanceTerminationAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<InstanceTerminationAction>::new(
                    ".google.cloud.compute.v1.Scheduling.instanceTerminationAction",
                ),
            )
        }
    }

    /// The enumerated type for the [onHostMaintenance][google.cloud.compute.v1.Scheduling.onHostMaintenance] field.
    ///
    /// [google.cloud.compute.v1.Scheduling.onHostMaintenance]: crate::model::scheduling::OnHostMaintenance
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OnHostMaintenance {
        /// *[Default]* Allows Compute Engine to automatically migrate instances
        /// out of the way of maintenance events.
        Migrate,
        /// Tells Compute Engine to terminate and (optionally) restart the instance
        /// away from the maintenance activity. If you would like your instance to be
        /// restarted, set the automaticRestart flag to true. Your
        /// instance may be restarted more than once, and it may be restarted outside
        /// the window of maintenance events.
        Terminate,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OnHostMaintenance::value] or
        /// [OnHostMaintenance::name].
        UnknownValue(on_host_maintenance::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod on_host_maintenance {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl OnHostMaintenance {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Migrate => std::option::Option::Some(0),
                Self::Terminate => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Migrate => std::option::Option::Some("MIGRATE"),
                Self::Terminate => std::option::Option::Some("TERMINATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for OnHostMaintenance {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for OnHostMaintenance {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for OnHostMaintenance {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Migrate,
                1 => Self::Terminate,
                _ => Self::UnknownValue(on_host_maintenance::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for OnHostMaintenance {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MIGRATE" => Self::Migrate,
                "TERMINATE" => Self::Terminate,
                _ => Self::UnknownValue(on_host_maintenance::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for OnHostMaintenance {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Migrate => serializer.serialize_str("MIGRATE"),
                Self::Terminate => serializer.serialize_str("TERMINATE"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for OnHostMaintenance {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OnHostMaintenance>::new(
                ".google.cloud.compute.v1.Scheduling.onHostMaintenance",
            ))
        }
    }

    /// The enumerated type for the [provisioningModel][google.cloud.compute.v1.Scheduling.provisioningModel] field.
    ///
    /// [google.cloud.compute.v1.Scheduling.provisioningModel]: crate::model::scheduling::ProvisioningModel
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ProvisioningModel {
        /// Instance is provisioned using the Flex Start provisioning model and
        /// has a limited runtime.
        FlexStart,
        /// Bound to the lifecycle of the reservation in which it is provisioned.
        ReservationBound,
        /// Heavily discounted, no guaranteed runtime.
        Spot,
        /// Standard provisioning with user controlled runtime, no discounts.
        Standard,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ProvisioningModel::value] or
        /// [ProvisioningModel::name].
        UnknownValue(provisioning_model::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod provisioning_model {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl ProvisioningModel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::FlexStart => std::option::Option::Some(0),
                Self::ReservationBound => std::option::Option::Some(1),
                Self::Spot => std::option::Option::Some(2),
                Self::Standard => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::FlexStart => std::option::Option::Some("FLEX_START"),
                Self::ReservationBound => std::option::Option::Some("RESERVATION_BOUND"),
                Self::Spot => std::option::Option::Some("SPOT"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for ProvisioningModel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for ProvisioningModel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for ProvisioningModel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::FlexStart,
                1 => Self::ReservationBound,
                2 => Self::Spot,
                3 => Self::Standard,
                _ => Self::UnknownValue(provisioning_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for ProvisioningModel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FLEX_START" => Self::FlexStart,
                "RESERVATION_BOUND" => Self::ReservationBound,
                "SPOT" => Self::Spot,
                "STANDARD" => Self::Standard,
                _ => Self::UnknownValue(provisioning_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for ProvisioningModel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::FlexStart => serializer.serialize_str("FLEX_START"),
                Self::ReservationBound => serializer.serialize_str("RESERVATION_BOUND"),
                Self::Spot => serializer.serialize_str("SPOT"),
                Self::Standard => serializer.serialize_str("STANDARD"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for ProvisioningModel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ProvisioningModel>::new(
                ".google.cloud.compute.v1.Scheduling.provisioningModel",
            ))
        }
    }
}

/// Node Affinity: the configuration of desired nodes onto which this Instance
/// could be scheduled.
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchedulingNodeAffinity {
    /// Corresponds to the label key of Node resource.
    pub key: std::option::Option<std::string::String>,

    /// Defines the operation of node selection. Valid operators areIN for affinity and NOT_IN for anti-affinity.
    pub operator: std::option::Option<crate::model::scheduling_node_affinity::Operator>,

    /// Corresponds to the label values of Node resource.
    pub values: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl SchedulingNodeAffinity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::SchedulingNodeAffinity::key].
    pub fn set_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key][crate::model::SchedulingNodeAffinity::key].
    pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operator][crate::model::SchedulingNodeAffinity::operator].
    pub fn set_operator<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::scheduling_node_affinity::Operator>,
    {
        self.operator = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [operator][crate::model::SchedulingNodeAffinity::operator].
    pub fn set_or_clear_operator<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::scheduling_node_affinity::Operator>,
    {
        self.operator = v.map(|x| x.into());
        self
    }

    /// Sets the value of [values][crate::model::SchedulingNodeAffinity::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for SchedulingNodeAffinity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.SchedulingNodeAffinity"
    }
}

/// Defines additional types related to [SchedulingNodeAffinity].
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
pub mod scheduling_node_affinity {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [operator][google.cloud.compute.v1.SchedulingNodeAffinity.operator] field.
    ///
    /// [google.cloud.compute.v1.SchedulingNodeAffinity.operator]: crate::model::scheduling_node_affinity::Operator
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Operator {
        /// Requires Compute Engine to seek for matched nodes.
        In,
        /// Requires Compute Engine to avoid certain nodes.
        NotIn,
        Unspecified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Operator::value] or
        /// [Operator::name].
        UnknownValue(operator::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    pub mod operator {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl Operator {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::In => std::option::Option::Some(0),
                Self::NotIn => std::option::Option::Some(1),
                Self::Unspecified => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::In => std::option::Option::Some("IN"),
                Self::NotIn => std::option::Option::Some("NOT_IN"),
                Self::Unspecified => std::option::Option::Some("OPERATOR_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::default::Default for Operator {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::fmt::Display for Operator {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<i32> for Operator {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::In,
                1 => Self::NotIn,
                2 => Self::Unspecified,
                _ => Self::UnknownValue(operator::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl std::convert::From<&str> for Operator {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IN" => Self::In,
                "NOT_IN" => Self::NotIn,
                "OPERATOR_UNSPECIFIED" => Self::Unspecified,
                _ => Self::UnknownValue(operator::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl serde::ser::Serialize for Operator {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::In => serializer.serialize_str("IN"),
                Self::NotIn => serializer.serialize_str("NOT_IN"),
                Self::Unspecified => serializer.serialize_str("OPERATOR_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instances",
        feature = "region-instance-templates",
        feature = "region-instances",
    ))]
    impl<'de> serde::de::Deserialize<'de> for Operator {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Operator>::new(
                ".google.cloud.compute.v1.SchedulingNodeAffinity.operator",
            ))
        }
    }
}

/// Defines the behaviour for instances with the instance_termination_actionSTOP.
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchedulingOnInstanceStopAction {
    /// If true, the contents of any attached Local SSD disks will be discarded
    /// else, the Local SSD data will be preserved when the instance is stopped
    /// at the end of the run duration/termination time.
    pub discard_local_ssd: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl SchedulingOnInstanceStopAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [discard_local_ssd][crate::model::SchedulingOnInstanceStopAction::discard_local_ssd].
    pub fn set_discard_local_ssd<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.discard_local_ssd = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [discard_local_ssd][crate::model::SchedulingOnInstanceStopAction::discard_local_ssd].
    pub fn set_or_clear_discard_local_ssd<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.discard_local_ssd = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for SchedulingOnInstanceStopAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.SchedulingOnInstanceStopAction"
    }
}

/// An instance's screenshot.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Screenshot {
    /// [Output Only] The Base64-encoded screenshot data.
    pub contents: std::option::Option<std::string::String>,

    /// [Output Only] Type of the resource. Always compute#screenshot
    /// for the screenshots.
    pub kind: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl Screenshot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [contents][crate::model::Screenshot::contents].
    pub fn set_contents<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.contents = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [contents][crate::model::Screenshot::contents].
    pub fn set_or_clear_contents<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.contents = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::Screenshot::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::Screenshot::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for Screenshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Screenshot"
    }
}

/// An instance serial console output.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SerialPortOutput {
    /// [Output Only] The contents of the console output.
    pub contents: std::option::Option<std::string::String>,

    /// [Output Only] Type of the resource. Alwayscompute#serialPortOutput for serial port output.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] The position of the next byte of content, regardless of
    /// whether the content exists, following the output returned in the `contents`
    /// property. Use this value in the next request as the start
    /// parameter.
    pub next: std::option::Option<i64>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// The starting byte position of the output that was returned.
    /// This should match the start parameter sent with the request.
    /// If the serial console output exceeds the size of the buffer (1 MB), older
    /// output is overwritten by newer content. The output start value will
    /// indicate the byte position of the output that was returned, which might be
    /// different than the `start` value that was specified in the request.
    pub start: std::option::Option<i64>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl SerialPortOutput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [contents][crate::model::SerialPortOutput::contents].
    pub fn set_contents<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.contents = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [contents][crate::model::SerialPortOutput::contents].
    pub fn set_or_clear_contents<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.contents = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::SerialPortOutput::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::SerialPortOutput::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next][crate::model::SerialPortOutput::next].
    pub fn set_next<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.next = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next][crate::model::SerialPortOutput::next].
    pub fn set_or_clear_next<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.next = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::SerialPortOutput::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::SerialPortOutput::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start][crate::model::SerialPortOutput::start].
    pub fn set_start<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.start = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start][crate::model::SerialPortOutput::start].
    pub fn set_or_clear_start<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.start = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for SerialPortOutput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.SerialPortOutput"
    }
}

/// A service account.
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ServiceAccount {
    /// Email address of the service account.
    pub email: std::option::Option<std::string::String>,

    /// The list of scopes to be made available for this service account.
    pub scopes: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl ServiceAccount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [email][crate::model::ServiceAccount::email].
    pub fn set_email<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.email = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [email][crate::model::ServiceAccount::email].
    pub fn set_or_clear_email<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.email = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scopes][crate::model::ServiceAccount::scopes].
    pub fn set_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for ServiceAccount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ServiceAccount"
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetCommonInstanceMetadataOperationMetadata {
    /// [Output Only] The client operation id.
    pub client_operation_id: std::option::Option<std::string::String>,

    /// [Output Only] Status information per location (location name is key).
    /// Example key: zones/us-central1-a
    pub per_location_operations: std::collections::HashMap<
        std::string::String,
        crate::model::SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo,
    >,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl SetCommonInstanceMetadataOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [client_operation_id][crate::model::SetCommonInstanceMetadataOperationMetadata::client_operation_id].
    pub fn set_client_operation_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.client_operation_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_operation_id][crate::model::SetCommonInstanceMetadataOperationMetadata::client_operation_id].
    pub fn set_or_clear_client_operation_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.client_operation_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [per_location_operations][crate::model::SetCommonInstanceMetadataOperationMetadata::per_location_operations].
    pub fn set_per_location_operations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<
                crate::model::SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo,
            >,
    {
        use std::iter::Iterator;
        self.per_location_operations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl wkt::message::Message for SetCommonInstanceMetadataOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.SetCommonInstanceMetadataOperationMetadata"
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo {

    /// [Output Only] If state is `ABANDONED` or `FAILED`, this field is
    /// populated.
    pub error: std::option::Option<crate::model::Status>,

    /// [Output Only] Status of the action, which can be one of the following:
    /// `PROPAGATING`, `PROPAGATED`, `ABANDONED`, `FAILED`, or `DONE`.
    pub state: std::option::Option<crate::model::set_common_instance_metadata_operation_metadata_per_location_operation_info::State>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error][crate::model::SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo::state].
    pub fn set_state<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::set_common_instance_metadata_operation_metadata_per_location_operation_info::State>
    {
        self.state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state][crate::model::SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo::state].
    pub fn set_or_clear_state<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::set_common_instance_metadata_operation_metadata_per_location_operation_info::State>
    {
        self.state = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl wkt::message::Message for SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo"
    }
}

/// Defines additional types related to [SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo].
#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
pub mod set_common_instance_metadata_operation_metadata_per_location_operation_info {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [state][google.cloud.compute.v1.SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo.state] field.
    ///
    /// [google.cloud.compute.v1.SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo.state]: crate::model::set_common_instance_metadata_operation_metadata_per_location_operation_info::State
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Operation not tracked in this location e.g. zone is marked as DOWN.
        Abandoned,
        /// Operation has completed successfully.
        Done,
        /// Operation is in an error state.
        Failed,
        /// Operation is confirmed to be in the location.
        Propagated,
        /// Operation is not yet confirmed to have been created in the location.
        Propagating,
        Unspecified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Abandoned => std::option::Option::Some(0),
                Self::Done => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Propagated => std::option::Option::Some(3),
                Self::Propagating => std::option::Option::Some(4),
                Self::Unspecified => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Abandoned => std::option::Option::Some("ABANDONED"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Propagated => std::option::Option::Some("PROPAGATED"),
                Self::Propagating => std::option::Option::Some("PROPAGATING"),
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Abandoned,
                1 => Self::Done,
                2 => Self::Failed,
                3 => Self::Propagated,
                4 => Self::Propagating,
                5 => Self::Unspecified,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ABANDONED" => Self::Abandoned,
                "DONE" => Self::Done,
                "FAILED" => Self::Failed,
                "PROPAGATED" => Self::Propagated,
                "PROPAGATING" => Self::Propagating,
                "UNSPECIFIED" => Self::Unspecified,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Abandoned => serializer.serialize_str("ABANDONED"),
                Self::Done => serializer.serialize_str("DONE"),
                Self::Failed => serializer.serialize_str("FAILED"),
                Self::Propagated => serializer.serialize_str("PROPAGATED"),
                Self::Propagating => serializer.serialize_str("PROPAGATING"),
                Self::Unspecified => serializer.serialize_str("UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "global-operations",
        feature = "global-organization-operations",
        feature = "images",
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
        feature = "zone-operations",
    ))]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.compute.v1.SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo.state"))
        }
    }
}

/// A set of Shielded Instance options.
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ShieldedInstanceConfig {
    /// Defines whether the instance has integrity monitoring enabled.Enabled by
    /// default.
    pub enable_integrity_monitoring: std::option::Option<bool>,

    /// Defines whether the instance has Secure Boot enabled.Disabled by
    /// default.
    pub enable_secure_boot: std::option::Option<bool>,

    /// Defines whether the instance has the vTPM enabled.Enabled by
    /// default.
    pub enable_vtpm: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl ShieldedInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_integrity_monitoring][crate::model::ShieldedInstanceConfig::enable_integrity_monitoring].
    pub fn set_enable_integrity_monitoring<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_integrity_monitoring = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_integrity_monitoring][crate::model::ShieldedInstanceConfig::enable_integrity_monitoring].
    pub fn set_or_clear_enable_integrity_monitoring<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_integrity_monitoring = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_secure_boot][crate::model::ShieldedInstanceConfig::enable_secure_boot].
    pub fn set_enable_secure_boot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_secure_boot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_secure_boot][crate::model::ShieldedInstanceConfig::enable_secure_boot].
    pub fn set_or_clear_enable_secure_boot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_secure_boot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_vtpm][crate::model::ShieldedInstanceConfig::enable_vtpm].
    pub fn set_enable_vtpm<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_vtpm = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_vtpm][crate::model::ShieldedInstanceConfig::enable_vtpm].
    pub fn set_or_clear_enable_vtpm<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_vtpm = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for ShieldedInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ShieldedInstanceConfig"
    }
}

/// A Shielded Instance Identity.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ShieldedInstanceIdentity {
    /// An Endorsement Key (EK) made by the RSA 2048 algorithm
    /// issued to the Shielded Instance's vTPM.
    pub encryption_key: std::option::Option<crate::model::ShieldedInstanceIdentityEntry>,

    /// [Output Only] Type of the resource. Alwayscompute#shieldedInstanceIdentity for shielded Instance
    /// identity entry.
    pub kind: std::option::Option<std::string::String>,

    /// An Attestation Key (AK) made by the RSA 2048 algorithm
    /// issued to the Shielded Instance's vTPM.
    pub signing_key: std::option::Option<crate::model::ShieldedInstanceIdentityEntry>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ShieldedInstanceIdentity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_key][crate::model::ShieldedInstanceIdentity::encryption_key].
    pub fn set_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceIdentityEntry>,
    {
        self.encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_key][crate::model::ShieldedInstanceIdentity::encryption_key].
    pub fn set_or_clear_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceIdentityEntry>,
    {
        self.encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::ShieldedInstanceIdentity::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::ShieldedInstanceIdentity::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [signing_key][crate::model::ShieldedInstanceIdentity::signing_key].
    pub fn set_signing_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceIdentityEntry>,
    {
        self.signing_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [signing_key][crate::model::ShieldedInstanceIdentity::signing_key].
    pub fn set_or_clear_signing_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceIdentityEntry>,
    {
        self.signing_key = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ShieldedInstanceIdentity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ShieldedInstanceIdentity"
    }
}

/// A Shielded Instance Identity Entry.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ShieldedInstanceIdentityEntry {
    /// A PEM-encoded X.509 certificate. This field can be empty.
    pub ek_cert: std::option::Option<std::string::String>,

    /// A PEM-encoded public key.
    pub ek_pub: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ShieldedInstanceIdentityEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ek_cert][crate::model::ShieldedInstanceIdentityEntry::ek_cert].
    pub fn set_ek_cert<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ek_cert = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ek_cert][crate::model::ShieldedInstanceIdentityEntry::ek_cert].
    pub fn set_or_clear_ek_cert<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ek_cert = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ek_pub][crate::model::ShieldedInstanceIdentityEntry::ek_pub].
    pub fn set_ek_pub<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ek_pub = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ek_pub][crate::model::ShieldedInstanceIdentityEntry::ek_pub].
    pub fn set_or_clear_ek_pub<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ek_pub = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ShieldedInstanceIdentityEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ShieldedInstanceIdentityEntry"
    }
}

/// The policy describes the baseline against which
/// Instance boot integrity is measured.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ShieldedInstanceIntegrityPolicy {
    /// Updates the integrity policy baseline using the
    /// measurements from the VM instance's most recent boot.
    pub update_auto_learn_policy: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ShieldedInstanceIntegrityPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_auto_learn_policy][crate::model::ShieldedInstanceIntegrityPolicy::update_auto_learn_policy].
    pub fn set_update_auto_learn_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.update_auto_learn_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_auto_learn_policy][crate::model::ShieldedInstanceIntegrityPolicy::update_auto_learn_policy].
    pub fn set_or_clear_update_auto_learn_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.update_auto_learn_policy = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ShieldedInstanceIntegrityPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ShieldedInstanceIntegrityPolicy"
    }
}

/// A specification of the parameters to use when creating the instance template
/// from a source instance.
#[cfg(feature = "region-instance-templates")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SourceInstanceParams {
    /// Attached disks configuration. If not provided, defaults are applied:
    /// For boot disk and any other R/W disks, the source images for each disk
    /// will be used. For read-only disks, they will be attached in read-only
    /// mode. Local SSD disks will be created as blank volumes.
    pub disk_configs: std::vec::Vec<crate::model::DiskInstantiationConfig>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "region-instance-templates")]
impl SourceInstanceParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disk_configs][crate::model::SourceInstanceParams::disk_configs].
    pub fn set_disk_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiskInstantiationConfig>,
    {
        use std::iter::Iterator;
        self.disk_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "region-instance-templates")]
impl wkt::message::Message for SourceInstanceParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.SourceInstanceParams"
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StatefulPolicy {
    pub preserved_state: std::option::Option<crate::model::StatefulPolicyPreservedState>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl StatefulPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [preserved_state][crate::model::StatefulPolicy::preserved_state].
    pub fn set_preserved_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::StatefulPolicyPreservedState>,
    {
        self.preserved_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [preserved_state][crate::model::StatefulPolicy::preserved_state].
    pub fn set_or_clear_preserved_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::StatefulPolicyPreservedState>,
    {
        self.preserved_state = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for StatefulPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.StatefulPolicy"
    }
}

/// Configuration of preserved resources.
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StatefulPolicyPreservedState {
    /// Disks created on the instances that will be preserved on instance
    /// delete, update, etc. This map is keyed with the device names of
    /// the disks.
    pub disks: std::collections::HashMap<
        std::string::String,
        crate::model::StatefulPolicyPreservedStateDiskDevice,
    >,

    /// External network IPs assigned to the instances that will be preserved on
    /// instance delete, update, etc. This map is keyed with the network
    /// interface name.
    pub external_i_ps: std::collections::HashMap<
        std::string::String,
        crate::model::StatefulPolicyPreservedStateNetworkIp,
    >,

    /// Internal network IPs assigned to the instances that will be preserved on
    /// instance delete, update, etc. This map is keyed with the network
    /// interface name.
    pub internal_i_ps: std::collections::HashMap<
        std::string::String,
        crate::model::StatefulPolicyPreservedStateNetworkIp,
    >,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl StatefulPolicyPreservedState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disks][crate::model::StatefulPolicyPreservedState::disks].
    pub fn set_disks<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::StatefulPolicyPreservedStateDiskDevice>,
    {
        use std::iter::Iterator;
        self.disks = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [external_i_ps][crate::model::StatefulPolicyPreservedState::external_i_ps].
    pub fn set_external_i_ps<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::StatefulPolicyPreservedStateNetworkIp>,
    {
        use std::iter::Iterator;
        self.external_i_ps = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [internal_i_ps][crate::model::StatefulPolicyPreservedState::internal_i_ps].
    pub fn set_internal_i_ps<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::StatefulPolicyPreservedStateNetworkIp>,
    {
        use std::iter::Iterator;
        self.internal_i_ps = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for StatefulPolicyPreservedState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.StatefulPolicyPreservedState"
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StatefulPolicyPreservedStateDiskDevice {
    /// These stateful disks will never be deleted during autohealing,
    /// update or VM instance recreate operations.
    /// This flag is used to configure if the disk should be deleted after it
    /// is no longer used by the group, e.g. when the given instance or
    /// the whole group is deleted. Note: disks attached inREAD_ONLY mode cannot be auto-deleted.
    pub auto_delete:
        std::option::Option<crate::model::stateful_policy_preserved_state_disk_device::AutoDelete>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl StatefulPolicyPreservedStateDiskDevice {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auto_delete][crate::model::StatefulPolicyPreservedStateDiskDevice::auto_delete].
    pub fn set_auto_delete<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::stateful_policy_preserved_state_disk_device::AutoDelete,
            >,
    {
        self.auto_delete = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [auto_delete][crate::model::StatefulPolicyPreservedStateDiskDevice::auto_delete].
    pub fn set_or_clear_auto_delete<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::stateful_policy_preserved_state_disk_device::AutoDelete,
            >,
    {
        self.auto_delete = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for StatefulPolicyPreservedStateDiskDevice {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.StatefulPolicyPreservedStateDiskDevice"
    }
}

/// Defines additional types related to [StatefulPolicyPreservedStateDiskDevice].
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
pub mod stateful_policy_preserved_state_disk_device {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [autoDelete][google.cloud.compute.v1.StatefulPolicyPreservedStateDiskDevice.autoDelete] field.
    ///
    /// [google.cloud.compute.v1.StatefulPolicyPreservedStateDiskDevice.autoDelete]: crate::model::stateful_policy_preserved_state_disk_device::AutoDelete
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AutoDelete {
        Never,
        OnPermanentInstanceDeletion,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AutoDelete::value] or
        /// [AutoDelete::name].
        UnknownValue(auto_delete::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod auto_delete {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl AutoDelete {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Never => std::option::Option::Some(0),
                Self::OnPermanentInstanceDeletion => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Never => std::option::Option::Some("NEVER"),
                Self::OnPermanentInstanceDeletion => {
                    std::option::Option::Some("ON_PERMANENT_INSTANCE_DELETION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for AutoDelete {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for AutoDelete {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for AutoDelete {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Never,
                1 => Self::OnPermanentInstanceDeletion,
                _ => Self::UnknownValue(auto_delete::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for AutoDelete {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NEVER" => Self::Never,
                "ON_PERMANENT_INSTANCE_DELETION" => Self::OnPermanentInstanceDeletion,
                _ => Self::UnknownValue(auto_delete::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for AutoDelete {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Never => serializer.serialize_str("NEVER"),
                Self::OnPermanentInstanceDeletion => {
                    serializer.serialize_str("ON_PERMANENT_INSTANCE_DELETION")
                }
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for AutoDelete {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AutoDelete>::new(
                ".google.cloud.compute.v1.StatefulPolicyPreservedStateDiskDevice.autoDelete",
            ))
        }
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StatefulPolicyPreservedStateNetworkIp {
    /// These stateful IPs will never be released during autohealing,
    /// update or VM instance recreate operations.
    /// This flag is used to configure if the IP reservation should be deleted
    /// after it is no longer used by the group, e.g. when the given instance
    /// or the whole group is deleted.
    pub auto_delete:
        std::option::Option<crate::model::stateful_policy_preserved_state_network_ip::AutoDelete>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl StatefulPolicyPreservedStateNetworkIp {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [auto_delete][crate::model::StatefulPolicyPreservedStateNetworkIp::auto_delete].
    pub fn set_auto_delete<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::stateful_policy_preserved_state_network_ip::AutoDelete>,
    {
        self.auto_delete = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [auto_delete][crate::model::StatefulPolicyPreservedStateNetworkIp::auto_delete].
    pub fn set_or_clear_auto_delete<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::stateful_policy_preserved_state_network_ip::AutoDelete>,
    {
        self.auto_delete = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
impl wkt::message::Message for StatefulPolicyPreservedStateNetworkIp {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.StatefulPolicyPreservedStateNetworkIp"
    }
}

/// Defines additional types related to [StatefulPolicyPreservedStateNetworkIp].
#[cfg(any(
    feature = "instance-group-managers",
    feature = "region-instance-group-managers",
))]
pub mod stateful_policy_preserved_state_network_ip {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [autoDelete][google.cloud.compute.v1.StatefulPolicyPreservedStateNetworkIp.autoDelete] field.
    ///
    /// [google.cloud.compute.v1.StatefulPolicyPreservedStateNetworkIp.autoDelete]: crate::model::stateful_policy_preserved_state_network_ip::AutoDelete
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AutoDelete {
        Never,
        OnPermanentInstanceDeletion,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AutoDelete::value] or
        /// [AutoDelete::name].
        UnknownValue(auto_delete::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    pub mod auto_delete {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl AutoDelete {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Never => std::option::Option::Some(0),
                Self::OnPermanentInstanceDeletion => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Never => std::option::Option::Some("NEVER"),
                Self::OnPermanentInstanceDeletion => {
                    std::option::Option::Some("ON_PERMANENT_INSTANCE_DELETION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::default::Default for AutoDelete {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::fmt::Display for AutoDelete {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<i32> for AutoDelete {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Never,
                1 => Self::OnPermanentInstanceDeletion,
                _ => Self::UnknownValue(auto_delete::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl std::convert::From<&str> for AutoDelete {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NEVER" => Self::Never,
                "ON_PERMANENT_INSTANCE_DELETION" => Self::OnPermanentInstanceDeletion,
                _ => Self::UnknownValue(auto_delete::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl serde::ser::Serialize for AutoDelete {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Never => serializer.serialize_str("NEVER"),
                Self::OnPermanentInstanceDeletion => {
                    serializer.serialize_str("ON_PERMANENT_INSTANCE_DELETION")
                }
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(
        feature = "instance-group-managers",
        feature = "region-instance-group-managers",
    ))]
    impl<'de> serde::de::Deserialize<'de> for AutoDelete {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AutoDelete>::new(
                ".google.cloud.compute.v1.StatefulPolicyPreservedStateNetworkIp.autoDelete",
            ))
        }
    }
}

/// The `Status` type defines a logical error model that is suitable for
/// different programming environments, including REST APIs and RPC APIs. It is
/// used by [gRPC](https://github.com/grpc). Each `Status` message contains
/// three pieces of data: error code, error message, and error details.
///
/// You can find out more about this error model and how to work with it in the
/// [API Design Guide](https://cloud.google.com/apis/design/errors).
#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Status {
    /// The status code, which should be an enum value of google.rpc.Code.
    pub code: std::option::Option<i32>,

    /// A list of messages that carry the error details.  There is a common set of
    /// message types for APIs to use.
    pub details: std::vec::Vec<wkt::Any>,

    /// A developer-facing error message, which should be in English. Any
    /// user-facing error message should be localized and sent in the
    /// google.rpc.Status.details field, or localized by the client.
    pub message: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl Status {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::Status::code].
    pub fn set_code<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.code = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [code][crate::model::Status::code].
    pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.code = v.map(|x| x.into());
        self
    }

    /// Sets the value of [details][crate::model::Status::details].
    pub fn set_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Any>,
    {
        use std::iter::Iterator;
        self.details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [message][crate::model::Status::message].
    pub fn set_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.message = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [message][crate::model::Status::message].
    pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.message = v.map(|x| x.into());
        self
    }
}

#[cfg(any(
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
))]
impl wkt::message::Message for Status {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Status"
    }
}

/// A set of instance tags.
#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Tags {
    /// Specifies a fingerprint for this request, which is essentially a hash of
    /// the tags' contents and used for optimistic locking. The
    /// fingerprint is initially generated by Compute Engine and changes after
    /// every request to modify or update tags. You must always provide an
    /// up-to-date fingerprint hash in order to update or change tags.
    ///
    /// To see the latest fingerprint, make get() request to the
    /// instance.
    pub fingerprint: std::option::Option<::bytes::Bytes>,

    /// An array of tags. Each tag must be 1-63 characters long, and comply
    /// with RFC1035.
    pub items: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl Tags {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fingerprint][crate::model::Tags::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::Tags::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::Tags::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "instances",
    feature = "region-instance-templates",
    feature = "region-instances",
))]
impl wkt::message::Message for Tags {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Tags"
    }
}

#[cfg(any(
    feature = "images",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-groups",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TestPermissionsRequest {
    /// The set of permissions to check for the 'resource'. Permissions with
    /// wildcards (such as '*' or 'storage.*') are not allowed.
    pub permissions: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "images",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-groups",
))]
impl TestPermissionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [permissions][crate::model::TestPermissionsRequest::permissions].
    pub fn set_permissions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.permissions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "images",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-groups",
))]
impl wkt::message::Message for TestPermissionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.TestPermissionsRequest"
    }
}

#[cfg(any(
    feature = "images",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-groups",
))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TestPermissionsResponse {
    /// A subset of `TestPermissionsRequest.permissions` that the caller is
    /// allowed.
    pub permissions: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(
    feature = "images",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-groups",
))]
impl TestPermissionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [permissions][crate::model::TestPermissionsResponse::permissions].
    pub fn set_permissions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.permissions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(
    feature = "images",
    feature = "instance-groups",
    feature = "instances",
    feature = "region-instance-groups",
))]
impl wkt::message::Message for TestPermissionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.TestPermissionsResponse"
    }
}

/// Upcoming Maintenance notification information.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpcomingMaintenance {
    /// Indicates if the maintenance can be customer triggered.
    pub can_reschedule: std::option::Option<bool>,

    /// The latest time for the planned maintenance window to start.
    /// This timestamp value is in RFC3339 text format.
    pub latest_window_start_time: std::option::Option<std::string::String>,

    /// Indicates whether the UpcomingMaintenance will be triggered on VM shutdown.
    pub maintenance_on_shutdown: std::option::Option<bool>,

    /// The reasons for the maintenance. Only valid for vms.
    pub maintenance_reasons: std::vec::Vec<crate::model::upcoming_maintenance::MaintenanceReasons>,

    pub maintenance_status:
        std::option::Option<crate::model::upcoming_maintenance::MaintenanceStatus>,

    /// Defines the type of maintenance.
    pub r#type: std::option::Option<crate::model::upcoming_maintenance::Type>,

    /// The time by which the maintenance disruption will be completed.
    /// This timestamp value is in RFC3339 text format.
    pub window_end_time: std::option::Option<std::string::String>,

    /// The current start time of the maintenance window.
    /// This timestamp value is in RFC3339 text format.
    pub window_start_time: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl UpcomingMaintenance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [can_reschedule][crate::model::UpcomingMaintenance::can_reschedule].
    pub fn set_can_reschedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.can_reschedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [can_reschedule][crate::model::UpcomingMaintenance::can_reschedule].
    pub fn set_or_clear_can_reschedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.can_reschedule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [latest_window_start_time][crate::model::UpcomingMaintenance::latest_window_start_time].
    pub fn set_latest_window_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.latest_window_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [latest_window_start_time][crate::model::UpcomingMaintenance::latest_window_start_time].
    pub fn set_or_clear_latest_window_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.latest_window_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_on_shutdown][crate::model::UpcomingMaintenance::maintenance_on_shutdown].
    pub fn set_maintenance_on_shutdown<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.maintenance_on_shutdown = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_on_shutdown][crate::model::UpcomingMaintenance::maintenance_on_shutdown].
    pub fn set_or_clear_maintenance_on_shutdown<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.maintenance_on_shutdown = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_reasons][crate::model::UpcomingMaintenance::maintenance_reasons].
    pub fn set_maintenance_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::upcoming_maintenance::MaintenanceReasons>,
    {
        use std::iter::Iterator;
        self.maintenance_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [maintenance_status][crate::model::UpcomingMaintenance::maintenance_status].
    pub fn set_maintenance_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::upcoming_maintenance::MaintenanceStatus>,
    {
        self.maintenance_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_status][crate::model::UpcomingMaintenance::maintenance_status].
    pub fn set_or_clear_maintenance_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::upcoming_maintenance::MaintenanceStatus>,
    {
        self.maintenance_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::UpcomingMaintenance::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::upcoming_maintenance::Type>,
    {
        self.r#type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#type][crate::model::UpcomingMaintenance::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::upcoming_maintenance::Type>,
    {
        self.r#type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [window_end_time][crate::model::UpcomingMaintenance::window_end_time].
    pub fn set_window_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.window_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [window_end_time][crate::model::UpcomingMaintenance::window_end_time].
    pub fn set_or_clear_window_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.window_end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [window_start_time][crate::model::UpcomingMaintenance::window_start_time].
    pub fn set_window_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.window_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [window_start_time][crate::model::UpcomingMaintenance::window_start_time].
    pub fn set_or_clear_window_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.window_start_time = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for UpcomingMaintenance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.UpcomingMaintenance"
    }
}

/// Defines additional types related to [UpcomingMaintenance].
#[cfg(feature = "instances")]
pub mod upcoming_maintenance {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [maintenanceReasons][google.cloud.compute.v1.UpcomingMaintenance.maintenanceReasons] field.
    ///
    /// [google.cloud.compute.v1.UpcomingMaintenance.maintenanceReasons]: crate::model::upcoming_maintenance::MaintenanceReasons
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MaintenanceReasons {
        /// Maintenance due to disk errors.
        FailureDisk,
        /// Maintenance due to GPU errors.
        FailureGpu,
        /// Maintenance due to customer reported multiple faulty hosts via R&R
        /// Subblock API.
        FailureGpuMultipleFaultyHostsCustomerReported,
        /// Maintenance due to customer reported NVLink switch failure via R&R
        /// Subblock API.
        FailureGpuNvlinkSwitchCustomerReported,
        /// Maintenance due to high GPU temperature.
        FailureGpuTemperature,
        /// Maintenance due to GPU xid failure.
        FailureGpuXid,
        /// Maintenance due to infrastructure errors.
        FailureInfra,
        /// Maintenance due to interface errors.
        FailureInterface,
        /// Maintenance due to memory errors.
        FailureMemory,
        /// Maintenance due to network errors.
        FailureNetwork,
        /// Maintenance due to NVLink failure.
        FailureNvlink,
        /// Maintenance due to redundant hardware fault.
        FailureRedundantHardwareFault,
        /// Maintenance due to infrastructure relocation.
        InfrastructureRelocation,
        /// Unknown maintenance reason. Do not use this value.
        MaintenanceReasonUnknown,
        /// Maintenance due to planned network update.
        PlannedNetworkUpdate,
        /// Maintenance due to planned update to the instance.
        PlannedUpdate,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MaintenanceReasons::value] or
        /// [MaintenanceReasons::name].
        UnknownValue(maintenance_reasons::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod maintenance_reasons {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl MaintenanceReasons {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::FailureDisk => std::option::Option::Some(0),
                Self::FailureGpu => std::option::Option::Some(1),
                Self::FailureGpuMultipleFaultyHostsCustomerReported => std::option::Option::Some(2),
                Self::FailureGpuNvlinkSwitchCustomerReported => std::option::Option::Some(3),
                Self::FailureGpuTemperature => std::option::Option::Some(4),
                Self::FailureGpuXid => std::option::Option::Some(5),
                Self::FailureInfra => std::option::Option::Some(6),
                Self::FailureInterface => std::option::Option::Some(7),
                Self::FailureMemory => std::option::Option::Some(8),
                Self::FailureNetwork => std::option::Option::Some(9),
                Self::FailureNvlink => std::option::Option::Some(10),
                Self::FailureRedundantHardwareFault => std::option::Option::Some(11),
                Self::InfrastructureRelocation => std::option::Option::Some(12),
                Self::MaintenanceReasonUnknown => std::option::Option::Some(13),
                Self::PlannedNetworkUpdate => std::option::Option::Some(14),
                Self::PlannedUpdate => std::option::Option::Some(15),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::FailureDisk => std::option::Option::Some("FAILURE_DISK"),
                Self::FailureGpu => std::option::Option::Some("FAILURE_GPU"),
                Self::FailureGpuMultipleFaultyHostsCustomerReported => {
                    std::option::Option::Some("FAILURE_GPU_MULTIPLE_FAULTY_HOSTS_CUSTOMER_REPORTED")
                }
                Self::FailureGpuNvlinkSwitchCustomerReported => {
                    std::option::Option::Some("FAILURE_GPU_NVLINK_SWITCH_CUSTOMER_REPORTED")
                }
                Self::FailureGpuTemperature => std::option::Option::Some("FAILURE_GPU_TEMPERATURE"),
                Self::FailureGpuXid => std::option::Option::Some("FAILURE_GPU_XID"),
                Self::FailureInfra => std::option::Option::Some("FAILURE_INFRA"),
                Self::FailureInterface => std::option::Option::Some("FAILURE_INTERFACE"),
                Self::FailureMemory => std::option::Option::Some("FAILURE_MEMORY"),
                Self::FailureNetwork => std::option::Option::Some("FAILURE_NETWORK"),
                Self::FailureNvlink => std::option::Option::Some("FAILURE_NVLINK"),
                Self::FailureRedundantHardwareFault => {
                    std::option::Option::Some("FAILURE_REDUNDANT_HARDWARE_FAULT")
                }
                Self::InfrastructureRelocation => {
                    std::option::Option::Some("INFRASTRUCTURE_RELOCATION")
                }
                Self::MaintenanceReasonUnknown => {
                    std::option::Option::Some("MAINTENANCE_REASON_UNKNOWN")
                }
                Self::PlannedNetworkUpdate => std::option::Option::Some("PLANNED_NETWORK_UPDATE"),
                Self::PlannedUpdate => std::option::Option::Some("PLANNED_UPDATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for MaintenanceReasons {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for MaintenanceReasons {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for MaintenanceReasons {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::FailureDisk,
                1 => Self::FailureGpu,
                2 => Self::FailureGpuMultipleFaultyHostsCustomerReported,
                3 => Self::FailureGpuNvlinkSwitchCustomerReported,
                4 => Self::FailureGpuTemperature,
                5 => Self::FailureGpuXid,
                6 => Self::FailureInfra,
                7 => Self::FailureInterface,
                8 => Self::FailureMemory,
                9 => Self::FailureNetwork,
                10 => Self::FailureNvlink,
                11 => Self::FailureRedundantHardwareFault,
                12 => Self::InfrastructureRelocation,
                13 => Self::MaintenanceReasonUnknown,
                14 => Self::PlannedNetworkUpdate,
                15 => Self::PlannedUpdate,
                _ => Self::UnknownValue(maintenance_reasons::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for MaintenanceReasons {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FAILURE_DISK" => Self::FailureDisk,
                "FAILURE_GPU" => Self::FailureGpu,
                "FAILURE_GPU_MULTIPLE_FAULTY_HOSTS_CUSTOMER_REPORTED" => {
                    Self::FailureGpuMultipleFaultyHostsCustomerReported
                }
                "FAILURE_GPU_NVLINK_SWITCH_CUSTOMER_REPORTED" => {
                    Self::FailureGpuNvlinkSwitchCustomerReported
                }
                "FAILURE_GPU_TEMPERATURE" => Self::FailureGpuTemperature,
                "FAILURE_GPU_XID" => Self::FailureGpuXid,
                "FAILURE_INFRA" => Self::FailureInfra,
                "FAILURE_INTERFACE" => Self::FailureInterface,
                "FAILURE_MEMORY" => Self::FailureMemory,
                "FAILURE_NETWORK" => Self::FailureNetwork,
                "FAILURE_NVLINK" => Self::FailureNvlink,
                "FAILURE_REDUNDANT_HARDWARE_FAULT" => Self::FailureRedundantHardwareFault,
                "INFRASTRUCTURE_RELOCATION" => Self::InfrastructureRelocation,
                "MAINTENANCE_REASON_UNKNOWN" => Self::MaintenanceReasonUnknown,
                "PLANNED_NETWORK_UPDATE" => Self::PlannedNetworkUpdate,
                "PLANNED_UPDATE" => Self::PlannedUpdate,
                _ => Self::UnknownValue(maintenance_reasons::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for MaintenanceReasons {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::FailureDisk => serializer.serialize_str("FAILURE_DISK"),
                Self::FailureGpu => serializer.serialize_str("FAILURE_GPU"),
                Self::FailureGpuMultipleFaultyHostsCustomerReported => {
                    serializer.serialize_str("FAILURE_GPU_MULTIPLE_FAULTY_HOSTS_CUSTOMER_REPORTED")
                }
                Self::FailureGpuNvlinkSwitchCustomerReported => {
                    serializer.serialize_str("FAILURE_GPU_NVLINK_SWITCH_CUSTOMER_REPORTED")
                }
                Self::FailureGpuTemperature => serializer.serialize_str("FAILURE_GPU_TEMPERATURE"),
                Self::FailureGpuXid => serializer.serialize_str("FAILURE_GPU_XID"),
                Self::FailureInfra => serializer.serialize_str("FAILURE_INFRA"),
                Self::FailureInterface => serializer.serialize_str("FAILURE_INTERFACE"),
                Self::FailureMemory => serializer.serialize_str("FAILURE_MEMORY"),
                Self::FailureNetwork => serializer.serialize_str("FAILURE_NETWORK"),
                Self::FailureNvlink => serializer.serialize_str("FAILURE_NVLINK"),
                Self::FailureRedundantHardwareFault => {
                    serializer.serialize_str("FAILURE_REDUNDANT_HARDWARE_FAULT")
                }
                Self::InfrastructureRelocation => {
                    serializer.serialize_str("INFRASTRUCTURE_RELOCATION")
                }
                Self::MaintenanceReasonUnknown => {
                    serializer.serialize_str("MAINTENANCE_REASON_UNKNOWN")
                }
                Self::PlannedNetworkUpdate => serializer.serialize_str("PLANNED_NETWORK_UPDATE"),
                Self::PlannedUpdate => serializer.serialize_str("PLANNED_UPDATE"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for MaintenanceReasons {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MaintenanceReasons>::new(
                ".google.cloud.compute.v1.UpcomingMaintenance.maintenanceReasons",
            ))
        }
    }

    /// The enumerated type for the [maintenanceStatus][google.cloud.compute.v1.UpcomingMaintenance.maintenanceStatus] field.
    ///
    /// [google.cloud.compute.v1.UpcomingMaintenance.maintenanceStatus]: crate::model::upcoming_maintenance::MaintenanceStatus
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MaintenanceStatus {
        /// There is ongoing maintenance on this VM.
        Ongoing,
        /// There is pending maintenance.
        Pending,
        /// Unknown maintenance status. Do not use this value.
        Unknown,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MaintenanceStatus::value] or
        /// [MaintenanceStatus::name].
        UnknownValue(maintenance_status::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod maintenance_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl MaintenanceStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Ongoing => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Unknown => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Ongoing => std::option::Option::Some("ONGOING"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for MaintenanceStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for MaintenanceStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for MaintenanceStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Ongoing,
                1 => Self::Pending,
                2 => Self::Unknown,
                _ => Self::UnknownValue(maintenance_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for MaintenanceStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ONGOING" => Self::Ongoing,
                "PENDING" => Self::Pending,
                "UNKNOWN" => Self::Unknown,
                _ => Self::UnknownValue(maintenance_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for MaintenanceStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Ongoing => serializer.serialize_str("ONGOING"),
                Self::Pending => serializer.serialize_str("PENDING"),
                Self::Unknown => serializer.serialize_str("UNKNOWN"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for MaintenanceStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MaintenanceStatus>::new(
                ".google.cloud.compute.v1.UpcomingMaintenance.maintenanceStatus",
            ))
        }
    }

    /// The enumerated type for the [type][google.cloud.compute.v1.UpcomingMaintenance.type] field.
    ///
    /// [google.cloud.compute.v1.UpcomingMaintenance.type]: crate::model::upcoming_maintenance::Type
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Multiple maintenance types in one window.
        /// This is only intended to be used for groups.
        Multiple,
        /// Scheduled maintenance (e.g. maintenance after uptime guarantee is
        /// complete).
        Scheduled,
        /// No type specified. Do not use this value.
        UnknownType,
        /// Unscheduled maintenance (e.g. emergency maintenance during
        /// uptime guarantee).
        Unscheduled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Multiple => std::option::Option::Some(0),
                Self::Scheduled => std::option::Option::Some(1),
                Self::UnknownType => std::option::Option::Some(2),
                Self::Unscheduled => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Multiple => std::option::Option::Some("MULTIPLE"),
                Self::Scheduled => std::option::Option::Some("SCHEDULED"),
                Self::UnknownType => std::option::Option::Some("UNKNOWN_TYPE"),
                Self::Unscheduled => std::option::Option::Some("UNSCHEDULED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Multiple,
                1 => Self::Scheduled,
                2 => Self::UnknownType,
                3 => Self::Unscheduled,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MULTIPLE" => Self::Multiple,
                "SCHEDULED" => Self::Scheduled,
                "UNKNOWN_TYPE" => Self::UnknownType,
                "UNSCHEDULED" => Self::Unscheduled,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Multiple => serializer.serialize_str("MULTIPLE"),
                Self::Scheduled => serializer.serialize_str("SCHEDULED"),
                Self::UnknownType => serializer.serialize_str("UNKNOWN_TYPE"),
                Self::Unscheduled => serializer.serialize_str("UNSCHEDULED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.compute.v1.UpcomingMaintenance.type",
            ))
        }
    }
}

/// Represents a Zone resource.
///
/// A zone is a deployment area. These deployment areas are subsets of a region.
/// For example the zone us-east1-b is located in theus-east1 region. For more information, readRegions and
/// Zones.
#[cfg(feature = "zones")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Zone {
    /// [Output Only] Available cpu/platform selections for the zone.
    pub available_cpu_platforms: std::vec::Vec<std::string::String>,

    /// [Output Only] Creation timestamp inRFC3339
    /// text format.
    pub creation_timestamp: std::option::Option<std::string::String>,

    /// [Output Only] The deprecation status associated with this zone.
    pub deprecated: std::option::Option<crate::model::DeprecationStatus>,

    /// [Output Only] Textual description of the resource.
    pub description: std::option::Option<std::string::String>,

    /// [Output Only] The unique identifier for the resource. This identifier is
    /// defined by the server.
    pub id: std::option::Option<u64>,

    /// [Output Only] Type of the resource. Always compute#zone for
    /// zones.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] Name of the resource.
    pub name: std::option::Option<std::string::String>,

    /// [Output Only] Full URL reference to the region which hosts the zone.
    pub region: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for the resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Status of the zone, either UP orDOWN.
    pub status: std::option::Option<crate::model::zone::Status>,

    /// [Output Only] Reserved for future use.
    pub supports_pzs: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "zones")]
impl Zone {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [available_cpu_platforms][crate::model::Zone::available_cpu_platforms].
    pub fn set_available_cpu_platforms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.available_cpu_platforms = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [creation_timestamp][crate::model::Zone::creation_timestamp].
    pub fn set_creation_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_timestamp][crate::model::Zone::creation_timestamp].
    pub fn set_or_clear_creation_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deprecated][crate::model::Zone::deprecated].
    pub fn set_deprecated<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeprecationStatus>,
    {
        self.deprecated = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deprecated][crate::model::Zone::deprecated].
    pub fn set_or_clear_deprecated<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeprecationStatus>,
    {
        self.deprecated = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::Zone::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::Zone::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::Zone::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::Zone::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::Zone::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::Zone::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::Zone::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::Zone::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [region][crate::model::Zone::region].
    pub fn set_region<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.region = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [region][crate::model::Zone::region].
    pub fn set_or_clear_region<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.region = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::Zone::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::Zone::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::Zone::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::zone::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::Zone::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::zone::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [supports_pzs][crate::model::Zone::supports_pzs].
    pub fn set_supports_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.supports_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [supports_pzs][crate::model::Zone::supports_pzs].
    pub fn set_or_clear_supports_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.supports_pzs = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "zones")]
impl wkt::message::Message for Zone {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Zone"
    }
}

/// Defines additional types related to [Zone].
#[cfg(feature = "zones")]
pub mod zone {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [status][google.cloud.compute.v1.Zone.status] field.
    ///
    /// [google.cloud.compute.v1.Zone.status]: crate::model::zone::Status
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "zones")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        Down,
        Up,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "zones")]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "zones")]
    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Down => std::option::Option::Some(0),
                Self::Up => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Down => std::option::Option::Some("DOWN"),
                Self::Up => std::option::Option::Some("UP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "zones")]
    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "zones")]
    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "zones")]
    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Down,
                1 => Self::Up,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "zones")]
    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DOWN" => Self::Down,
                "UP" => Self::Up,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "zones")]
    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Down => serializer.serialize_str("DOWN"),
                Self::Up => serializer.serialize_str("UP"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "zones")]
    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.cloud.compute.v1.Zone.status",
            ))
        }
    }
}

/// Contains a list of zone resources.
#[cfg(feature = "zones")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ZoneList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of Zone resources.
    pub items: std::vec::Vec<crate::model::Zone>,

    /// Type of resource.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for
    /// list requests. If the number of results is larger thanmaxResults, use the nextPageToken as a value for
    /// the query parameter pageToken in the next list request.
    /// Subsequent list requests will have their own nextPageToken to
    /// continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::zone_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "zones")]
impl ZoneList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::ZoneList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::ZoneList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::ZoneList::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Zone>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::ZoneList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::ZoneList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::ZoneList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::ZoneList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::ZoneList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::ZoneList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::ZoneList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::zone_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::ZoneList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::zone_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "zones")]
impl wkt::message::Message for ZoneList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ZoneList"
    }
}

#[cfg(feature = "zones")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ZoneList {
    type PageItem = crate::model::Zone;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [ZoneList].
#[cfg(feature = "zones")]
pub mod zone_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.ZoneList.warning] field.
    ///
    /// [google.cloud.compute.v1.ZoneList.warning]: crate::model::zone_list::Warning
    #[cfg(feature = "zones")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute
        /// Engine returns NO_RESULTS_ON_PAGE if there
        /// are no results in the response.
        pub code: std::option::Option<crate::model::zone_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key:
        /// value format. For example:
        ///
        /// "data": [
        /// {
        /// "key": "scope",
        /// "value": "zones/us-east1-d"
        /// }
        pub data: std::vec::Vec<crate::model::zone_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "zones")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::zone_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::zone_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::zone_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::zone_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::zone_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::zone_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::zone_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::zone_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "zones")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.ZoneList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "zones")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.ZoneList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.ZoneList.warning.data]: crate::model::zone_list::warning::Data
        #[cfg(feature = "zones")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being
            /// returned. For example, for warnings where there are no results in a list
            /// request for a particular zone, this key might be scope and
            /// the key value might be the zone name. Other examples might be a key
            /// indicating a deprecated resource and a suggested replacement, or a
            /// warning about invalid network settings (for example, if an instance
            /// attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "zones")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::zone_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::zone_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::zone_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::zone_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "zones")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.ZoneList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.ZoneList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.ZoneList.warning.code]: crate::model::zone_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "zones")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed
            /// operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as
            /// deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as
            /// experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden.
            /// Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is
            /// not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed
            /// which captures the amount of resources filtered out by
            /// user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the
            /// network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an
            /// ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the
            /// same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite
            /// the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g:
            /// regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not
            /// accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted
            /// because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but
            /// its application does not make a lot of sense, because it allows only
            /// single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "zones")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "zones")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "zones")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "zones")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "zones")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "zones")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "zones")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "zones")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.ZoneList.warning.code",
                ))
            }
        }
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ZoneSetPolicyRequest {
    /// Flatten Policy to create a backwacd compatible wire-format.
    /// Deprecated. Use 'policy' to specify bindings.
    pub bindings: std::vec::Vec<crate::model::Binding>,

    /// Flatten Policy to create a backward compatible wire-format.
    /// Deprecated. Use 'policy' to specify the etag.
    pub etag: std::option::Option<::bytes::Bytes>,

    /// REQUIRED: The complete policy to be applied to the 'resource'. The size of
    /// the policy is limited to a few 10s of KB. An empty policy is in general a
    /// valid policy but certain services (like Projects) might reject them.
    pub policy: std::option::Option<crate::model::Policy>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ZoneSetPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bindings][crate::model::ZoneSetPolicyRequest::bindings].
    pub fn set_bindings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Binding>,
    {
        use std::iter::Iterator;
        self.bindings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [etag][crate::model::ZoneSetPolicyRequest::etag].
    pub fn set_etag<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.etag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [etag][crate::model::ZoneSetPolicyRequest::etag].
    pub fn set_or_clear_etag<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.etag = v.map(|x| x.into());
        self
    }

    /// Sets the value of [policy][crate::model::ZoneSetPolicyRequest::policy].
    pub fn set_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Policy>,
    {
        self.policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy][crate::model::ZoneSetPolicyRequest::policy].
    pub fn set_or_clear_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Policy>,
    {
        self.policy = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ZoneSetPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ZoneSetPolicyRequest"
    }
}

/// Synthetic messages for the [globalOperations][google.cloud.compute.v1.globalOperations] service
///
/// [google.cloud.compute.v1.globalOperations]: crate::model::GlobalOperations
#[cfg(any(feature = "global-operations", feature = "images",))]
pub mod global_operations {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [aggregatedList()][google.cloud.compute.v1.globalOperations.aggregatedList] method.
    ///
    /// [google.cloud.compute.v1.globalOperations.aggregatedList]: crate::client::GlobalOperations::aggregated_list
    #[cfg(feature = "global-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AggregatedListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// Indicates whether every visible scope for each scope type (zone, region,
        /// global) should be included in the response. For new resource types added
        /// after this field, the flag has no effect as new resource types will always
        /// include every visible scope for each scope type in response. For resource
        /// types which predate this field, if this flag is omitted or false, only
        /// scopes of the scope types where the resource type is expected to be found
        /// will be included.
        pub include_all_scopes: std::option::Option<bool>,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The Shared VPC service project id or service project number for which
        /// aggregated list request is invoked for subnetworks list-usable api.
        pub service_project_number: std::option::Option<i64>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "global-operations")]
    impl AggregatedListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::global_operations::AggregatedListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::global_operations::AggregatedListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [include_all_scopes][crate::model::global_operations::AggregatedListRequest::include_all_scopes].
        pub fn set_include_all_scopes<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.include_all_scopes = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [include_all_scopes][crate::model::global_operations::AggregatedListRequest::include_all_scopes].
        pub fn set_or_clear_include_all_scopes<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.include_all_scopes = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::global_operations::AggregatedListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::global_operations::AggregatedListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::global_operations::AggregatedListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::global_operations::AggregatedListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::global_operations::AggregatedListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::global_operations::AggregatedListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::global_operations::AggregatedListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::global_operations::AggregatedListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::global_operations::AggregatedListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [service_project_number][crate::model::global_operations::AggregatedListRequest::service_project_number].
        pub fn set_service_project_number<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.service_project_number = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [service_project_number][crate::model::global_operations::AggregatedListRequest::service_project_number].
        pub fn set_or_clear_service_project_number<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.service_project_number = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [delete()][google.cloud.compute.v1.globalOperations.delete] method.
    ///
    /// [google.cloud.compute.v1.globalOperations.delete]: crate::client::GlobalOperations::delete
    #[cfg(feature = "global-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteRequest {
        /// Name of the Operations resource to delete, or its unique numeric
        /// identifier.
        pub operation: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "global-operations")]
    impl DeleteRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation][crate::model::global_operations::DeleteRequest::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [project][crate::model::global_operations::DeleteRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }
    }

    /// Synthetic request message for the [get()][google.cloud.compute.v1.globalOperations.get] method.
    ///
    /// [google.cloud.compute.v1.globalOperations.get]: crate::client::GlobalOperations::get
    #[cfg(any(feature = "global-operations", feature = "images",))]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// Name of the Operations resource to return, or its unique numeric
        /// identifier.
        pub operation: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "global-operations", feature = "images",))]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation][crate::model::global_operations::GetRequest::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [project][crate::model::global_operations::GetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.globalOperations.list] method.
    ///
    /// [google.cloud.compute.v1.globalOperations.list]: crate::client::GlobalOperations::list
    #[cfg(feature = "global-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "global-operations")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::global_operations::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::global_operations::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::global_operations::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::global_operations::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::global_operations::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::global_operations::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::global_operations::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::global_operations::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::global_operations::ListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::global_operations::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::global_operations::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [wait()][google.cloud.compute.v1.globalOperations.wait] method.
    ///
    /// [google.cloud.compute.v1.globalOperations.wait]: crate::client::GlobalOperations::wait
    #[cfg(feature = "global-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WaitRequest {
        /// Name of the Operations resource to return, or its unique numeric
        /// identifier.
        pub operation: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "global-operations")]
    impl WaitRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation][crate::model::global_operations::WaitRequest::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [project][crate::model::global_operations::WaitRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }
    }
}

/// Synthetic messages for the [globalOrganizationOperations][google.cloud.compute.v1.globalOrganizationOperations] service
///
/// [google.cloud.compute.v1.globalOrganizationOperations]: crate::model::GlobalOrganizationOperations
#[cfg(feature = "global-organization-operations")]
pub mod global_organization_operations {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [delete()][google.cloud.compute.v1.globalOrganizationOperations.delete] method.
    ///
    /// [google.cloud.compute.v1.globalOrganizationOperations.delete]: crate::client::GlobalOrganizationOperations::delete
    #[cfg(feature = "global-organization-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteRequest {
        /// Name of the Operations resource to delete, or its unique numeric
        /// identifier.
        pub operation: std::string::String,

        /// Parent ID for this request.
        pub parent_id: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "global-organization-operations")]
    impl DeleteRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation][crate::model::global_organization_operations::DeleteRequest::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [parent_id][crate::model::global_organization_operations::DeleteRequest::parent_id].
        pub fn set_parent_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.parent_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [parent_id][crate::model::global_organization_operations::DeleteRequest::parent_id].
        pub fn set_or_clear_parent_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.parent_id = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [get()][google.cloud.compute.v1.globalOrganizationOperations.get] method.
    ///
    /// [google.cloud.compute.v1.globalOrganizationOperations.get]: crate::client::GlobalOrganizationOperations::get
    #[cfg(feature = "global-organization-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// Name of the Operations resource to return. Parent is derived from this
        /// field.
        pub operation: std::string::String,

        /// Parent ID for this request. Not used. Parent is derived from resource_id.
        pub parent_id: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "global-organization-operations")]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation][crate::model::global_organization_operations::GetRequest::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [parent_id][crate::model::global_organization_operations::GetRequest::parent_id].
        pub fn set_parent_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.parent_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [parent_id][crate::model::global_organization_operations::GetRequest::parent_id].
        pub fn set_or_clear_parent_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.parent_id = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.globalOrganizationOperations.list] method.
    ///
    /// [google.cloud.compute.v1.globalOrganizationOperations.list]: crate::client::GlobalOrganizationOperations::list
    #[cfg(feature = "global-organization-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Parent ID for this request.
        pub parent_id: std::option::Option<std::string::String>,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "global-organization-operations")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::global_organization_operations::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::global_organization_operations::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::global_organization_operations::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::global_organization_operations::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::global_organization_operations::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::global_organization_operations::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::global_organization_operations::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::global_organization_operations::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [parent_id][crate::model::global_organization_operations::ListRequest::parent_id].
        pub fn set_parent_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.parent_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [parent_id][crate::model::global_organization_operations::ListRequest::parent_id].
        pub fn set_or_clear_parent_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.parent_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [return_partial_success][crate::model::global_organization_operations::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::global_organization_operations::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }
    }
}

/// Synthetic messages for the [images][google.cloud.compute.v1.images] service
///
/// [google.cloud.compute.v1.images]: crate::model::Images
#[cfg(feature = "images")]
pub mod images {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [delete()][google.cloud.compute.v1.images.delete] method.
    ///
    /// [google.cloud.compute.v1.images.delete]: crate::client::Images::delete
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteRequest {
        /// Name of the image resource to delete.
        pub image: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl DeleteRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [image][crate::model::images::DeleteRequest::image].
        pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.image = v.into();
            self
        }

        /// Sets the value of [project][crate::model::images::DeleteRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::images::DeleteRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::images::DeleteRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [deprecate()][google.cloud.compute.v1.images.deprecate] method.
    ///
    /// [google.cloud.compute.v1.images.deprecate]: crate::client::Images::deprecate
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeprecateRequest {
        /// Image name.
        pub image: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [deprecate()][google.cloud.compute.v1.images.deprecate] method.
        ///
        /// [google.cloud.compute.v1.images.deprecate]: crate::client::Images::deprecate
        pub body: std::option::Option<crate::model::DeprecationStatus>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl DeprecateRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [image][crate::model::images::DeprecateRequest::image].
        pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.image = v.into();
            self
        }

        /// Sets the value of [project][crate::model::images::DeprecateRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::images::DeprecateRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::images::DeprecateRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::images::DeprecateRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::DeprecationStatus>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::images::DeprecateRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::DeprecationStatus>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [get()][google.cloud.compute.v1.images.get] method.
    ///
    /// [google.cloud.compute.v1.images.get]: crate::client::Images::get
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// Name of the image resource to return.
        pub image: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [image][crate::model::images::GetRequest::image].
        pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.image = v.into();
            self
        }

        /// Sets the value of [project][crate::model::images::GetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }
    }

    /// Synthetic request message for the [getFromFamily()][google.cloud.compute.v1.images.getFromFamily] method.
    ///
    /// [google.cloud.compute.v1.images.getFromFamily]: crate::client::Images::get_from_family
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetFromFamilyRequest {
        /// Name of the image family to search for.
        pub family: std::string::String,

        /// The image project that the image belongs to. For example, to get a CentOS
        /// image, specify centos-cloud as the image project.
        pub project: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl GetFromFamilyRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [family][crate::model::images::GetFromFamilyRequest::family].
        pub fn set_family<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.family = v.into();
            self
        }

        /// Sets the value of [project][crate::model::images::GetFromFamilyRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }
    }

    /// Synthetic request message for the [getIamPolicy()][google.cloud.compute.v1.images.getIamPolicy] method.
    ///
    /// [google.cloud.compute.v1.images.getIamPolicy]: crate::client::Images::get_iam_policy
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetIamPolicyRequest {
        /// Requested IAM Policy version.
        pub options_requested_policy_version: std::option::Option<i32>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name or id of the resource for this request.
        pub resource: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl GetIamPolicyRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [options_requested_policy_version][crate::model::images::GetIamPolicyRequest::options_requested_policy_version].
        pub fn set_options_requested_policy_version<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.options_requested_policy_version = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [options_requested_policy_version][crate::model::images::GetIamPolicyRequest::options_requested_policy_version].
        pub fn set_or_clear_options_requested_policy_version<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.options_requested_policy_version = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::images::GetIamPolicyRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::images::GetIamPolicyRequest::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }
    }

    /// Synthetic request message for the [insert()][google.cloud.compute.v1.images.insert] method.
    ///
    /// [google.cloud.compute.v1.images.insert]: crate::client::Images::insert
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InsertRequest {
        /// Force image creation if true.
        pub force_create: std::option::Option<bool>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [insert()][google.cloud.compute.v1.images.insert] method.
        ///
        /// [google.cloud.compute.v1.images.insert]: crate::client::Images::insert
        pub body: std::option::Option<crate::model::Image>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl InsertRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [force_create][crate::model::images::InsertRequest::force_create].
        pub fn set_force_create<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.force_create = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [force_create][crate::model::images::InsertRequest::force_create].
        pub fn set_or_clear_force_create<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.force_create = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::images::InsertRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::images::InsertRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::images::InsertRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::images::InsertRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Image>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::images::InsertRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Image>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.images.list] method.
    ///
    /// [google.cloud.compute.v1.images.list]: crate::client::Images::list
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::images::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::images::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::images::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::images::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::images::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::images::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::images::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::images::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::images::ListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::images::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::images::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [patch()][google.cloud.compute.v1.images.patch] method.
    ///
    /// [google.cloud.compute.v1.images.patch]: crate::client::Images::patch
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PatchRequest {
        /// Name of the image resource to patch.
        pub image: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [patch()][google.cloud.compute.v1.images.patch] method.
        ///
        /// [google.cloud.compute.v1.images.patch]: crate::client::Images::patch
        pub body: std::option::Option<crate::model::Image>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl PatchRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [image][crate::model::images::PatchRequest::image].
        pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.image = v.into();
            self
        }

        /// Sets the value of [project][crate::model::images::PatchRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::images::PatchRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::images::PatchRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::images::PatchRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Image>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::images::PatchRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Image>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setIamPolicy()][google.cloud.compute.v1.images.setIamPolicy] method.
    ///
    /// [google.cloud.compute.v1.images.setIamPolicy]: crate::client::Images::set_iam_policy
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetIamPolicyRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// Name or id of the resource for this request.
        pub resource: std::string::String,

        /// Synthetic request body field for the [setIamPolicy()][google.cloud.compute.v1.images.setIamPolicy] method.
        ///
        /// [google.cloud.compute.v1.images.setIamPolicy]: crate::client::Images::set_iam_policy
        pub body: std::option::Option<crate::model::GlobalSetPolicyRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl SetIamPolicyRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::images::SetIamPolicyRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::images::SetIamPolicyRequest::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [body][crate::model::images::SetIamPolicyRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::GlobalSetPolicyRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::images::SetIamPolicyRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::GlobalSetPolicyRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setLabels()][google.cloud.compute.v1.images.setLabels] method.
    ///
    /// [google.cloud.compute.v1.images.setLabels]: crate::client::Images::set_labels
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetLabelsRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// Name or id of the resource for this request.
        pub resource: std::string::String,

        /// Synthetic request body field for the [setLabels()][google.cloud.compute.v1.images.setLabels] method.
        ///
        /// [google.cloud.compute.v1.images.setLabels]: crate::client::Images::set_labels
        pub body: std::option::Option<crate::model::GlobalSetLabelsRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl SetLabelsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::images::SetLabelsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::images::SetLabelsRequest::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [body][crate::model::images::SetLabelsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::GlobalSetLabelsRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::images::SetLabelsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::GlobalSetLabelsRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [testIamPermissions()][google.cloud.compute.v1.images.testIamPermissions] method.
    ///
    /// [google.cloud.compute.v1.images.testIamPermissions]: crate::client::Images::test_iam_permissions
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TestIamPermissionsRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// Name or id of the resource for this request.
        pub resource: std::string::String,

        /// Synthetic request body field for the [testIamPermissions()][google.cloud.compute.v1.images.testIamPermissions] method.
        ///
        /// [google.cloud.compute.v1.images.testIamPermissions]: crate::client::Images::test_iam_permissions
        pub body: std::option::Option<crate::model::TestPermissionsRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl TestIamPermissionsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::images::TestIamPermissionsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::images::TestIamPermissionsRequest::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [body][crate::model::images::TestIamPermissionsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TestPermissionsRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::images::TestIamPermissionsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TestPermissionsRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }
}

/// Synthetic messages for the [instanceGroupManagerResizeRequests][google.cloud.compute.v1.instanceGroupManagerResizeRequests] service
///
/// [google.cloud.compute.v1.instanceGroupManagerResizeRequests]: crate::model::InstanceGroupManagerResizeRequests
#[cfg(feature = "instance-group-manager-resize-requests")]
pub mod instance_group_manager_resize_requests {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [cancel()][google.cloud.compute.v1.instanceGroupManagerResizeRequests.cancel] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagerResizeRequests.cancel]: crate::client::InstanceGroupManagerResizeRequests::cancel
    #[cfg(feature = "instance-group-manager-resize-requests")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CancelRequest {
        /// The name of the managed instance group.
        /// The name should conform to RFC1035 or be a resource ID.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the resize request to cancel.
        /// The name should conform to RFC1035 or be a resource ID.
        pub resize_request: std::string::String,

        /// The name of thezone where the managed
        /// instance group is located. The name should conform to RFC1035.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-manager-resize-requests")]
    impl CancelRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_manager_resize_requests::CancelRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_manager_resize_requests::CancelRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_manager_resize_requests::CancelRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_manager_resize_requests::CancelRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [resize_request][crate::model::instance_group_manager_resize_requests::CancelRequest::resize_request].
        pub fn set_resize_request<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.resize_request = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_manager_resize_requests::CancelRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [delete()][google.cloud.compute.v1.instanceGroupManagerResizeRequests.delete] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagerResizeRequests.delete]: crate::client::InstanceGroupManagerResizeRequests::delete
    #[cfg(feature = "instance-group-manager-resize-requests")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteRequest {
        /// The name of the managed instance group.
        /// The name should conform to RFC1035 or be a resource ID.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the resize request to delete.
        /// The name should conform to RFC1035 or be a resource ID.
        pub resize_request: std::string::String,

        /// The name of thezone where the managed
        /// instance group is located. The name should conform to RFC1035.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-manager-resize-requests")]
    impl DeleteRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_manager_resize_requests::DeleteRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_manager_resize_requests::DeleteRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_manager_resize_requests::DeleteRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_manager_resize_requests::DeleteRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [resize_request][crate::model::instance_group_manager_resize_requests::DeleteRequest::resize_request].
        pub fn set_resize_request<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.resize_request = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_manager_resize_requests::DeleteRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [get()][google.cloud.compute.v1.instanceGroupManagerResizeRequests.get] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagerResizeRequests.get]: crate::client::InstanceGroupManagerResizeRequests::get
    #[cfg(feature = "instance-group-manager-resize-requests")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// The name of the managed instance group.
        /// Name should conform to RFC1035 or be a resource ID.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the resize request.
        /// Name should conform to RFC1035 or be a resource ID.
        pub resize_request: std::string::String,

        /// Name of the href="/compute/docs/regions-zones/#available">zone
        /// scoping this request. Name should conform to RFC1035.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-manager-resize-requests")]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_manager_resize_requests::GetRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_manager_resize_requests::GetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [resize_request][crate::model::instance_group_manager_resize_requests::GetRequest::resize_request].
        pub fn set_resize_request<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.resize_request = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_manager_resize_requests::GetRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [insert()][google.cloud.compute.v1.instanceGroupManagerResizeRequests.insert] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagerResizeRequests.insert]: crate::client::InstanceGroupManagerResizeRequests::insert
    #[cfg(feature = "instance-group-manager-resize-requests")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InsertRequest {
        /// The name of the managed instance group to which the resize request will
        /// be added.
        /// Name should conform to RFC1035 or be a resource ID.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of thezone where the managed
        /// instance group is located and where the resize request will be created.
        /// Name should conform to RFC1035.
        pub zone: std::string::String,

        /// Synthetic request body field for the [insert()][google.cloud.compute.v1.instanceGroupManagerResizeRequests.insert] method.
        ///
        /// [google.cloud.compute.v1.instanceGroupManagerResizeRequests.insert]: crate::client::InstanceGroupManagerResizeRequests::insert
        pub body: std::option::Option<crate::model::InstanceGroupManagerResizeRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-manager-resize-requests")]
    impl InsertRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_manager_resize_requests::InsertRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_manager_resize_requests::InsertRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_manager_resize_requests::InsertRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_manager_resize_requests::InsertRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_manager_resize_requests::InsertRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_group_manager_resize_requests::InsertRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagerResizeRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_group_manager_resize_requests::InsertRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagerResizeRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.instanceGroupManagerResizeRequests.list] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagerResizeRequests.list]: crate::client::InstanceGroupManagerResizeRequests::list
    #[cfg(feature = "instance-group-manager-resize-requests")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The name of the managed instance group. The name should conform to RFC1035.
        pub instance_group_manager: std::string::String,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The name of thezone where the managed
        /// instance group is located. The name should conform to RFC1035.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-manager-resize-requests")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::instance_group_manager_resize_requests::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::instance_group_manager_resize_requests::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_manager_resize_requests::ListRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [max_results][crate::model::instance_group_manager_resize_requests::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::instance_group_manager_resize_requests::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::instance_group_manager_resize_requests::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::instance_group_manager_resize_requests::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::instance_group_manager_resize_requests::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::instance_group_manager_resize_requests::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instance_group_manager_resize_requests::ListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::instance_group_manager_resize_requests::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::instance_group_manager_resize_requests::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_manager_resize_requests::ListRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }
}

/// Synthetic messages for the [instanceGroupManagers][google.cloud.compute.v1.instanceGroupManagers] service
///
/// [google.cloud.compute.v1.instanceGroupManagers]: crate::model::InstanceGroupManagers
#[cfg(feature = "instance-group-managers")]
pub mod instance_group_managers {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [abandonInstances()][google.cloud.compute.v1.instanceGroupManagers.abandonInstances] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.abandonInstances]: crate::client::InstanceGroupManagers::abandon_instances
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AbandonInstancesRequest {
        /// The name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of thezone where the managed
        /// instance group is located.
        pub zone: std::string::String,

        /// Synthetic request body field for the [abandonInstances()][google.cloud.compute.v1.instanceGroupManagers.abandonInstances] method.
        ///
        /// [google.cloud.compute.v1.instanceGroupManagers.abandonInstances]: crate::client::InstanceGroupManagers::abandon_instances
        pub body: std::option::Option<crate::model::InstanceGroupManagersAbandonInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl AbandonInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::AbandonInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::AbandonInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_managers::AbandonInstancesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_managers::AbandonInstancesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::AbandonInstancesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_group_managers::AbandonInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersAbandonInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_group_managers::AbandonInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersAbandonInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [aggregatedList()][google.cloud.compute.v1.instanceGroupManagers.aggregatedList] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.aggregatedList]: crate::client::InstanceGroupManagers::aggregated_list
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AggregatedListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// Indicates whether every visible scope for each scope type (zone, region,
        /// global) should be included in the response. For new resource types added
        /// after this field, the flag has no effect as new resource types will always
        /// include every visible scope for each scope type in response. For resource
        /// types which predate this field, if this flag is omitted or false, only
        /// scopes of the scope types where the resource type is expected to be found
        /// will be included.
        pub include_all_scopes: std::option::Option<bool>,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The Shared VPC service project id or service project number for which
        /// aggregated list request is invoked for subnetworks list-usable api.
        pub service_project_number: std::option::Option<i64>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl AggregatedListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::instance_group_managers::AggregatedListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::instance_group_managers::AggregatedListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [include_all_scopes][crate::model::instance_group_managers::AggregatedListRequest::include_all_scopes].
        pub fn set_include_all_scopes<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.include_all_scopes = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [include_all_scopes][crate::model::instance_group_managers::AggregatedListRequest::include_all_scopes].
        pub fn set_or_clear_include_all_scopes<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.include_all_scopes = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::instance_group_managers::AggregatedListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::instance_group_managers::AggregatedListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::instance_group_managers::AggregatedListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::instance_group_managers::AggregatedListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::instance_group_managers::AggregatedListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::instance_group_managers::AggregatedListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::AggregatedListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::instance_group_managers::AggregatedListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::instance_group_managers::AggregatedListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [service_project_number][crate::model::instance_group_managers::AggregatedListRequest::service_project_number].
        pub fn set_service_project_number<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.service_project_number = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [service_project_number][crate::model::instance_group_managers::AggregatedListRequest::service_project_number].
        pub fn set_or_clear_service_project_number<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.service_project_number = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [applyUpdatesToInstances()][google.cloud.compute.v1.instanceGroupManagers.applyUpdatesToInstances] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.applyUpdatesToInstances]: crate::client::InstanceGroupManagers::apply_updates_to_instances
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ApplyUpdatesToInstancesRequest {
        /// The name of the managed instance group, should conform to RFC1035.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of thezone
        /// where the managed instance group is located. Should conform to RFC1035.
        pub zone: std::string::String,

        /// Synthetic request body field for the [applyUpdatesToInstances()][google.cloud.compute.v1.instanceGroupManagers.applyUpdatesToInstances] method.
        ///
        /// [google.cloud.compute.v1.instanceGroupManagers.applyUpdatesToInstances]: crate::client::InstanceGroupManagers::apply_updates_to_instances
        pub body: std::option::Option<crate::model::InstanceGroupManagersApplyUpdatesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl ApplyUpdatesToInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::ApplyUpdatesToInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::ApplyUpdatesToInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::ApplyUpdatesToInstancesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_group_managers::ApplyUpdatesToInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersApplyUpdatesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_group_managers::ApplyUpdatesToInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersApplyUpdatesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [createInstances()][google.cloud.compute.v1.instanceGroupManagers.createInstances] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.createInstances]: crate::client::InstanceGroupManagers::create_instances
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CreateInstancesRequest {
        /// The name of the managed instance group.
        /// It should conform to RFC1035.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of thezone
        /// where the managed instance group is located.
        /// It should conform to RFC1035.
        pub zone: std::string::String,

        /// Synthetic request body field for the [createInstances()][google.cloud.compute.v1.instanceGroupManagers.createInstances] method.
        ///
        /// [google.cloud.compute.v1.instanceGroupManagers.createInstances]: crate::client::InstanceGroupManagers::create_instances
        pub body: std::option::Option<crate::model::InstanceGroupManagersCreateInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl CreateInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::CreateInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::CreateInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_managers::CreateInstancesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_managers::CreateInstancesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::CreateInstancesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_group_managers::CreateInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersCreateInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_group_managers::CreateInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersCreateInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [delete()][google.cloud.compute.v1.instanceGroupManagers.delete] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.delete]: crate::client::InstanceGroupManagers::delete
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteRequest {
        /// The name of the managed instance group to delete.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of thezone where the managed
        /// instance group is located.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl DeleteRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::DeleteRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::DeleteRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_managers::DeleteRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_managers::DeleteRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::DeleteRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [deleteInstances()][google.cloud.compute.v1.instanceGroupManagers.deleteInstances] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.deleteInstances]: crate::client::InstanceGroupManagers::delete_instances
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteInstancesRequest {
        /// The name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of thezone where the managed
        /// instance group is located.
        pub zone: std::string::String,

        /// Synthetic request body field for the [deleteInstances()][google.cloud.compute.v1.instanceGroupManagers.deleteInstances] method.
        ///
        /// [google.cloud.compute.v1.instanceGroupManagers.deleteInstances]: crate::client::InstanceGroupManagers::delete_instances
        pub body: std::option::Option<crate::model::InstanceGroupManagersDeleteInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl DeleteInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::DeleteInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::DeleteInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_managers::DeleteInstancesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_managers::DeleteInstancesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::DeleteInstancesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_group_managers::DeleteInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersDeleteInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_group_managers::DeleteInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersDeleteInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [deletePerInstanceConfigs()][google.cloud.compute.v1.instanceGroupManagers.deletePerInstanceConfigs] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.deletePerInstanceConfigs]: crate::client::InstanceGroupManagers::delete_per_instance_configs
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeletePerInstanceConfigsRequest {
        /// The name of the managed instance group.
        /// It should conform to RFC1035.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of thezone
        /// where the managed instance
        /// group is located.
        /// It should conform to RFC1035.
        pub zone: std::string::String,

        /// Synthetic request body field for the [deletePerInstanceConfigs()][google.cloud.compute.v1.instanceGroupManagers.deletePerInstanceConfigs] method.
        ///
        /// [google.cloud.compute.v1.instanceGroupManagers.deletePerInstanceConfigs]: crate::client::InstanceGroupManagers::delete_per_instance_configs
        pub body:
            std::option::Option<crate::model::InstanceGroupManagersDeletePerInstanceConfigsReq>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl DeletePerInstanceConfigsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::DeletePerInstanceConfigsRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::DeletePerInstanceConfigsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::DeletePerInstanceConfigsRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_group_managers::DeletePerInstanceConfigsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersDeletePerInstanceConfigsReq>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_group_managers::DeletePerInstanceConfigsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersDeletePerInstanceConfigsReq>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [get()][google.cloud.compute.v1.instanceGroupManagers.get] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.get]: crate::client::InstanceGroupManagers::get
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// The name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of thezone where the managed
        /// instance group is located.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::GetRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::GetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::GetRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [insert()][google.cloud.compute.v1.instanceGroupManagers.insert] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.insert]: crate::client::InstanceGroupManagers::insert
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InsertRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone
        /// where you want to create the managed instance group.
        pub zone: std::string::String,

        /// Synthetic request body field for the [insert()][google.cloud.compute.v1.instanceGroupManagers.insert] method.
        ///
        /// [google.cloud.compute.v1.instanceGroupManagers.insert]: crate::client::InstanceGroupManagers::insert
        pub body: std::option::Option<crate::model::InstanceGroupManager>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl InsertRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::instance_group_managers::InsertRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_managers::InsertRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_managers::InsertRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::InsertRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_group_managers::InsertRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManager>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_group_managers::InsertRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManager>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.instanceGroupManagers.list] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.list]: crate::client::InstanceGroupManagers::list
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The name of thezone where the managed
        /// instance group is located.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::instance_group_managers::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::instance_group_managers::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::instance_group_managers::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::instance_group_managers::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::instance_group_managers::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::instance_group_managers::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::instance_group_managers::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::instance_group_managers::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::ListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::instance_group_managers::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::instance_group_managers::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::ListRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [listErrors()][google.cloud.compute.v1.instanceGroupManagers.listErrors] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.listErrors]: crate::client::InstanceGroupManagers::list_errors
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListErrorsRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The name of the managed instance group.
        /// It must be a string that meets the requirements in RFC1035, or an
        /// unsigned long integer: must match regexp pattern:
        /// (?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?)|1-9{0,19}.
        pub instance_group_manager: std::string::String,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The name of thezone where the managed
        /// instance group is located.
        /// It should conform to RFC1035.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl ListErrorsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::instance_group_managers::ListErrorsRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::instance_group_managers::ListErrorsRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::ListErrorsRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [max_results][crate::model::instance_group_managers::ListErrorsRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::instance_group_managers::ListErrorsRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::instance_group_managers::ListErrorsRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::instance_group_managers::ListErrorsRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::instance_group_managers::ListErrorsRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::instance_group_managers::ListErrorsRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::ListErrorsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::instance_group_managers::ListErrorsRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::instance_group_managers::ListErrorsRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::ListErrorsRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [listManagedInstances()][google.cloud.compute.v1.instanceGroupManagers.listManagedInstances] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.listManagedInstances]: crate::client::InstanceGroupManagers::list_managed_instances
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListManagedInstancesRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The name of thezone where the managed
        /// instance group is located.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl ListManagedInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::instance_group_managers::ListManagedInstancesRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::instance_group_managers::ListManagedInstancesRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::ListManagedInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [max_results][crate::model::instance_group_managers::ListManagedInstancesRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::instance_group_managers::ListManagedInstancesRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::instance_group_managers::ListManagedInstancesRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::instance_group_managers::ListManagedInstancesRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::instance_group_managers::ListManagedInstancesRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::instance_group_managers::ListManagedInstancesRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::ListManagedInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::instance_group_managers::ListManagedInstancesRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::instance_group_managers::ListManagedInstancesRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::ListManagedInstancesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [listPerInstanceConfigs()][google.cloud.compute.v1.instanceGroupManagers.listPerInstanceConfigs] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.listPerInstanceConfigs]: crate::client::InstanceGroupManagers::list_per_instance_configs
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListPerInstanceConfigsRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The name of the managed instance group. It should conform to RFC1035.
        pub instance_group_manager: std::string::String,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The name of thezone
        /// where the managed instance group is located.
        /// It should conform to RFC1035.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl ListPerInstanceConfigsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::instance_group_managers::ListPerInstanceConfigsRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::instance_group_managers::ListPerInstanceConfigsRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::ListPerInstanceConfigsRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [max_results][crate::model::instance_group_managers::ListPerInstanceConfigsRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::instance_group_managers::ListPerInstanceConfigsRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::instance_group_managers::ListPerInstanceConfigsRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::instance_group_managers::ListPerInstanceConfigsRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::instance_group_managers::ListPerInstanceConfigsRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::instance_group_managers::ListPerInstanceConfigsRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::ListPerInstanceConfigsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::instance_group_managers::ListPerInstanceConfigsRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::instance_group_managers::ListPerInstanceConfigsRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::ListPerInstanceConfigsRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [patch()][google.cloud.compute.v1.instanceGroupManagers.patch] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.patch]: crate::client::InstanceGroupManagers::patch
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PatchRequest {
        /// The name of the instance group manager.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone where
        /// you want to create the managed instance group.
        pub zone: std::string::String,

        /// Synthetic request body field for the [patch()][google.cloud.compute.v1.instanceGroupManagers.patch] method.
        ///
        /// [google.cloud.compute.v1.instanceGroupManagers.patch]: crate::client::InstanceGroupManagers::patch
        pub body: std::option::Option<crate::model::InstanceGroupManager>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl PatchRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::PatchRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::PatchRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_managers::PatchRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_managers::PatchRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::PatchRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_group_managers::PatchRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManager>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_group_managers::PatchRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManager>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [patchPerInstanceConfigs()][google.cloud.compute.v1.instanceGroupManagers.patchPerInstanceConfigs] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.patchPerInstanceConfigs]: crate::client::InstanceGroupManagers::patch_per_instance_configs
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PatchPerInstanceConfigsRequest {
        /// The name of the managed instance group.
        /// It should conform to RFC1035.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of thezone
        /// where the managed instance group is located.
        /// It should conform to RFC1035.
        pub zone: std::string::String,

        /// Synthetic request body field for the [patchPerInstanceConfigs()][google.cloud.compute.v1.instanceGroupManagers.patchPerInstanceConfigs] method.
        ///
        /// [google.cloud.compute.v1.instanceGroupManagers.patchPerInstanceConfigs]: crate::client::InstanceGroupManagers::patch_per_instance_configs
        pub body:
            std::option::Option<crate::model::InstanceGroupManagersPatchPerInstanceConfigsReq>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl PatchPerInstanceConfigsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::PatchPerInstanceConfigsRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::PatchPerInstanceConfigsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_managers::PatchPerInstanceConfigsRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_managers::PatchPerInstanceConfigsRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::PatchPerInstanceConfigsRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_group_managers::PatchPerInstanceConfigsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersPatchPerInstanceConfigsReq>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_group_managers::PatchPerInstanceConfigsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersPatchPerInstanceConfigsReq>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [recreateInstances()][google.cloud.compute.v1.instanceGroupManagers.recreateInstances] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.recreateInstances]: crate::client::InstanceGroupManagers::recreate_instances
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RecreateInstancesRequest {
        /// The name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of thezone where the managed
        /// instance group is located.
        pub zone: std::string::String,

        /// Synthetic request body field for the [recreateInstances()][google.cloud.compute.v1.instanceGroupManagers.recreateInstances] method.
        ///
        /// [google.cloud.compute.v1.instanceGroupManagers.recreateInstances]: crate::client::InstanceGroupManagers::recreate_instances
        pub body: std::option::Option<crate::model::InstanceGroupManagersRecreateInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl RecreateInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::RecreateInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::RecreateInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_managers::RecreateInstancesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_managers::RecreateInstancesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::RecreateInstancesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_group_managers::RecreateInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersRecreateInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_group_managers::RecreateInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersRecreateInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [resize()][google.cloud.compute.v1.instanceGroupManagers.resize] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.resize]: crate::client::InstanceGroupManagers::resize
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResizeRequest {
        /// The name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The number of running instances that the managed instance group should
        /// maintain at any given time. The group automatically adds or removes
        /// instances to maintain the number of instances specified by this parameter.
        pub size: i32,

        /// The name of thezone where the managed
        /// instance group is located.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl ResizeRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::ResizeRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::ResizeRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_managers::ResizeRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_managers::ResizeRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [size][crate::model::instance_group_managers::ResizeRequest::size].
        pub fn set_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.size = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::ResizeRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [resumeInstances()][google.cloud.compute.v1.instanceGroupManagers.resumeInstances] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.resumeInstances]: crate::client::InstanceGroupManagers::resume_instances
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResumeInstancesRequest {
        /// The name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of thezone where the managed
        /// instance group is located.
        pub zone: std::string::String,

        /// Synthetic request body field for the [resumeInstances()][google.cloud.compute.v1.instanceGroupManagers.resumeInstances] method.
        ///
        /// [google.cloud.compute.v1.instanceGroupManagers.resumeInstances]: crate::client::InstanceGroupManagers::resume_instances
        pub body: std::option::Option<crate::model::InstanceGroupManagersResumeInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl ResumeInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::ResumeInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::ResumeInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_managers::ResumeInstancesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_managers::ResumeInstancesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::ResumeInstancesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_group_managers::ResumeInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersResumeInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_group_managers::ResumeInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersResumeInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setInstanceTemplate()][google.cloud.compute.v1.instanceGroupManagers.setInstanceTemplate] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.setInstanceTemplate]: crate::client::InstanceGroupManagers::set_instance_template
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetInstanceTemplateRequest {
        /// The name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of thezone where the managed
        /// instance group is located.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setInstanceTemplate()][google.cloud.compute.v1.instanceGroupManagers.setInstanceTemplate] method.
        ///
        /// [google.cloud.compute.v1.instanceGroupManagers.setInstanceTemplate]: crate::client::InstanceGroupManagers::set_instance_template
        pub body:
            std::option::Option<crate::model::InstanceGroupManagersSetInstanceTemplateRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl SetInstanceTemplateRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::SetInstanceTemplateRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::SetInstanceTemplateRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_managers::SetInstanceTemplateRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_managers::SetInstanceTemplateRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::SetInstanceTemplateRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_group_managers::SetInstanceTemplateRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersSetInstanceTemplateRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_group_managers::SetInstanceTemplateRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersSetInstanceTemplateRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setTargetPools()][google.cloud.compute.v1.instanceGroupManagers.setTargetPools] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.setTargetPools]: crate::client::InstanceGroupManagers::set_target_pools
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetTargetPoolsRequest {
        /// The name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of thezone where the managed
        /// instance group is located.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setTargetPools()][google.cloud.compute.v1.instanceGroupManagers.setTargetPools] method.
        ///
        /// [google.cloud.compute.v1.instanceGroupManagers.setTargetPools]: crate::client::InstanceGroupManagers::set_target_pools
        pub body: std::option::Option<crate::model::InstanceGroupManagersSetTargetPoolsRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl SetTargetPoolsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::SetTargetPoolsRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::SetTargetPoolsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_managers::SetTargetPoolsRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_managers::SetTargetPoolsRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::SetTargetPoolsRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_group_managers::SetTargetPoolsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersSetTargetPoolsRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_group_managers::SetTargetPoolsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersSetTargetPoolsRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [startInstances()][google.cloud.compute.v1.instanceGroupManagers.startInstances] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.startInstances]: crate::client::InstanceGroupManagers::start_instances
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StartInstancesRequest {
        /// The name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of thezone where the managed
        /// instance group is located.
        pub zone: std::string::String,

        /// Synthetic request body field for the [startInstances()][google.cloud.compute.v1.instanceGroupManagers.startInstances] method.
        ///
        /// [google.cloud.compute.v1.instanceGroupManagers.startInstances]: crate::client::InstanceGroupManagers::start_instances
        pub body: std::option::Option<crate::model::InstanceGroupManagersStartInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl StartInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::StartInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::StartInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_managers::StartInstancesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_managers::StartInstancesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::StartInstancesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_group_managers::StartInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersStartInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_group_managers::StartInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersStartInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [stopInstances()][google.cloud.compute.v1.instanceGroupManagers.stopInstances] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.stopInstances]: crate::client::InstanceGroupManagers::stop_instances
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StopInstancesRequest {
        /// The name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of thezone where the managed
        /// instance group is located.
        pub zone: std::string::String,

        /// Synthetic request body field for the [stopInstances()][google.cloud.compute.v1.instanceGroupManagers.stopInstances] method.
        ///
        /// [google.cloud.compute.v1.instanceGroupManagers.stopInstances]: crate::client::InstanceGroupManagers::stop_instances
        pub body: std::option::Option<crate::model::InstanceGroupManagersStopInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl StopInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::StopInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::StopInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_managers::StopInstancesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_managers::StopInstancesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::StopInstancesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_group_managers::StopInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersStopInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_group_managers::StopInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersStopInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [suspendInstances()][google.cloud.compute.v1.instanceGroupManagers.suspendInstances] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.suspendInstances]: crate::client::InstanceGroupManagers::suspend_instances
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SuspendInstancesRequest {
        /// The name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of thezone where the managed
        /// instance group is located.
        pub zone: std::string::String,

        /// Synthetic request body field for the [suspendInstances()][google.cloud.compute.v1.instanceGroupManagers.suspendInstances] method.
        ///
        /// [google.cloud.compute.v1.instanceGroupManagers.suspendInstances]: crate::client::InstanceGroupManagers::suspend_instances
        pub body: std::option::Option<crate::model::InstanceGroupManagersSuspendInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl SuspendInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::SuspendInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::SuspendInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_managers::SuspendInstancesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_managers::SuspendInstancesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::SuspendInstancesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_group_managers::SuspendInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersSuspendInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_group_managers::SuspendInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersSuspendInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [updatePerInstanceConfigs()][google.cloud.compute.v1.instanceGroupManagers.updatePerInstanceConfigs] method.
    ///
    /// [google.cloud.compute.v1.instanceGroupManagers.updatePerInstanceConfigs]: crate::client::InstanceGroupManagers::update_per_instance_configs
    #[cfg(feature = "instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UpdatePerInstanceConfigsRequest {
        /// The name of the managed instance group.
        /// It should conform to RFC1035.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of thezone
        /// where the managed instance group is located.
        /// It should conform to RFC1035.
        pub zone: std::string::String,

        /// Synthetic request body field for the [updatePerInstanceConfigs()][google.cloud.compute.v1.instanceGroupManagers.updatePerInstanceConfigs] method.
        ///
        /// [google.cloud.compute.v1.instanceGroupManagers.updatePerInstanceConfigs]: crate::client::InstanceGroupManagers::update_per_instance_configs
        pub body:
            std::option::Option<crate::model::InstanceGroupManagersUpdatePerInstanceConfigsReq>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-group-managers")]
    impl UpdatePerInstanceConfigsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::instance_group_managers::UpdatePerInstanceConfigsRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_group_managers::UpdatePerInstanceConfigsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_group_managers::UpdatePerInstanceConfigsRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_group_managers::UpdatePerInstanceConfigsRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_group_managers::UpdatePerInstanceConfigsRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_group_managers::UpdatePerInstanceConfigsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersUpdatePerInstanceConfigsReq>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_group_managers::UpdatePerInstanceConfigsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManagersUpdatePerInstanceConfigsReq>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }
}

/// Synthetic messages for the [instanceGroups][google.cloud.compute.v1.instanceGroups] service
///
/// [google.cloud.compute.v1.instanceGroups]: crate::model::InstanceGroups
#[cfg(feature = "instance-groups")]
pub mod instance_groups {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [addInstances()][google.cloud.compute.v1.instanceGroups.addInstances] method.
    ///
    /// [google.cloud.compute.v1.instanceGroups.addInstances]: crate::client::InstanceGroups::add_instances
    #[cfg(feature = "instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AddInstancesRequest {
        /// The name of the instance group where you are adding instances.
        pub instance_group: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone
        /// where the instance group is located.
        pub zone: std::string::String,

        /// Synthetic request body field for the [addInstances()][google.cloud.compute.v1.instanceGroups.addInstances] method.
        ///
        /// [google.cloud.compute.v1.instanceGroups.addInstances]: crate::client::InstanceGroups::add_instances
        pub body: std::option::Option<crate::model::InstanceGroupsAddInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-groups")]
    impl AddInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group][crate::model::instance_groups::AddInstancesRequest::instance_group].
        pub fn set_instance_group<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_groups::AddInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_groups::AddInstancesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_groups::AddInstancesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_groups::AddInstancesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_groups::AddInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupsAddInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_groups::AddInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupsAddInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [aggregatedList()][google.cloud.compute.v1.instanceGroups.aggregatedList] method.
    ///
    /// [google.cloud.compute.v1.instanceGroups.aggregatedList]: crate::client::InstanceGroups::aggregated_list
    #[cfg(feature = "instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AggregatedListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// Indicates whether every visible scope for each scope type (zone, region,
        /// global) should be included in the response. For new resource types added
        /// after this field, the flag has no effect as new resource types will always
        /// include every visible scope for each scope type in response. For resource
        /// types which predate this field, if this flag is omitted or false, only
        /// scopes of the scope types where the resource type is expected to be found
        /// will be included.
        pub include_all_scopes: std::option::Option<bool>,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The Shared VPC service project id or service project number for which
        /// aggregated list request is invoked for subnetworks list-usable api.
        pub service_project_number: std::option::Option<i64>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-groups")]
    impl AggregatedListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::instance_groups::AggregatedListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::instance_groups::AggregatedListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [include_all_scopes][crate::model::instance_groups::AggregatedListRequest::include_all_scopes].
        pub fn set_include_all_scopes<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.include_all_scopes = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [include_all_scopes][crate::model::instance_groups::AggregatedListRequest::include_all_scopes].
        pub fn set_or_clear_include_all_scopes<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.include_all_scopes = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::instance_groups::AggregatedListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::instance_groups::AggregatedListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::instance_groups::AggregatedListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::instance_groups::AggregatedListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::instance_groups::AggregatedListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::instance_groups::AggregatedListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instance_groups::AggregatedListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::instance_groups::AggregatedListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::instance_groups::AggregatedListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [service_project_number][crate::model::instance_groups::AggregatedListRequest::service_project_number].
        pub fn set_service_project_number<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.service_project_number = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [service_project_number][crate::model::instance_groups::AggregatedListRequest::service_project_number].
        pub fn set_or_clear_service_project_number<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.service_project_number = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [delete()][google.cloud.compute.v1.instanceGroups.delete] method.
    ///
    /// [google.cloud.compute.v1.instanceGroups.delete]: crate::client::InstanceGroups::delete
    #[cfg(feature = "instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteRequest {
        /// The name of the instance group to delete.
        pub instance_group: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone
        /// where the instance group is located.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-groups")]
    impl DeleteRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group][crate::model::instance_groups::DeleteRequest::instance_group].
        pub fn set_instance_group<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_groups::DeleteRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_groups::DeleteRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_groups::DeleteRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_groups::DeleteRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [get()][google.cloud.compute.v1.instanceGroups.get] method.
    ///
    /// [google.cloud.compute.v1.instanceGroups.get]: crate::client::InstanceGroups::get
    #[cfg(feature = "instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// The name of the instance group.
        pub instance_group: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the zone
        /// where the instance group is located.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-groups")]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group][crate::model::instance_groups::GetRequest::instance_group].
        pub fn set_instance_group<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_groups::GetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instance_groups::GetRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [insert()][google.cloud.compute.v1.instanceGroups.insert] method.
    ///
    /// [google.cloud.compute.v1.instanceGroups.insert]: crate::client::InstanceGroups::insert
    #[cfg(feature = "instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InsertRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone
        /// where you want to create the instance group.
        pub zone: std::string::String,

        /// Synthetic request body field for the [insert()][google.cloud.compute.v1.instanceGroups.insert] method.
        ///
        /// [google.cloud.compute.v1.instanceGroups.insert]: crate::client::InstanceGroups::insert
        pub body: std::option::Option<crate::model::InstanceGroup>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-groups")]
    impl InsertRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::instance_groups::InsertRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_groups::InsertRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_groups::InsertRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_groups::InsertRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_groups::InsertRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroup>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_groups::InsertRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroup>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.instanceGroups.list] method.
    ///
    /// [google.cloud.compute.v1.instanceGroups.list]: crate::client::InstanceGroups::list
    #[cfg(feature = "instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The name of thezone
        /// where the instance group is located.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-groups")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::instance_groups::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::instance_groups::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::instance_groups::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::instance_groups::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::instance_groups::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::instance_groups::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::instance_groups::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::instance_groups::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instance_groups::ListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::instance_groups::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::instance_groups::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_groups::ListRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [listInstances()][google.cloud.compute.v1.instanceGroups.listInstances] method.
    ///
    /// [google.cloud.compute.v1.instanceGroups.listInstances]: crate::client::InstanceGroups::list_instances
    #[cfg(feature = "instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListInstancesRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The name of the instance group from which you want to generate a list
        /// of included instances.
        pub instance_group: std::string::String,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The name of the zone
        /// where the instance group is located.
        pub zone: std::string::String,

        /// Synthetic request body field for the [listInstances()][google.cloud.compute.v1.instanceGroups.listInstances] method.
        ///
        /// [google.cloud.compute.v1.instanceGroups.listInstances]: crate::client::InstanceGroups::list_instances
        pub body: std::option::Option<crate::model::InstanceGroupsListInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-groups")]
    impl ListInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::instance_groups::ListInstancesRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::instance_groups::ListInstancesRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [instance_group][crate::model::instance_groups::ListInstancesRequest::instance_group].
        pub fn set_instance_group<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group = v.into();
            self
        }

        /// Sets the value of [max_results][crate::model::instance_groups::ListInstancesRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::instance_groups::ListInstancesRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::instance_groups::ListInstancesRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::instance_groups::ListInstancesRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::instance_groups::ListInstancesRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::instance_groups::ListInstancesRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instance_groups::ListInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::instance_groups::ListInstancesRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::instance_groups::ListInstancesRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_groups::ListInstancesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_groups::ListInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupsListInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_groups::ListInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupsListInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [removeInstances()][google.cloud.compute.v1.instanceGroups.removeInstances] method.
    ///
    /// [google.cloud.compute.v1.instanceGroups.removeInstances]: crate::client::InstanceGroups::remove_instances
    #[cfg(feature = "instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RemoveInstancesRequest {
        /// The name of the instance group where the specified instances will be
        /// removed.
        pub instance_group: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone
        /// where the instance group is located.
        pub zone: std::string::String,

        /// Synthetic request body field for the [removeInstances()][google.cloud.compute.v1.instanceGroups.removeInstances] method.
        ///
        /// [google.cloud.compute.v1.instanceGroups.removeInstances]: crate::client::InstanceGroups::remove_instances
        pub body: std::option::Option<crate::model::InstanceGroupsRemoveInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-groups")]
    impl RemoveInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group][crate::model::instance_groups::RemoveInstancesRequest::instance_group].
        pub fn set_instance_group<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_groups::RemoveInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_groups::RemoveInstancesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_groups::RemoveInstancesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_groups::RemoveInstancesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_groups::RemoveInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupsRemoveInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_groups::RemoveInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupsRemoveInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setNamedPorts()][google.cloud.compute.v1.instanceGroups.setNamedPorts] method.
    ///
    /// [google.cloud.compute.v1.instanceGroups.setNamedPorts]: crate::client::InstanceGroups::set_named_ports
    #[cfg(feature = "instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetNamedPortsRequest {
        /// The name of the instance group where the named ports are updated.
        pub instance_group: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone
        /// where the instance group is located.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setNamedPorts()][google.cloud.compute.v1.instanceGroups.setNamedPorts] method.
        ///
        /// [google.cloud.compute.v1.instanceGroups.setNamedPorts]: crate::client::InstanceGroups::set_named_ports
        pub body: std::option::Option<crate::model::InstanceGroupsSetNamedPortsRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-groups")]
    impl SetNamedPortsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group][crate::model::instance_groups::SetNamedPortsRequest::instance_group].
        pub fn set_instance_group<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instance_groups::SetNamedPortsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instance_groups::SetNamedPortsRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instance_groups::SetNamedPortsRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instance_groups::SetNamedPortsRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_groups::SetNamedPortsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupsSetNamedPortsRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_groups::SetNamedPortsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupsSetNamedPortsRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [testIamPermissions()][google.cloud.compute.v1.instanceGroups.testIamPermissions] method.
    ///
    /// [google.cloud.compute.v1.instanceGroups.testIamPermissions]: crate::client::InstanceGroups::test_iam_permissions
    #[cfg(feature = "instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TestIamPermissionsRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// Name or id of the resource for this request.
        pub resource: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [testIamPermissions()][google.cloud.compute.v1.instanceGroups.testIamPermissions] method.
        ///
        /// [google.cloud.compute.v1.instanceGroups.testIamPermissions]: crate::client::InstanceGroups::test_iam_permissions
        pub body: std::option::Option<crate::model::TestPermissionsRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instance-groups")]
    impl TestIamPermissionsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::instance_groups::TestIamPermissionsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::instance_groups::TestIamPermissionsRequest::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instance_groups::TestIamPermissionsRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instance_groups::TestIamPermissionsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TestPermissionsRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instance_groups::TestIamPermissionsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TestPermissionsRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }
}

/// Synthetic messages for the [instances][google.cloud.compute.v1.instances] service
///
/// [google.cloud.compute.v1.instances]: crate::model::Instances
#[cfg(feature = "instances")]
pub mod instances {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [addAccessConfig()][google.cloud.compute.v1.instances.addAccessConfig] method.
    ///
    /// [google.cloud.compute.v1.instances.addAccessConfig]: crate::client::Instances::add_access_config
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AddAccessConfigRequest {
        /// The instance name for this request.
        pub instance: std::string::String,

        /// The name of the network interface to add to this instance.
        pub network_interface: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [addAccessConfig()][google.cloud.compute.v1.instances.addAccessConfig] method.
        ///
        /// [google.cloud.compute.v1.instances.addAccessConfig]: crate::client::Instances::add_access_config
        pub body: std::option::Option<crate::model::AccessConfig>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl AddAccessConfigRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::AddAccessConfigRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [network_interface][crate::model::instances::AddAccessConfigRequest::network_interface].
        pub fn set_network_interface<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_interface = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::AddAccessConfigRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::AddAccessConfigRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::AddAccessConfigRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::AddAccessConfigRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::AddAccessConfigRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::AccessConfig>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::AddAccessConfigRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::AccessConfig>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [addNetworkInterface()][google.cloud.compute.v1.instances.addNetworkInterface] method.
    ///
    /// [google.cloud.compute.v1.instances.addNetworkInterface]: crate::client::Instances::add_network_interface
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AddNetworkInterfaceRequest {
        /// The instance name for this request stored as resource_id.
        /// Name should conform to RFC1035 or be an unsigned long integer.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [addNetworkInterface()][google.cloud.compute.v1.instances.addNetworkInterface] method.
        ///
        /// [google.cloud.compute.v1.instances.addNetworkInterface]: crate::client::Instances::add_network_interface
        pub body: std::option::Option<crate::model::NetworkInterface>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl AddNetworkInterfaceRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::AddNetworkInterfaceRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::AddNetworkInterfaceRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::AddNetworkInterfaceRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::AddNetworkInterfaceRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::AddNetworkInterfaceRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::AddNetworkInterfaceRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::NetworkInterface>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::AddNetworkInterfaceRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::NetworkInterface>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [addResourcePolicies()][google.cloud.compute.v1.instances.addResourcePolicies] method.
    ///
    /// [google.cloud.compute.v1.instances.addResourcePolicies]: crate::client::Instances::add_resource_policies
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AddResourcePoliciesRequest {
        /// The instance name for this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [addResourcePolicies()][google.cloud.compute.v1.instances.addResourcePolicies] method.
        ///
        /// [google.cloud.compute.v1.instances.addResourcePolicies]: crate::client::Instances::add_resource_policies
        pub body: std::option::Option<crate::model::InstancesAddResourcePoliciesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl AddResourcePoliciesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::AddResourcePoliciesRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::AddResourcePoliciesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::AddResourcePoliciesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::AddResourcePoliciesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::AddResourcePoliciesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::AddResourcePoliciesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesAddResourcePoliciesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::AddResourcePoliciesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesAddResourcePoliciesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [aggregatedList()][google.cloud.compute.v1.instances.aggregatedList] method.
    ///
    /// [google.cloud.compute.v1.instances.aggregatedList]: crate::client::Instances::aggregated_list
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AggregatedListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// Indicates whether every visible scope for each scope type (zone, region,
        /// global) should be included in the response. For new resource types added
        /// after this field, the flag has no effect as new resource types will always
        /// include every visible scope for each scope type in response. For resource
        /// types which predate this field, if this flag is omitted or false, only
        /// scopes of the scope types where the resource type is expected to be found
        /// will be included.
        pub include_all_scopes: std::option::Option<bool>,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The Shared VPC service project id or service project number for which
        /// aggregated list request is invoked for subnetworks list-usable api.
        pub service_project_number: std::option::Option<i64>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl AggregatedListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::instances::AggregatedListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::instances::AggregatedListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [include_all_scopes][crate::model::instances::AggregatedListRequest::include_all_scopes].
        pub fn set_include_all_scopes<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.include_all_scopes = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [include_all_scopes][crate::model::instances::AggregatedListRequest::include_all_scopes].
        pub fn set_or_clear_include_all_scopes<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.include_all_scopes = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::instances::AggregatedListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::instances::AggregatedListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::instances::AggregatedListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::instances::AggregatedListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::instances::AggregatedListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::instances::AggregatedListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instances::AggregatedListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::instances::AggregatedListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::instances::AggregatedListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [service_project_number][crate::model::instances::AggregatedListRequest::service_project_number].
        pub fn set_service_project_number<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.service_project_number = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [service_project_number][crate::model::instances::AggregatedListRequest::service_project_number].
        pub fn set_or_clear_service_project_number<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.service_project_number = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [attachDisk()][google.cloud.compute.v1.instances.attachDisk] method.
    ///
    /// [google.cloud.compute.v1.instances.attachDisk]: crate::client::Instances::attach_disk
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AttachDiskRequest {
        /// Whether to force attach the regional disk even if it's currently attached
        /// to another instance. If you try to force attach a zonal disk to an
        /// instance, you will receive an error.
        pub force_attach: std::option::Option<bool>,

        /// The instance name for this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [attachDisk()][google.cloud.compute.v1.instances.attachDisk] method.
        ///
        /// [google.cloud.compute.v1.instances.attachDisk]: crate::client::Instances::attach_disk
        pub body: std::option::Option<crate::model::AttachedDisk>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl AttachDiskRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [force_attach][crate::model::instances::AttachDiskRequest::force_attach].
        pub fn set_force_attach<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.force_attach = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [force_attach][crate::model::instances::AttachDiskRequest::force_attach].
        pub fn set_or_clear_force_attach<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.force_attach = v.map(|x| x.into());
            self
        }

        /// Sets the value of [instance][crate::model::instances::AttachDiskRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::AttachDiskRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::AttachDiskRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::AttachDiskRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::AttachDiskRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::AttachDiskRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::AttachedDisk>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::AttachDiskRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::AttachedDisk>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [bulkInsert()][google.cloud.compute.v1.instances.bulkInsert] method.
    ///
    /// [google.cloud.compute.v1.instances.bulkInsert]: crate::client::Instances::bulk_insert
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BulkInsertRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [bulkInsert()][google.cloud.compute.v1.instances.bulkInsert] method.
        ///
        /// [google.cloud.compute.v1.instances.bulkInsert]: crate::client::Instances::bulk_insert
        pub body: std::option::Option<crate::model::BulkInsertInstanceResource>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl BulkInsertRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::instances::BulkInsertRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::BulkInsertRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::BulkInsertRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::BulkInsertRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::BulkInsertRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::BulkInsertInstanceResource>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::BulkInsertRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::BulkInsertInstanceResource>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [delete()][google.cloud.compute.v1.instances.delete] method.
    ///
    /// [google.cloud.compute.v1.instances.delete]: crate::client::Instances::delete
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteRequest {
        /// Name of the instance resource to delete.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl DeleteRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::DeleteRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::DeleteRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::DeleteRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::DeleteRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::DeleteRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [deleteAccessConfig()][google.cloud.compute.v1.instances.deleteAccessConfig] method.
    ///
    /// [google.cloud.compute.v1.instances.deleteAccessConfig]: crate::client::Instances::delete_access_config
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteAccessConfigRequest {
        /// The name of the access config to delete.
        pub access_config: std::string::String,

        /// The instance name for this request.
        pub instance: std::string::String,

        /// The name of the network interface.
        pub network_interface: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl DeleteAccessConfigRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [access_config][crate::model::instances::DeleteAccessConfigRequest::access_config].
        pub fn set_access_config<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.access_config = v.into();
            self
        }

        /// Sets the value of [instance][crate::model::instances::DeleteAccessConfigRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [network_interface][crate::model::instances::DeleteAccessConfigRequest::network_interface].
        pub fn set_network_interface<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_interface = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::DeleteAccessConfigRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::DeleteAccessConfigRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::DeleteAccessConfigRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::DeleteAccessConfigRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [deleteNetworkInterface()][google.cloud.compute.v1.instances.deleteNetworkInterface] method.
    ///
    /// [google.cloud.compute.v1.instances.deleteNetworkInterface]: crate::client::Instances::delete_network_interface
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteNetworkInterfaceRequest {
        /// The instance name for this request stored as resource_id.
        /// Name should conform to RFC1035 or be an unsigned long integer.
        pub instance: std::string::String,

        /// The name of the dynamic network interface to be deleted from the instance.
        pub network_interface_name: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl DeleteNetworkInterfaceRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::DeleteNetworkInterfaceRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [network_interface_name][crate::model::instances::DeleteNetworkInterfaceRequest::network_interface_name].
        pub fn set_network_interface_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_interface_name = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::DeleteNetworkInterfaceRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::DeleteNetworkInterfaceRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::DeleteNetworkInterfaceRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::DeleteNetworkInterfaceRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [detachDisk()][google.cloud.compute.v1.instances.detachDisk] method.
    ///
    /// [google.cloud.compute.v1.instances.detachDisk]: crate::client::Instances::detach_disk
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DetachDiskRequest {
        /// The device name of the disk to detach. Make a get() request on
        /// the instance to view currently attached disks and device names.
        pub device_name: std::string::String,

        /// Instance name for this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl DetachDiskRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [device_name][crate::model::instances::DetachDiskRequest::device_name].
        pub fn set_device_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.device_name = v.into();
            self
        }

        /// Sets the value of [instance][crate::model::instances::DetachDiskRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::DetachDiskRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::DetachDiskRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::DetachDiskRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::DetachDiskRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [get()][google.cloud.compute.v1.instances.get] method.
    ///
    /// [google.cloud.compute.v1.instances.get]: crate::client::Instances::get
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// Name of the instance resource to return.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::GetRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::GetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instances::GetRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [getEffectiveFirewalls()][google.cloud.compute.v1.instances.getEffectiveFirewalls] method.
    ///
    /// [google.cloud.compute.v1.instances.getEffectiveFirewalls]: crate::client::Instances::get_effective_firewalls
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetEffectiveFirewallsRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// The name of the network interface to get the effective firewalls.
        pub network_interface: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl GetEffectiveFirewallsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::GetEffectiveFirewallsRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [network_interface][crate::model::instances::GetEffectiveFirewallsRequest::network_interface].
        pub fn set_network_interface<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_interface = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::GetEffectiveFirewallsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instances::GetEffectiveFirewallsRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [getGuestAttributes()][google.cloud.compute.v1.instances.getGuestAttributes] method.
    ///
    /// [google.cloud.compute.v1.instances.getGuestAttributes]: crate::client::Instances::get_guest_attributes
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetGuestAttributesRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Specifies the guest attributes path to be queried.
        pub query_path: std::option::Option<std::string::String>,

        /// Specifies the key for the guest attributes entry.
        pub variable_key: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl GetGuestAttributesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::GetGuestAttributesRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::GetGuestAttributesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [query_path][crate::model::instances::GetGuestAttributesRequest::query_path].
        pub fn set_query_path<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.query_path = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [query_path][crate::model::instances::GetGuestAttributesRequest::query_path].
        pub fn set_or_clear_query_path<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.query_path = v.map(|x| x.into());
            self
        }

        /// Sets the value of [variable_key][crate::model::instances::GetGuestAttributesRequest::variable_key].
        pub fn set_variable_key<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.variable_key = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [variable_key][crate::model::instances::GetGuestAttributesRequest::variable_key].
        pub fn set_or_clear_variable_key<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.variable_key = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::GetGuestAttributesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [getIamPolicy()][google.cloud.compute.v1.instances.getIamPolicy] method.
    ///
    /// [google.cloud.compute.v1.instances.getIamPolicy]: crate::client::Instances::get_iam_policy
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetIamPolicyRequest {
        /// Requested IAM Policy version.
        pub options_requested_policy_version: std::option::Option<i32>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name or id of the resource for this request.
        pub resource: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl GetIamPolicyRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [options_requested_policy_version][crate::model::instances::GetIamPolicyRequest::options_requested_policy_version].
        pub fn set_options_requested_policy_version<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.options_requested_policy_version = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [options_requested_policy_version][crate::model::instances::GetIamPolicyRequest::options_requested_policy_version].
        pub fn set_or_clear_options_requested_policy_version<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.options_requested_policy_version = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instances::GetIamPolicyRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::instances::GetIamPolicyRequest::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instances::GetIamPolicyRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [getScreenshot()][google.cloud.compute.v1.instances.getScreenshot] method.
    ///
    /// [google.cloud.compute.v1.instances.getScreenshot]: crate::client::Instances::get_screenshot
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetScreenshotRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl GetScreenshotRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::GetScreenshotRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::GetScreenshotRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instances::GetScreenshotRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [getSerialPortOutput()][google.cloud.compute.v1.instances.getSerialPortOutput] method.
    ///
    /// [google.cloud.compute.v1.instances.getSerialPortOutput]: crate::client::Instances::get_serial_port_output
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetSerialPortOutputRequest {
        /// Name of the instance for this request.
        pub instance: std::string::String,

        /// Specifies which COM or serial port to retrieve data from.
        pub port: std::option::Option<i32>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Specifies the starting byte position of the output to return. To start with
        /// the first byte of output to the specified port, omit this field or set it
        /// to `0`.
        ///
        /// If the output for that byte position is available, this field matches the
        /// `start` parameter sent with the request. If the amount of serial console
        /// output exceeds the size of the buffer (1 MB), the oldest output is
        /// discarded and is no longer available. If the requested start position
        /// refers to discarded output, the start position is adjusted to the oldest
        /// output still available, and the adjusted start position is returned as the
        /// `start` property value.
        ///
        /// You can also provide a negative start position, which translates to the
        /// most recent number of bytes written to the serial port. For example, -3 is
        /// interpreted as the most recent 3 bytes written to the serial console. Note
        /// that the negative start is bounded by the retained buffer size, and the
        /// returned serial console output will not exceed the max buffer size.
        pub start: std::option::Option<i64>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl GetSerialPortOutputRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::GetSerialPortOutputRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [port][crate::model::instances::GetSerialPortOutputRequest::port].
        pub fn set_port<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.port = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [port][crate::model::instances::GetSerialPortOutputRequest::port].
        pub fn set_or_clear_port<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.port = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instances::GetSerialPortOutputRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [start][crate::model::instances::GetSerialPortOutputRequest::start].
        pub fn set_start<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.start = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start][crate::model::instances::GetSerialPortOutputRequest::start].
        pub fn set_or_clear_start<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.start = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::GetSerialPortOutputRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [getShieldedInstanceIdentity()][google.cloud.compute.v1.instances.getShieldedInstanceIdentity] method.
    ///
    /// [google.cloud.compute.v1.instances.getShieldedInstanceIdentity]: crate::client::Instances::get_shielded_instance_identity
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetShieldedInstanceIdentityRequest {
        /// Name or id of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl GetShieldedInstanceIdentityRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::GetShieldedInstanceIdentityRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::GetShieldedInstanceIdentityRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instances::GetShieldedInstanceIdentityRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [insert()][google.cloud.compute.v1.instances.insert] method.
    ///
    /// [google.cloud.compute.v1.instances.insert]: crate::client::Instances::insert
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InsertRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Specifies instance template to create the instance.
        ///
        /// This field is optional. It can be a full or partial URL. For example, the
        /// following are all valid URLs to an instance template:
        ///
        /// ```norust
        ///   - https://www.googleapis.com/compute/v1/projects/project/global/instanceTemplates/instanceTemplate
        ///   - projects/project/global/instanceTemplates/instanceTemplate
        ///   - global/instanceTemplates/instanceTemplate
        /// ```
        pub source_instance_template: std::option::Option<std::string::String>,

        /// Specifies the machine image to use to create the instance.
        ///
        /// This field is optional. It can be a full or partial URL. For example, the
        /// following are all valid URLs to a machine image:
        ///
        /// ```norust
        ///   - https://www.googleapis.com/compute/v1/projects/project/global/global/machineImages/machineImage
        ///   - projects/project/global/global/machineImages/machineImage
        ///   - global/machineImages/machineImage
        /// ```
        pub source_machine_image: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [insert()][google.cloud.compute.v1.instances.insert] method.
        ///
        /// [google.cloud.compute.v1.instances.insert]: crate::client::Instances::insert
        pub body: std::option::Option<crate::model::Instance>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl InsertRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::instances::InsertRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::InsertRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::InsertRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [source_instance_template][crate::model::instances::InsertRequest::source_instance_template].
        pub fn set_source_instance_template<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.source_instance_template = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [source_instance_template][crate::model::instances::InsertRequest::source_instance_template].
        pub fn set_or_clear_source_instance_template<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.source_instance_template = v.map(|x| x.into());
            self
        }

        /// Sets the value of [source_machine_image][crate::model::instances::InsertRequest::source_machine_image].
        pub fn set_source_machine_image<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.source_machine_image = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [source_machine_image][crate::model::instances::InsertRequest::source_machine_image].
        pub fn set_or_clear_source_machine_image<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.source_machine_image = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::InsertRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::InsertRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Instance>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::InsertRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Instance>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.instances.list] method.
    ///
    /// [google.cloud.compute.v1.instances.list]: crate::client::Instances::list
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::instances::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::instances::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::instances::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::instances::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::instances::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::instances::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::instances::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::instances::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instances::ListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::instances::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::instances::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::ListRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [listReferrers()][google.cloud.compute.v1.instances.listReferrers] method.
    ///
    /// [google.cloud.compute.v1.instances.listReferrers]: crate::client::Instances::list_referrers
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListReferrersRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// Name of the target instance scoping this request, or '-' if the
        /// request should span over all instances in the container.
        pub instance: std::string::String,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl ListReferrersRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::instances::ListReferrersRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::instances::ListReferrersRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [instance][crate::model::instances::ListReferrersRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [max_results][crate::model::instances::ListReferrersRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::instances::ListReferrersRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::instances::ListReferrersRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::instances::ListReferrersRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::instances::ListReferrersRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::instances::ListReferrersRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instances::ListReferrersRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::instances::ListReferrersRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::instances::ListReferrersRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::ListReferrersRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [performMaintenance()][google.cloud.compute.v1.instances.performMaintenance] method.
    ///
    /// [google.cloud.compute.v1.instances.performMaintenance]: crate::client::Instances::perform_maintenance
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PerformMaintenanceRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl PerformMaintenanceRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::PerformMaintenanceRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::PerformMaintenanceRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::PerformMaintenanceRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::PerformMaintenanceRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::PerformMaintenanceRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [removeResourcePolicies()][google.cloud.compute.v1.instances.removeResourcePolicies] method.
    ///
    /// [google.cloud.compute.v1.instances.removeResourcePolicies]: crate::client::Instances::remove_resource_policies
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RemoveResourcePoliciesRequest {
        /// The instance name for this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [removeResourcePolicies()][google.cloud.compute.v1.instances.removeResourcePolicies] method.
        ///
        /// [google.cloud.compute.v1.instances.removeResourcePolicies]: crate::client::Instances::remove_resource_policies
        pub body: std::option::Option<crate::model::InstancesRemoveResourcePoliciesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl RemoveResourcePoliciesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::RemoveResourcePoliciesRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::RemoveResourcePoliciesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::RemoveResourcePoliciesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::RemoveResourcePoliciesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::RemoveResourcePoliciesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::RemoveResourcePoliciesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesRemoveResourcePoliciesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::RemoveResourcePoliciesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesRemoveResourcePoliciesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [reportHostAsFaulty()][google.cloud.compute.v1.instances.reportHostAsFaulty] method.
    ///
    /// [google.cloud.compute.v1.instances.reportHostAsFaulty]: crate::client::Instances::report_host_as_faulty
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ReportHostAsFaultyRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [reportHostAsFaulty()][google.cloud.compute.v1.instances.reportHostAsFaulty] method.
        ///
        /// [google.cloud.compute.v1.instances.reportHostAsFaulty]: crate::client::Instances::report_host_as_faulty
        pub body: std::option::Option<crate::model::InstancesReportHostAsFaultyRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl ReportHostAsFaultyRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::ReportHostAsFaultyRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::ReportHostAsFaultyRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::ReportHostAsFaultyRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::ReportHostAsFaultyRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::ReportHostAsFaultyRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::ReportHostAsFaultyRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesReportHostAsFaultyRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::ReportHostAsFaultyRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesReportHostAsFaultyRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [reset()][google.cloud.compute.v1.instances.reset] method.
    ///
    /// [google.cloud.compute.v1.instances.reset]: crate::client::Instances::reset
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResetRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl ResetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::ResetRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::ResetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::ResetRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::ResetRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::ResetRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [resume()][google.cloud.compute.v1.instances.resume] method.
    ///
    /// [google.cloud.compute.v1.instances.resume]: crate::client::Instances::resume
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResumeRequest {
        /// Name of the instance resource to resume.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl ResumeRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::ResumeRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::ResumeRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::ResumeRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::ResumeRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::ResumeRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [sendDiagnosticInterrupt()][google.cloud.compute.v1.instances.sendDiagnosticInterrupt] method.
    ///
    /// [google.cloud.compute.v1.instances.sendDiagnosticInterrupt]: crate::client::Instances::send_diagnostic_interrupt
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SendDiagnosticInterruptRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SendDiagnosticInterruptRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SendDiagnosticInterruptRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SendDiagnosticInterruptRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instances::SendDiagnosticInterruptRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [setDeletionProtection()][google.cloud.compute.v1.instances.setDeletionProtection] method.
    ///
    /// [google.cloud.compute.v1.instances.setDeletionProtection]: crate::client::Instances::set_deletion_protection
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetDeletionProtectionRequest {
        /// Whether the resource should be protected against deletion.
        pub deletion_protection: std::option::Option<bool>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Name or id of the resource for this request.
        pub resource: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetDeletionProtectionRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [deletion_protection][crate::model::instances::SetDeletionProtectionRequest::deletion_protection].
        pub fn set_deletion_protection<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.deletion_protection = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [deletion_protection][crate::model::instances::SetDeletionProtectionRequest::deletion_protection].
        pub fn set_or_clear_deletion_protection<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.deletion_protection = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instances::SetDeletionProtectionRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetDeletionProtectionRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetDeletionProtectionRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [resource][crate::model::instances::SetDeletionProtectionRequest::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetDeletionProtectionRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [setDiskAutoDelete()][google.cloud.compute.v1.instances.setDiskAutoDelete] method.
    ///
    /// [google.cloud.compute.v1.instances.setDiskAutoDelete]: crate::client::Instances::set_disk_auto_delete
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetDiskAutoDeleteRequest {
        /// Whether to auto-delete the disk when the instance is deleted.
        pub auto_delete: bool,

        /// The device name of the disk to modify. Make a get() request
        /// on the instance to view currently attached disks and device names.
        pub device_name: std::string::String,

        /// The instance name for this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetDiskAutoDeleteRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [auto_delete][crate::model::instances::SetDiskAutoDeleteRequest::auto_delete].
        pub fn set_auto_delete<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.auto_delete = v.into();
            self
        }

        /// Sets the value of [device_name][crate::model::instances::SetDiskAutoDeleteRequest::device_name].
        pub fn set_device_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.device_name = v.into();
            self
        }

        /// Sets the value of [instance][crate::model::instances::SetDiskAutoDeleteRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetDiskAutoDeleteRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetDiskAutoDeleteRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetDiskAutoDeleteRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetDiskAutoDeleteRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [setIamPolicy()][google.cloud.compute.v1.instances.setIamPolicy] method.
    ///
    /// [google.cloud.compute.v1.instances.setIamPolicy]: crate::client::Instances::set_iam_policy
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetIamPolicyRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// Name or id of the resource for this request.
        pub resource: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setIamPolicy()][google.cloud.compute.v1.instances.setIamPolicy] method.
        ///
        /// [google.cloud.compute.v1.instances.setIamPolicy]: crate::client::Instances::set_iam_policy
        pub body: std::option::Option<crate::model::ZoneSetPolicyRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetIamPolicyRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::instances::SetIamPolicyRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::instances::SetIamPolicyRequest::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetIamPolicyRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetIamPolicyRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::ZoneSetPolicyRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetIamPolicyRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::ZoneSetPolicyRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setLabels()][google.cloud.compute.v1.instances.setLabels] method.
    ///
    /// [google.cloud.compute.v1.instances.setLabels]: crate::client::Instances::set_labels
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetLabelsRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setLabels()][google.cloud.compute.v1.instances.setLabels] method.
        ///
        /// [google.cloud.compute.v1.instances.setLabels]: crate::client::Instances::set_labels
        pub body: std::option::Option<crate::model::InstancesSetLabelsRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetLabelsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetLabelsRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetLabelsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetLabelsRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetLabelsRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetLabelsRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetLabelsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetLabelsRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetLabelsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetLabelsRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setMachineResources()][google.cloud.compute.v1.instances.setMachineResources] method.
    ///
    /// [google.cloud.compute.v1.instances.setMachineResources]: crate::client::Instances::set_machine_resources
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetMachineResourcesRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setMachineResources()][google.cloud.compute.v1.instances.setMachineResources] method.
        ///
        /// [google.cloud.compute.v1.instances.setMachineResources]: crate::client::Instances::set_machine_resources
        pub body: std::option::Option<crate::model::InstancesSetMachineResourcesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetMachineResourcesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetMachineResourcesRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetMachineResourcesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetMachineResourcesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetMachineResourcesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetMachineResourcesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetMachineResourcesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetMachineResourcesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetMachineResourcesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetMachineResourcesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setMachineType()][google.cloud.compute.v1.instances.setMachineType] method.
    ///
    /// [google.cloud.compute.v1.instances.setMachineType]: crate::client::Instances::set_machine_type
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetMachineTypeRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setMachineType()][google.cloud.compute.v1.instances.setMachineType] method.
        ///
        /// [google.cloud.compute.v1.instances.setMachineType]: crate::client::Instances::set_machine_type
        pub body: std::option::Option<crate::model::InstancesSetMachineTypeRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetMachineTypeRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetMachineTypeRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetMachineTypeRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetMachineTypeRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetMachineTypeRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetMachineTypeRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetMachineTypeRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetMachineTypeRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetMachineTypeRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetMachineTypeRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setMetadata()][google.cloud.compute.v1.instances.setMetadata] method.
    ///
    /// [google.cloud.compute.v1.instances.setMetadata]: crate::client::Instances::set_metadata
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetMetadataRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setMetadata()][google.cloud.compute.v1.instances.setMetadata] method.
        ///
        /// [google.cloud.compute.v1.instances.setMetadata]: crate::client::Instances::set_metadata
        pub body: std::option::Option<crate::model::Metadata>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetMetadataRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetMetadataRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetMetadataRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetMetadataRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetMetadataRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetMetadataRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetMetadataRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Metadata>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetMetadataRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Metadata>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setMinCpuPlatform()][google.cloud.compute.v1.instances.setMinCpuPlatform] method.
    ///
    /// [google.cloud.compute.v1.instances.setMinCpuPlatform]: crate::client::Instances::set_min_cpu_platform
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetMinCpuPlatformRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setMinCpuPlatform()][google.cloud.compute.v1.instances.setMinCpuPlatform] method.
        ///
        /// [google.cloud.compute.v1.instances.setMinCpuPlatform]: crate::client::Instances::set_min_cpu_platform
        pub body: std::option::Option<crate::model::InstancesSetMinCpuPlatformRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetMinCpuPlatformRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetMinCpuPlatformRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetMinCpuPlatformRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetMinCpuPlatformRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetMinCpuPlatformRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetMinCpuPlatformRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetMinCpuPlatformRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetMinCpuPlatformRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetMinCpuPlatformRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetMinCpuPlatformRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setName()][google.cloud.compute.v1.instances.setName] method.
    ///
    /// [google.cloud.compute.v1.instances.setName]: crate::client::Instances::set_name
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetNameRequest {
        /// The instance name for this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setName()][google.cloud.compute.v1.instances.setName] method.
        ///
        /// [google.cloud.compute.v1.instances.setName]: crate::client::Instances::set_name
        pub body: std::option::Option<crate::model::InstancesSetNameRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetNameRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetNameRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetNameRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetNameRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetNameRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetNameRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetNameRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetNameRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetNameRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetNameRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setScheduling()][google.cloud.compute.v1.instances.setScheduling] method.
    ///
    /// [google.cloud.compute.v1.instances.setScheduling]: crate::client::Instances::set_scheduling
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetSchedulingRequest {
        /// Instance name for this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setScheduling()][google.cloud.compute.v1.instances.setScheduling] method.
        ///
        /// [google.cloud.compute.v1.instances.setScheduling]: crate::client::Instances::set_scheduling
        pub body: std::option::Option<crate::model::Scheduling>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetSchedulingRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetSchedulingRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetSchedulingRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetSchedulingRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetSchedulingRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetSchedulingRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetSchedulingRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Scheduling>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetSchedulingRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Scheduling>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setSecurityPolicy()][google.cloud.compute.v1.instances.setSecurityPolicy] method.
    ///
    /// [google.cloud.compute.v1.instances.setSecurityPolicy]: crate::client::Instances::set_security_policy
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetSecurityPolicyRequest {
        /// Name of the Instance resource to which the security policy should be
        /// set. The name should conform to RFC1035.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Name of the zone scoping this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setSecurityPolicy()][google.cloud.compute.v1.instances.setSecurityPolicy] method.
        ///
        /// [google.cloud.compute.v1.instances.setSecurityPolicy]: crate::client::Instances::set_security_policy
        pub body: std::option::Option<crate::model::InstancesSetSecurityPolicyRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetSecurityPolicyRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetSecurityPolicyRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetSecurityPolicyRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetSecurityPolicyRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetSecurityPolicyRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetSecurityPolicyRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetSecurityPolicyRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetSecurityPolicyRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetSecurityPolicyRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetSecurityPolicyRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setServiceAccount()][google.cloud.compute.v1.instances.setServiceAccount] method.
    ///
    /// [google.cloud.compute.v1.instances.setServiceAccount]: crate::client::Instances::set_service_account
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetServiceAccountRequest {
        /// Name of the instance resource to start.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setServiceAccount()][google.cloud.compute.v1.instances.setServiceAccount] method.
        ///
        /// [google.cloud.compute.v1.instances.setServiceAccount]: crate::client::Instances::set_service_account
        pub body: std::option::Option<crate::model::InstancesSetServiceAccountRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetServiceAccountRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetServiceAccountRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetServiceAccountRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetServiceAccountRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetServiceAccountRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetServiceAccountRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetServiceAccountRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetServiceAccountRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetServiceAccountRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetServiceAccountRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setShieldedInstanceIntegrityPolicy()][google.cloud.compute.v1.instances.setShieldedInstanceIntegrityPolicy] method.
    ///
    /// [google.cloud.compute.v1.instances.setShieldedInstanceIntegrityPolicy]: crate::client::Instances::set_shielded_instance_integrity_policy
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetShieldedInstanceIntegrityPolicyRequest {
        /// Name or id of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setShieldedInstanceIntegrityPolicy()][google.cloud.compute.v1.instances.setShieldedInstanceIntegrityPolicy] method.
        ///
        /// [google.cloud.compute.v1.instances.setShieldedInstanceIntegrityPolicy]: crate::client::Instances::set_shielded_instance_integrity_policy
        pub body: std::option::Option<crate::model::ShieldedInstanceIntegrityPolicy>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetShieldedInstanceIntegrityPolicyRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::ShieldedInstanceIntegrityPolicy>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::ShieldedInstanceIntegrityPolicy>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setTags()][google.cloud.compute.v1.instances.setTags] method.
    ///
    /// [google.cloud.compute.v1.instances.setTags]: crate::client::Instances::set_tags
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetTagsRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setTags()][google.cloud.compute.v1.instances.setTags] method.
        ///
        /// [google.cloud.compute.v1.instances.setTags]: crate::client::Instances::set_tags
        pub body: std::option::Option<crate::model::Tags>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetTagsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetTagsRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetTagsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetTagsRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetTagsRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetTagsRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetTagsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Tags>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetTagsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Tags>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [simulateMaintenanceEvent()][google.cloud.compute.v1.instances.simulateMaintenanceEvent] method.
    ///
    /// [google.cloud.compute.v1.instances.simulateMaintenanceEvent]: crate::client::Instances::simulate_maintenance_event
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SimulateMaintenanceEventRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Determines whether the customers receive notifications before migration.
        /// Only applicable to SF vms.
        pub with_extended_notifications: std::option::Option<bool>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SimulateMaintenanceEventRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SimulateMaintenanceEventRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SimulateMaintenanceEventRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SimulateMaintenanceEventRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SimulateMaintenanceEventRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [with_extended_notifications][crate::model::instances::SimulateMaintenanceEventRequest::with_extended_notifications].
        pub fn set_with_extended_notifications<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.with_extended_notifications = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [with_extended_notifications][crate::model::instances::SimulateMaintenanceEventRequest::with_extended_notifications].
        pub fn set_or_clear_with_extended_notifications<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.with_extended_notifications = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SimulateMaintenanceEventRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [start()][google.cloud.compute.v1.instances.start] method.
    ///
    /// [google.cloud.compute.v1.instances.start]: crate::client::Instances::start
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StartRequest {
        /// Name of the instance resource to start.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl StartRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::StartRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::StartRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::StartRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::StartRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::StartRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [startWithEncryptionKey()][google.cloud.compute.v1.instances.startWithEncryptionKey] method.
    ///
    /// [google.cloud.compute.v1.instances.startWithEncryptionKey]: crate::client::Instances::start_with_encryption_key
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StartWithEncryptionKeyRequest {
        /// Name of the instance resource to start.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [startWithEncryptionKey()][google.cloud.compute.v1.instances.startWithEncryptionKey] method.
        ///
        /// [google.cloud.compute.v1.instances.startWithEncryptionKey]: crate::client::Instances::start_with_encryption_key
        pub body: std::option::Option<crate::model::InstancesStartWithEncryptionKeyRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl StartWithEncryptionKeyRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::StartWithEncryptionKeyRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::StartWithEncryptionKeyRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::StartWithEncryptionKeyRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::StartWithEncryptionKeyRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::StartWithEncryptionKeyRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::StartWithEncryptionKeyRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesStartWithEncryptionKeyRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::StartWithEncryptionKeyRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesStartWithEncryptionKeyRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [stop()][google.cloud.compute.v1.instances.stop] method.
    ///
    /// [google.cloud.compute.v1.instances.stop]: crate::client::Instances::stop
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StopRequest {
        /// This property is required if the instance has any attached Local SSD disks.
        /// If false, Local SSD data will be preserved when the instance is suspended.
        /// If true, the contents of any attached Local SSD disks will be discarded.
        pub discard_local_ssd: std::option::Option<bool>,

        /// Name of the instance resource to stop.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl StopRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [discard_local_ssd][crate::model::instances::StopRequest::discard_local_ssd].
        pub fn set_discard_local_ssd<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.discard_local_ssd = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [discard_local_ssd][crate::model::instances::StopRequest::discard_local_ssd].
        pub fn set_or_clear_discard_local_ssd<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.discard_local_ssd = v.map(|x| x.into());
            self
        }

        /// Sets the value of [instance][crate::model::instances::StopRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::StopRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::StopRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::StopRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::StopRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [suspend()][google.cloud.compute.v1.instances.suspend] method.
    ///
    /// [google.cloud.compute.v1.instances.suspend]: crate::client::Instances::suspend
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SuspendRequest {
        /// This property is required if the instance has any attached Local SSD disks.
        /// If false, Local SSD data will be preserved when the instance is suspended.
        /// If true, the contents of any attached Local SSD disks will be discarded.
        pub discard_local_ssd: std::option::Option<bool>,

        /// Name of the instance resource to suspend.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SuspendRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [discard_local_ssd][crate::model::instances::SuspendRequest::discard_local_ssd].
        pub fn set_discard_local_ssd<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.discard_local_ssd = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [discard_local_ssd][crate::model::instances::SuspendRequest::discard_local_ssd].
        pub fn set_or_clear_discard_local_ssd<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.discard_local_ssd = v.map(|x| x.into());
            self
        }

        /// Sets the value of [instance][crate::model::instances::SuspendRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SuspendRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SuspendRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SuspendRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SuspendRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [testIamPermissions()][google.cloud.compute.v1.instances.testIamPermissions] method.
    ///
    /// [google.cloud.compute.v1.instances.testIamPermissions]: crate::client::Instances::test_iam_permissions
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TestIamPermissionsRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// Name or id of the resource for this request.
        pub resource: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [testIamPermissions()][google.cloud.compute.v1.instances.testIamPermissions] method.
        ///
        /// [google.cloud.compute.v1.instances.testIamPermissions]: crate::client::Instances::test_iam_permissions
        pub body: std::option::Option<crate::model::TestPermissionsRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl TestIamPermissionsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::instances::TestIamPermissionsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::instances::TestIamPermissionsRequest::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instances::TestIamPermissionsRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::TestIamPermissionsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TestPermissionsRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::TestIamPermissionsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TestPermissionsRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [update()][google.cloud.compute.v1.instances.update] method.
    ///
    /// [google.cloud.compute.v1.instances.update]: crate::client::Instances::update
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UpdateRequest {
        /// Name of the instance resource to update.
        pub instance: std::string::String,

        /// Specifies the action to take when updating an instance even if the
        /// updated properties do not require it. If not specified, then
        /// Compute Engine acts based on the minimum action that the updated
        /// properties require.
        pub minimal_action:
            std::option::Option<crate::model::instances::update_request::MinimalAction>,

        /// Specifies the most disruptive action that can be taken on the instance
        /// as part of the update. Compute Engine returns an error if the
        /// instance properties require a more disruptive action as part of the
        /// instance update. Valid options from lowest to highest are
        /// NO_EFFECT, REFRESH, and RESTART.
        pub most_disruptive_allowed_action: std::option::Option<
            crate::model::instances::update_request::MostDisruptiveAllowedAction,
        >,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [update()][google.cloud.compute.v1.instances.update] method.
        ///
        /// [google.cloud.compute.v1.instances.update]: crate::client::Instances::update
        pub body: std::option::Option<crate::model::Instance>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl UpdateRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::UpdateRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [minimal_action][crate::model::instances::UpdateRequest::minimal_action].
        pub fn set_minimal_action<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::instances::update_request::MinimalAction>,
        {
            self.minimal_action = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [minimal_action][crate::model::instances::UpdateRequest::minimal_action].
        pub fn set_or_clear_minimal_action<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::instances::update_request::MinimalAction>,
        {
            self.minimal_action = v.map(|x| x.into());
            self
        }

        /// Sets the value of [most_disruptive_allowed_action][crate::model::instances::UpdateRequest::most_disruptive_allowed_action].
        pub fn set_most_disruptive_allowed_action<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::instances::update_request::MostDisruptiveAllowedAction,
                >,
        {
            self.most_disruptive_allowed_action = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [most_disruptive_allowed_action][crate::model::instances::UpdateRequest::most_disruptive_allowed_action].
        pub fn set_or_clear_most_disruptive_allowed_action<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<
                    crate::model::instances::update_request::MostDisruptiveAllowedAction,
                >,
        {
            self.most_disruptive_allowed_action = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instances::UpdateRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::UpdateRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::UpdateRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::UpdateRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::UpdateRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Instance>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::UpdateRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Instance>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Defines additional types related to [UpdateRequest].
    #[cfg(feature = "instances")]
    pub mod update_request {
        #[allow(unused_imports)]
        use super::*;

        /// The enumerated type for the [minimalAction][google.cloud.compute.v1.instances.updateRequest.minimalAction] field.
        ///
        /// [google.cloud.compute.v1.instances.updateRequest.minimalAction]: crate::model::instances::update_request::MinimalAction
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instances")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum MinimalAction {
            Invalid,
            /// No changes can be made to the instance.
            NoEffect,
            /// The instance will not restart.
            Refresh,
            /// The instance will restart.
            Restart,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [MinimalAction::value] or
            /// [MinimalAction::name].
            UnknownValue(minimal_action::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instances")]
        pub mod minimal_action {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instances")]
        impl MinimalAction {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Invalid => std::option::Option::Some(0),
                    Self::NoEffect => std::option::Option::Some(1),
                    Self::Refresh => std::option::Option::Some(2),
                    Self::Restart => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Invalid => std::option::Option::Some("INVALID"),
                    Self::NoEffect => std::option::Option::Some("NO_EFFECT"),
                    Self::Refresh => std::option::Option::Some("REFRESH"),
                    Self::Restart => std::option::Option::Some("RESTART"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::default::Default for MinimalAction {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instances")]
        impl std::fmt::Display for MinimalAction {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<i32> for MinimalAction {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Invalid,
                    1 => Self::NoEffect,
                    2 => Self::Refresh,
                    3 => Self::Restart,
                    _ => Self::UnknownValue(minimal_action::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<&str> for MinimalAction {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "INVALID" => Self::Invalid,
                    "NO_EFFECT" => Self::NoEffect,
                    "REFRESH" => Self::Refresh,
                    "RESTART" => Self::Restart,
                    _ => Self::UnknownValue(minimal_action::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl serde::ser::Serialize for MinimalAction {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Invalid => serializer.serialize_str("INVALID"),
                    Self::NoEffect => serializer.serialize_str("NO_EFFECT"),
                    Self::Refresh => serializer.serialize_str("REFRESH"),
                    Self::Restart => serializer.serialize_str("RESTART"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl<'de> serde::de::Deserialize<'de> for MinimalAction {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<MinimalAction>::new(
                    ".google.cloud.compute.v1.instances.updateRequest.minimalAction",
                ))
            }
        }

        /// The enumerated type for the [mostDisruptiveAllowedAction][google.cloud.compute.v1.instances.updateRequest.mostDisruptiveAllowedAction] field.
        ///
        /// [google.cloud.compute.v1.instances.updateRequest.mostDisruptiveAllowedAction]: crate::model::instances::update_request::MostDisruptiveAllowedAction
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instances")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum MostDisruptiveAllowedAction {
            Invalid,
            /// No changes can be made to the instance.
            NoEffect,
            /// The instance will not restart.
            Refresh,
            /// The instance will restart.
            Restart,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [MostDisruptiveAllowedAction::value] or
            /// [MostDisruptiveAllowedAction::name].
            UnknownValue(most_disruptive_allowed_action::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instances")]
        pub mod most_disruptive_allowed_action {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instances")]
        impl MostDisruptiveAllowedAction {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Invalid => std::option::Option::Some(0),
                    Self::NoEffect => std::option::Option::Some(1),
                    Self::Refresh => std::option::Option::Some(2),
                    Self::Restart => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Invalid => std::option::Option::Some("INVALID"),
                    Self::NoEffect => std::option::Option::Some("NO_EFFECT"),
                    Self::Refresh => std::option::Option::Some("REFRESH"),
                    Self::Restart => std::option::Option::Some("RESTART"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::default::Default for MostDisruptiveAllowedAction {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instances")]
        impl std::fmt::Display for MostDisruptiveAllowedAction {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<i32> for MostDisruptiveAllowedAction {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Invalid,
                    1 => Self::NoEffect,
                    2 => Self::Refresh,
                    3 => Self::Restart,
                    _ => Self::UnknownValue(most_disruptive_allowed_action::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<&str> for MostDisruptiveAllowedAction {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "INVALID" => Self::Invalid,
                    "NO_EFFECT" => Self::NoEffect,
                    "REFRESH" => Self::Refresh,
                    "RESTART" => Self::Restart,
                    _ => Self::UnknownValue(most_disruptive_allowed_action::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl serde::ser::Serialize for MostDisruptiveAllowedAction {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Invalid => serializer.serialize_str("INVALID"),
                    Self::NoEffect => serializer.serialize_str("NO_EFFECT"),
                    Self::Refresh => serializer.serialize_str("REFRESH"),
                    Self::Restart => serializer.serialize_str("RESTART"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl<'de> serde::de::Deserialize<'de> for MostDisruptiveAllowedAction {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<
                    MostDisruptiveAllowedAction,
                >::new(
                    ".google.cloud.compute.v1.instances.updateRequest.mostDisruptiveAllowedAction",
                ))
            }
        }
    }

    /// Synthetic request message for the [updateAccessConfig()][google.cloud.compute.v1.instances.updateAccessConfig] method.
    ///
    /// [google.cloud.compute.v1.instances.updateAccessConfig]: crate::client::Instances::update_access_config
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UpdateAccessConfigRequest {
        /// The instance name for this request.
        pub instance: std::string::String,

        /// The name of the network interface where the access config is attached.
        pub network_interface: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [updateAccessConfig()][google.cloud.compute.v1.instances.updateAccessConfig] method.
        ///
        /// [google.cloud.compute.v1.instances.updateAccessConfig]: crate::client::Instances::update_access_config
        pub body: std::option::Option<crate::model::AccessConfig>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl UpdateAccessConfigRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::UpdateAccessConfigRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [network_interface][crate::model::instances::UpdateAccessConfigRequest::network_interface].
        pub fn set_network_interface<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_interface = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::UpdateAccessConfigRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::UpdateAccessConfigRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::UpdateAccessConfigRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::UpdateAccessConfigRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::UpdateAccessConfigRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::AccessConfig>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::UpdateAccessConfigRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::AccessConfig>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [updateDisplayDevice()][google.cloud.compute.v1.instances.updateDisplayDevice] method.
    ///
    /// [google.cloud.compute.v1.instances.updateDisplayDevice]: crate::client::Instances::update_display_device
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UpdateDisplayDeviceRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [updateDisplayDevice()][google.cloud.compute.v1.instances.updateDisplayDevice] method.
        ///
        /// [google.cloud.compute.v1.instances.updateDisplayDevice]: crate::client::Instances::update_display_device
        pub body: std::option::Option<crate::model::DisplayDevice>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl UpdateDisplayDeviceRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::UpdateDisplayDeviceRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::UpdateDisplayDeviceRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::UpdateDisplayDeviceRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::UpdateDisplayDeviceRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::UpdateDisplayDeviceRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::UpdateDisplayDeviceRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::DisplayDevice>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::UpdateDisplayDeviceRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::DisplayDevice>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [updateNetworkInterface()][google.cloud.compute.v1.instances.updateNetworkInterface] method.
    ///
    /// [google.cloud.compute.v1.instances.updateNetworkInterface]: crate::client::Instances::update_network_interface
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UpdateNetworkInterfaceRequest {
        /// The instance name for this request.
        pub instance: std::string::String,

        /// The name of the network interface to update.
        pub network_interface: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [updateNetworkInterface()][google.cloud.compute.v1.instances.updateNetworkInterface] method.
        ///
        /// [google.cloud.compute.v1.instances.updateNetworkInterface]: crate::client::Instances::update_network_interface
        pub body: std::option::Option<crate::model::NetworkInterface>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl UpdateNetworkInterfaceRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::UpdateNetworkInterfaceRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [network_interface][crate::model::instances::UpdateNetworkInterfaceRequest::network_interface].
        pub fn set_network_interface<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_interface = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::UpdateNetworkInterfaceRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::UpdateNetworkInterfaceRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::UpdateNetworkInterfaceRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::UpdateNetworkInterfaceRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::UpdateNetworkInterfaceRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::NetworkInterface>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::UpdateNetworkInterfaceRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::NetworkInterface>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [updateShieldedInstanceConfig()][google.cloud.compute.v1.instances.updateShieldedInstanceConfig] method.
    ///
    /// [google.cloud.compute.v1.instances.updateShieldedInstanceConfig]: crate::client::Instances::update_shielded_instance_config
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UpdateShieldedInstanceConfigRequest {
        /// Name or id of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [updateShieldedInstanceConfig()][google.cloud.compute.v1.instances.updateShieldedInstanceConfig] method.
        ///
        /// [google.cloud.compute.v1.instances.updateShieldedInstanceConfig]: crate::client::Instances::update_shielded_instance_config
        pub body: std::option::Option<crate::model::ShieldedInstanceConfig>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl UpdateShieldedInstanceConfigRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::UpdateShieldedInstanceConfigRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::UpdateShieldedInstanceConfigRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::UpdateShieldedInstanceConfigRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::UpdateShieldedInstanceConfigRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::UpdateShieldedInstanceConfigRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::UpdateShieldedInstanceConfigRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::UpdateShieldedInstanceConfigRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }
}

/// Synthetic messages for the [machineTypes][google.cloud.compute.v1.machineTypes] service
///
/// [google.cloud.compute.v1.machineTypes]: crate::model::MachineTypes
#[cfg(feature = "machine-types")]
pub mod machine_types {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [aggregatedList()][google.cloud.compute.v1.machineTypes.aggregatedList] method.
    ///
    /// [google.cloud.compute.v1.machineTypes.aggregatedList]: crate::client::MachineTypes::aggregated_list
    #[cfg(feature = "machine-types")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AggregatedListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// Indicates whether every visible scope for each scope type (zone, region,
        /// global) should be included in the response. For new resource types added
        /// after this field, the flag has no effect as new resource types will always
        /// include every visible scope for each scope type in response. For resource
        /// types which predate this field, if this flag is omitted or false, only
        /// scopes of the scope types where the resource type is expected to be found
        /// will be included.
        pub include_all_scopes: std::option::Option<bool>,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The Shared VPC service project id or service project number for which
        /// aggregated list request is invoked for subnetworks list-usable api.
        pub service_project_number: std::option::Option<i64>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "machine-types")]
    impl AggregatedListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::machine_types::AggregatedListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::machine_types::AggregatedListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [include_all_scopes][crate::model::machine_types::AggregatedListRequest::include_all_scopes].
        pub fn set_include_all_scopes<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.include_all_scopes = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [include_all_scopes][crate::model::machine_types::AggregatedListRequest::include_all_scopes].
        pub fn set_or_clear_include_all_scopes<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.include_all_scopes = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::machine_types::AggregatedListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::machine_types::AggregatedListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::machine_types::AggregatedListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::machine_types::AggregatedListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::machine_types::AggregatedListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::machine_types::AggregatedListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::machine_types::AggregatedListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::machine_types::AggregatedListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::machine_types::AggregatedListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [service_project_number][crate::model::machine_types::AggregatedListRequest::service_project_number].
        pub fn set_service_project_number<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.service_project_number = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [service_project_number][crate::model::machine_types::AggregatedListRequest::service_project_number].
        pub fn set_or_clear_service_project_number<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.service_project_number = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [get()][google.cloud.compute.v1.machineTypes.get] method.
    ///
    /// [google.cloud.compute.v1.machineTypes.get]: crate::client::MachineTypes::get
    #[cfg(feature = "machine-types")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// Name of the machine type to return.
        pub machine_type: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "machine-types")]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [machine_type][crate::model::machine_types::GetRequest::machine_type].
        pub fn set_machine_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.machine_type = v.into();
            self
        }

        /// Sets the value of [project][crate::model::machine_types::GetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::machine_types::GetRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.machineTypes.list] method.
    ///
    /// [google.cloud.compute.v1.machineTypes.list]: crate::client::MachineTypes::list
    #[cfg(feature = "machine-types")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "machine-types")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::machine_types::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::machine_types::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::machine_types::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::machine_types::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::machine_types::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::machine_types::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::machine_types::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::machine_types::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::machine_types::ListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::machine_types::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::machine_types::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::machine_types::ListRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }
}

/// Synthetic messages for the [regionInstanceGroupManagers][google.cloud.compute.v1.regionInstanceGroupManagers] service
///
/// [google.cloud.compute.v1.regionInstanceGroupManagers]: crate::model::RegionInstanceGroupManagers
#[cfg(feature = "region-instance-group-managers")]
pub mod region_instance_group_managers {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [abandonInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.abandonInstances] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.abandonInstances]: crate::client::RegionInstanceGroupManagers::abandon_instances
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AbandonInstancesRequest {
        /// Name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [abandonInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.abandonInstances] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroupManagers.abandonInstances]: crate::client::RegionInstanceGroupManagers::abandon_instances
        pub body:
            std::option::Option<crate::model::RegionInstanceGroupManagersAbandonInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl AbandonInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::AbandonInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::AbandonInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::AbandonInstancesRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_group_managers::AbandonInstancesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_group_managers::AbandonInstancesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::region_instance_group_managers::AbandonInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersAbandonInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_group_managers::AbandonInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersAbandonInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [applyUpdatesToInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.applyUpdatesToInstances] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.applyUpdatesToInstances]: crate::client::RegionInstanceGroupManagers::apply_updates_to_instances
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ApplyUpdatesToInstancesRequest {
        /// The name of the managed instance group, should conform to RFC1035.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request, should conform to RFC1035.
        pub region: std::string::String,

        /// Synthetic request body field for the [applyUpdatesToInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.applyUpdatesToInstances] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroupManagers.applyUpdatesToInstances]: crate::client::RegionInstanceGroupManagers::apply_updates_to_instances
        pub body: std::option::Option<crate::model::RegionInstanceGroupManagersApplyUpdatesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl ApplyUpdatesToInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::ApplyUpdatesToInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::ApplyUpdatesToInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::ApplyUpdatesToInstancesRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [body][crate::model::region_instance_group_managers::ApplyUpdatesToInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersApplyUpdatesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_group_managers::ApplyUpdatesToInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersApplyUpdatesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [createInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.createInstances] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.createInstances]: crate::client::RegionInstanceGroupManagers::create_instances
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CreateInstancesRequest {
        /// The name of the managed instance group.
        /// It should conform to RFC1035.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of theregion
        /// where the managed instance group is located.
        /// It should conform to RFC1035.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [createInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.createInstances] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroupManagers.createInstances]: crate::client::RegionInstanceGroupManagers::create_instances
        pub body:
            std::option::Option<crate::model::RegionInstanceGroupManagersCreateInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl CreateInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::CreateInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::CreateInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::CreateInstancesRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_group_managers::CreateInstancesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_group_managers::CreateInstancesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::region_instance_group_managers::CreateInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersCreateInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_group_managers::CreateInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersCreateInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [delete()][google.cloud.compute.v1.regionInstanceGroupManagers.delete] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.delete]: crate::client::RegionInstanceGroupManagers::delete
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteRequest {
        /// Name of the managed instance group to delete.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl DeleteRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::DeleteRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::DeleteRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::DeleteRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_group_managers::DeleteRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_group_managers::DeleteRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [deleteInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.deleteInstances] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.deleteInstances]: crate::client::RegionInstanceGroupManagers::delete_instances
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteInstancesRequest {
        /// Name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [deleteInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.deleteInstances] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroupManagers.deleteInstances]: crate::client::RegionInstanceGroupManagers::delete_instances
        pub body:
            std::option::Option<crate::model::RegionInstanceGroupManagersDeleteInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl DeleteInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::DeleteInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::DeleteInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::DeleteInstancesRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_group_managers::DeleteInstancesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_group_managers::DeleteInstancesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::region_instance_group_managers::DeleteInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersDeleteInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_group_managers::DeleteInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersDeleteInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [deletePerInstanceConfigs()][google.cloud.compute.v1.regionInstanceGroupManagers.deletePerInstanceConfigs] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.deletePerInstanceConfigs]: crate::client::RegionInstanceGroupManagers::delete_per_instance_configs
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeletePerInstanceConfigsRequest {
        /// The name of the managed instance group. It should conform to RFC1035.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request, should conform to RFC1035.
        pub region: std::string::String,

        /// Synthetic request body field for the [deletePerInstanceConfigs()][google.cloud.compute.v1.regionInstanceGroupManagers.deletePerInstanceConfigs] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroupManagers.deletePerInstanceConfigs]: crate::client::RegionInstanceGroupManagers::delete_per_instance_configs
        pub body:
            std::option::Option<crate::model::RegionInstanceGroupManagerDeleteInstanceConfigReq>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl DeletePerInstanceConfigsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::DeletePerInstanceConfigsRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::DeletePerInstanceConfigsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::DeletePerInstanceConfigsRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [body][crate::model::region_instance_group_managers::DeletePerInstanceConfigsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagerDeleteInstanceConfigReq>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_group_managers::DeletePerInstanceConfigsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagerDeleteInstanceConfigReq>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [get()][google.cloud.compute.v1.regionInstanceGroupManagers.get] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.get]: crate::client::RegionInstanceGroupManagers::get
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// Name of the managed instance group to return.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::GetRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::GetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::GetRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }
    }

    /// Synthetic request message for the [insert()][google.cloud.compute.v1.regionInstanceGroupManagers.insert] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.insert]: crate::client::RegionInstanceGroupManagers::insert
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InsertRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [insert()][google.cloud.compute.v1.regionInstanceGroupManagers.insert] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroupManagers.insert]: crate::client::RegionInstanceGroupManagers::insert
        pub body: std::option::Option<crate::model::InstanceGroupManager>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl InsertRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::InsertRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::InsertRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_group_managers::InsertRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_group_managers::InsertRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::region_instance_group_managers::InsertRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManager>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_group_managers::InsertRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManager>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.regionInstanceGroupManagers.list] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.list]: crate::client::RegionInstanceGroupManagers::list
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::region_instance_group_managers::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::region_instance_group_managers::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::region_instance_group_managers::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::region_instance_group_managers::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::region_instance_group_managers::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::region_instance_group_managers::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::region_instance_group_managers::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::region_instance_group_managers::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::ListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::ListRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::region_instance_group_managers::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::region_instance_group_managers::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [listErrors()][google.cloud.compute.v1.regionInstanceGroupManagers.listErrors] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.listErrors]: crate::client::RegionInstanceGroupManagers::list_errors
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListErrorsRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The name of the managed instance group.
        /// It must be a string that meets the requirements in RFC1035, or an
        /// unsigned long integer: must match regexp pattern:
        /// (?:[a-z](?:[-a-z0-9]{0,61}[a-z0-9])?)|1-9{0,19}.
        pub instance_group_manager: std::string::String,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        /// This should conform to RFC1035.
        pub region: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl ListErrorsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::region_instance_group_managers::ListErrorsRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::region_instance_group_managers::ListErrorsRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::ListErrorsRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [max_results][crate::model::region_instance_group_managers::ListErrorsRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::region_instance_group_managers::ListErrorsRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::region_instance_group_managers::ListErrorsRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::region_instance_group_managers::ListErrorsRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::region_instance_group_managers::ListErrorsRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::region_instance_group_managers::ListErrorsRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::ListErrorsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::ListErrorsRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::region_instance_group_managers::ListErrorsRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::region_instance_group_managers::ListErrorsRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [listManagedInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.listManagedInstances] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.listManagedInstances]: crate::client::RegionInstanceGroupManagers::list_managed_instances
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListManagedInstancesRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl ListManagedInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::region_instance_group_managers::ListManagedInstancesRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::region_instance_group_managers::ListManagedInstancesRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::ListManagedInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [max_results][crate::model::region_instance_group_managers::ListManagedInstancesRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::region_instance_group_managers::ListManagedInstancesRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::region_instance_group_managers::ListManagedInstancesRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::region_instance_group_managers::ListManagedInstancesRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::region_instance_group_managers::ListManagedInstancesRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::region_instance_group_managers::ListManagedInstancesRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::ListManagedInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::ListManagedInstancesRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::region_instance_group_managers::ListManagedInstancesRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::region_instance_group_managers::ListManagedInstancesRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [listPerInstanceConfigs()][google.cloud.compute.v1.regionInstanceGroupManagers.listPerInstanceConfigs] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.listPerInstanceConfigs]: crate::client::RegionInstanceGroupManagers::list_per_instance_configs
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListPerInstanceConfigsRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The name of the managed instance group. It should conform to RFC1035.
        pub instance_group_manager: std::string::String,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request, should conform to RFC1035.
        pub region: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl ListPerInstanceConfigsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::region_instance_group_managers::ListPerInstanceConfigsRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::region_instance_group_managers::ListPerInstanceConfigsRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::ListPerInstanceConfigsRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [max_results][crate::model::region_instance_group_managers::ListPerInstanceConfigsRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::region_instance_group_managers::ListPerInstanceConfigsRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::region_instance_group_managers::ListPerInstanceConfigsRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::region_instance_group_managers::ListPerInstanceConfigsRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::region_instance_group_managers::ListPerInstanceConfigsRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::region_instance_group_managers::ListPerInstanceConfigsRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::ListPerInstanceConfigsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::ListPerInstanceConfigsRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::region_instance_group_managers::ListPerInstanceConfigsRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::region_instance_group_managers::ListPerInstanceConfigsRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [patch()][google.cloud.compute.v1.regionInstanceGroupManagers.patch] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.patch]: crate::client::RegionInstanceGroupManagers::patch
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PatchRequest {
        /// The name of the instance group manager.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [patch()][google.cloud.compute.v1.regionInstanceGroupManagers.patch] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroupManagers.patch]: crate::client::RegionInstanceGroupManagers::patch
        pub body: std::option::Option<crate::model::InstanceGroupManager>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl PatchRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::PatchRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::PatchRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::PatchRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_group_managers::PatchRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_group_managers::PatchRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::region_instance_group_managers::PatchRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManager>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_group_managers::PatchRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceGroupManager>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [patchPerInstanceConfigs()][google.cloud.compute.v1.regionInstanceGroupManagers.patchPerInstanceConfigs] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.patchPerInstanceConfigs]: crate::client::RegionInstanceGroupManagers::patch_per_instance_configs
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PatchPerInstanceConfigsRequest {
        /// The name of the managed instance group.
        /// It should conform to RFC1035.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request, should conform to RFC1035.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [patchPerInstanceConfigs()][google.cloud.compute.v1.regionInstanceGroupManagers.patchPerInstanceConfigs] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroupManagers.patchPerInstanceConfigs]: crate::client::RegionInstanceGroupManagers::patch_per_instance_configs
        pub body:
            std::option::Option<crate::model::RegionInstanceGroupManagerPatchInstanceConfigReq>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl PatchPerInstanceConfigsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::PatchPerInstanceConfigsRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::PatchPerInstanceConfigsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::PatchPerInstanceConfigsRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_group_managers::PatchPerInstanceConfigsRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_group_managers::PatchPerInstanceConfigsRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::region_instance_group_managers::PatchPerInstanceConfigsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagerPatchInstanceConfigReq>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_group_managers::PatchPerInstanceConfigsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagerPatchInstanceConfigReq>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [recreateInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.recreateInstances] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.recreateInstances]: crate::client::RegionInstanceGroupManagers::recreate_instances
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RecreateInstancesRequest {
        /// Name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [recreateInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.recreateInstances] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroupManagers.recreateInstances]: crate::client::RegionInstanceGroupManagers::recreate_instances
        pub body: std::option::Option<crate::model::RegionInstanceGroupManagersRecreateRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl RecreateInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::RecreateInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::RecreateInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::RecreateInstancesRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_group_managers::RecreateInstancesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_group_managers::RecreateInstancesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::region_instance_group_managers::RecreateInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersRecreateRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_group_managers::RecreateInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersRecreateRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [resize()][google.cloud.compute.v1.regionInstanceGroupManagers.resize] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.resize]: crate::client::RegionInstanceGroupManagers::resize
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResizeRequest {
        /// Name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Number of instances that should exist in this instance group
        /// manager.
        pub size: i32,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl ResizeRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::ResizeRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::ResizeRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::ResizeRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_group_managers::ResizeRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_group_managers::ResizeRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [size][crate::model::region_instance_group_managers::ResizeRequest::size].
        pub fn set_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.size = v.into();
            self
        }
    }

    /// Synthetic request message for the [resumeInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.resumeInstances] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.resumeInstances]: crate::client::RegionInstanceGroupManagers::resume_instances
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResumeInstancesRequest {
        /// Name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [resumeInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.resumeInstances] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroupManagers.resumeInstances]: crate::client::RegionInstanceGroupManagers::resume_instances
        pub body:
            std::option::Option<crate::model::RegionInstanceGroupManagersResumeInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl ResumeInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::ResumeInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::ResumeInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::ResumeInstancesRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_group_managers::ResumeInstancesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_group_managers::ResumeInstancesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::region_instance_group_managers::ResumeInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersResumeInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_group_managers::ResumeInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersResumeInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setInstanceTemplate()][google.cloud.compute.v1.regionInstanceGroupManagers.setInstanceTemplate] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.setInstanceTemplate]: crate::client::RegionInstanceGroupManagers::set_instance_template
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetInstanceTemplateRequest {
        /// The name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [setInstanceTemplate()][google.cloud.compute.v1.regionInstanceGroupManagers.setInstanceTemplate] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroupManagers.setInstanceTemplate]: crate::client::RegionInstanceGroupManagers::set_instance_template
        pub body: std::option::Option<crate::model::RegionInstanceGroupManagersSetTemplateRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl SetInstanceTemplateRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::SetInstanceTemplateRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::SetInstanceTemplateRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::SetInstanceTemplateRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_group_managers::SetInstanceTemplateRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_group_managers::SetInstanceTemplateRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::region_instance_group_managers::SetInstanceTemplateRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersSetTemplateRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_group_managers::SetInstanceTemplateRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersSetTemplateRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setTargetPools()][google.cloud.compute.v1.regionInstanceGroupManagers.setTargetPools] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.setTargetPools]: crate::client::RegionInstanceGroupManagers::set_target_pools
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetTargetPoolsRequest {
        /// Name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [setTargetPools()][google.cloud.compute.v1.regionInstanceGroupManagers.setTargetPools] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroupManagers.setTargetPools]: crate::client::RegionInstanceGroupManagers::set_target_pools
        pub body:
            std::option::Option<crate::model::RegionInstanceGroupManagersSetTargetPoolsRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl SetTargetPoolsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::SetTargetPoolsRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::SetTargetPoolsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::SetTargetPoolsRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_group_managers::SetTargetPoolsRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_group_managers::SetTargetPoolsRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::region_instance_group_managers::SetTargetPoolsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersSetTargetPoolsRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_group_managers::SetTargetPoolsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersSetTargetPoolsRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [startInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.startInstances] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.startInstances]: crate::client::RegionInstanceGroupManagers::start_instances
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StartInstancesRequest {
        /// Name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [startInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.startInstances] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroupManagers.startInstances]: crate::client::RegionInstanceGroupManagers::start_instances
        pub body:
            std::option::Option<crate::model::RegionInstanceGroupManagersStartInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl StartInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::StartInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::StartInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::StartInstancesRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_group_managers::StartInstancesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_group_managers::StartInstancesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::region_instance_group_managers::StartInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersStartInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_group_managers::StartInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersStartInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [stopInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.stopInstances] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.stopInstances]: crate::client::RegionInstanceGroupManagers::stop_instances
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StopInstancesRequest {
        /// The name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [stopInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.stopInstances] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroupManagers.stopInstances]: crate::client::RegionInstanceGroupManagers::stop_instances
        pub body:
            std::option::Option<crate::model::RegionInstanceGroupManagersStopInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl StopInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::StopInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::StopInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::StopInstancesRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_group_managers::StopInstancesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_group_managers::StopInstancesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::region_instance_group_managers::StopInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersStopInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_group_managers::StopInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersStopInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [suspendInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.suspendInstances] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.suspendInstances]: crate::client::RegionInstanceGroupManagers::suspend_instances
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SuspendInstancesRequest {
        /// Name of the managed instance group.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [suspendInstances()][google.cloud.compute.v1.regionInstanceGroupManagers.suspendInstances] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroupManagers.suspendInstances]: crate::client::RegionInstanceGroupManagers::suspend_instances
        pub body:
            std::option::Option<crate::model::RegionInstanceGroupManagersSuspendInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl SuspendInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::SuspendInstancesRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::SuspendInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::SuspendInstancesRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_group_managers::SuspendInstancesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_group_managers::SuspendInstancesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::region_instance_group_managers::SuspendInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersSuspendInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_group_managers::SuspendInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagersSuspendInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [updatePerInstanceConfigs()][google.cloud.compute.v1.regionInstanceGroupManagers.updatePerInstanceConfigs] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroupManagers.updatePerInstanceConfigs]: crate::client::RegionInstanceGroupManagers::update_per_instance_configs
    #[cfg(feature = "region-instance-group-managers")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UpdatePerInstanceConfigsRequest {
        /// The name of the managed instance group.
        /// It should conform to RFC1035.
        pub instance_group_manager: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request, should conform to RFC1035.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [updatePerInstanceConfigs()][google.cloud.compute.v1.regionInstanceGroupManagers.updatePerInstanceConfigs] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroupManagers.updatePerInstanceConfigs]: crate::client::RegionInstanceGroupManagers::update_per_instance_configs
        pub body:
            std::option::Option<crate::model::RegionInstanceGroupManagerUpdateInstanceConfigReq>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-group-managers")]
    impl UpdatePerInstanceConfigsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group_manager][crate::model::region_instance_group_managers::UpdatePerInstanceConfigsRequest::instance_group_manager].
        pub fn set_instance_group_manager<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group_manager = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_group_managers::UpdatePerInstanceConfigsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_group_managers::UpdatePerInstanceConfigsRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_group_managers::UpdatePerInstanceConfigsRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_group_managers::UpdatePerInstanceConfigsRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::region_instance_group_managers::UpdatePerInstanceConfigsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagerUpdateInstanceConfigReq>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_group_managers::UpdatePerInstanceConfigsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupManagerUpdateInstanceConfigReq>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }
}

/// Synthetic messages for the [regionInstanceGroups][google.cloud.compute.v1.regionInstanceGroups] service
///
/// [google.cloud.compute.v1.regionInstanceGroups]: crate::model::RegionInstanceGroups
#[cfg(feature = "region-instance-groups")]
pub mod region_instance_groups {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [get()][google.cloud.compute.v1.regionInstanceGroups.get] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroups.get]: crate::client::RegionInstanceGroups::get
    #[cfg(feature = "region-instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// Name of the instance group resource to return.
        pub instance_group: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-groups")]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group][crate::model::region_instance_groups::GetRequest::instance_group].
        pub fn set_instance_group<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_groups::GetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_groups::GetRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.regionInstanceGroups.list] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroups.list]: crate::client::RegionInstanceGroups::list
    #[cfg(feature = "region-instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-groups")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::region_instance_groups::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::region_instance_groups::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::region_instance_groups::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::region_instance_groups::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::region_instance_groups::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::region_instance_groups::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::region_instance_groups::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::region_instance_groups::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::region_instance_groups::ListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_groups::ListRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::region_instance_groups::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::region_instance_groups::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [listInstances()][google.cloud.compute.v1.regionInstanceGroups.listInstances] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroups.listInstances]: crate::client::RegionInstanceGroups::list_instances
    #[cfg(feature = "region-instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListInstancesRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// Name of the regional instance group for which we want to list the
        /// instances.
        pub instance_group: std::string::String,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// Synthetic request body field for the [listInstances()][google.cloud.compute.v1.regionInstanceGroups.listInstances] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroups.listInstances]: crate::client::RegionInstanceGroups::list_instances
        pub body: std::option::Option<crate::model::RegionInstanceGroupsListInstancesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-groups")]
    impl ListInstancesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::region_instance_groups::ListInstancesRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::region_instance_groups::ListInstancesRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [instance_group][crate::model::region_instance_groups::ListInstancesRequest::instance_group].
        pub fn set_instance_group<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group = v.into();
            self
        }

        /// Sets the value of [max_results][crate::model::region_instance_groups::ListInstancesRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::region_instance_groups::ListInstancesRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::region_instance_groups::ListInstancesRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::region_instance_groups::ListInstancesRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::region_instance_groups::ListInstancesRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::region_instance_groups::ListInstancesRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::region_instance_groups::ListInstancesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_groups::ListInstancesRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::region_instance_groups::ListInstancesRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::region_instance_groups::ListInstancesRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::region_instance_groups::ListInstancesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupsListInstancesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_groups::ListInstancesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupsListInstancesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setNamedPorts()][google.cloud.compute.v1.regionInstanceGroups.setNamedPorts] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroups.setNamedPorts]: crate::client::RegionInstanceGroups::set_named_ports
    #[cfg(feature = "region-instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetNamedPortsRequest {
        /// The name of the regional instance group where the named ports are updated.
        pub instance_group: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region scoping this request.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [setNamedPorts()][google.cloud.compute.v1.regionInstanceGroups.setNamedPorts] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroups.setNamedPorts]: crate::client::RegionInstanceGroups::set_named_ports
        pub body: std::option::Option<crate::model::RegionInstanceGroupsSetNamedPortsRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-groups")]
    impl SetNamedPortsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_group][crate::model::region_instance_groups::SetNamedPortsRequest::instance_group].
        pub fn set_instance_group<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_group = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_groups::SetNamedPortsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_groups::SetNamedPortsRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_groups::SetNamedPortsRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_groups::SetNamedPortsRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::region_instance_groups::SetNamedPortsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupsSetNamedPortsRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_groups::SetNamedPortsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RegionInstanceGroupsSetNamedPortsRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [testIamPermissions()][google.cloud.compute.v1.regionInstanceGroups.testIamPermissions] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceGroups.testIamPermissions]: crate::client::RegionInstanceGroups::test_iam_permissions
    #[cfg(feature = "region-instance-groups")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TestIamPermissionsRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the region for this request.
        pub region: std::string::String,

        /// Name or id of the resource for this request.
        pub resource: std::string::String,

        /// Synthetic request body field for the [testIamPermissions()][google.cloud.compute.v1.regionInstanceGroups.testIamPermissions] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceGroups.testIamPermissions]: crate::client::RegionInstanceGroups::test_iam_permissions
        pub body: std::option::Option<crate::model::TestPermissionsRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-groups")]
    impl TestIamPermissionsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::region_instance_groups::TestIamPermissionsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_groups::TestIamPermissionsRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::region_instance_groups::TestIamPermissionsRequest::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [body][crate::model::region_instance_groups::TestIamPermissionsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TestPermissionsRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_groups::TestIamPermissionsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TestPermissionsRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }
}

/// Synthetic messages for the [regionInstanceTemplates][google.cloud.compute.v1.regionInstanceTemplates] service
///
/// [google.cloud.compute.v1.regionInstanceTemplates]: crate::model::RegionInstanceTemplates
#[cfg(feature = "region-instance-templates")]
pub mod region_instance_templates {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [delete()][google.cloud.compute.v1.regionInstanceTemplates.delete] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceTemplates.delete]: crate::client::RegionInstanceTemplates::delete
    #[cfg(feature = "region-instance-templates")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteRequest {
        /// The name of the instance template to delete.
        pub instance_template: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the region for this request.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-templates")]
    impl DeleteRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_template][crate::model::region_instance_templates::DeleteRequest::instance_template].
        pub fn set_instance_template<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_template = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_templates::DeleteRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_templates::DeleteRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_templates::DeleteRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_templates::DeleteRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [get()][google.cloud.compute.v1.regionInstanceTemplates.get] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceTemplates.get]: crate::client::RegionInstanceTemplates::get
    #[cfg(feature = "region-instance-templates")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// The name of the instance template.
        pub instance_template: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the region for this request.
        pub region: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-templates")]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance_template][crate::model::region_instance_templates::GetRequest::instance_template].
        pub fn set_instance_template<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.instance_template = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_instance_templates::GetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_templates::GetRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }
    }

    /// Synthetic request message for the [insert()][google.cloud.compute.v1.regionInstanceTemplates.insert] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceTemplates.insert]: crate::client::RegionInstanceTemplates::insert
    #[cfg(feature = "region-instance-templates")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InsertRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the region for this request.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [insert()][google.cloud.compute.v1.regionInstanceTemplates.insert] method.
        ///
        /// [google.cloud.compute.v1.regionInstanceTemplates.insert]: crate::client::RegionInstanceTemplates::insert
        pub body: std::option::Option<crate::model::InstanceTemplate>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-templates")]
    impl InsertRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::region_instance_templates::InsertRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_templates::InsertRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instance_templates::InsertRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instance_templates::InsertRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::region_instance_templates::InsertRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstanceTemplate>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instance_templates::InsertRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstanceTemplate>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.regionInstanceTemplates.list] method.
    ///
    /// [google.cloud.compute.v1.regionInstanceTemplates.list]: crate::client::RegionInstanceTemplates::list
    #[cfg(feature = "region-instance-templates")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the regions for this request.
        pub region: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instance-templates")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::region_instance_templates::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::region_instance_templates::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::region_instance_templates::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::region_instance_templates::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::region_instance_templates::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::region_instance_templates::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::region_instance_templates::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::region_instance_templates::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::region_instance_templates::ListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instance_templates::ListRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::region_instance_templates::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::region_instance_templates::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }
    }
}

/// Synthetic messages for the [regionInstances][google.cloud.compute.v1.regionInstances] service
///
/// [google.cloud.compute.v1.regionInstances]: crate::model::RegionInstances
#[cfg(feature = "region-instances")]
pub mod region_instances {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [bulkInsert()][google.cloud.compute.v1.regionInstances.bulkInsert] method.
    ///
    /// [google.cloud.compute.v1.regionInstances.bulkInsert]: crate::client::RegionInstances::bulk_insert
    #[cfg(feature = "region-instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BulkInsertRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the region for this request.
        pub region: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so
        /// that if you must retry your request, the server will know to ignore the
        /// request if it has already been completed.
        ///
        /// For example, consider a situation where you make an initial request and
        /// the request times out. If you make the request again with the same
        /// request ID, the server can check if original operation with the same
        /// request ID was received, and if so, will ignore the second request. This
        /// prevents clients from accidentally creating duplicate commitments.
        ///
        /// The request ID must be
        /// a valid UUID with the exception that zero UUID is not supported
        /// (00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [bulkInsert()][google.cloud.compute.v1.regionInstances.bulkInsert] method.
        ///
        /// [google.cloud.compute.v1.regionInstances.bulkInsert]: crate::client::RegionInstances::bulk_insert
        pub body: std::option::Option<crate::model::BulkInsertInstanceResource>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-instances")]
    impl BulkInsertRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::region_instances::BulkInsertRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_instances::BulkInsertRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::region_instances::BulkInsertRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::region_instances::BulkInsertRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::region_instances::BulkInsertRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::BulkInsertInstanceResource>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::region_instances::BulkInsertRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::BulkInsertInstanceResource>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }
}

/// Synthetic messages for the [regionOperations][google.cloud.compute.v1.regionOperations] service
///
/// [google.cloud.compute.v1.regionOperations]: crate::model::RegionOperations
#[cfg(any(
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
))]
pub mod region_operations {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [delete()][google.cloud.compute.v1.regionOperations.delete] method.
    ///
    /// [google.cloud.compute.v1.regionOperations.delete]: crate::client::RegionOperations::delete
    #[cfg(feature = "region-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteRequest {
        /// Name of the Operations resource to delete, or its unique numeric
        /// identifier.
        pub operation: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region for this request.
        pub region: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-operations")]
    impl DeleteRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation][crate::model::region_operations::DeleteRequest::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_operations::DeleteRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_operations::DeleteRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }
    }

    /// Synthetic request message for the [get()][google.cloud.compute.v1.regionOperations.get] method.
    ///
    /// [google.cloud.compute.v1.regionOperations.get]: crate::client::RegionOperations::get
    #[cfg(any(
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
    ))]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// Name of the Operations resource to return, or its unique numeric
        /// identifier.
        pub operation: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region for this request.
        pub region: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "region-instance-group-managers",
        feature = "region-instance-groups",
        feature = "region-instance-templates",
        feature = "region-instances",
        feature = "region-operations",
    ))]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation][crate::model::region_operations::GetRequest::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_operations::GetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_operations::GetRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.regionOperations.list] method.
    ///
    /// [google.cloud.compute.v1.regionOperations.list]: crate::client::RegionOperations::list
    #[cfg(feature = "region-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region for this request.
        pub region: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-operations")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::region_operations::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::region_operations::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::region_operations::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::region_operations::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::region_operations::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::region_operations::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::region_operations::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::region_operations::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::region_operations::ListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_operations::ListRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::region_operations::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::region_operations::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [wait()][google.cloud.compute.v1.regionOperations.wait] method.
    ///
    /// [google.cloud.compute.v1.regionOperations.wait]: crate::client::RegionOperations::wait
    #[cfg(feature = "region-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WaitRequest {
        /// Name of the Operations resource to return, or its unique numeric
        /// identifier.
        pub operation: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the region for this request.
        pub region: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "region-operations")]
    impl WaitRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation][crate::model::region_operations::WaitRequest::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [project][crate::model::region_operations::WaitRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [region][crate::model::region_operations::WaitRequest::region].
        pub fn set_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.region = v.into();
            self
        }
    }
}

/// Synthetic messages for the [zoneOperations][google.cloud.compute.v1.zoneOperations] service
///
/// [google.cloud.compute.v1.zoneOperations]: crate::model::ZoneOperations
#[cfg(any(
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "zone-operations",
))]
pub mod zone_operations {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [delete()][google.cloud.compute.v1.zoneOperations.delete] method.
    ///
    /// [google.cloud.compute.v1.zoneOperations.delete]: crate::client::ZoneOperations::delete
    #[cfg(feature = "zone-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteRequest {
        /// Name of the Operations resource to delete, or its unique numeric
        /// identifier.
        pub operation: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "zone-operations")]
    impl DeleteRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation][crate::model::zone_operations::DeleteRequest::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [project][crate::model::zone_operations::DeleteRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::zone_operations::DeleteRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [get()][google.cloud.compute.v1.zoneOperations.get] method.
    ///
    /// [google.cloud.compute.v1.zoneOperations.get]: crate::client::ZoneOperations::get
    #[cfg(any(
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "zone-operations",
    ))]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// Name of the Operations resource to return, or its unique numeric
        /// identifier.
        pub operation: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(
        feature = "instance-group-manager-resize-requests",
        feature = "instance-group-managers",
        feature = "instance-groups",
        feature = "instances",
        feature = "zone-operations",
    ))]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation][crate::model::zone_operations::GetRequest::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [project][crate::model::zone_operations::GetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::zone_operations::GetRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.zoneOperations.list] method.
    ///
    /// [google.cloud.compute.v1.zoneOperations.list]: crate::client::ZoneOperations::list
    #[cfg(feature = "zone-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// Name of the zone for request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "zone-operations")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::zone_operations::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::zone_operations::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::zone_operations::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::zone_operations::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::zone_operations::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::zone_operations::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::zone_operations::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::zone_operations::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::zone_operations::ListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::zone_operations::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::zone_operations::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::zone_operations::ListRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [wait()][google.cloud.compute.v1.zoneOperations.wait] method.
    ///
    /// [google.cloud.compute.v1.zoneOperations.wait]: crate::client::ZoneOperations::wait
    #[cfg(feature = "zone-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WaitRequest {
        /// Name of the Operations resource to return, or its unique numeric
        /// identifier.
        pub operation: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "zone-operations")]
    impl WaitRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation][crate::model::zone_operations::WaitRequest::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [project][crate::model::zone_operations::WaitRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::zone_operations::WaitRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }
}

/// Synthetic messages for the [zones][google.cloud.compute.v1.zones] service
///
/// [google.cloud.compute.v1.zones]: crate::model::Zones
#[cfg(feature = "zones")]
pub mod zones {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [get()][google.cloud.compute.v1.zones.get] method.
    ///
    /// [google.cloud.compute.v1.zones.get]: crate::client::Zones::get
    #[cfg(feature = "zones")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the zone resource to return.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "zones")]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::zones::GetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::zones::GetRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.zones.list] method.
    ///
    /// [google.cloud.compute.v1.zones.list]: crate::client::Zones::list
    #[cfg(feature = "zones")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most
        /// Compute resources support two types of filter expressions:
        /// expressions that support regular expressions and expressions that follow
        /// API improvement proposal AIP-160.
        /// These two types of filter expressions cannot be mixed in one request.
        ///
        /// If you want to use AIP-160, your expression must specify the field name, an
        /// operator, and the value that you want to use for filtering. The value
        /// must be a string, a number, or a boolean. The operator
        /// must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`.
        ///
        /// For example, if you are filtering Compute Engine instances, you can
        /// exclude instances named `example-instance` by specifying
        /// `name != example-instance`.
        ///
        /// The `:*` comparison can be used to test whether a key has been defined.
        /// For example, to find all objects with `owner` label use:
        ///
        /// ```norust
        /// labels.owner:*
        /// ```
        ///
        /// You can also filter nested fields. For example, you could specify
        /// `scheduling.automaticRestart = false` to include instances only
        /// if they are not scheduled for automatic restarts. You can use filtering
        /// on nested fields to filter based onresource labels.
        ///
        /// To filter on multiple expressions, provide each separate expression within
        /// parentheses. For example:
        ///
        /// ```norust
        /// (scheduling.automaticRestart = true)
        /// (cpuPlatform = "Intel Skylake")
        /// ```
        ///
        /// By default, each expression is an `AND` expression. However, you
        /// can include `AND` and `OR` expressions explicitly.
        /// For example:
        ///
        /// ```norust
        /// (cpuPlatform = "Intel Skylake") OR
        /// (cpuPlatform = "Intel Broadwell") AND
        /// (scheduling.automaticRestart = true)
        /// ```
        ///
        /// If you want to use a regular expression, use the `eq` (equal) or `ne`
        /// (not equal) operator against a single un-parenthesized expression with or
        /// without quotes or against multiple parenthesized expressions. Examples:
        ///
        /// `fieldname eq unquoted literal`
        /// `fieldname eq 'single quoted literal'`
        /// `fieldname eq "double quoted literal"`
        /// `(fieldname1 eq literal) (fieldname2 ne "literal")`
        ///
        /// The literal value is interpreted as a regular expression using GoogleRE2 library syntax.
        /// The literal value must match the entire field.
        ///
        /// For example, to filter for instances that do not end with name "instance",
        /// you would use `name ne .*instance`.
        ///
        /// You cannot combine constraints on multiple fields using regular
        /// expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The maximum number of results per page that should be returned.
        /// If the number of available results is larger than `maxResults`,
        /// Compute Engine returns a `nextPageToken` that can be used to get
        /// the next page of results in subsequent list requests. Acceptable values are
        /// `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results
        /// are returned in alphanumerical order based on the resource name.
        ///
        /// You can also sort results in descending order based on the creation
        /// timestamp using `orderBy="creationTimestamp desc"`. This sorts
        /// results based on the `creationTimestamp` field in
        /// reverse chronological order (newest result first). Use this to sort
        /// resources like operations so that the newest operation is returned first.
        ///
        /// Currently, only sorting by `name` or
        /// `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the
        /// `nextPageToken` returned by a previous list request to get
        /// the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case
        /// of failure. The default value is false.
        ///
        /// For example, when partial success behavior is enabled, aggregatedList for a
        /// single zone scope either returns all resources in the zone or no resources,
        /// with an error code.
        pub return_partial_success: std::option::Option<bool>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "zones")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::zones::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::zones::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::zones::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::zones::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::zones::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::zones::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::zones::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::zones::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::zones::ListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::zones::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::zones::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }
    }
}
