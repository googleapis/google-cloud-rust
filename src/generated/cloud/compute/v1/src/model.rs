// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

mod debug;
mod deserialize;
mod serialize;

/// A specification of the type and number of accelerator cards attached to the instance.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AcceleratorConfig {
    /// The number of the guest accelerator cards exposed to this instance.
    pub accelerator_count: std::option::Option<i32>,

    /// Full or partial URL of the accelerator type resource to attach to this instance. For example: projects/my-project/zones/us-central1-c/acceleratorTypes/nvidia-tesla-p100 If you are creating an instance template, specify only the accelerator name. See GPUs on Compute Engine for a full list of accelerator types.
    pub accelerator_type: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl AcceleratorConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [accelerator_count][crate::model::AcceleratorConfig::accelerator_count].
    pub fn set_accelerator_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.accelerator_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [accelerator_count][crate::model::AcceleratorConfig::accelerator_count].
    pub fn set_or_clear_accelerator_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.accelerator_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [accelerator_type][crate::model::AcceleratorConfig::accelerator_type].
    pub fn set_accelerator_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.accelerator_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [accelerator_type][crate::model::AcceleratorConfig::accelerator_type].
    pub fn set_or_clear_accelerator_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.accelerator_type = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for AcceleratorConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.AcceleratorConfig"
    }
}

/// An access configuration attached to an instance's network interface. Only one access config per instance is supported.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AccessConfig {
    /// Applies to ipv6AccessConfigs only. The first IPv6 address of the external IPv6 range associated with this instance, prefix length is stored in externalIpv6PrefixLength in ipv6AccessConfig. To use a static external IP address, it must be unused and in the same region as the instance's zone. If not specified, Google Cloud will automatically assign an external IPv6 address from the instance's subnetwork.
    pub external_ipv_6: std::option::Option<std::string::String>,

    /// Applies to ipv6AccessConfigs only. The prefix length of the external IPv6 range.
    pub external_ipv_6_prefix_length: std::option::Option<i32>,

    /// [Output Only] Type of the resource. Always compute#accessConfig for access configs.
    pub kind: std::option::Option<std::string::String>,

    /// The name of this access configuration. In accessConfigs (IPv4), the default and recommended name is External NAT, but you can use any arbitrary string, such as My external IP or Network Access. In ipv6AccessConfigs, the recommend name is External IPv6.
    pub name: std::option::Option<std::string::String>,

    /// Applies to accessConfigs (IPv4) only. An external IP address associated with this instance. Specify an unused static external IP address available to the project or leave this field undefined to use an IP from a shared ephemeral IP address pool. If you specify a static external IP address, it must live in the same region as the zone of the instance.
    pub nat_ip: std::option::Option<std::string::String>,

    /// This signifies the networking tier used for configuring this access configuration and can only take the following values: PREMIUM, STANDARD. If an AccessConfig is specified without a valid external IP address, an ephemeral IP will be created with this networkTier. If an AccessConfig with a valid external IP address is specified, it must match that of the networkTier associated with the Address resource owning that IP.
    pub network_tier: std::option::Option<crate::model::access_config::NetworkTier>,

    /// The DNS domain name for the public PTR record. You can set this field only if the `setPublicPtr` field is enabled in accessConfig. If this field is unspecified in ipv6AccessConfig, a default PTR record will be created for first IP in associated external IPv6 range.
    pub public_ptr_domain_name: std::option::Option<std::string::String>,

    /// The resource URL for the security policy associated with this access config.
    pub security_policy: std::option::Option<std::string::String>,

    /// Specifies whether a public DNS 'PTR' record should be created to map the external IP address of the instance to a DNS domain name. This field is not used in ipv6AccessConfig. A default PTR record will be created if the VM has external IPv6 range associated.
    pub set_public_ptr: std::option::Option<bool>,

    /// The type of configuration. In accessConfigs (IPv4), the default and only option is ONE_TO_ONE_NAT. In ipv6AccessConfigs, the default and only option is DIRECT_IPV6.
    pub r#type: std::option::Option<crate::model::access_config::Type>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl AccessConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [external_ipv_6][crate::model::AccessConfig::external_ipv_6].
    pub fn set_external_ipv_6<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.external_ipv_6 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_ipv_6][crate::model::AccessConfig::external_ipv_6].
    pub fn set_or_clear_external_ipv_6<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.external_ipv_6 = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_ipv_6_prefix_length][crate::model::AccessConfig::external_ipv_6_prefix_length].
    pub fn set_external_ipv_6_prefix_length<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.external_ipv_6_prefix_length = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [external_ipv_6_prefix_length][crate::model::AccessConfig::external_ipv_6_prefix_length].
    pub fn set_or_clear_external_ipv_6_prefix_length<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.external_ipv_6_prefix_length = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::AccessConfig::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::AccessConfig::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::AccessConfig::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::AccessConfig::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [nat_ip][crate::model::AccessConfig::nat_ip].
    pub fn set_nat_ip<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.nat_ip = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nat_ip][crate::model::AccessConfig::nat_ip].
    pub fn set_or_clear_nat_ip<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.nat_ip = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_tier][crate::model::AccessConfig::network_tier].
    pub fn set_network_tier<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::access_config::NetworkTier>,
    {
        self.network_tier = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_tier][crate::model::AccessConfig::network_tier].
    pub fn set_or_clear_network_tier<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::access_config::NetworkTier>,
    {
        self.network_tier = v.map(|x| x.into());
        self
    }

    /// Sets the value of [public_ptr_domain_name][crate::model::AccessConfig::public_ptr_domain_name].
    pub fn set_public_ptr_domain_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.public_ptr_domain_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [public_ptr_domain_name][crate::model::AccessConfig::public_ptr_domain_name].
    pub fn set_or_clear_public_ptr_domain_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.public_ptr_domain_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [security_policy][crate::model::AccessConfig::security_policy].
    pub fn set_security_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.security_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [security_policy][crate::model::AccessConfig::security_policy].
    pub fn set_or_clear_security_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.security_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [set_public_ptr][crate::model::AccessConfig::set_public_ptr].
    pub fn set_set_public_ptr<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.set_public_ptr = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [set_public_ptr][crate::model::AccessConfig::set_public_ptr].
    pub fn set_or_clear_set_public_ptr<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.set_public_ptr = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::AccessConfig::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::access_config::Type>,
    {
        self.r#type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#type][crate::model::AccessConfig::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::access_config::Type>,
    {
        self.r#type = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for AccessConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.AccessConfig"
    }
}

/// Defines additional types related to [AccessConfig].
#[cfg(feature = "instances")]
pub mod access_config {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [networkTier][google.cloud.compute.v1.AccessConfig.networkTier] field.
    ///
    /// [google.cloud.compute.v1.AccessConfig.networkTier]: crate::model::access_config::NetworkTier
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NetworkTier {
        /// Public internet quality with fixed bandwidth.
        FixedStandard,
        /// High quality, Google-grade network tier, support for all networking products.
        Premium,
        /// Public internet quality, only limited support for other networking products.
        Standard,
        /// (Output only) Temporary tier for FIXED_STANDARD when fixed standard tier is expired or not configured.
        StandardOverridesFixedStandard,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NetworkTier::value] or
        /// [NetworkTier::name].
        UnknownValue(network_tier::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod network_tier {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl NetworkTier {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::FixedStandard => std::option::Option::Some(0),
                Self::Premium => std::option::Option::Some(1),
                Self::Standard => std::option::Option::Some(2),
                Self::StandardOverridesFixedStandard => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::FixedStandard => std::option::Option::Some("FIXED_STANDARD"),
                Self::Premium => std::option::Option::Some("PREMIUM"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::StandardOverridesFixedStandard => {
                    std::option::Option::Some("STANDARD_OVERRIDES_FIXED_STANDARD")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for NetworkTier {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for NetworkTier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for NetworkTier {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::FixedStandard,
                1 => Self::Premium,
                2 => Self::Standard,
                3 => Self::StandardOverridesFixedStandard,
                _ => Self::UnknownValue(network_tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for NetworkTier {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FIXED_STANDARD" => Self::FixedStandard,
                "PREMIUM" => Self::Premium,
                "STANDARD" => Self::Standard,
                "STANDARD_OVERRIDES_FIXED_STANDARD" => Self::StandardOverridesFixedStandard,
                _ => Self::UnknownValue(network_tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for NetworkTier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::FixedStandard => serializer.serialize_str("FIXED_STANDARD"),
                Self::Premium => serializer.serialize_str("PREMIUM"),
                Self::Standard => serializer.serialize_str("STANDARD"),
                Self::StandardOverridesFixedStandard => {
                    serializer.serialize_str("STANDARD_OVERRIDES_FIXED_STANDARD")
                }
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for NetworkTier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NetworkTier>::new(
                ".google.cloud.compute.v1.AccessConfig.networkTier",
            ))
        }
    }

    /// The enumerated type for the [type][google.cloud.compute.v1.AccessConfig.type] field.
    ///
    /// [google.cloud.compute.v1.AccessConfig.type]: crate::model::access_config::Type
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        DirectIpv6,
        OneToOneNat,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::DirectIpv6 => std::option::Option::Some(0),
                Self::OneToOneNat => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::DirectIpv6 => std::option::Option::Some("DIRECT_IPV6"),
                Self::OneToOneNat => std::option::Option::Some("ONE_TO_ONE_NAT"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::DirectIpv6,
                1 => Self::OneToOneNat,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DIRECT_IPV6" => Self::DirectIpv6,
                "ONE_TO_ONE_NAT" => Self::OneToOneNat,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::DirectIpv6 => serializer.serialize_str("DIRECT_IPV6"),
                Self::OneToOneNat => serializer.serialize_str("ONE_TO_ONE_NAT"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.compute.v1.AccessConfig.type",
            ))
        }
    }
}

/// Specifies options for controlling advanced machine features. Options that would traditionally be configured in a BIOS belong here. Features that require operating system support may have corresponding entries in the GuestOsFeatures of an Image (e.g., whether or not the OS in the Image supports nested virtualization being enabled or disabled).
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AdvancedMachineFeatures {
    /// Whether to enable nested virtualization or not (default is false).
    pub enable_nested_virtualization: std::option::Option<bool>,

    /// Whether to enable UEFI networking for instance creation.
    pub enable_uefi_networking: std::option::Option<bool>,

    /// Type of Performance Monitoring Unit requested on instance.
    pub performance_monitoring_unit:
        std::option::Option<crate::model::advanced_machine_features::PerformanceMonitoringUnit>,

    /// The number of threads per physical core. To disable simultaneous multithreading (SMT) set this to 1. If unset, the maximum number of threads supported per core by the underlying processor is assumed.
    pub threads_per_core: std::option::Option<i32>,

    /// Turbo frequency mode to use for the instance. Supported modes include: * ALL_CORE_MAX Using empty string or not setting this field will use the platform-specific default turbo mode.
    pub turbo_mode: std::option::Option<std::string::String>,

    /// The number of physical cores to expose to an instance. Multiply by the number of threads per core to compute the total number of virtual CPUs to expose to the instance. If unset, the number of cores is inferred from the instance's nominal CPU count and the underlying platform's SMT width.
    pub visible_core_count: std::option::Option<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl AdvancedMachineFeatures {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_nested_virtualization][crate::model::AdvancedMachineFeatures::enable_nested_virtualization].
    pub fn set_enable_nested_virtualization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_nested_virtualization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_nested_virtualization][crate::model::AdvancedMachineFeatures::enable_nested_virtualization].
    pub fn set_or_clear_enable_nested_virtualization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_nested_virtualization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_uefi_networking][crate::model::AdvancedMachineFeatures::enable_uefi_networking].
    pub fn set_enable_uefi_networking<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_uefi_networking = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_uefi_networking][crate::model::AdvancedMachineFeatures::enable_uefi_networking].
    pub fn set_or_clear_enable_uefi_networking<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_uefi_networking = v.map(|x| x.into());
        self
    }

    /// Sets the value of [performance_monitoring_unit][crate::model::AdvancedMachineFeatures::performance_monitoring_unit].
    pub fn set_performance_monitoring_unit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::advanced_machine_features::PerformanceMonitoringUnit>,
    {
        self.performance_monitoring_unit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [performance_monitoring_unit][crate::model::AdvancedMachineFeatures::performance_monitoring_unit].
    pub fn set_or_clear_performance_monitoring_unit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::advanced_machine_features::PerformanceMonitoringUnit>,
    {
        self.performance_monitoring_unit = v.map(|x| x.into());
        self
    }

    /// Sets the value of [threads_per_core][crate::model::AdvancedMachineFeatures::threads_per_core].
    pub fn set_threads_per_core<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.threads_per_core = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [threads_per_core][crate::model::AdvancedMachineFeatures::threads_per_core].
    pub fn set_or_clear_threads_per_core<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.threads_per_core = v.map(|x| x.into());
        self
    }

    /// Sets the value of [turbo_mode][crate::model::AdvancedMachineFeatures::turbo_mode].
    pub fn set_turbo_mode<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.turbo_mode = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [turbo_mode][crate::model::AdvancedMachineFeatures::turbo_mode].
    pub fn set_or_clear_turbo_mode<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.turbo_mode = v.map(|x| x.into());
        self
    }

    /// Sets the value of [visible_core_count][crate::model::AdvancedMachineFeatures::visible_core_count].
    pub fn set_visible_core_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.visible_core_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [visible_core_count][crate::model::AdvancedMachineFeatures::visible_core_count].
    pub fn set_or_clear_visible_core_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.visible_core_count = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for AdvancedMachineFeatures {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.AdvancedMachineFeatures"
    }
}

/// Defines additional types related to [AdvancedMachineFeatures].
#[cfg(feature = "instances")]
pub mod advanced_machine_features {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [performanceMonitoringUnit][google.cloud.compute.v1.AdvancedMachineFeatures.performanceMonitoringUnit] field.
    ///
    /// [google.cloud.compute.v1.AdvancedMachineFeatures.performanceMonitoringUnit]: crate::model::advanced_machine_features::PerformanceMonitoringUnit
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PerformanceMonitoringUnit {
        /// Architecturally defined non-LLC events.
        Architectural,
        /// Most documented core/L2 and LLC events.
        Enhanced,
        Unspecified,
        /// Most documented core/L2 events.
        Standard,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PerformanceMonitoringUnit::value] or
        /// [PerformanceMonitoringUnit::name].
        UnknownValue(performance_monitoring_unit::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod performance_monitoring_unit {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl PerformanceMonitoringUnit {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Architectural => std::option::Option::Some(0),
                Self::Enhanced => std::option::Option::Some(1),
                Self::Unspecified => std::option::Option::Some(2),
                Self::Standard => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Architectural => std::option::Option::Some("ARCHITECTURAL"),
                Self::Enhanced => std::option::Option::Some("ENHANCED"),
                Self::Unspecified => {
                    std::option::Option::Some("PERFORMANCE_MONITORING_UNIT_UNSPECIFIED")
                }
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for PerformanceMonitoringUnit {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for PerformanceMonitoringUnit {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for PerformanceMonitoringUnit {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Architectural,
                1 => Self::Enhanced,
                2 => Self::Unspecified,
                3 => Self::Standard,
                _ => Self::UnknownValue(performance_monitoring_unit::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for PerformanceMonitoringUnit {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ARCHITECTURAL" => Self::Architectural,
                "ENHANCED" => Self::Enhanced,
                "PERFORMANCE_MONITORING_UNIT_UNSPECIFIED" => Self::Unspecified,
                "STANDARD" => Self::Standard,
                _ => Self::UnknownValue(performance_monitoring_unit::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for PerformanceMonitoringUnit {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Architectural => serializer.serialize_str("ARCHITECTURAL"),
                Self::Enhanced => serializer.serialize_str("ENHANCED"),
                Self::Unspecified => {
                    serializer.serialize_str("PERFORMANCE_MONITORING_UNIT_UNSPECIFIED")
                }
                Self::Standard => serializer.serialize_str("STANDARD"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for PerformanceMonitoringUnit {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<PerformanceMonitoringUnit>::new(
                    ".google.cloud.compute.v1.AdvancedMachineFeatures.performanceMonitoringUnit",
                ),
            )
        }
    }
}

/// An alias IP range attached to an instance's network interface.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AliasIpRange {
    /// The IP alias ranges to allocate for this interface. This IP CIDR range must belong to the specified subnetwork and cannot contain IP addresses reserved by system or used by other network interfaces. This range may be a single IP address (such as 10.2.3.4), a netmask (such as /24) or a CIDR-formatted string (such as 10.1.2.0/24).
    pub ip_cidr_range: std::option::Option<std::string::String>,

    /// The name of a subnetwork secondary IP range from which to allocate an IP alias range. If not specified, the primary range of the subnetwork is used.
    pub subnetwork_range_name: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl AliasIpRange {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip_cidr_range][crate::model::AliasIpRange::ip_cidr_range].
    pub fn set_ip_cidr_range<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ip_cidr_range = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ip_cidr_range][crate::model::AliasIpRange::ip_cidr_range].
    pub fn set_or_clear_ip_cidr_range<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ip_cidr_range = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subnetwork_range_name][crate::model::AliasIpRange::subnetwork_range_name].
    pub fn set_subnetwork_range_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subnetwork_range_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subnetwork_range_name][crate::model::AliasIpRange::subnetwork_range_name].
    pub fn set_or_clear_subnetwork_range_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subnetwork_range_name = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for AliasIpRange {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.AliasIpRange"
    }
}

/// An instance-attached disk resource.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AttachedDisk {
    /// [Output Only] The architecture of the attached disk. Valid values are ARM64 or X86_64.
    pub architecture: std::option::Option<crate::model::attached_disk::Architecture>,

    /// Specifies whether the disk will be auto-deleted when the instance is deleted (but not when the disk is detached from the instance).
    pub auto_delete: std::option::Option<bool>,

    /// Indicates that this is a boot disk. The virtual machine will use the first partition of the disk for its root filesystem.
    pub boot: std::option::Option<bool>,

    /// Specifies a unique device name of your choice that is reflected into the /dev/disk/by-id/google-* tree of a Linux operating system running within the instance. This name can be used to reference the device for mounting, resizing, and so on, from within the instance. If not specified, the server chooses a default device name to apply to this disk, in the form persistent-disk-x, where x is a number assigned by Google Compute Engine. This field is only applicable for persistent disks.
    pub device_name: std::option::Option<std::string::String>,

    /// Encrypts or decrypts a disk using a customer-supplied encryption key. If you are creating a new disk, this field encrypts the new disk using an encryption key that you provide. If you are attaching an existing disk that is already encrypted, this field decrypts the disk using the customer-supplied encryption key. If you encrypt a disk using a customer-supplied key, you must provide the same key again when you attempt to use this resource at a later time. For example, you must provide the key when you create a snapshot or an image from the disk or when you attach the disk to a virtual machine instance. If you do not provide an encryption key, then the disk will be encrypted using an automatically generated key and you do not need to provide a key to use the disk later. Note: Instance templates do not store customer-supplied encryption keys, so you cannot use your own keys to encrypt disks in a managed instance group. You cannot create VMs that have disks with customer-supplied keys using the bulk insert method.
    pub disk_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// The size of the disk in GB.
    pub disk_size_gb: std::option::Option<i64>,

    /// [Input Only] Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error.
    pub force_attach: std::option::Option<bool>,

    /// A list of features to enable on the guest operating system. Applicable only for bootable images. Read Enabling guest operating system features to see a list of available options.
    pub guest_os_features: std::vec::Vec<crate::model::GuestOsFeature>,

    /// [Output Only] A zero-based index to this disk, where 0 is reserved for the boot disk. If you have many disks attached to an instance, each disk would have a unique index number.
    pub index: std::option::Option<i32>,

    /// [Input Only] Specifies the parameters for a new disk that will be created alongside the new instance. Use initialization parameters to create boot disks or local SSDs attached to the new instance. This property is mutually exclusive with the source property; you can only define one or the other, but not both.
    pub initialize_params: std::option::Option<crate::model::AttachedDiskInitializeParams>,

    /// Specifies the disk interface to use for attaching this disk, which is either SCSI or NVME. For most machine types, the default is SCSI. Local SSDs can use either NVME or SCSI. In certain configurations, persistent disks can use NVMe. For more information, see About persistent disks.
    pub interface: std::option::Option<crate::model::attached_disk::Interface>,

    /// [Output Only] Type of the resource. Always compute#attachedDisk for attached disks.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] Any valid publicly visible licenses.
    pub licenses: std::vec::Vec<std::string::String>,

    /// The mode in which to attach this disk, either READ_WRITE or READ_ONLY. If not specified, the default is to attach the disk in READ_WRITE mode.
    pub mode: std::option::Option<crate::model::attached_disk::Mode>,

    /// For LocalSSD disks on VM Instances in STOPPED or SUSPENDED state, this field is set to PRESERVED if the LocalSSD data has been saved to a persistent location by customer request. (see the discard_local_ssd option on Stop/Suspend). Read-only in the api.
    pub saved_state: std::option::Option<crate::model::attached_disk::SavedState>,

    /// [Output Only] shielded vm initial state stored on disk
    pub shielded_instance_initial_state: std::option::Option<crate::model::InitialStateConfig>,

    /// Specifies a valid partial or full URL to an existing Persistent Disk resource. When creating a new instance boot disk, one of initializeParams.sourceImage or initializeParams.sourceSnapshot or disks.source is required. If desired, you can also attach existing non-root persistent disks using this property. This field is only applicable for persistent disks. Note that for InstanceTemplate, specify the disk name for zonal disk, and the URL for regional disk.
    pub source: std::option::Option<std::string::String>,

    /// Specifies the type of the disk, either SCRATCH or PERSISTENT. If not specified, the default is PERSISTENT.
    pub r#type: std::option::Option<crate::model::attached_disk::Type>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl AttachedDisk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [architecture][crate::model::AttachedDisk::architecture].
    pub fn set_architecture<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::Architecture>,
    {
        self.architecture = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [architecture][crate::model::AttachedDisk::architecture].
    pub fn set_or_clear_architecture<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::Architecture>,
    {
        self.architecture = v.map(|x| x.into());
        self
    }

    /// Sets the value of [auto_delete][crate::model::AttachedDisk::auto_delete].
    pub fn set_auto_delete<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.auto_delete = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [auto_delete][crate::model::AttachedDisk::auto_delete].
    pub fn set_or_clear_auto_delete<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.auto_delete = v.map(|x| x.into());
        self
    }

    /// Sets the value of [boot][crate::model::AttachedDisk::boot].
    pub fn set_boot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.boot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [boot][crate::model::AttachedDisk::boot].
    pub fn set_or_clear_boot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.boot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [device_name][crate::model::AttachedDisk::device_name].
    pub fn set_device_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.device_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [device_name][crate::model::AttachedDisk::device_name].
    pub fn set_or_clear_device_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.device_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_encryption_key][crate::model::AttachedDisk::disk_encryption_key].
    pub fn set_disk_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.disk_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_encryption_key][crate::model::AttachedDisk::disk_encryption_key].
    pub fn set_or_clear_disk_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.disk_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::AttachedDisk::disk_size_gb].
    pub fn set_disk_size_gb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.disk_size_gb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_size_gb][crate::model::AttachedDisk::disk_size_gb].
    pub fn set_or_clear_disk_size_gb<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.disk_size_gb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [force_attach][crate::model::AttachedDisk::force_attach].
    pub fn set_force_attach<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.force_attach = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [force_attach][crate::model::AttachedDisk::force_attach].
    pub fn set_or_clear_force_attach<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.force_attach = v.map(|x| x.into());
        self
    }

    /// Sets the value of [guest_os_features][crate::model::AttachedDisk::guest_os_features].
    pub fn set_guest_os_features<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GuestOsFeature>,
    {
        use std::iter::Iterator;
        self.guest_os_features = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [index][crate::model::AttachedDisk::index].
    pub fn set_index<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.index = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [index][crate::model::AttachedDisk::index].
    pub fn set_or_clear_index<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.index = v.map(|x| x.into());
        self
    }

    /// Sets the value of [initialize_params][crate::model::AttachedDisk::initialize_params].
    pub fn set_initialize_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AttachedDiskInitializeParams>,
    {
        self.initialize_params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [initialize_params][crate::model::AttachedDisk::initialize_params].
    pub fn set_or_clear_initialize_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AttachedDiskInitializeParams>,
    {
        self.initialize_params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [interface][crate::model::AttachedDisk::interface].
    pub fn set_interface<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::Interface>,
    {
        self.interface = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [interface][crate::model::AttachedDisk::interface].
    pub fn set_or_clear_interface<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::Interface>,
    {
        self.interface = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::AttachedDisk::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::AttachedDisk::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [licenses][crate::model::AttachedDisk::licenses].
    pub fn set_licenses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.licenses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [mode][crate::model::AttachedDisk::mode].
    pub fn set_mode<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::Mode>,
    {
        self.mode = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [mode][crate::model::AttachedDisk::mode].
    pub fn set_or_clear_mode<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::Mode>,
    {
        self.mode = v.map(|x| x.into());
        self
    }

    /// Sets the value of [saved_state][crate::model::AttachedDisk::saved_state].
    pub fn set_saved_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::SavedState>,
    {
        self.saved_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [saved_state][crate::model::AttachedDisk::saved_state].
    pub fn set_or_clear_saved_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::SavedState>,
    {
        self.saved_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [shielded_instance_initial_state][crate::model::AttachedDisk::shielded_instance_initial_state].
    pub fn set_shielded_instance_initial_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InitialStateConfig>,
    {
        self.shielded_instance_initial_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shielded_instance_initial_state][crate::model::AttachedDisk::shielded_instance_initial_state].
    pub fn set_or_clear_shielded_instance_initial_state<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::InitialStateConfig>,
    {
        self.shielded_instance_initial_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::AttachedDisk::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::AttachedDisk::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::AttachedDisk::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::Type>,
    {
        self.r#type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#type][crate::model::AttachedDisk::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk::Type>,
    {
        self.r#type = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for AttachedDisk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.AttachedDisk"
    }
}

/// Defines additional types related to [AttachedDisk].
#[cfg(feature = "instances")]
pub mod attached_disk {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [architecture][google.cloud.compute.v1.AttachedDisk.architecture] field.
    ///
    /// [google.cloud.compute.v1.AttachedDisk.architecture]: crate::model::attached_disk::Architecture
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Architecture {
        /// Default value indicating Architecture is not set.
        Unspecified,
        /// Machines with architecture ARM64
        Arm64,
        /// Machines with architecture X86_64
        X8664,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Architecture::value] or
        /// [Architecture::name].
        UnknownValue(architecture::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod architecture {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Architecture {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Arm64 => std::option::Option::Some(1),
                Self::X8664 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ARCHITECTURE_UNSPECIFIED"),
                Self::Arm64 => std::option::Option::Some("ARM64"),
                Self::X8664 => std::option::Option::Some("X86_64"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Architecture {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Architecture {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Architecture {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Arm64,
                2 => Self::X8664,
                _ => Self::UnknownValue(architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Architecture {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
                "ARM64" => Self::Arm64,
                "X86_64" => Self::X8664,
                _ => Self::UnknownValue(architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Architecture {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_str("ARCHITECTURE_UNSPECIFIED"),
                Self::Arm64 => serializer.serialize_str("ARM64"),
                Self::X8664 => serializer.serialize_str("X86_64"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Architecture {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Architecture>::new(
                ".google.cloud.compute.v1.AttachedDisk.architecture",
            ))
        }
    }

    /// The enumerated type for the [interface][google.cloud.compute.v1.AttachedDisk.interface] field.
    ///
    /// [google.cloud.compute.v1.AttachedDisk.interface]: crate::model::attached_disk::Interface
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Interface {
        Nvme,
        Scsi,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Interface::value] or
        /// [Interface::name].
        UnknownValue(interface::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod interface {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Interface {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Nvme => std::option::Option::Some(0),
                Self::Scsi => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Nvme => std::option::Option::Some("NVME"),
                Self::Scsi => std::option::Option::Some("SCSI"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Interface {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Interface {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Interface {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Nvme,
                1 => Self::Scsi,
                _ => Self::UnknownValue(interface::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Interface {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NVME" => Self::Nvme,
                "SCSI" => Self::Scsi,
                _ => Self::UnknownValue(interface::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Interface {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Nvme => serializer.serialize_str("NVME"),
                Self::Scsi => serializer.serialize_str("SCSI"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Interface {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Interface>::new(
                ".google.cloud.compute.v1.AttachedDisk.interface",
            ))
        }
    }

    /// The enumerated type for the [mode][google.cloud.compute.v1.AttachedDisk.mode] field.
    ///
    /// [google.cloud.compute.v1.AttachedDisk.mode]: crate::model::attached_disk::Mode
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Mode {
        /// Attaches this disk in read-only mode. Multiple virtual machines can use a disk in read-only mode at a time.
        ReadOnly,
        /// *[Default]* Attaches this disk in read-write mode. Only one virtual machine at a time can be attached to a disk in read-write mode.
        ReadWrite,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Mode::value] or
        /// [Mode::name].
        UnknownValue(mode::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Mode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::ReadOnly => std::option::Option::Some(0),
                Self::ReadWrite => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::ReadOnly => std::option::Option::Some("READ_ONLY"),
                Self::ReadWrite => std::option::Option::Some("READ_WRITE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Mode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Mode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Mode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::ReadOnly,
                1 => Self::ReadWrite,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Mode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "READ_ONLY" => Self::ReadOnly,
                "READ_WRITE" => Self::ReadWrite,
                _ => Self::UnknownValue(mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Mode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::ReadOnly => serializer.serialize_str("READ_ONLY"),
                Self::ReadWrite => serializer.serialize_str("READ_WRITE"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Mode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Mode>::new(
                ".google.cloud.compute.v1.AttachedDisk.mode",
            ))
        }
    }

    /// The enumerated type for the [savedState][google.cloud.compute.v1.AttachedDisk.savedState] field.
    ///
    /// [google.cloud.compute.v1.AttachedDisk.savedState]: crate::model::attached_disk::SavedState
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SavedState {
        /// *[Default]* Disk state has not been preserved.
        DiskSavedStateUnspecified,
        /// Disk state has been preserved.
        Preserved,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SavedState::value] or
        /// [SavedState::name].
        UnknownValue(saved_state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod saved_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl SavedState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::DiskSavedStateUnspecified => std::option::Option::Some(0),
                Self::Preserved => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::DiskSavedStateUnspecified => {
                    std::option::Option::Some("DISK_SAVED_STATE_UNSPECIFIED")
                }
                Self::Preserved => std::option::Option::Some("PRESERVED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for SavedState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for SavedState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for SavedState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::DiskSavedStateUnspecified,
                1 => Self::Preserved,
                _ => Self::UnknownValue(saved_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for SavedState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISK_SAVED_STATE_UNSPECIFIED" => Self::DiskSavedStateUnspecified,
                "PRESERVED" => Self::Preserved,
                _ => Self::UnknownValue(saved_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for SavedState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::DiskSavedStateUnspecified => {
                    serializer.serialize_str("DISK_SAVED_STATE_UNSPECIFIED")
                }
                Self::Preserved => serializer.serialize_str("PRESERVED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for SavedState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SavedState>::new(
                ".google.cloud.compute.v1.AttachedDisk.savedState",
            ))
        }
    }

    /// The enumerated type for the [type][google.cloud.compute.v1.AttachedDisk.type] field.
    ///
    /// [google.cloud.compute.v1.AttachedDisk.type]: crate::model::attached_disk::Type
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        Persistent,
        Scratch,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Persistent => std::option::Option::Some(0),
                Self::Scratch => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Persistent => std::option::Option::Some("PERSISTENT"),
                Self::Scratch => std::option::Option::Some("SCRATCH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Persistent,
                1 => Self::Scratch,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PERSISTENT" => Self::Persistent,
                "SCRATCH" => Self::Scratch,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Persistent => serializer.serialize_str("PERSISTENT"),
                Self::Scratch => serializer.serialize_str("SCRATCH"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.compute.v1.AttachedDisk.type",
            ))
        }
    }
}

/// [Input Only] Specifies the parameters for a new disk that will be created alongside the new instance. Use initialization parameters to create boot disks or local SSDs attached to the new instance. This field is persisted and returned for instanceTemplate and not returned in the context of instance. This property is mutually exclusive with the source property; you can only define one or the other, but not both.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AttachedDiskInitializeParams {
    /// The architecture of the attached disk. Valid values are arm64 or x86_64.
    pub architecture:
        std::option::Option<crate::model::attached_disk_initialize_params::Architecture>,

    /// An optional description. Provide this property when creating the disk.
    pub description: std::option::Option<std::string::String>,

    /// Specifies the disk name. If not specified, the default is to use the name of the instance. If a disk with the same name already exists in the given region, the existing disk is attached to the new instance and the new disk is not created.
    pub disk_name: std::option::Option<std::string::String>,

    /// Specifies the size of the disk in base-2 GB. The size must be at least 10 GB. If you specify a sourceImage, which is required for boot disks, the default size is the size of the sourceImage. If you do not specify a sourceImage, the default disk size is 500 GB.
    pub disk_size_gb: std::option::Option<i64>,

    /// Specifies the disk type to use to create the instance. If not specified, the default is pd-standard, specified using the full URL. For example: <https://www.googleapis.com/compute/v1/projects/project/zones/zone> /diskTypes/pd-standard For a full list of acceptable values, see Persistent disk types. If you specify this field when creating a VM, you can provide either the full or partial URL. For example, the following values are valid: - <https://www.googleapis.com/compute/v1/projects/project/zones/zone> /diskTypes/diskType - projects/project/zones/zone/diskTypes/diskType - zones/zone/diskTypes/diskType If you specify this field when creating or updating an instance template or all-instances configuration, specify the type of the disk, not the URL. For example: pd-standard.
    pub disk_type: std::option::Option<std::string::String>,

    /// Whether this disk is using confidential compute mode.
    pub enable_confidential_compute: std::option::Option<bool>,

    /// Labels to apply to this disk. These can be later modified by the disks.setLabels method. This field is only applicable for persistent disks.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// A list of publicly visible licenses. Reserved for Google's use.
    pub licenses: std::vec::Vec<std::string::String>,

    /// Specifies which action to take on instance update with this disk. Default is to use the existing disk.
    pub on_update_action:
        std::option::Option<crate::model::attached_disk_initialize_params::OnUpdateAction>,

    /// Indicates how many IOPS to provision for the disk. This sets the number of I/O operations per second that the disk can handle. Values must be between 10,000 and 120,000. For more details, see the Extreme persistent disk documentation.
    pub provisioned_iops: std::option::Option<i64>,

    /// Indicates how much throughput to provision for the disk. This sets the number of throughput mb per second that the disk can handle. Values must greater than or equal to 1.
    pub provisioned_throughput: std::option::Option<i64>,

    /// Required for each regional disk associated with the instance. Specify the URLs of the zones where the disk should be replicated to. You must provide exactly two replica zones, and one zone must be the same as the instance zone.
    pub replica_zones: std::vec::Vec<std::string::String>,

    /// Resource manager tags to be bound to the disk. Tag keys and values have the same definition as resource manager tags. Keys must be in the format `tagKeys/{tag_key_id}`, and values are in the format `tagValues/456`. The field is ignored (both PUT & PATCH) when empty.
    pub resource_manager_tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Resource policies applied to this disk for automatic snapshot creations. Specified using the full or partial URL. For instance template, specify only the resource policy name.
    pub resource_policies: std::vec::Vec<std::string::String>,

    /// The source image to create this disk. When creating a new instance boot disk, one of initializeParams.sourceImage or initializeParams.sourceSnapshot or disks.source is required. To create a disk with one of the public operating system images, specify the image by its family name. For example, specify family/debian-9 to use the latest Debian 9 image: projects/debian-cloud/global/images/family/debian-9 Alternatively, use a specific version of a public operating system image: projects/debian-cloud/global/images/debian-9-stretch-vYYYYMMDD To create a disk with a custom image that you created, specify the image name in the following format: global/images/my-custom-image You can also specify a custom image by its image family, which returns the latest version of the image in that family. Replace the image name with family/family-name: global/images/family/my-image-family If the source image is deleted later, this field will not be set.
    pub source_image: std::option::Option<std::string::String>,

    /// The customer-supplied encryption key of the source image. Required if the source image is protected by a customer-supplied encryption key. InstanceTemplate and InstancePropertiesPatch do not store customer-supplied encryption keys, so you cannot create disks for instances in a managed instance group if the source images are encrypted with your own keys.
    pub source_image_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// The source snapshot to create this disk. When creating a new instance boot disk, one of initializeParams.sourceSnapshot or initializeParams.sourceImage or disks.source is required. To create a disk with a snapshot that you created, specify the snapshot name in the following format: global/snapshots/my-backup If the source snapshot is deleted later, this field will not be set. Note: You cannot create VMs in bulk using a snapshot as the source. Use an image instead when you create VMs using the bulk insert method.
    pub source_snapshot: std::option::Option<std::string::String>,

    /// The customer-supplied encryption key of the source snapshot.
    pub source_snapshot_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// The storage pool in which the new disk is created. You can provide this as a partial or full URL to the resource. For example, the following are valid values: - <https://www.googleapis.com/compute/v1/projects/project/zones/zone> /storagePools/storagePool - projects/project/zones/zone/storagePools/storagePool - zones/zone/storagePools/storagePool
    pub storage_pool: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl AttachedDiskInitializeParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [architecture][crate::model::AttachedDiskInitializeParams::architecture].
    pub fn set_architecture<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk_initialize_params::Architecture>,
    {
        self.architecture = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [architecture][crate::model::AttachedDiskInitializeParams::architecture].
    pub fn set_or_clear_architecture<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk_initialize_params::Architecture>,
    {
        self.architecture = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::AttachedDiskInitializeParams::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::AttachedDiskInitializeParams::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_name][crate::model::AttachedDiskInitializeParams::disk_name].
    pub fn set_disk_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.disk_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_name][crate::model::AttachedDiskInitializeParams::disk_name].
    pub fn set_or_clear_disk_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.disk_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::AttachedDiskInitializeParams::disk_size_gb].
    pub fn set_disk_size_gb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.disk_size_gb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_size_gb][crate::model::AttachedDiskInitializeParams::disk_size_gb].
    pub fn set_or_clear_disk_size_gb<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.disk_size_gb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_type][crate::model::AttachedDiskInitializeParams::disk_type].
    pub fn set_disk_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.disk_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_type][crate::model::AttachedDiskInitializeParams::disk_type].
    pub fn set_or_clear_disk_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.disk_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_confidential_compute][crate::model::AttachedDiskInitializeParams::enable_confidential_compute].
    pub fn set_enable_confidential_compute<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_confidential_compute = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_confidential_compute][crate::model::AttachedDiskInitializeParams::enable_confidential_compute].
    pub fn set_or_clear_enable_confidential_compute<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_confidential_compute = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::AttachedDiskInitializeParams::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [licenses][crate::model::AttachedDiskInitializeParams::licenses].
    pub fn set_licenses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.licenses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [on_update_action][crate::model::AttachedDiskInitializeParams::on_update_action].
    pub fn set_on_update_action<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk_initialize_params::OnUpdateAction>,
    {
        self.on_update_action = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [on_update_action][crate::model::AttachedDiskInitializeParams::on_update_action].
    pub fn set_or_clear_on_update_action<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::attached_disk_initialize_params::OnUpdateAction>,
    {
        self.on_update_action = v.map(|x| x.into());
        self
    }

    /// Sets the value of [provisioned_iops][crate::model::AttachedDiskInitializeParams::provisioned_iops].
    pub fn set_provisioned_iops<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.provisioned_iops = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provisioned_iops][crate::model::AttachedDiskInitializeParams::provisioned_iops].
    pub fn set_or_clear_provisioned_iops<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.provisioned_iops = v.map(|x| x.into());
        self
    }

    /// Sets the value of [provisioned_throughput][crate::model::AttachedDiskInitializeParams::provisioned_throughput].
    pub fn set_provisioned_throughput<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.provisioned_throughput = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provisioned_throughput][crate::model::AttachedDiskInitializeParams::provisioned_throughput].
    pub fn set_or_clear_provisioned_throughput<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.provisioned_throughput = v.map(|x| x.into());
        self
    }

    /// Sets the value of [replica_zones][crate::model::AttachedDiskInitializeParams::replica_zones].
    pub fn set_replica_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.replica_zones = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource_manager_tags][crate::model::AttachedDiskInitializeParams::resource_manager_tags].
    pub fn set_resource_manager_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_manager_tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [resource_policies][crate::model::AttachedDiskInitializeParams::resource_policies].
    pub fn set_resource_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source_image][crate::model::AttachedDiskInitializeParams::source_image].
    pub fn set_source_image<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_image = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_image][crate::model::AttachedDiskInitializeParams::source_image].
    pub fn set_or_clear_source_image<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_image = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_image_encryption_key][crate::model::AttachedDiskInitializeParams::source_image_encryption_key].
    pub fn set_source_image_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_image_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_image_encryption_key][crate::model::AttachedDiskInitializeParams::source_image_encryption_key].
    pub fn set_or_clear_source_image_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_image_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_snapshot][crate::model::AttachedDiskInitializeParams::source_snapshot].
    pub fn set_source_snapshot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_snapshot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_snapshot][crate::model::AttachedDiskInitializeParams::source_snapshot].
    pub fn set_or_clear_source_snapshot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_snapshot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_snapshot_encryption_key][crate::model::AttachedDiskInitializeParams::source_snapshot_encryption_key].
    pub fn set_source_snapshot_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_snapshot_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_snapshot_encryption_key][crate::model::AttachedDiskInitializeParams::source_snapshot_encryption_key].
    pub fn set_or_clear_source_snapshot_encryption_key<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_snapshot_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [storage_pool][crate::model::AttachedDiskInitializeParams::storage_pool].
    pub fn set_storage_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.storage_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [storage_pool][crate::model::AttachedDiskInitializeParams::storage_pool].
    pub fn set_or_clear_storage_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.storage_pool = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for AttachedDiskInitializeParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.AttachedDiskInitializeParams"
    }
}

/// Defines additional types related to [AttachedDiskInitializeParams].
#[cfg(feature = "instances")]
pub mod attached_disk_initialize_params {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [architecture][google.cloud.compute.v1.AttachedDiskInitializeParams.architecture] field.
    ///
    /// [google.cloud.compute.v1.AttachedDiskInitializeParams.architecture]: crate::model::attached_disk_initialize_params::Architecture
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Architecture {
        /// Default value indicating Architecture is not set.
        Unspecified,
        /// Machines with architecture ARM64
        Arm64,
        /// Machines with architecture X86_64
        X8664,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Architecture::value] or
        /// [Architecture::name].
        UnknownValue(architecture::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod architecture {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Architecture {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Arm64 => std::option::Option::Some(1),
                Self::X8664 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ARCHITECTURE_UNSPECIFIED"),
                Self::Arm64 => std::option::Option::Some("ARM64"),
                Self::X8664 => std::option::Option::Some("X86_64"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Architecture {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Architecture {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Architecture {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Arm64,
                2 => Self::X8664,
                _ => Self::UnknownValue(architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Architecture {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
                "ARM64" => Self::Arm64,
                "X86_64" => Self::X8664,
                _ => Self::UnknownValue(architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Architecture {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_str("ARCHITECTURE_UNSPECIFIED"),
                Self::Arm64 => serializer.serialize_str("ARM64"),
                Self::X8664 => serializer.serialize_str("X86_64"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Architecture {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Architecture>::new(
                ".google.cloud.compute.v1.AttachedDiskInitializeParams.architecture",
            ))
        }
    }

    /// The enumerated type for the [onUpdateAction][google.cloud.compute.v1.AttachedDiskInitializeParams.onUpdateAction] field.
    ///
    /// [google.cloud.compute.v1.AttachedDiskInitializeParams.onUpdateAction]: crate::model::attached_disk_initialize_params::OnUpdateAction
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OnUpdateAction {
        /// Always recreate the disk.
        RecreateDisk,
        /// Recreate the disk if source (image, snapshot) of this disk is different from source of existing disk.
        RecreateDiskIfSourceChanged,
        /// Use the existing disk, this is the default behaviour.
        UseExistingDisk,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OnUpdateAction::value] or
        /// [OnUpdateAction::name].
        UnknownValue(on_update_action::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod on_update_action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl OnUpdateAction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::RecreateDisk => std::option::Option::Some(0),
                Self::RecreateDiskIfSourceChanged => std::option::Option::Some(1),
                Self::UseExistingDisk => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::RecreateDisk => std::option::Option::Some("RECREATE_DISK"),
                Self::RecreateDiskIfSourceChanged => {
                    std::option::Option::Some("RECREATE_DISK_IF_SOURCE_CHANGED")
                }
                Self::UseExistingDisk => std::option::Option::Some("USE_EXISTING_DISK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for OnUpdateAction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for OnUpdateAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for OnUpdateAction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::RecreateDisk,
                1 => Self::RecreateDiskIfSourceChanged,
                2 => Self::UseExistingDisk,
                _ => Self::UnknownValue(on_update_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for OnUpdateAction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RECREATE_DISK" => Self::RecreateDisk,
                "RECREATE_DISK_IF_SOURCE_CHANGED" => Self::RecreateDiskIfSourceChanged,
                "USE_EXISTING_DISK" => Self::UseExistingDisk,
                _ => Self::UnknownValue(on_update_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for OnUpdateAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::RecreateDisk => serializer.serialize_str("RECREATE_DISK"),
                Self::RecreateDiskIfSourceChanged => {
                    serializer.serialize_str("RECREATE_DISK_IF_SOURCE_CHANGED")
                }
                Self::UseExistingDisk => serializer.serialize_str("USE_EXISTING_DISK"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for OnUpdateAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OnUpdateAction>::new(
                ".google.cloud.compute.v1.AttachedDiskInitializeParams.onUpdateAction",
            ))
        }
    }
}

/// Specifies the audit configuration for a service. The configuration determines which permission types are logged, and what identities, if any, are exempted from logging. An AuditConfig must have one or more AuditLogConfigs. If there are AuditConfigs for both `allServices` and a specific service, the union of the two AuditConfigs is used for that service: the log_types specified in each AuditConfig are enabled, and the exempted_members in each AuditLogConfig are exempted. Example Policy with multiple AuditConfigs: { "audit_configs": [ { "service": "allServices", "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" }, { "log_type": "ADMIN_READ" } ] }, { "service": "sampleservice.googleapis.com", "audit_log_configs": [ { "log_type": "DATA_READ" }, { "log_type": "DATA_WRITE", "exempted_members": [ "user:aliya@example.com" ] } ] } ] } For sampleservice, this policy enables DATA_READ, DATA_WRITE and ADMIN_READ logging. It also exempts `jose@example.com` from DATA_READ logging, and `aliya@example.com` from DATA_WRITE logging.
#[cfg(any(feature = "images", feature = "instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AuditConfig {
    /// The configuration for logging of each type of permission.
    pub audit_log_configs: std::vec::Vec<crate::model::AuditLogConfig>,

    /// Specifies a service that will be enabled for audit logging. For example, `storage.googleapis.com`, `cloudsql.googleapis.com`. `allServices` is a special value that covers all services.
    pub service: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances",))]
impl AuditConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audit_log_configs][crate::model::AuditConfig::audit_log_configs].
    pub fn set_audit_log_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AuditLogConfig>,
    {
        use std::iter::Iterator;
        self.audit_log_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service][crate::model::AuditConfig::service].
    pub fn set_service<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.service = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service][crate::model::AuditConfig::service].
    pub fn set_or_clear_service<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.service = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
impl wkt::message::Message for AuditConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.AuditConfig"
    }
}

/// Provides the configuration for logging a type of permissions. Example: { "audit_log_configs": [ { "log_type": "DATA_READ", "exempted_members": [ "user:jose@example.com" ] }, { "log_type": "DATA_WRITE" } ] } This enables 'DATA_READ' and 'DATA_WRITE' logging, while exempting jose@example.com from DATA_READ logging.
#[cfg(any(feature = "images", feature = "instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AuditLogConfig {
    /// Specifies the identities that do not cause logging for this type of permission. Follows the same format of Binding.members.
    pub exempted_members: std::vec::Vec<std::string::String>,

    /// The log type that this config enables.
    pub log_type: std::option::Option<crate::model::audit_log_config::LogType>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances",))]
impl AuditLogConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [exempted_members][crate::model::AuditLogConfig::exempted_members].
    pub fn set_exempted_members<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.exempted_members = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [log_type][crate::model::AuditLogConfig::log_type].
    pub fn set_log_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::audit_log_config::LogType>,
    {
        self.log_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [log_type][crate::model::AuditLogConfig::log_type].
    pub fn set_or_clear_log_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::audit_log_config::LogType>,
    {
        self.log_type = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
impl wkt::message::Message for AuditLogConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.AuditLogConfig"
    }
}

/// Defines additional types related to [AuditLogConfig].
#[cfg(any(feature = "images", feature = "instances",))]
pub mod audit_log_config {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [logType][google.cloud.compute.v1.AuditLogConfig.logType] field.
    ///
    /// [google.cloud.compute.v1.AuditLogConfig.logType]: crate::model::audit_log_config::LogType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "images", feature = "instances",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum LogType {
        /// Admin reads. Example: CloudIAM getIamPolicy
        AdminRead,
        /// Data reads. Example: CloudSQL Users list
        DataRead,
        /// Data writes. Example: CloudSQL Users create
        DataWrite,
        /// Default case. Should never be this.
        Unspecified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [LogType::value] or
        /// [LogType::name].
        UnknownValue(log_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "images", feature = "instances",))]
    pub mod log_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl LogType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::AdminRead => std::option::Option::Some(0),
                Self::DataRead => std::option::Option::Some(1),
                Self::DataWrite => std::option::Option::Some(2),
                Self::Unspecified => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::AdminRead => std::option::Option::Some("ADMIN_READ"),
                Self::DataRead => std::option::Option::Some("DATA_READ"),
                Self::DataWrite => std::option::Option::Some("DATA_WRITE"),
                Self::Unspecified => std::option::Option::Some("LOG_TYPE_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl std::default::Default for LogType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl std::fmt::Display for LogType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl std::convert::From<i32> for LogType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::AdminRead,
                1 => Self::DataRead,
                2 => Self::DataWrite,
                3 => Self::Unspecified,
                _ => Self::UnknownValue(log_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl std::convert::From<&str> for LogType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ADMIN_READ" => Self::AdminRead,
                "DATA_READ" => Self::DataRead,
                "DATA_WRITE" => Self::DataWrite,
                "LOG_TYPE_UNSPECIFIED" => Self::Unspecified,
                _ => Self::UnknownValue(log_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl serde::ser::Serialize for LogType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::AdminRead => serializer.serialize_str("ADMIN_READ"),
                Self::DataRead => serializer.serialize_str("DATA_READ"),
                Self::DataWrite => serializer.serialize_str("DATA_WRITE"),
                Self::Unspecified => serializer.serialize_str("LOG_TYPE_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl<'de> serde::de::Deserialize<'de> for LogType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<LogType>::new(
                ".google.cloud.compute.v1.AuditLogConfig.logType",
            ))
        }
    }
}

/// Associates `members`, or principals, with a `role`.
#[cfg(any(feature = "images", feature = "instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Binding {
    /// The condition that is associated with this binding. If the condition evaluates to `true`, then this binding applies to the current request. If the condition evaluates to `false`, then this binding does not apply to the current request. However, a different role binding might grant the same role to one or more of the principals in this binding. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
    pub condition: std::option::Option<crate::model::Expr>,

    /// Specifies the principals requesting access for a Google Cloud resource. `members` can have the following values: * `allUsers`: A special identifier that represents anyone who is on the internet; with or without a Google account. * `allAuthenticatedUsers`: A special identifier that represents anyone who is authenticated with a Google account or a service account. Does not include identities that come from external identity providers (IdPs) through identity federation. * `user:{emailid}`: An email address that represents a specific Google account. For example, `alice@example.com` . * `serviceAccount:{emailid}`: An email address that represents a Google service account. For example, `my-other-app@appspot.gserviceaccount.com`. * `serviceAccount:{projectid}.svc.id.goog[{namespace}/{kubernetes-sa}]`: An identifier for a [Kubernetes service account](https://cloud.google.com/kubernetes-engine/docs/how-to/kubernetes-service-accounts). For example, `my-project.svc.id.goog[my-namespace/my-kubernetes-sa]`. * `group:{emailid}`: An email address that represents a Google group. For example, `admins@example.com`. * `domain:{domain}`: The G Suite domain (primary) that represents all the users of that domain. For example, `google.com` or `example.com`. * `principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workforce identity pool. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/group/{group_id}`: All workforce identities in a group. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All workforce identities with a specific attribute value. * `principalSet://iam.googleapis.com/locations/global/workforcePools/{pool_id}/*`: All identities in a workforce identity pool. * `principal://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/subject/{subject_attribute_value}`: A single identity in a workload identity pool. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/group/{group_id}`: A workload identity pool group. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/attribute.{attribute_name}/{attribute_value}`: All identities in a workload identity pool with a certain attribute. * `principalSet://iam.googleapis.com/projects/{project_number}/locations/global/workloadIdentityPools/{pool_id}/*`: All identities in a workload identity pool. * `deleted:user:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a user that has been recently deleted. For example, `alice@example.com?uid=123456789012345678901`. If the user is recovered, this value reverts to `user:{emailid}` and the recovered user retains the role in the binding. * `deleted:serviceAccount:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a service account that has been recently deleted. For example, `my-other-app@appspot.gserviceaccount.com?uid=123456789012345678901`. If the service account is undeleted, this value reverts to `serviceAccount:{emailid}` and the undeleted service account retains the role in the binding. * `deleted:group:{emailid}?uid={uniqueid}`: An email address (plus unique identifier) representing a Google group that has been recently deleted. For example, `admins@example.com?uid=123456789012345678901`. If the group is recovered, this value reverts to `group:{emailid}` and the recovered group retains the role in the binding. * `deleted:principal://iam.googleapis.com/locations/global/workforcePools/{pool_id}/subject/{subject_attribute_value}`: Deleted single identity in a workforce identity pool. For example, `deleted:principal://iam.googleapis.com/locations/global/workforcePools/my-pool-id/subject/my-subject-attribute-value`.
    pub members: std::vec::Vec<std::string::String>,

    /// Role that is assigned to the list of `members`, or principals. For example, `roles/viewer`, `roles/editor`, or `roles/owner`. For an overview of the IAM roles and permissions, see the [IAM documentation](https://cloud.google.com/iam/docs/roles-overview). For a list of the available pre-defined roles, see [here](https://cloud.google.com/iam/docs/understanding-roles).
    pub role: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances",))]
impl Binding {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [condition][crate::model::Binding::condition].
    pub fn set_condition<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Expr>,
    {
        self.condition = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [condition][crate::model::Binding::condition].
    pub fn set_or_clear_condition<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Expr>,
    {
        self.condition = v.map(|x| x.into());
        self
    }

    /// Sets the value of [members][crate::model::Binding::members].
    pub fn set_members<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.members = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [role][crate::model::Binding::role].
    pub fn set_role<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.role = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [role][crate::model::Binding::role].
    pub fn set_or_clear_role<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.role = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
impl wkt::message::Message for Binding {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Binding"
    }
}

/// A transient resource used in compute.instances.bulkInsert and compute.regionInstances.bulkInsert . This resource is not persisted anywhere, it is used only for processing the requests.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkInsertInstanceResource {
    /// The maximum number of instances to create.
    pub count: std::option::Option<i64>,

    /// The instance properties defining the VM instances to be created. Required if sourceInstanceTemplate is not provided.
    pub instance_properties: std::option::Option<crate::model::InstanceProperties>,

    /// Policy for choosing target zone. For more information, see Create VMs in bulk.
    pub location_policy: std::option::Option<crate::model::LocationPolicy>,

    /// The minimum number of instances to create. If no min_count is specified then count is used as the default value. If min_count instances cannot be created, then no instances will be created and instances already created will be deleted.
    pub min_count: std::option::Option<i64>,

    /// The string pattern used for the names of the VMs. Either name_pattern or per_instance_properties must be set. The pattern must contain one continuous sequence of placeholder hash characters (#) with each character corresponding to one digit of the generated instance name. Example: a name_pattern of inst-#### generates instance names such as inst-0001 and inst-0002. If existing instances in the same project and zone have names that match the name pattern then the generated instance numbers start after the biggest existing number. For example, if there exists an instance with name inst-0050, then instance names generated using the pattern inst-#### begin with inst-0051. The name pattern placeholder #...# can contain up to 18 characters.
    pub name_pattern: std::option::Option<std::string::String>,

    /// Per-instance properties to be set on individual instances. Keys of this map specify requested instance names. Can be empty if name_pattern is used.
    pub per_instance_properties: std::collections::HashMap<
        std::string::String,
        crate::model::BulkInsertInstanceResourcePerInstanceProperties,
    >,

    /// Specifies the instance template from which to create instances. You may combine sourceInstanceTemplate with instanceProperties to override specific values from an existing instance template. Bulk API follows the semantics of JSON Merge Patch described by RFC 7396. It can be a full or partial URL. For example, the following are all valid URLs to an instance template: - <https://www.googleapis.com/compute/v1/projects/project> /global/instanceTemplates/instanceTemplate - projects/project/global/instanceTemplates/instanceTemplate - global/instanceTemplates/instanceTemplate This field is optional.
    pub source_instance_template: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl BulkInsertInstanceResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [count][crate::model::BulkInsertInstanceResource::count].
    pub fn set_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [count][crate::model::BulkInsertInstanceResource::count].
    pub fn set_or_clear_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_properties][crate::model::BulkInsertInstanceResource::instance_properties].
    pub fn set_instance_properties<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceProperties>,
    {
        self.instance_properties = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_properties][crate::model::BulkInsertInstanceResource::instance_properties].
    pub fn set_or_clear_instance_properties<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceProperties>,
    {
        self.instance_properties = v.map(|x| x.into());
        self
    }

    /// Sets the value of [location_policy][crate::model::BulkInsertInstanceResource::location_policy].
    pub fn set_location_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LocationPolicy>,
    {
        self.location_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [location_policy][crate::model::BulkInsertInstanceResource::location_policy].
    pub fn set_or_clear_location_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LocationPolicy>,
    {
        self.location_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [min_count][crate::model::BulkInsertInstanceResource::min_count].
    pub fn set_min_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.min_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_count][crate::model::BulkInsertInstanceResource::min_count].
    pub fn set_or_clear_min_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.min_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name_pattern][crate::model::BulkInsertInstanceResource::name_pattern].
    pub fn set_name_pattern<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name_pattern = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name_pattern][crate::model::BulkInsertInstanceResource::name_pattern].
    pub fn set_or_clear_name_pattern<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name_pattern = v.map(|x| x.into());
        self
    }

    /// Sets the value of [per_instance_properties][crate::model::BulkInsertInstanceResource::per_instance_properties].
    pub fn set_per_instance_properties<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::BulkInsertInstanceResourcePerInstanceProperties>,
    {
        use std::iter::Iterator;
        self.per_instance_properties = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [source_instance_template][crate::model::BulkInsertInstanceResource::source_instance_template].
    pub fn set_source_instance_template<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_instance_template = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_instance_template][crate::model::BulkInsertInstanceResource::source_instance_template].
    pub fn set_or_clear_source_instance_template<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_instance_template = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for BulkInsertInstanceResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.BulkInsertInstanceResource"
    }
}

/// Per-instance properties to be set on individual instances. To be extended in the future.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkInsertInstanceResourcePerInstanceProperties {
    /// Specifies the hostname of the instance. More details in: <https://cloud.google.com/compute/docs/instances/custom-hostname-vm#naming_convention>
    pub hostname: std::option::Option<std::string::String>,

    /// This field is only temporary. It will be removed. Do not use it.
    pub name: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl BulkInsertInstanceResourcePerInstanceProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [hostname][crate::model::BulkInsertInstanceResourcePerInstanceProperties::hostname].
    pub fn set_hostname<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.hostname = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hostname][crate::model::BulkInsertInstanceResourcePerInstanceProperties::hostname].
    pub fn set_or_clear_hostname<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.hostname = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::BulkInsertInstanceResourcePerInstanceProperties::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::BulkInsertInstanceResourcePerInstanceProperties::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for BulkInsertInstanceResourcePerInstanceProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.BulkInsertInstanceResourcePerInstanceProperties"
    }
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BulkInsertOperationStatus {
    /// [Output Only] Count of VMs successfully created so far.
    pub created_vm_count: std::option::Option<i32>,

    /// [Output Only] Count of VMs that got deleted during rollback.
    pub deleted_vm_count: std::option::Option<i32>,

    /// [Output Only] Count of VMs that started creating but encountered an error.
    pub failed_to_create_vm_count: std::option::Option<i32>,

    /// [Output Only] Creation status of BulkInsert operation - information if the flow is rolling forward or rolling back.
    pub status: std::option::Option<crate::model::bulk_insert_operation_status::Status>,

    /// [Output Only] Count of VMs originally planned to be created.
    pub target_vm_count: std::option::Option<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl BulkInsertOperationStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [created_vm_count][crate::model::BulkInsertOperationStatus::created_vm_count].
    pub fn set_created_vm_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.created_vm_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [created_vm_count][crate::model::BulkInsertOperationStatus::created_vm_count].
    pub fn set_or_clear_created_vm_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.created_vm_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deleted_vm_count][crate::model::BulkInsertOperationStatus::deleted_vm_count].
    pub fn set_deleted_vm_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.deleted_vm_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleted_vm_count][crate::model::BulkInsertOperationStatus::deleted_vm_count].
    pub fn set_or_clear_deleted_vm_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.deleted_vm_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [failed_to_create_vm_count][crate::model::BulkInsertOperationStatus::failed_to_create_vm_count].
    pub fn set_failed_to_create_vm_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.failed_to_create_vm_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [failed_to_create_vm_count][crate::model::BulkInsertOperationStatus::failed_to_create_vm_count].
    pub fn set_or_clear_failed_to_create_vm_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.failed_to_create_vm_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::BulkInsertOperationStatus::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::bulk_insert_operation_status::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::BulkInsertOperationStatus::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::bulk_insert_operation_status::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_vm_count][crate::model::BulkInsertOperationStatus::target_vm_count].
    pub fn set_target_vm_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.target_vm_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_vm_count][crate::model::BulkInsertOperationStatus::target_vm_count].
    pub fn set_or_clear_target_vm_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.target_vm_count = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl wkt::message::Message for BulkInsertOperationStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.BulkInsertOperationStatus"
    }
}

/// Defines additional types related to [BulkInsertOperationStatus].
#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
pub mod bulk_insert_operation_status {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [status][google.cloud.compute.v1.BulkInsertOperationStatus.status] field.
    ///
    /// [google.cloud.compute.v1.BulkInsertOperationStatus.status]: crate::model::bulk_insert_operation_status::Status
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Rolling forward - creating VMs.
        Creating,
        /// Done
        Done,
        /// Rolling back - cleaning up after an error.
        RollingBack,
        Unspecified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Creating => std::option::Option::Some(0),
                Self::Done => std::option::Option::Some(1),
                Self::RollingBack => std::option::Option::Some(2),
                Self::Unspecified => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::RollingBack => std::option::Option::Some("ROLLING_BACK"),
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Creating,
                1 => Self::Done,
                2 => Self::RollingBack,
                3 => Self::Unspecified,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CREATING" => Self::Creating,
                "DONE" => Self::Done,
                "ROLLING_BACK" => Self::RollingBack,
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Creating => serializer.serialize_str("CREATING"),
                Self::Done => serializer.serialize_str("DONE"),
                Self::RollingBack => serializer.serialize_str("ROLLING_BACK"),
                Self::Unspecified => serializer.serialize_str("STATUS_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.cloud.compute.v1.BulkInsertOperationStatus.status",
            ))
        }
    }
}

/// A set of Confidential Instance options.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConfidentialInstanceConfig {
    /// Defines the type of technology used by the confidential instance.
    pub confidential_instance_type:
        std::option::Option<crate::model::confidential_instance_config::ConfidentialInstanceType>,

    /// Defines whether the instance should have confidential compute enabled.
    pub enable_confidential_compute: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ConfidentialInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [confidential_instance_type][crate::model::ConfidentialInstanceConfig::confidential_instance_type].
    pub fn set_confidential_instance_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::confidential_instance_config::ConfidentialInstanceType>,
    {
        self.confidential_instance_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [confidential_instance_type][crate::model::ConfidentialInstanceConfig::confidential_instance_type].
    pub fn set_or_clear_confidential_instance_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::confidential_instance_config::ConfidentialInstanceType>,
    {
        self.confidential_instance_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_confidential_compute][crate::model::ConfidentialInstanceConfig::enable_confidential_compute].
    pub fn set_enable_confidential_compute<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_confidential_compute = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_confidential_compute][crate::model::ConfidentialInstanceConfig::enable_confidential_compute].
    pub fn set_or_clear_enable_confidential_compute<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_confidential_compute = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ConfidentialInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ConfidentialInstanceConfig"
    }
}

/// Defines additional types related to [ConfidentialInstanceConfig].
#[cfg(feature = "instances")]
pub mod confidential_instance_config {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [confidentialInstanceType][google.cloud.compute.v1.ConfidentialInstanceConfig.confidentialInstanceType] field.
    ///
    /// [google.cloud.compute.v1.ConfidentialInstanceConfig.confidentialInstanceType]: crate::model::confidential_instance_config::ConfidentialInstanceType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConfidentialInstanceType {
        /// No type specified. Do not use this value.
        Unspecified,
        /// AMD Secure Encrypted Virtualization.
        Sev,
        /// AMD Secure Encrypted Virtualization - Secure Nested Paging.
        SevSnp,
        /// Intel Trust Domain eXtension.
        Tdx,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConfidentialInstanceType::value] or
        /// [ConfidentialInstanceType::name].
        UnknownValue(confidential_instance_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod confidential_instance_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl ConfidentialInstanceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Sev => std::option::Option::Some(1),
                Self::SevSnp => std::option::Option::Some(2),
                Self::Tdx => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("CONFIDENTIAL_INSTANCE_TYPE_UNSPECIFIED")
                }
                Self::Sev => std::option::Option::Some("SEV"),
                Self::SevSnp => std::option::Option::Some("SEV_SNP"),
                Self::Tdx => std::option::Option::Some("TDX"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for ConfidentialInstanceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for ConfidentialInstanceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for ConfidentialInstanceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Sev,
                2 => Self::SevSnp,
                3 => Self::Tdx,
                _ => Self::UnknownValue(confidential_instance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for ConfidentialInstanceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CONFIDENTIAL_INSTANCE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "SEV" => Self::Sev,
                "SEV_SNP" => Self::SevSnp,
                "TDX" => Self::Tdx,
                _ => Self::UnknownValue(confidential_instance_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for ConfidentialInstanceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => {
                    serializer.serialize_str("CONFIDENTIAL_INSTANCE_TYPE_UNSPECIFIED")
                }
                Self::Sev => serializer.serialize_str("SEV"),
                Self::SevSnp => serializer.serialize_str("SEV_SNP"),
                Self::Tdx => serializer.serialize_str("TDX"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for ConfidentialInstanceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<ConfidentialInstanceType>::new(
                    ".google.cloud.compute.v1.ConfidentialInstanceConfig.confidentialInstanceType",
                ),
            )
        }
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomerEncryptionKey {
    /// The name of the encryption key that is stored in Google Cloud KMS. For example: "kmsKeyName": "projects/kms_project_id/locations/region/keyRings/ key_region/cryptoKeys/key The fully-qualifed key name may be returned for resource GET requests. For example: "kmsKeyName": "projects/kms_project_id/locations/region/keyRings/ key_region/cryptoKeys/key /cryptoKeyVersions/1
    pub kms_key_name: std::option::Option<std::string::String>,

    /// The service account being used for the encryption request for the given KMS key. If absent, the Compute Engine default service account is used. For example: "kmsKeyServiceAccount": "name@project_id.iam.gserviceaccount.com/
    pub kms_key_service_account: std::option::Option<std::string::String>,

    /// Specifies a 256-bit customer-supplied encryption key, encoded in RFC 4648 base64 to either encrypt or decrypt this resource. You can provide either the rawKey or the rsaEncryptedKey. For example: "rawKey": "SGVsbG8gZnJvbSBHb29nbGUgQ2xvdWQgUGxhdGZvcm0="
    pub raw_key: std::option::Option<std::string::String>,

    /// Specifies an RFC 4648 base64 encoded, RSA-wrapped 2048-bit customer-supplied encryption key to either encrypt or decrypt this resource. You can provide either the rawKey or the rsaEncryptedKey. For example: "rsaEncryptedKey": "ieCx/NcW06PcT7Ep1X6LUTc/hLvUDYyzSZPPVCVPTVEohpeHASqC8uw5TzyO9U+Fka9JFH z0mBibXUInrC/jEk014kCK/NPjYgEMOyssZ4ZINPKxlUh2zn1bV+MCaTICrdmuSBTWlUUiFoD D6PYznLwh8ZNdaheCeZ8ewEXgFQ8V+sDroLaN3Xs3MDTXQEMMoNUXMCZEIpg9Vtp9x2oe==" The key must meet the following requirements before you can provide it to Compute Engine: 1. The key is wrapped using a RSA public key certificate provided by Google. 2. After being wrapped, the key must be encoded in RFC 4648 base64 encoding. Gets the RSA public key certificate provided by Google at: <https://cloud-certs.storage.googleapis.com/google-cloud-csek-ingress.pem>
    pub rsa_encrypted_key: std::option::Option<std::string::String>,

    /// [Output only] The RFC 4648 base64 encoded SHA-256 hash of the customer-supplied encryption key that protects this resource.
    pub sha256: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances",))]
impl CustomerEncryptionKey {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_name][crate::model::CustomerEncryptionKey::kms_key_name].
    pub fn set_kms_key_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kms_key_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kms_key_name][crate::model::CustomerEncryptionKey::kms_key_name].
    pub fn set_or_clear_kms_key_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kms_key_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kms_key_service_account][crate::model::CustomerEncryptionKey::kms_key_service_account].
    pub fn set_kms_key_service_account<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kms_key_service_account = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kms_key_service_account][crate::model::CustomerEncryptionKey::kms_key_service_account].
    pub fn set_or_clear_kms_key_service_account<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kms_key_service_account = v.map(|x| x.into());
        self
    }

    /// Sets the value of [raw_key][crate::model::CustomerEncryptionKey::raw_key].
    pub fn set_raw_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.raw_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [raw_key][crate::model::CustomerEncryptionKey::raw_key].
    pub fn set_or_clear_raw_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.raw_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rsa_encrypted_key][crate::model::CustomerEncryptionKey::rsa_encrypted_key].
    pub fn set_rsa_encrypted_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.rsa_encrypted_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rsa_encrypted_key][crate::model::CustomerEncryptionKey::rsa_encrypted_key].
    pub fn set_or_clear_rsa_encrypted_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.rsa_encrypted_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [sha256][crate::model::CustomerEncryptionKey::sha256].
    pub fn set_sha256<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.sha256 = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [sha256][crate::model::CustomerEncryptionKey::sha256].
    pub fn set_or_clear_sha256<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.sha256 = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
impl wkt::message::Message for CustomerEncryptionKey {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.CustomerEncryptionKey"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CustomerEncryptionKeyProtectedDisk {
    /// Decrypts data associated with the disk with a customer-supplied encryption key.
    pub disk_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// Specifies a valid partial or full URL to an existing Persistent Disk resource. This field is only applicable for persistent disks. For example: "source": "/compute/v1/projects/project_id/zones/zone/disks/ disk_name
    pub source: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl CustomerEncryptionKeyProtectedDisk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disk_encryption_key][crate::model::CustomerEncryptionKeyProtectedDisk::disk_encryption_key].
    pub fn set_disk_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.disk_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_encryption_key][crate::model::CustomerEncryptionKeyProtectedDisk::disk_encryption_key].
    pub fn set_or_clear_disk_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.disk_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::CustomerEncryptionKeyProtectedDisk::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::CustomerEncryptionKeyProtectedDisk::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for CustomerEncryptionKeyProtectedDisk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.CustomerEncryptionKeyProtectedDisk"
    }
}

/// Deprecation status for a public resource.
#[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeprecationStatus {
    /// An optional RFC3339 timestamp on or after which the state of this resource is intended to change to DELETED. This is only informational and the status will not change unless the client explicitly changes it.
    pub deleted: std::option::Option<std::string::String>,

    /// An optional RFC3339 timestamp on or after which the state of this resource is intended to change to DEPRECATED. This is only informational and the status will not change unless the client explicitly changes it.
    pub deprecated: std::option::Option<std::string::String>,

    /// An optional RFC3339 timestamp on or after which the state of this resource is intended to change to OBSOLETE. This is only informational and the status will not change unless the client explicitly changes it.
    pub obsolete: std::option::Option<std::string::String>,

    /// The URL of the suggested replacement for a deprecated resource. The suggested replacement resource must be the same kind of resource as the deprecated resource.
    pub replacement: std::option::Option<std::string::String>,

    /// The deprecation state of this resource. This can be ACTIVE, DEPRECATED, OBSOLETE, or DELETED. Operations which communicate the end of life date for an image, can use ACTIVE. Operations which create a new resource using a DEPRECATED resource will return successfully, but with a warning indicating the deprecated resource and recommending its replacement. Operations which use OBSOLETE or DELETED resources will be rejected and result in an error.
    pub state: std::option::Option<crate::model::deprecation_status::State>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
impl DeprecationStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [deleted][crate::model::DeprecationStatus::deleted].
    pub fn set_deleted<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.deleted = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deleted][crate::model::DeprecationStatus::deleted].
    pub fn set_or_clear_deleted<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.deleted = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deprecated][crate::model::DeprecationStatus::deprecated].
    pub fn set_deprecated<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.deprecated = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deprecated][crate::model::DeprecationStatus::deprecated].
    pub fn set_or_clear_deprecated<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.deprecated = v.map(|x| x.into());
        self
    }

    /// Sets the value of [obsolete][crate::model::DeprecationStatus::obsolete].
    pub fn set_obsolete<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.obsolete = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [obsolete][crate::model::DeprecationStatus::obsolete].
    pub fn set_or_clear_obsolete<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.obsolete = v.map(|x| x.into());
        self
    }

    /// Sets the value of [replacement][crate::model::DeprecationStatus::replacement].
    pub fn set_replacement<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.replacement = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replacement][crate::model::DeprecationStatus::replacement].
    pub fn set_or_clear_replacement<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.replacement = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::DeprecationStatus::state].
    pub fn set_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::deprecation_status::State>,
    {
        self.state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state][crate::model::DeprecationStatus::state].
    pub fn set_or_clear_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::deprecation_status::State>,
    {
        self.state = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
impl wkt::message::Message for DeprecationStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.DeprecationStatus"
    }
}

/// Defines additional types related to [DeprecationStatus].
#[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
pub mod deprecation_status {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [state][google.cloud.compute.v1.DeprecationStatus.state] field.
    ///
    /// [google.cloud.compute.v1.DeprecationStatus.state]: crate::model::deprecation_status::State
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        Active,
        Deleted,
        Deprecated,
        Obsolete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Active => std::option::Option::Some(0),
                Self::Deleted => std::option::Option::Some(1),
                Self::Deprecated => std::option::Option::Some(2),
                Self::Obsolete => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::Deprecated => std::option::Option::Some("DEPRECATED"),
                Self::Obsolete => std::option::Option::Some("OBSOLETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Active,
                1 => Self::Deleted,
                2 => Self::Deprecated,
                3 => Self::Obsolete,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACTIVE" => Self::Active,
                "DELETED" => Self::Deleted,
                "DEPRECATED" => Self::Deprecated,
                "OBSOLETE" => Self::Obsolete,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Active => serializer.serialize_str("ACTIVE"),
                Self::Deleted => serializer.serialize_str("DELETED"),
                Self::Deprecated => serializer.serialize_str("DEPRECATED"),
                Self::Obsolete => serializer.serialize_str("OBSOLETE"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "machine-types", feature = "zones",))]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.compute.v1.DeprecationStatus.state",
            ))
        }
    }
}

/// A set of Display Device options
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DisplayDevice {
    /// Defines whether the instance has Display enabled.
    pub enable_display: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl DisplayDevice {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_display][crate::model::DisplayDevice::enable_display].
    pub fn set_enable_display<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_display = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_display][crate::model::DisplayDevice::enable_display].
    pub fn set_or_clear_enable_display<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_display = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for DisplayDevice {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.DisplayDevice"
    }
}

/// A Duration represents a fixed-length span of time represented as a count of seconds and fractions of seconds at nanosecond resolution. It is independent of any calendar and concepts like "day" or "month". Range is approximately 10,000 years.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Duration {
    /// Span of time that's a fraction of a second at nanosecond resolution. Durations less than one second are represented with a 0 `seconds` field and a positive `nanos` field. Must be from 0 to 999,999,999 inclusive.
    pub nanos: std::option::Option<i32>,

    /// Span of time at a resolution of a second. Must be from 0 to 315,576,000,000 inclusive. Note: these bounds are computed from: 60 sec/min * 60 min/hr * 24 hr/day * 365.25 days/year * 10000 years
    pub seconds: std::option::Option<i64>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl Duration {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [nanos][crate::model::Duration::nanos].
    pub fn set_nanos<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.nanos = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nanos][crate::model::Duration::nanos].
    pub fn set_or_clear_nanos<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.nanos = v.map(|x| x.into());
        self
    }

    /// Sets the value of [seconds][crate::model::Duration::seconds].
    pub fn set_seconds<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.seconds = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [seconds][crate::model::Duration::seconds].
    pub fn set_or_clear_seconds<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.seconds = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for Duration {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Duration"
    }
}

/// Describes the cause of the error with structured details. Example of an error when contacting the "pubsub.googleapis.com" API when it is not enabled: { "reason": "API_DISABLED" "domain": "googleapis.com" "metadata": { "resource": "projects/123", "service": "pubsub.googleapis.com" } } This response indicates that the pubsub.googleapis.com API is not enabled. Example of an error that is returned when attempting to create a Spanner instance in a region that is out of stock: { "reason": "STOCKOUT" "domain": "spanner.googleapis.com", "metadata": { "availableRegions": "us-central1,us-east2" } }
#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ErrorInfo {
    /// The logical grouping to which the "reason" belongs. The error domain is typically the registered service name of the tool or product that generates the error. Example: "pubsub.googleapis.com". If the error is generated by some common infrastructure, the error domain must be a globally unique value that identifies the infrastructure. For Google API infrastructure, the error domain is "googleapis.com".
    pub domain: std::option::Option<std::string::String>,

    /// Additional structured details about this error. Keys must match a regular expression of `a-z+` but should ideally be lowerCamelCase. Also, they must be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than `{"instanceLimit": "100/request"}`, should be returned as, `{"instanceLimitPerRequest": "100"}`, if the client exceeds the number of instances that can be created in a single (batch) request.
    pub metadatas: std::collections::HashMap<std::string::String, std::string::String>,

    /// The reason of the error. This is a constant value that identifies the proximate cause of the error. Error reasons are unique within a particular domain of errors. This should be at most 63 characters and match a regular expression of `A-Z+[A-Z0-9]`, which represents UPPER_SNAKE_CASE.
    pub reason: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl ErrorInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [domain][crate::model::ErrorInfo::domain].
    pub fn set_domain<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.domain = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [domain][crate::model::ErrorInfo::domain].
    pub fn set_or_clear_domain<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.domain = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadatas][crate::model::ErrorInfo::metadatas].
    pub fn set_metadatas<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadatas = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [reason][crate::model::ErrorInfo::reason].
    pub fn set_reason<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.reason = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reason][crate::model::ErrorInfo::reason].
    pub fn set_or_clear_reason<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.reason = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl wkt::message::Message for ErrorInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ErrorInfo"
    }
}

/// Represents a textual expression in the Common Expression Language (CEL) syntax. CEL is a C-like expression language. The syntax and semantics of CEL are documented at <https://github.com/google/cel-spec>. Example (Comparison): title: "Summary size limit" description: "Determines if a summary is less than 100 chars" expression: "document.summary.size() < 100" Example (Equality): title: "Requestor is owner" description: "Determines if requestor is the document owner" expression: "document.owner == request.auth.claims.email" Example (Logic): title: "Public documents" description: "Determine whether the document should be publicly visible" expression: "document.type != 'private' && document.type != 'internal'" Example (Data Manipulation): title: "Notification string" description: "Create a notification string with a timestamp." expression: "'New message received at ' + string(document.create_time)" The exact variables and functions that may be referenced within an expression are determined by the service that evaluates it. See the service documentation for additional information.
#[cfg(any(feature = "images", feature = "instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Expr {
    /// Optional. Description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
    pub description: std::option::Option<std::string::String>,

    /// Textual representation of an expression in Common Expression Language syntax.
    pub expression: std::option::Option<std::string::String>,

    /// Optional. String indicating the location of the expression for error reporting, e.g. a file name and a position in the file.
    pub location: std::option::Option<std::string::String>,

    /// Optional. Title for the expression, i.e. a short string describing its purpose. This can be used e.g. in UIs which allow to enter the expression.
    pub title: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances",))]
impl Expr {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::Expr::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::Expr::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expression][crate::model::Expr::expression].
    pub fn set_expression<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.expression = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expression][crate::model::Expr::expression].
    pub fn set_or_clear_expression<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.expression = v.map(|x| x.into());
        self
    }

    /// Sets the value of [location][crate::model::Expr::location].
    pub fn set_location<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.location = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [location][crate::model::Expr::location].
    pub fn set_or_clear_location<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.location = v.map(|x| x.into());
        self
    }

    /// Sets the value of [title][crate::model::Expr::title].
    pub fn set_title<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.title = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [title][crate::model::Expr::title].
    pub fn set_or_clear_title<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.title = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
impl wkt::message::Message for Expr {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Expr"
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FileContentBuffer {
    /// The raw content in the secure keys file.
    pub content: std::option::Option<::bytes::Bytes>,

    /// The file type of source file.
    pub file_type: std::option::Option<crate::model::file_content_buffer::FileType>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances",))]
impl FileContentBuffer {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [content][crate::model::FileContentBuffer::content].
    pub fn set_content<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.content = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [content][crate::model::FileContentBuffer::content].
    pub fn set_or_clear_content<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.content = v.map(|x| x.into());
        self
    }

    /// Sets the value of [file_type][crate::model::FileContentBuffer::file_type].
    pub fn set_file_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::file_content_buffer::FileType>,
    {
        self.file_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [file_type][crate::model::FileContentBuffer::file_type].
    pub fn set_or_clear_file_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::file_content_buffer::FileType>,
    {
        self.file_type = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
impl wkt::message::Message for FileContentBuffer {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.FileContentBuffer"
    }
}

/// Defines additional types related to [FileContentBuffer].
#[cfg(any(feature = "images", feature = "instances",))]
pub mod file_content_buffer {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [fileType][google.cloud.compute.v1.FileContentBuffer.fileType] field.
    ///
    /// [google.cloud.compute.v1.FileContentBuffer.fileType]: crate::model::file_content_buffer::FileType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "images", feature = "instances",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum FileType {
        Bin,
        Undefined,
        X509,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [FileType::value] or
        /// [FileType::name].
        UnknownValue(file_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "images", feature = "instances",))]
    pub mod file_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl FileType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Bin => std::option::Option::Some(0),
                Self::Undefined => std::option::Option::Some(1),
                Self::X509 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Bin => std::option::Option::Some("BIN"),
                Self::Undefined => std::option::Option::Some("UNDEFINED"),
                Self::X509 => std::option::Option::Some("X509"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl std::default::Default for FileType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl std::fmt::Display for FileType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl std::convert::From<i32> for FileType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Bin,
                1 => Self::Undefined,
                2 => Self::X509,
                _ => Self::UnknownValue(file_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl std::convert::From<&str> for FileType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BIN" => Self::Bin,
                "UNDEFINED" => Self::Undefined,
                "X509" => Self::X509,
                _ => Self::UnknownValue(file_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl serde::ser::Serialize for FileType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Bin => serializer.serialize_str("BIN"),
                Self::Undefined => serializer.serialize_str("UNDEFINED"),
                Self::X509 => serializer.serialize_str("X509"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl<'de> serde::de::Deserialize<'de> for FileType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<FileType>::new(
                ".google.cloud.compute.v1.FileContentBuffer.fileType",
            ))
        }
    }
}

/// Represents a Firewall Rule resource. Firewall rules allow or deny ingress traffic to, and egress traffic from your instances. For more information, read Firewall rules.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Firewall {
    /// The list of ALLOW rules specified by this firewall. Each rule specifies a protocol and port-range tuple that describes a permitted connection.
    pub allowed: std::vec::Vec<crate::model::firewall::Allowed>,

    /// [Output Only] Creation timestamp in RFC3339 text format.
    pub creation_timestamp: std::option::Option<std::string::String>,

    /// The list of DENY rules specified by this firewall. Each rule specifies a protocol and port-range tuple that describes a denied connection.
    pub denied: std::vec::Vec<crate::model::firewall::Denied>,

    /// An optional description of this resource. Provide this field when you create the resource.
    pub description: std::option::Option<std::string::String>,

    /// If destination ranges are specified, the firewall rule applies only to traffic that has destination IP address in these ranges. These ranges must be expressed in CIDR format. Both IPv4 and IPv6 are supported.
    pub destination_ranges: std::vec::Vec<std::string::String>,

    /// Direction of traffic to which this firewall applies, either `INGRESS` or `EGRESS`. The default is `INGRESS`. For `EGRESS` traffic, you cannot specify the sourceTags fields.
    pub direction: std::option::Option<crate::model::firewall::Direction>,

    /// Denotes whether the firewall rule is disabled. When set to true, the firewall rule is not enforced and the network behaves as if it did not exist. If this is unspecified, the firewall rule will be enabled.
    pub disabled: std::option::Option<bool>,

    /// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
    pub id: std::option::Option<u64>,

    /// [Output Only] Type of the resource. Always compute#firewall for firewall rules.
    pub kind: std::option::Option<std::string::String>,

    /// This field denotes the logging options for a particular firewall rule. If logging is enabled, logs will be exported to Cloud Logging.
    pub log_config: std::option::Option<crate::model::FirewallLogConfig>,

    /// Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?`. The first character must be a lowercase letter, and all following characters (except for the last character) must be a dash, lowercase letter, or digit. The last character must be a lowercase letter or digit.
    pub name: std::option::Option<std::string::String>,

    /// URL of the network resource for this firewall rule. If not specified when creating a firewall rule, the default network is used: global/networks/default If you choose to specify this field, you can specify the network as a full or partial URL. For example, the following are all valid URLs: - <https://www.googleapis.com/compute/v1/projects/myproject/global/networks/my-network> - projects/myproject/global/networks/my-network - global/networks/default
    pub network: std::option::Option<std::string::String>,

    /// Input only. [Input Only] Additional params passed with the request, but not persisted as part of resource payload.
    pub params: std::option::Option<crate::model::FirewallParams>,

    /// Priority for this rule. This is an integer between `0` and `65535`, both inclusive. The default value is `1000`. Relative priorities determine which rule takes effect if multiple rules apply. Lower values indicate higher priority. For example, a rule with priority `0` has higher precedence than a rule with priority `1`. DENY rules take precedence over ALLOW rules if they have equal priority. Note that VPC networks have implied rules with a priority of `65535`. To avoid conflicts with the implied rules, use a priority number less than `65535`.
    pub priority: std::option::Option<i32>,

    /// [Output Only] Server-defined URL for the resource.
    pub self_link: std::option::Option<std::string::String>,

    /// If source ranges are specified, the firewall rule applies only to traffic that has a source IP address in these ranges. These ranges must be expressed in CIDR format. One or both of sourceRanges and sourceTags may be set. If both fields are set, the rule applies to traffic that has a source IP address within sourceRanges OR a source IP from a resource with a matching tag listed in the sourceTags field. The connection does not need to match both fields for the rule to apply. Both IPv4 and IPv6 are supported.
    pub source_ranges: std::vec::Vec<std::string::String>,

    /// If source service accounts are specified, the firewall rules apply only to traffic originating from an instance with a service account in this list. Source service accounts cannot be used to control traffic to an instance's external IP address because service accounts are associated with an instance, not an IP address. sourceRanges can be set at the same time as sourceServiceAccounts. If both are set, the firewall applies to traffic that has a source IP address within the sourceRanges OR a source IP that belongs to an instance with service account listed in sourceServiceAccount. The connection does not need to match both fields for the firewall to apply. sourceServiceAccounts cannot be used at the same time as sourceTags or targetTags.
    pub source_service_accounts: std::vec::Vec<std::string::String>,

    /// If source tags are specified, the firewall rule applies only to traffic with source IPs that match the primary network interfaces of VM instances that have the tag and are in the same VPC network. Source tags cannot be used to control traffic to an instance's external IP address, it only applies to traffic between instances in the same virtual network. Because tags are associated with instances, not IP addresses. One or both of sourceRanges and sourceTags may be set. If both fields are set, the firewall applies to traffic that has a source IP address within sourceRanges OR a source IP from a resource with a matching tag listed in the sourceTags field. The connection does not need to match both fields for the firewall to apply.
    pub source_tags: std::vec::Vec<std::string::String>,

    /// A list of service accounts indicating sets of instances located in the network that may make network connections as specified in allowed[]. targetServiceAccounts cannot be used at the same time as targetTags or sourceTags. If neither targetServiceAccounts nor targetTags are specified, the firewall rule applies to all instances on the specified network.
    pub target_service_accounts: std::vec::Vec<std::string::String>,

    /// A list of tags that controls which instances the firewall rule applies to. If targetTags are specified, then the firewall rule applies only to instances in the VPC network that have one of those tags. If no targetTags are specified, the firewall rule applies to all instances on the specified network.
    pub target_tags: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl Firewall {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [allowed][crate::model::Firewall::allowed].
    pub fn set_allowed<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::firewall::Allowed>,
    {
        use std::iter::Iterator;
        self.allowed = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [creation_timestamp][crate::model::Firewall::creation_timestamp].
    pub fn set_creation_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_timestamp][crate::model::Firewall::creation_timestamp].
    pub fn set_or_clear_creation_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [denied][crate::model::Firewall::denied].
    pub fn set_denied<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::firewall::Denied>,
    {
        use std::iter::Iterator;
        self.denied = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [description][crate::model::Firewall::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::Firewall::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [destination_ranges][crate::model::Firewall::destination_ranges].
    pub fn set_destination_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.destination_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [direction][crate::model::Firewall::direction].
    pub fn set_direction<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::firewall::Direction>,
    {
        self.direction = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [direction][crate::model::Firewall::direction].
    pub fn set_or_clear_direction<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::firewall::Direction>,
    {
        self.direction = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disabled][crate::model::Firewall::disabled].
    pub fn set_disabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.disabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disabled][crate::model::Firewall::disabled].
    pub fn set_or_clear_disabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.disabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::Firewall::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::Firewall::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::Firewall::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::Firewall::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [log_config][crate::model::Firewall::log_config].
    pub fn set_log_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FirewallLogConfig>,
    {
        self.log_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [log_config][crate::model::Firewall::log_config].
    pub fn set_or_clear_log_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FirewallLogConfig>,
    {
        self.log_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::Firewall::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::Firewall::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network][crate::model::Firewall::network].
    pub fn set_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network][crate::model::Firewall::network].
    pub fn set_or_clear_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [params][crate::model::Firewall::params].
    pub fn set_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FirewallParams>,
    {
        self.params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [params][crate::model::Firewall::params].
    pub fn set_or_clear_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FirewallParams>,
    {
        self.params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [priority][crate::model::Firewall::priority].
    pub fn set_priority<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.priority = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [priority][crate::model::Firewall::priority].
    pub fn set_or_clear_priority<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.priority = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::Firewall::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::Firewall::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_ranges][crate::model::Firewall::source_ranges].
    pub fn set_source_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.source_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source_service_accounts][crate::model::Firewall::source_service_accounts].
    pub fn set_source_service_accounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.source_service_accounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source_tags][crate::model::Firewall::source_tags].
    pub fn set_source_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.source_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_service_accounts][crate::model::Firewall::target_service_accounts].
    pub fn set_target_service_accounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_service_accounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_tags][crate::model::Firewall::target_tags].
    pub fn set_target_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for Firewall {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Firewall"
    }
}

/// Defines additional types related to [Firewall].
#[cfg(feature = "instances")]
pub mod firewall {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [allowed][google.cloud.compute.v1.Firewall.allowed] field.
    ///
    /// [google.cloud.compute.v1.Firewall.allowed]: crate::model::firewall::Allowed
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Allowed {
        /// The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule. This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp) or the IP protocol number.
        pub ip_protocol: std::option::Option<std::string::String>,

        /// An optional list of ports to which this rule applies. This field is only applicable for the UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port. Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
        pub ports: std::vec::Vec<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl Allowed {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ip_protocol][crate::model::firewall::Allowed::ip_protocol].
        pub fn set_ip_protocol<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.ip_protocol = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [ip_protocol][crate::model::firewall::Allowed::ip_protocol].
        pub fn set_or_clear_ip_protocol<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.ip_protocol = v.map(|x| x.into());
            self
        }

        /// Sets the value of [ports][crate::model::firewall::Allowed::ports].
        pub fn set_ports<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.ports = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "instances")]
    impl wkt::message::Message for Allowed {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.Firewall.allowed"
        }
    }

    /// The message type for the [denied][google.cloud.compute.v1.Firewall.denied] field.
    ///
    /// [google.cloud.compute.v1.Firewall.denied]: crate::model::firewall::Denied
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Denied {
        /// The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule. This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp) or the IP protocol number.
        pub ip_protocol: std::option::Option<std::string::String>,

        /// An optional list of ports to which this rule applies. This field is only applicable for the UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port. Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
        pub ports: std::vec::Vec<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl Denied {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ip_protocol][crate::model::firewall::Denied::ip_protocol].
        pub fn set_ip_protocol<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.ip_protocol = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [ip_protocol][crate::model::firewall::Denied::ip_protocol].
        pub fn set_or_clear_ip_protocol<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.ip_protocol = v.map(|x| x.into());
            self
        }

        /// Sets the value of [ports][crate::model::firewall::Denied::ports].
        pub fn set_ports<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.ports = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(feature = "instances")]
    impl wkt::message::Message for Denied {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.Firewall.denied"
        }
    }

    /// The enumerated type for the [direction][google.cloud.compute.v1.Firewall.direction] field.
    ///
    /// [google.cloud.compute.v1.Firewall.direction]: crate::model::firewall::Direction
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Direction {
        /// Indicates that firewall should apply to outgoing traffic.
        Egress,
        /// Indicates that firewall should apply to incoming traffic.
        Ingress,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Direction::value] or
        /// [Direction::name].
        UnknownValue(direction::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod direction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Direction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Egress => std::option::Option::Some(0),
                Self::Ingress => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Egress => std::option::Option::Some("EGRESS"),
                Self::Ingress => std::option::Option::Some("INGRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Direction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Direction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Direction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Egress,
                1 => Self::Ingress,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Direction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EGRESS" => Self::Egress,
                "INGRESS" => Self::Ingress,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Direction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Egress => serializer.serialize_str("EGRESS"),
                Self::Ingress => serializer.serialize_str("INGRESS"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Direction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Direction>::new(
                ".google.cloud.compute.v1.Firewall.direction",
            ))
        }
    }
}

/// The available logging options for a firewall rule.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallLogConfig {
    /// This field denotes whether to enable logging for a particular firewall rule.
    pub enable: std::option::Option<bool>,

    /// This field can only be specified for a particular firewall rule if logging is enabled for that rule. This field denotes whether to include or exclude metadata for firewall logs.
    pub metadata: std::option::Option<crate::model::firewall_log_config::Metadata>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl FirewallLogConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable][crate::model::FirewallLogConfig::enable].
    pub fn set_enable<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable][crate::model::FirewallLogConfig::enable].
    pub fn set_or_clear_enable<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::FirewallLogConfig::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::firewall_log_config::Metadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::FirewallLogConfig::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::firewall_log_config::Metadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for FirewallLogConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.FirewallLogConfig"
    }
}

/// Defines additional types related to [FirewallLogConfig].
#[cfg(feature = "instances")]
pub mod firewall_log_config {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [metadata][google.cloud.compute.v1.FirewallLogConfig.metadata] field.
    ///
    /// [google.cloud.compute.v1.FirewallLogConfig.metadata]: crate::model::firewall_log_config::Metadata
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Metadata {
        ExcludeAllMetadata,
        IncludeAllMetadata,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Metadata::value] or
        /// [Metadata::name].
        UnknownValue(metadata::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod metadata {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Metadata {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::ExcludeAllMetadata => std::option::Option::Some(0),
                Self::IncludeAllMetadata => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::ExcludeAllMetadata => std::option::Option::Some("EXCLUDE_ALL_METADATA"),
                Self::IncludeAllMetadata => std::option::Option::Some("INCLUDE_ALL_METADATA"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Metadata {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Metadata {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Metadata {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::ExcludeAllMetadata,
                1 => Self::IncludeAllMetadata,
                _ => Self::UnknownValue(metadata::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Metadata {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXCLUDE_ALL_METADATA" => Self::ExcludeAllMetadata,
                "INCLUDE_ALL_METADATA" => Self::IncludeAllMetadata,
                _ => Self::UnknownValue(metadata::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Metadata {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::ExcludeAllMetadata => serializer.serialize_str("EXCLUDE_ALL_METADATA"),
                Self::IncludeAllMetadata => serializer.serialize_str("INCLUDE_ALL_METADATA"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Metadata {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Metadata>::new(
                ".google.cloud.compute.v1.FirewallLogConfig.metadata",
            ))
        }
    }
}

/// Additional firewall parameters.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallParams {
    /// Tag keys/values directly bound to this resource. Tag keys and values have the same definition as resource manager tags. The field is allowed for INSERT only. The keys/values to set on the resource should be specified in either ID { : } or Namespaced format { : }. For example the following are valid inputs: * {"tagKeys/333" : "tagValues/444", "tagKeys/123" : "tagValues/456"} * {"123/environment" : "production", "345/abc" : "xyz"} Note: * Invalid combinations of ID & namespaced format is not supported. For instance: {"123/environment" : "tagValues/444"} is invalid.
    pub resource_manager_tags: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl FirewallParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_manager_tags][crate::model::FirewallParams::resource_manager_tags].
    pub fn set_resource_manager_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_manager_tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for FirewallParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.FirewallParams"
    }
}

/// Represents a rule that describes one or more match conditions along with the action to be taken when traffic matches this condition (allow or deny).
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallPolicyRule {
    /// The Action to perform when the client connection triggers the rule. Valid actions for firewall rules are: "allow", "deny", "apply_security_profile_group" and "goto_next". Valid actions for packet mirroring rules are: "mirror", "do_not_mirror" and "goto_next".
    pub action: std::option::Option<std::string::String>,

    /// An optional description for this resource.
    pub description: std::option::Option<std::string::String>,

    /// The direction in which this rule applies.
    pub direction: std::option::Option<crate::model::firewall_policy_rule::Direction>,

    /// Denotes whether the firewall policy rule is disabled. When set to true, the firewall policy rule is not enforced and traffic behaves as if it did not exist. If this is unspecified, the firewall policy rule will be enabled.
    pub disabled: std::option::Option<bool>,

    /// Denotes whether to enable logging for a particular rule. If logging is enabled, logs will be exported to the configured export destination in Stackdriver. Logs may be exported to BigQuery or Pub/Sub. Note: you cannot enable logging on "goto_next" rules.
    pub enable_logging: std::option::Option<bool>,

    /// [Output only] Type of the resource. Returns compute#firewallPolicyRule for firewall rules and compute#packetMirroringRule for packet mirroring rules.
    pub kind: std::option::Option<std::string::String>,

    /// A match condition that incoming traffic is evaluated against. If it evaluates to true, the corresponding 'action' is enforced.
    pub r#match: std::option::Option<crate::model::FirewallPolicyRuleMatcher>,

    /// An integer indicating the priority of a rule in the list. The priority must be a positive value between 0 and 2147483647. Rules are evaluated from highest to lowest priority where 0 is the highest priority and 2147483647 is the lowest priority.
    pub priority: std::option::Option<i32>,

    /// An optional name for the rule. This field is not a unique identifier and can be updated.
    pub rule_name: std::option::Option<std::string::String>,

    /// [Output Only] Calculation of the complexity of a single firewall policy rule.
    pub rule_tuple_count: std::option::Option<i32>,

    /// A fully-qualified URL of a SecurityProfile resource instance. Example: <https://networksecurity.googleapis.com/v1/projects/{project}/locations/{location}/securityProfileGroups/my-security-profile-group> Must be specified if action is one of 'apply_security_profile_group' or 'mirror'. Cannot be specified for other actions.
    pub security_profile_group: std::option::Option<std::string::String>,

    /// A list of network resource URLs to which this rule applies. This field allows you to control which network's VMs get this rule. If this field is left blank, all VMs within the organization will receive the rule.
    pub target_resources: std::vec::Vec<std::string::String>,

    /// A list of secure tags that controls which instances the firewall rule applies to. If targetSecureTag are specified, then the firewall rule applies only to instances in the VPC network that have one of those EFFECTIVE secure tags, if all the target_secure_tag are in INEFFECTIVE state, then this rule will be ignored. targetSecureTag may not be set at the same time as targetServiceAccounts. If neither targetServiceAccounts nor targetSecureTag are specified, the firewall rule applies to all instances on the specified network. Maximum number of target label tags allowed is 256.
    pub target_secure_tags: std::vec::Vec<crate::model::FirewallPolicyRuleSecureTag>,

    /// A list of service accounts indicating the sets of instances that are applied with this rule.
    pub target_service_accounts: std::vec::Vec<std::string::String>,

    /// Boolean flag indicating if the traffic should be TLS decrypted. Can be set only if action = 'apply_security_profile_group' and cannot be set for other actions.
    pub tls_inspect: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl FirewallPolicyRule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [action][crate::model::FirewallPolicyRule::action].
    pub fn set_action<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.action = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [action][crate::model::FirewallPolicyRule::action].
    pub fn set_or_clear_action<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.action = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::FirewallPolicyRule::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::FirewallPolicyRule::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [direction][crate::model::FirewallPolicyRule::direction].
    pub fn set_direction<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::firewall_policy_rule::Direction>,
    {
        self.direction = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [direction][crate::model::FirewallPolicyRule::direction].
    pub fn set_or_clear_direction<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::firewall_policy_rule::Direction>,
    {
        self.direction = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disabled][crate::model::FirewallPolicyRule::disabled].
    pub fn set_disabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.disabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disabled][crate::model::FirewallPolicyRule::disabled].
    pub fn set_or_clear_disabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.disabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_logging][crate::model::FirewallPolicyRule::enable_logging].
    pub fn set_enable_logging<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_logging = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_logging][crate::model::FirewallPolicyRule::enable_logging].
    pub fn set_or_clear_enable_logging<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_logging = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::FirewallPolicyRule::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::FirewallPolicyRule::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#match][crate::model::FirewallPolicyRule::match].
    pub fn set_match<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicyRuleMatcher>,
    {
        self.r#match = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#match][crate::model::FirewallPolicyRule::match].
    pub fn set_or_clear_match<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FirewallPolicyRuleMatcher>,
    {
        self.r#match = v.map(|x| x.into());
        self
    }

    /// Sets the value of [priority][crate::model::FirewallPolicyRule::priority].
    pub fn set_priority<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.priority = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [priority][crate::model::FirewallPolicyRule::priority].
    pub fn set_or_clear_priority<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.priority = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rule_name][crate::model::FirewallPolicyRule::rule_name].
    pub fn set_rule_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.rule_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rule_name][crate::model::FirewallPolicyRule::rule_name].
    pub fn set_or_clear_rule_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.rule_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rule_tuple_count][crate::model::FirewallPolicyRule::rule_tuple_count].
    pub fn set_rule_tuple_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.rule_tuple_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rule_tuple_count][crate::model::FirewallPolicyRule::rule_tuple_count].
    pub fn set_or_clear_rule_tuple_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.rule_tuple_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [security_profile_group][crate::model::FirewallPolicyRule::security_profile_group].
    pub fn set_security_profile_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.security_profile_group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [security_profile_group][crate::model::FirewallPolicyRule::security_profile_group].
    pub fn set_or_clear_security_profile_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.security_profile_group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_resources][crate::model::FirewallPolicyRule::target_resources].
    pub fn set_target_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_secure_tags][crate::model::FirewallPolicyRule::target_secure_tags].
    pub fn set_target_secure_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallPolicyRuleSecureTag>,
    {
        use std::iter::Iterator;
        self.target_secure_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_service_accounts][crate::model::FirewallPolicyRule::target_service_accounts].
    pub fn set_target_service_accounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_service_accounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tls_inspect][crate::model::FirewallPolicyRule::tls_inspect].
    pub fn set_tls_inspect<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.tls_inspect = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tls_inspect][crate::model::FirewallPolicyRule::tls_inspect].
    pub fn set_or_clear_tls_inspect<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.tls_inspect = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for FirewallPolicyRule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.FirewallPolicyRule"
    }
}

/// Defines additional types related to [FirewallPolicyRule].
#[cfg(feature = "instances")]
pub mod firewall_policy_rule {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [direction][google.cloud.compute.v1.FirewallPolicyRule.direction] field.
    ///
    /// [google.cloud.compute.v1.FirewallPolicyRule.direction]: crate::model::firewall_policy_rule::Direction
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Direction {
        Egress,
        Ingress,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Direction::value] or
        /// [Direction::name].
        UnknownValue(direction::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod direction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Direction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Egress => std::option::Option::Some(0),
                Self::Ingress => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Egress => std::option::Option::Some("EGRESS"),
                Self::Ingress => std::option::Option::Some("INGRESS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Direction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Direction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Direction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Egress,
                1 => Self::Ingress,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Direction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EGRESS" => Self::Egress,
                "INGRESS" => Self::Ingress,
                _ => Self::UnknownValue(direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Direction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Egress => serializer.serialize_str("EGRESS"),
                Self::Ingress => serializer.serialize_str("INGRESS"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Direction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Direction>::new(
                ".google.cloud.compute.v1.FirewallPolicyRule.direction",
            ))
        }
    }
}

/// Represents a match condition that incoming traffic is evaluated against. Exactly one field must be specified.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallPolicyRuleMatcher {
    /// Address groups which should be matched against the traffic destination. Maximum number of destination address groups is 10.
    pub dest_address_groups: std::vec::Vec<std::string::String>,

    /// Fully Qualified Domain Name (FQDN) which should be matched against traffic destination. Maximum number of destination fqdn allowed is 100.
    pub dest_fqdns: std::vec::Vec<std::string::String>,

    /// CIDR IP address range. Maximum number of destination CIDR IP ranges allowed is 5000.
    pub dest_ip_ranges: std::vec::Vec<std::string::String>,

    /// Network type of the traffic destination. Allowed values are: - UNSPECIFIED - INTERNET - NON_INTERNET
    pub dest_network_type:
        std::option::Option<crate::model::firewall_policy_rule_matcher::DestNetworkType>,

    /// Region codes whose IP addresses will be used to match for destination of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of dest region codes allowed is 5000.
    pub dest_region_codes: std::vec::Vec<std::string::String>,

    /// Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic destination.
    pub dest_threat_intelligences: std::vec::Vec<std::string::String>,

    /// Pairs of IP protocols and ports that the rule should match.
    pub layer_4_configs: std::vec::Vec<crate::model::FirewallPolicyRuleMatcherLayer4Config>,

    /// Address groups which should be matched against the traffic source. Maximum number of source address groups is 10.
    pub src_address_groups: std::vec::Vec<std::string::String>,

    /// Fully Qualified Domain Name (FQDN) which should be matched against traffic source. Maximum number of source fqdn allowed is 100.
    pub src_fqdns: std::vec::Vec<std::string::String>,

    /// CIDR IP address range. Maximum number of source CIDR IP ranges allowed is 5000.
    pub src_ip_ranges: std::vec::Vec<std::string::String>,

    /// Network type of the traffic source. Allowed values are: - UNSPECIFIED - INTERNET - INTRA_VPC - NON_INTERNET - VPC_NETWORKS
    pub src_network_type:
        std::option::Option<crate::model::firewall_policy_rule_matcher::SrcNetworkType>,

    /// Networks of the traffic source. It can be either a full or partial url.
    pub src_networks: std::vec::Vec<std::string::String>,

    /// Region codes whose IP addresses will be used to match for source of traffic. Should be specified as 2 letter country code defined as per ISO 3166 alpha-2 country codes. ex."US" Maximum number of source region codes allowed is 5000.
    pub src_region_codes: std::vec::Vec<std::string::String>,

    /// List of secure tag values, which should be matched at the source of the traffic. For INGRESS rule, if all the srcSecureTag are INEFFECTIVE, and there is no srcIpRange, this rule will be ignored. Maximum number of source tag values allowed is 256.
    pub src_secure_tags: std::vec::Vec<crate::model::FirewallPolicyRuleSecureTag>,

    /// Names of Network Threat Intelligence lists. The IPs in these lists will be matched against traffic source.
    pub src_threat_intelligences: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl FirewallPolicyRuleMatcher {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dest_address_groups][crate::model::FirewallPolicyRuleMatcher::dest_address_groups].
    pub fn set_dest_address_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dest_address_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dest_fqdns][crate::model::FirewallPolicyRuleMatcher::dest_fqdns].
    pub fn set_dest_fqdns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dest_fqdns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dest_ip_ranges][crate::model::FirewallPolicyRuleMatcher::dest_ip_ranges].
    pub fn set_dest_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dest_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dest_network_type][crate::model::FirewallPolicyRuleMatcher::dest_network_type].
    pub fn set_dest_network_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::firewall_policy_rule_matcher::DestNetworkType>,
    {
        self.dest_network_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [dest_network_type][crate::model::FirewallPolicyRuleMatcher::dest_network_type].
    pub fn set_or_clear_dest_network_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::firewall_policy_rule_matcher::DestNetworkType>,
    {
        self.dest_network_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [dest_region_codes][crate::model::FirewallPolicyRuleMatcher::dest_region_codes].
    pub fn set_dest_region_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dest_region_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dest_threat_intelligences][crate::model::FirewallPolicyRuleMatcher::dest_threat_intelligences].
    pub fn set_dest_threat_intelligences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dest_threat_intelligences = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [layer_4_configs][crate::model::FirewallPolicyRuleMatcher::layer_4_configs].
    pub fn set_layer_4_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallPolicyRuleMatcherLayer4Config>,
    {
        use std::iter::Iterator;
        self.layer_4_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [src_address_groups][crate::model::FirewallPolicyRuleMatcher::src_address_groups].
    pub fn set_src_address_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.src_address_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [src_fqdns][crate::model::FirewallPolicyRuleMatcher::src_fqdns].
    pub fn set_src_fqdns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.src_fqdns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [src_ip_ranges][crate::model::FirewallPolicyRuleMatcher::src_ip_ranges].
    pub fn set_src_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.src_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [src_network_type][crate::model::FirewallPolicyRuleMatcher::src_network_type].
    pub fn set_src_network_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::firewall_policy_rule_matcher::SrcNetworkType>,
    {
        self.src_network_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [src_network_type][crate::model::FirewallPolicyRuleMatcher::src_network_type].
    pub fn set_or_clear_src_network_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::firewall_policy_rule_matcher::SrcNetworkType>,
    {
        self.src_network_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [src_networks][crate::model::FirewallPolicyRuleMatcher::src_networks].
    pub fn set_src_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.src_networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [src_region_codes][crate::model::FirewallPolicyRuleMatcher::src_region_codes].
    pub fn set_src_region_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.src_region_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [src_secure_tags][crate::model::FirewallPolicyRuleMatcher::src_secure_tags].
    pub fn set_src_secure_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallPolicyRuleSecureTag>,
    {
        use std::iter::Iterator;
        self.src_secure_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [src_threat_intelligences][crate::model::FirewallPolicyRuleMatcher::src_threat_intelligences].
    pub fn set_src_threat_intelligences<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.src_threat_intelligences = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for FirewallPolicyRuleMatcher {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.FirewallPolicyRuleMatcher"
    }
}

/// Defines additional types related to [FirewallPolicyRuleMatcher].
#[cfg(feature = "instances")]
pub mod firewall_policy_rule_matcher {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [destNetworkType][google.cloud.compute.v1.FirewallPolicyRuleMatcher.destNetworkType] field.
    ///
    /// [google.cloud.compute.v1.FirewallPolicyRuleMatcher.destNetworkType]: crate::model::firewall_policy_rule_matcher::DestNetworkType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DestNetworkType {
        Internet,
        IntraVpc,
        NonInternet,
        Unspecified,
        VpcNetworks,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DestNetworkType::value] or
        /// [DestNetworkType::name].
        UnknownValue(dest_network_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod dest_network_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl DestNetworkType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Internet => std::option::Option::Some(0),
                Self::IntraVpc => std::option::Option::Some(1),
                Self::NonInternet => std::option::Option::Some(2),
                Self::Unspecified => std::option::Option::Some(3),
                Self::VpcNetworks => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Internet => std::option::Option::Some("INTERNET"),
                Self::IntraVpc => std::option::Option::Some("INTRA_VPC"),
                Self::NonInternet => std::option::Option::Some("NON_INTERNET"),
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::VpcNetworks => std::option::Option::Some("VPC_NETWORKS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for DestNetworkType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for DestNetworkType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for DestNetworkType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Internet,
                1 => Self::IntraVpc,
                2 => Self::NonInternet,
                3 => Self::Unspecified,
                4 => Self::VpcNetworks,
                _ => Self::UnknownValue(dest_network_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for DestNetworkType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INTERNET" => Self::Internet,
                "INTRA_VPC" => Self::IntraVpc,
                "NON_INTERNET" => Self::NonInternet,
                "UNSPECIFIED" => Self::Unspecified,
                "VPC_NETWORKS" => Self::VpcNetworks,
                _ => Self::UnknownValue(dest_network_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for DestNetworkType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Internet => serializer.serialize_str("INTERNET"),
                Self::IntraVpc => serializer.serialize_str("INTRA_VPC"),
                Self::NonInternet => serializer.serialize_str("NON_INTERNET"),
                Self::Unspecified => serializer.serialize_str("UNSPECIFIED"),
                Self::VpcNetworks => serializer.serialize_str("VPC_NETWORKS"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for DestNetworkType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DestNetworkType>::new(
                ".google.cloud.compute.v1.FirewallPolicyRuleMatcher.destNetworkType",
            ))
        }
    }

    /// The enumerated type for the [srcNetworkType][google.cloud.compute.v1.FirewallPolicyRuleMatcher.srcNetworkType] field.
    ///
    /// [google.cloud.compute.v1.FirewallPolicyRuleMatcher.srcNetworkType]: crate::model::firewall_policy_rule_matcher::SrcNetworkType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SrcNetworkType {
        Internet,
        IntraVpc,
        NonInternet,
        Unspecified,
        VpcNetworks,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SrcNetworkType::value] or
        /// [SrcNetworkType::name].
        UnknownValue(src_network_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod src_network_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl SrcNetworkType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Internet => std::option::Option::Some(0),
                Self::IntraVpc => std::option::Option::Some(1),
                Self::NonInternet => std::option::Option::Some(2),
                Self::Unspecified => std::option::Option::Some(3),
                Self::VpcNetworks => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Internet => std::option::Option::Some("INTERNET"),
                Self::IntraVpc => std::option::Option::Some("INTRA_VPC"),
                Self::NonInternet => std::option::Option::Some("NON_INTERNET"),
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::VpcNetworks => std::option::Option::Some("VPC_NETWORKS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for SrcNetworkType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for SrcNetworkType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for SrcNetworkType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Internet,
                1 => Self::IntraVpc,
                2 => Self::NonInternet,
                3 => Self::Unspecified,
                4 => Self::VpcNetworks,
                _ => Self::UnknownValue(src_network_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for SrcNetworkType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "INTERNET" => Self::Internet,
                "INTRA_VPC" => Self::IntraVpc,
                "NON_INTERNET" => Self::NonInternet,
                "UNSPECIFIED" => Self::Unspecified,
                "VPC_NETWORKS" => Self::VpcNetworks,
                _ => Self::UnknownValue(src_network_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for SrcNetworkType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Internet => serializer.serialize_str("INTERNET"),
                Self::IntraVpc => serializer.serialize_str("INTRA_VPC"),
                Self::NonInternet => serializer.serialize_str("NON_INTERNET"),
                Self::Unspecified => serializer.serialize_str("UNSPECIFIED"),
                Self::VpcNetworks => serializer.serialize_str("VPC_NETWORKS"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for SrcNetworkType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SrcNetworkType>::new(
                ".google.cloud.compute.v1.FirewallPolicyRuleMatcher.srcNetworkType",
            ))
        }
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallPolicyRuleMatcherLayer4Config {
    /// The IP protocol to which this rule applies. The protocol type is required when creating a firewall rule. This value can either be one of the following well known protocol strings (tcp, udp, icmp, esp, ah, ipip, sctp), or the IP protocol number.
    pub ip_protocol: std::option::Option<std::string::String>,

    /// An optional list of ports to which this rule applies. This field is only applicable for UDP or TCP protocol. Each entry must be either an integer or a range. If not specified, this rule applies to connections through any port. Example inputs include: ["22"], ["80","443"], and ["12345-12349"].
    pub ports: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl FirewallPolicyRuleMatcherLayer4Config {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ip_protocol][crate::model::FirewallPolicyRuleMatcherLayer4Config::ip_protocol].
    pub fn set_ip_protocol<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ip_protocol = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ip_protocol][crate::model::FirewallPolicyRuleMatcherLayer4Config::ip_protocol].
    pub fn set_or_clear_ip_protocol<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ip_protocol = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ports][crate::model::FirewallPolicyRuleMatcherLayer4Config::ports].
    pub fn set_ports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ports = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for FirewallPolicyRuleMatcherLayer4Config {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.FirewallPolicyRuleMatcherLayer4Config"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FirewallPolicyRuleSecureTag {
    /// Name of the secure tag, created with TagManager's TagValue API.
    pub name: std::option::Option<std::string::String>,

    /// [Output Only] State of the secure tag, either `EFFECTIVE` or `INEFFECTIVE`. A secure tag is `INEFFECTIVE` when it is deleted or its network is deleted.
    pub state: std::option::Option<crate::model::firewall_policy_rule_secure_tag::State>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl FirewallPolicyRuleSecureTag {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FirewallPolicyRuleSecureTag::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::FirewallPolicyRuleSecureTag::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::FirewallPolicyRuleSecureTag::state].
    pub fn set_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::firewall_policy_rule_secure_tag::State>,
    {
        self.state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state][crate::model::FirewallPolicyRuleSecureTag::state].
    pub fn set_or_clear_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::firewall_policy_rule_secure_tag::State>,
    {
        self.state = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for FirewallPolicyRuleSecureTag {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.FirewallPolicyRuleSecureTag"
    }
}

/// Defines additional types related to [FirewallPolicyRuleSecureTag].
#[cfg(feature = "instances")]
pub mod firewall_policy_rule_secure_tag {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [state][google.cloud.compute.v1.FirewallPolicyRuleSecureTag.state] field.
    ///
    /// [google.cloud.compute.v1.FirewallPolicyRuleSecureTag.state]: crate::model::firewall_policy_rule_secure_tag::State
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        Effective,
        Ineffective,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Effective => std::option::Option::Some(0),
                Self::Ineffective => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Effective => std::option::Option::Some("EFFECTIVE"),
                Self::Ineffective => std::option::Option::Some("INEFFECTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Effective,
                1 => Self::Ineffective,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EFFECTIVE" => Self::Effective,
                "INEFFECTIVE" => Self::Ineffective,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Effective => serializer.serialize_str("EFFECTIVE"),
                Self::Ineffective => serializer.serialize_str("INEFFECTIVE"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.compute.v1.FirewallPolicyRuleSecureTag.state",
            ))
        }
    }
}

#[cfg(feature = "images")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GlobalSetLabelsRequest {
    /// The fingerprint of the previous set of labels for this resource, used to detect conflicts. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash when updating or changing labels, otherwise the request will fail with error 412 conditionNotMet. Make a get() request to the resource to get the latest fingerprint.
    pub label_fingerprint: std::option::Option<::bytes::Bytes>,

    /// A list of labels to apply for this resource. Each label must comply with the requirements for labels. For example, "webserver-frontend": "images". A label value can also be empty (e.g. "my-label": "").
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "images")]
impl GlobalSetLabelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [label_fingerprint][crate::model::GlobalSetLabelsRequest::label_fingerprint].
    pub fn set_label_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.label_fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [label_fingerprint][crate::model::GlobalSetLabelsRequest::label_fingerprint].
    pub fn set_or_clear_label_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.label_fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::GlobalSetLabelsRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "images")]
impl wkt::message::Message for GlobalSetLabelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.GlobalSetLabelsRequest"
    }
}

#[cfg(feature = "images")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GlobalSetPolicyRequest {
    /// Flatten Policy to create a backward compatible wire-format. Deprecated. Use 'policy' to specify bindings.
    pub bindings: std::vec::Vec<crate::model::Binding>,

    /// Flatten Policy to create a backward compatible wire-format. Deprecated. Use 'policy' to specify the etag.
    pub etag: std::option::Option<::bytes::Bytes>,

    /// REQUIRED: The complete policy to be applied to the 'resource'. The size of the policy is limited to a few 10s of KB. An empty policy is in general a valid policy but certain services (like Projects) might reject them.
    pub policy: std::option::Option<crate::model::Policy>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "images")]
impl GlobalSetPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bindings][crate::model::GlobalSetPolicyRequest::bindings].
    pub fn set_bindings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Binding>,
    {
        use std::iter::Iterator;
        self.bindings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [etag][crate::model::GlobalSetPolicyRequest::etag].
    pub fn set_etag<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.etag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [etag][crate::model::GlobalSetPolicyRequest::etag].
    pub fn set_or_clear_etag<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.etag = v.map(|x| x.into());
        self
    }

    /// Sets the value of [policy][crate::model::GlobalSetPolicyRequest::policy].
    pub fn set_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Policy>,
    {
        self.policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy][crate::model::GlobalSetPolicyRequest::policy].
    pub fn set_or_clear_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Policy>,
    {
        self.policy = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "images")]
impl wkt::message::Message for GlobalSetPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.GlobalSetPolicyRequest"
    }
}

/// A guest attributes entry.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GuestAttributes {
    /// [Output Only] Type of the resource. Always compute#guestAttributes for guest attributes entry.
    pub kind: std::option::Option<std::string::String>,

    /// The path to be queried. This can be the default namespace ('') or a nested namespace ('\/') or a specified key ('\/\').
    pub query_path: std::option::Option<std::string::String>,

    /// [Output Only] The value of the requested queried path.
    pub query_value: std::option::Option<crate::model::GuestAttributesValue>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// The key to search for.
    pub variable_key: std::option::Option<std::string::String>,

    /// [Output Only] The value found for the requested key.
    pub variable_value: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl GuestAttributes {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::GuestAttributes::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::GuestAttributes::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query_path][crate::model::GuestAttributes::query_path].
    pub fn set_query_path<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.query_path = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_path][crate::model::GuestAttributes::query_path].
    pub fn set_or_clear_query_path<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.query_path = v.map(|x| x.into());
        self
    }

    /// Sets the value of [query_value][crate::model::GuestAttributes::query_value].
    pub fn set_query_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GuestAttributesValue>,
    {
        self.query_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [query_value][crate::model::GuestAttributes::query_value].
    pub fn set_or_clear_query_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GuestAttributesValue>,
    {
        self.query_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::GuestAttributes::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::GuestAttributes::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [variable_key][crate::model::GuestAttributes::variable_key].
    pub fn set_variable_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.variable_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [variable_key][crate::model::GuestAttributes::variable_key].
    pub fn set_or_clear_variable_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.variable_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [variable_value][crate::model::GuestAttributes::variable_value].
    pub fn set_variable_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.variable_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [variable_value][crate::model::GuestAttributes::variable_value].
    pub fn set_or_clear_variable_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.variable_value = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for GuestAttributes {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.GuestAttributes"
    }
}

/// A guest attributes namespace/key/value entry.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GuestAttributesEntry {
    /// Key for the guest attribute entry.
    pub key: std::option::Option<std::string::String>,

    /// Namespace for the guest attribute entry.
    pub namespace: std::option::Option<std::string::String>,

    /// Value for the guest attribute entry.
    pub value: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl GuestAttributesEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::GuestAttributesEntry::key].
    pub fn set_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key][crate::model::GuestAttributesEntry::key].
    pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [namespace][crate::model::GuestAttributesEntry::namespace].
    pub fn set_namespace<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.namespace = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [namespace][crate::model::GuestAttributesEntry::namespace].
    pub fn set_or_clear_namespace<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.namespace = v.map(|x| x.into());
        self
    }

    /// Sets the value of [value][crate::model::GuestAttributesEntry::value].
    pub fn set_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [value][crate::model::GuestAttributesEntry::value].
    pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.value = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for GuestAttributesEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.GuestAttributesEntry"
    }
}

/// Array of guest attribute namespace/key/value tuples.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GuestAttributesValue {
    pub items: std::vec::Vec<crate::model::GuestAttributesEntry>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl GuestAttributesValue {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [items][crate::model::GuestAttributesValue::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GuestAttributesEntry>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for GuestAttributesValue {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.GuestAttributesValue"
    }
}

/// Guest OS features.
#[cfg(any(feature = "images", feature = "instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GuestOsFeature {
    /// The ID of a supported feature. To add multiple values, use commas to separate values. Set to one or more of the following values: - VIRTIO_SCSI_MULTIQUEUE - WINDOWS - MULTI_IP_SUBNET - UEFI_COMPATIBLE - GVNIC - SEV_CAPABLE - SUSPEND_RESUME_COMPATIBLE - SEV_LIVE_MIGRATABLE_V2 - SEV_SNP_CAPABLE - TDX_CAPABLE - IDPF - SNP_SVSM_CAPABLE For more information, see Enabling guest operating system features.
    pub r#type: std::option::Option<crate::model::guest_os_feature::Type>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances",))]
impl GuestOsFeature {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::GuestOsFeature::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::guest_os_feature::Type>,
    {
        self.r#type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#type][crate::model::GuestOsFeature::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::guest_os_feature::Type>,
    {
        self.r#type = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
impl wkt::message::Message for GuestOsFeature {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.GuestOsFeature"
    }
}

/// Defines additional types related to [GuestOsFeature].
#[cfg(any(feature = "images", feature = "instances",))]
pub mod guest_os_feature {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [type][google.cloud.compute.v1.GuestOsFeature.type] field.
    ///
    /// [google.cloud.compute.v1.GuestOsFeature.type]: crate::model::guest_os_feature::Type
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "images", feature = "instances",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        BareMetalLinuxCompatible,
        FeatureTypeUnspecified,
        Gvnic,
        Idpf,
        MultiIpSubnet,
        SecureBoot,
        SevCapable,
        SevLiveMigratable,
        SevLiveMigratableV2,
        SevSnpCapable,
        SnpSvsmCapable,
        TdxCapable,
        UefiCompatible,
        VirtioScsiMultiqueue,
        Windows,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "images", feature = "instances",))]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::BareMetalLinuxCompatible => std::option::Option::Some(0),
                Self::FeatureTypeUnspecified => std::option::Option::Some(1),
                Self::Gvnic => std::option::Option::Some(2),
                Self::Idpf => std::option::Option::Some(3),
                Self::MultiIpSubnet => std::option::Option::Some(4),
                Self::SecureBoot => std::option::Option::Some(5),
                Self::SevCapable => std::option::Option::Some(6),
                Self::SevLiveMigratable => std::option::Option::Some(7),
                Self::SevLiveMigratableV2 => std::option::Option::Some(8),
                Self::SevSnpCapable => std::option::Option::Some(9),
                Self::SnpSvsmCapable => std::option::Option::Some(10),
                Self::TdxCapable => std::option::Option::Some(11),
                Self::UefiCompatible => std::option::Option::Some(12),
                Self::VirtioScsiMultiqueue => std::option::Option::Some(13),
                Self::Windows => std::option::Option::Some(14),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::BareMetalLinuxCompatible => {
                    std::option::Option::Some("BARE_METAL_LINUX_COMPATIBLE")
                }
                Self::FeatureTypeUnspecified => {
                    std::option::Option::Some("FEATURE_TYPE_UNSPECIFIED")
                }
                Self::Gvnic => std::option::Option::Some("GVNIC"),
                Self::Idpf => std::option::Option::Some("IDPF"),
                Self::MultiIpSubnet => std::option::Option::Some("MULTI_IP_SUBNET"),
                Self::SecureBoot => std::option::Option::Some("SECURE_BOOT"),
                Self::SevCapable => std::option::Option::Some("SEV_CAPABLE"),
                Self::SevLiveMigratable => std::option::Option::Some("SEV_LIVE_MIGRATABLE"),
                Self::SevLiveMigratableV2 => std::option::Option::Some("SEV_LIVE_MIGRATABLE_V2"),
                Self::SevSnpCapable => std::option::Option::Some("SEV_SNP_CAPABLE"),
                Self::SnpSvsmCapable => std::option::Option::Some("SNP_SVSM_CAPABLE"),
                Self::TdxCapable => std::option::Option::Some("TDX_CAPABLE"),
                Self::UefiCompatible => std::option::Option::Some("UEFI_COMPATIBLE"),
                Self::VirtioScsiMultiqueue => std::option::Option::Some("VIRTIO_SCSI_MULTIQUEUE"),
                Self::Windows => std::option::Option::Some("WINDOWS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::BareMetalLinuxCompatible,
                1 => Self::FeatureTypeUnspecified,
                2 => Self::Gvnic,
                3 => Self::Idpf,
                4 => Self::MultiIpSubnet,
                5 => Self::SecureBoot,
                6 => Self::SevCapable,
                7 => Self::SevLiveMigratable,
                8 => Self::SevLiveMigratableV2,
                9 => Self::SevSnpCapable,
                10 => Self::SnpSvsmCapable,
                11 => Self::TdxCapable,
                12 => Self::UefiCompatible,
                13 => Self::VirtioScsiMultiqueue,
                14 => Self::Windows,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BARE_METAL_LINUX_COMPATIBLE" => Self::BareMetalLinuxCompatible,
                "FEATURE_TYPE_UNSPECIFIED" => Self::FeatureTypeUnspecified,
                "GVNIC" => Self::Gvnic,
                "IDPF" => Self::Idpf,
                "MULTI_IP_SUBNET" => Self::MultiIpSubnet,
                "SECURE_BOOT" => Self::SecureBoot,
                "SEV_CAPABLE" => Self::SevCapable,
                "SEV_LIVE_MIGRATABLE" => Self::SevLiveMigratable,
                "SEV_LIVE_MIGRATABLE_V2" => Self::SevLiveMigratableV2,
                "SEV_SNP_CAPABLE" => Self::SevSnpCapable,
                "SNP_SVSM_CAPABLE" => Self::SnpSvsmCapable,
                "TDX_CAPABLE" => Self::TdxCapable,
                "UEFI_COMPATIBLE" => Self::UefiCompatible,
                "VIRTIO_SCSI_MULTIQUEUE" => Self::VirtioScsiMultiqueue,
                "WINDOWS" => Self::Windows,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::BareMetalLinuxCompatible => {
                    serializer.serialize_str("BARE_METAL_LINUX_COMPATIBLE")
                }
                Self::FeatureTypeUnspecified => {
                    serializer.serialize_str("FEATURE_TYPE_UNSPECIFIED")
                }
                Self::Gvnic => serializer.serialize_str("GVNIC"),
                Self::Idpf => serializer.serialize_str("IDPF"),
                Self::MultiIpSubnet => serializer.serialize_str("MULTI_IP_SUBNET"),
                Self::SecureBoot => serializer.serialize_str("SECURE_BOOT"),
                Self::SevCapable => serializer.serialize_str("SEV_CAPABLE"),
                Self::SevLiveMigratable => serializer.serialize_str("SEV_LIVE_MIGRATABLE"),
                Self::SevLiveMigratableV2 => serializer.serialize_str("SEV_LIVE_MIGRATABLE_V2"),
                Self::SevSnpCapable => serializer.serialize_str("SEV_SNP_CAPABLE"),
                Self::SnpSvsmCapable => serializer.serialize_str("SNP_SVSM_CAPABLE"),
                Self::TdxCapable => serializer.serialize_str("TDX_CAPABLE"),
                Self::UefiCompatible => serializer.serialize_str("UEFI_COMPATIBLE"),
                Self::VirtioScsiMultiqueue => serializer.serialize_str("VIRTIO_SCSI_MULTIQUEUE"),
                Self::Windows => serializer.serialize_str("WINDOWS"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances",))]
    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.compute.v1.GuestOsFeature.type",
            ))
        }
    }
}

/// Provides links to documentation or for performing an out of band action. For example, if a quota check failed with an error indicating the calling project hasn't enabled the accessed service, this can contain a URL pointing directly to the right place in the developer console to flip the bit.
#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Help {
    /// URL(s) pointing to additional information on handling the current error.
    pub links: std::vec::Vec<crate::model::HelpLink>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl Help {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [links][crate::model::Help::links].
    pub fn set_links<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::HelpLink>,
    {
        use std::iter::Iterator;
        self.links = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl wkt::message::Message for Help {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Help"
    }
}

/// Describes a URL link.
#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct HelpLink {
    /// Describes what the link offers.
    pub description: std::option::Option<std::string::String>,

    /// The URL of the link.
    pub url: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl HelpLink {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::HelpLink::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::HelpLink::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [url][crate::model::HelpLink::url].
    pub fn set_url<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.url = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [url][crate::model::HelpLink::url].
    pub fn set_or_clear_url<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.url = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl wkt::message::Message for HelpLink {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.HelpLink"
    }
}

/// Represents an Image resource. You can use images to create boot disks for your VM instances. For more information, read Images.
#[cfg(feature = "images")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Image {
    /// The architecture of the image. Valid values are ARM64 or X86_64.
    pub architecture: std::option::Option<crate::model::image::Architecture>,

    /// Size of the image tar.gz archive stored in Google Cloud Storage (in bytes).
    pub archive_size_bytes: std::option::Option<i64>,

    /// [Output Only] Creation timestamp in RFC3339 text format.
    pub creation_timestamp: std::option::Option<std::string::String>,

    /// The deprecation status associated with this image.
    pub deprecated: std::option::Option<crate::model::DeprecationStatus>,

    /// An optional description of this resource. Provide this property when you create the resource.
    pub description: std::option::Option<std::string::String>,

    /// Size of the image when restored onto a persistent disk (in GB).
    pub disk_size_gb: std::option::Option<i64>,

    /// Whether this image is created from a confidential compute mode disk. [Output Only]: This field is not set by user, but from source disk.
    pub enable_confidential_compute: std::option::Option<bool>,

    /// The name of the image family to which this image belongs. The image family name can be from a publicly managed image family provided by Compute Engine, or from a custom image family you create. For example, centos-stream-9 is a publicly available image family. For more information, see Image family best practices. When creating disks, you can specify an image family instead of a specific image name. The image family always returns its latest image that is not deprecated. The name of the image family must comply with RFC1035.
    pub family: std::option::Option<std::string::String>,

    /// A list of features to enable on the guest operating system. Applicable only for bootable images. To see a list of available options, see the guestOSfeatures[].type parameter.
    pub guest_os_features: std::vec::Vec<crate::model::GuestOsFeature>,

    /// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
    pub id: std::option::Option<u64>,

    /// Encrypts the image using a customer-supplied encryption key. After you encrypt an image with a customer-supplied key, you must provide the same key if you use the image later (e.g. to create a disk from the image). Customer-supplied encryption keys do not protect access to metadata of the disk. If you do not provide an encryption key when creating the image, then the disk will be encrypted using an automatically generated key and you do not need to provide a key to use the image later.
    pub image_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// [Output Only] Type of the resource. Always compute#image for images.
    pub kind: std::option::Option<std::string::String>,

    /// A fingerprint for the labels being applied to this image, which is essentially a hash of the labels used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash in order to update or change labels, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve an image.
    pub label_fingerprint: std::option::Option<::bytes::Bytes>,

    /// Labels to apply to this image. These can be later modified by the setLabels method.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Integer license codes indicating which licenses are attached to this image.
    pub license_codes: std::vec::Vec<i64>,

    /// Any applicable license URI.
    pub licenses: std::vec::Vec<std::string::String>,

    /// Name of the resource; provided by the client when the resource is created. The name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
    pub name: std::option::Option<std::string::String>,

    /// The parameters of the raw disk image.
    pub raw_disk: std::option::Option<crate::model::image::RawDisk>,

    /// Output only. Reserved for future use.
    pub satisfies_pzi: std::option::Option<bool>,

    /// [Output Only] Reserved for future use.
    pub satisfies_pzs: std::option::Option<bool>,

    /// [Output Only] Server-defined URL for the resource.
    pub self_link: std::option::Option<std::string::String>,

    /// Set the secure boot keys of shielded instance.
    pub shielded_instance_initial_state: std::option::Option<crate::model::InitialStateConfig>,

    /// URL of the source disk used to create this image. For example, the following are valid values: - <https://www.googleapis.com/compute/v1/projects/project/zones/zone> /disks/disk - projects/project/zones/zone/disks/disk - zones/zone/disks/disk In order to create an image, you must provide the full or partial URL of one of the following: - The rawDisk.source URL - The sourceDisk URL - The sourceImage URL - The sourceSnapshot URL
    pub source_disk: std::option::Option<std::string::String>,

    /// The customer-supplied encryption key of the source disk. Required if the source disk is protected by a customer-supplied encryption key.
    pub source_disk_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// [Output Only] The ID value of the disk used to create this image. This value may be used to determine whether the image was taken from the current or a previous instance of a given disk name.
    pub source_disk_id: std::option::Option<std::string::String>,

    /// URL of the source image used to create this image. The following are valid formats for the URL: - <https://www.googleapis.com/compute/v1/projects/project_id/global/> images/image_name - projects/project_id/global/images/image_name In order to create an image, you must provide the full or partial URL of one of the following: - The rawDisk.source URL - The sourceDisk URL - The sourceImage URL - The sourceSnapshot URL
    pub source_image: std::option::Option<std::string::String>,

    /// The customer-supplied encryption key of the source image. Required if the source image is protected by a customer-supplied encryption key.
    pub source_image_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// [Output Only] The ID value of the image used to create this image. This value may be used to determine whether the image was taken from the current or a previous instance of a given image name.
    pub source_image_id: std::option::Option<std::string::String>,

    /// URL of the source snapshot used to create this image. The following are valid formats for the URL: - <https://www.googleapis.com/compute/v1/projects/project_id/global/> snapshots/snapshot_name - projects/project_id/global/snapshots/snapshot_name In order to create an image, you must provide the full or partial URL of one of the following: - The rawDisk.source URL - The sourceDisk URL - The sourceImage URL - The sourceSnapshot URL
    pub source_snapshot: std::option::Option<std::string::String>,

    /// The customer-supplied encryption key of the source snapshot. Required if the source snapshot is protected by a customer-supplied encryption key.
    pub source_snapshot_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// [Output Only] The ID value of the snapshot used to create this image. This value may be used to determine whether the snapshot was taken from the current or a previous instance of a given snapshot name.
    pub source_snapshot_id: std::option::Option<std::string::String>,

    /// The type of the image used to create this disk. The default and only valid value is RAW.
    pub source_type: std::option::Option<crate::model::image::SourceType>,

    /// [Output Only] The status of the image. An image can be used to create other resources, such as instances, only after the image has been successfully created and the status is set to READY. Possible values are FAILED, PENDING, or READY.
    pub status: std::option::Option<crate::model::image::Status>,

    /// Cloud Storage bucket storage location of the image (regional or multi-regional).
    pub storage_locations: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "images")]
impl Image {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [architecture][crate::model::Image::architecture].
    pub fn set_architecture<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::image::Architecture>,
    {
        self.architecture = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [architecture][crate::model::Image::architecture].
    pub fn set_or_clear_architecture<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::image::Architecture>,
    {
        self.architecture = v.map(|x| x.into());
        self
    }

    /// Sets the value of [archive_size_bytes][crate::model::Image::archive_size_bytes].
    pub fn set_archive_size_bytes<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.archive_size_bytes = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [archive_size_bytes][crate::model::Image::archive_size_bytes].
    pub fn set_or_clear_archive_size_bytes<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.archive_size_bytes = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creation_timestamp][crate::model::Image::creation_timestamp].
    pub fn set_creation_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_timestamp][crate::model::Image::creation_timestamp].
    pub fn set_or_clear_creation_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deprecated][crate::model::Image::deprecated].
    pub fn set_deprecated<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeprecationStatus>,
    {
        self.deprecated = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deprecated][crate::model::Image::deprecated].
    pub fn set_or_clear_deprecated<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeprecationStatus>,
    {
        self.deprecated = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::Image::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::Image::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_size_gb][crate::model::Image::disk_size_gb].
    pub fn set_disk_size_gb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.disk_size_gb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_size_gb][crate::model::Image::disk_size_gb].
    pub fn set_or_clear_disk_size_gb<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.disk_size_gb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_confidential_compute][crate::model::Image::enable_confidential_compute].
    pub fn set_enable_confidential_compute<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_confidential_compute = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_confidential_compute][crate::model::Image::enable_confidential_compute].
    pub fn set_or_clear_enable_confidential_compute<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_confidential_compute = v.map(|x| x.into());
        self
    }

    /// Sets the value of [family][crate::model::Image::family].
    pub fn set_family<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.family = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [family][crate::model::Image::family].
    pub fn set_or_clear_family<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.family = v.map(|x| x.into());
        self
    }

    /// Sets the value of [guest_os_features][crate::model::Image::guest_os_features].
    pub fn set_guest_os_features<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GuestOsFeature>,
    {
        use std::iter::Iterator;
        self.guest_os_features = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [id][crate::model::Image::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::Image::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [image_encryption_key][crate::model::Image::image_encryption_key].
    pub fn set_image_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.image_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [image_encryption_key][crate::model::Image::image_encryption_key].
    pub fn set_or_clear_image_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.image_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::Image::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::Image::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [label_fingerprint][crate::model::Image::label_fingerprint].
    pub fn set_label_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.label_fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [label_fingerprint][crate::model::Image::label_fingerprint].
    pub fn set_or_clear_label_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.label_fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Image::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [license_codes][crate::model::Image::license_codes].
    pub fn set_license_codes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<i64>,
    {
        use std::iter::Iterator;
        self.license_codes = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [licenses][crate::model::Image::licenses].
    pub fn set_licenses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.licenses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [name][crate::model::Image::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::Image::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [raw_disk][crate::model::Image::raw_disk].
    pub fn set_raw_disk<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::image::RawDisk>,
    {
        self.raw_disk = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [raw_disk][crate::model::Image::raw_disk].
    pub fn set_or_clear_raw_disk<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::image::RawDisk>,
    {
        self.raw_disk = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Image::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::Image::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Image::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::Image::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::Image::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::Image::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [shielded_instance_initial_state][crate::model::Image::shielded_instance_initial_state].
    pub fn set_shielded_instance_initial_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InitialStateConfig>,
    {
        self.shielded_instance_initial_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shielded_instance_initial_state][crate::model::Image::shielded_instance_initial_state].
    pub fn set_or_clear_shielded_instance_initial_state<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::InitialStateConfig>,
    {
        self.shielded_instance_initial_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_disk][crate::model::Image::source_disk].
    pub fn set_source_disk<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_disk = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_disk][crate::model::Image::source_disk].
    pub fn set_or_clear_source_disk<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_disk = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_disk_encryption_key][crate::model::Image::source_disk_encryption_key].
    pub fn set_source_disk_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_disk_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_disk_encryption_key][crate::model::Image::source_disk_encryption_key].
    pub fn set_or_clear_source_disk_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_disk_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_disk_id][crate::model::Image::source_disk_id].
    pub fn set_source_disk_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_disk_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_disk_id][crate::model::Image::source_disk_id].
    pub fn set_or_clear_source_disk_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_disk_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_image][crate::model::Image::source_image].
    pub fn set_source_image<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_image = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_image][crate::model::Image::source_image].
    pub fn set_or_clear_source_image<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_image = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_image_encryption_key][crate::model::Image::source_image_encryption_key].
    pub fn set_source_image_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_image_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_image_encryption_key][crate::model::Image::source_image_encryption_key].
    pub fn set_or_clear_source_image_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_image_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_image_id][crate::model::Image::source_image_id].
    pub fn set_source_image_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_image_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_image_id][crate::model::Image::source_image_id].
    pub fn set_or_clear_source_image_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_image_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_snapshot][crate::model::Image::source_snapshot].
    pub fn set_source_snapshot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_snapshot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_snapshot][crate::model::Image::source_snapshot].
    pub fn set_or_clear_source_snapshot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_snapshot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_snapshot_encryption_key][crate::model::Image::source_snapshot_encryption_key].
    pub fn set_source_snapshot_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_snapshot_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_snapshot_encryption_key][crate::model::Image::source_snapshot_encryption_key].
    pub fn set_or_clear_source_snapshot_encryption_key<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_snapshot_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_snapshot_id][crate::model::Image::source_snapshot_id].
    pub fn set_source_snapshot_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_snapshot_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_snapshot_id][crate::model::Image::source_snapshot_id].
    pub fn set_or_clear_source_snapshot_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_snapshot_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_type][crate::model::Image::source_type].
    pub fn set_source_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::image::SourceType>,
    {
        self.source_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_type][crate::model::Image::source_type].
    pub fn set_or_clear_source_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::image::SourceType>,
    {
        self.source_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::Image::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::image::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::Image::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::image::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [storage_locations][crate::model::Image::storage_locations].
    pub fn set_storage_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.storage_locations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "images")]
impl wkt::message::Message for Image {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Image"
    }
}

/// Defines additional types related to [Image].
#[cfg(feature = "images")]
pub mod image {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [rawDisk][google.cloud.compute.v1.Image.rawDisk] field.
    ///
    /// [google.cloud.compute.v1.Image.rawDisk]: crate::model::image::RawDisk
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RawDisk {
        /// The format used to encode and transmit the block device, which should be TAR. This is just a container and transmission format and not a runtime format. Provided by the client when the disk image is created.
        pub container_type: std::option::Option<crate::model::image::raw_disk::ContainerType>,

        /// [Deprecated] This field is deprecated. An optional SHA1 checksum of the disk image before unpackaging provided by the client when the disk image is created.
        #[deprecated]
        pub sha_1_checksum: std::option::Option<std::string::String>,

        /// The full Google Cloud Storage URL where the raw disk image archive is stored. The following are valid formats for the URL: - <https://storage.googleapis.com/bucket_name/image_archive_name> - <https://storage.googleapis.com/bucket_name/folder_name/> image_archive_name In order to create an image, you must provide the full or partial URL of one of the following: - The rawDisk.source URL - The sourceDisk URL - The sourceImage URL - The sourceSnapshot URL
        pub source: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl RawDisk {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [container_type][crate::model::image::RawDisk::container_type].
        pub fn set_container_type<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::image::raw_disk::ContainerType>,
        {
            self.container_type = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [container_type][crate::model::image::RawDisk::container_type].
        pub fn set_or_clear_container_type<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::image::raw_disk::ContainerType>,
        {
            self.container_type = v.map(|x| x.into());
            self
        }

        /// Sets the value of [sha_1_checksum][crate::model::image::RawDisk::sha_1_checksum].
        #[deprecated]
        pub fn set_sha_1_checksum<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.sha_1_checksum = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [sha_1_checksum][crate::model::image::RawDisk::sha_1_checksum].
        #[deprecated]
        pub fn set_or_clear_sha_1_checksum<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.sha_1_checksum = v.map(|x| x.into());
            self
        }

        /// Sets the value of [source][crate::model::image::RawDisk::source].
        pub fn set_source<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.source = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [source][crate::model::image::RawDisk::source].
        pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.source = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "images")]
    impl wkt::message::Message for RawDisk {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.Image.rawDisk"
        }
    }

    /// Defines additional types related to [RawDisk].
    #[cfg(feature = "images")]
    pub mod raw_disk {
        #[allow(unused_imports)]
        use super::*;

        /// The enumerated type for the [containerType][google.cloud.compute.v1.Image.rawDisk.containerType] field.
        ///
        /// [google.cloud.compute.v1.Image.rawDisk.containerType]: crate::model::image::raw_disk::ContainerType
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "images")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum ContainerType {
            Tar,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [ContainerType::value] or
            /// [ContainerType::name].
            UnknownValue(container_type::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "images")]
        pub mod container_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "images")]
        impl ContainerType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Tar => std::option::Option::Some(0),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Tar => std::option::Option::Some("TAR"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "images")]
        impl std::default::Default for ContainerType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "images")]
        impl std::fmt::Display for ContainerType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "images")]
        impl std::convert::From<i32> for ContainerType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Tar,
                    _ => Self::UnknownValue(container_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "images")]
        impl std::convert::From<&str> for ContainerType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TAR" => Self::Tar,
                    _ => Self::UnknownValue(container_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "images")]
        impl serde::ser::Serialize for ContainerType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Tar => serializer.serialize_str("TAR"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "images")]
        impl<'de> serde::de::Deserialize<'de> for ContainerType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<ContainerType>::new(
                    ".google.cloud.compute.v1.Image.rawDisk.containerType",
                ))
            }
        }
    }

    /// The enumerated type for the [architecture][google.cloud.compute.v1.Image.architecture] field.
    ///
    /// [google.cloud.compute.v1.Image.architecture]: crate::model::image::Architecture
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "images")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Architecture {
        /// Default value indicating Architecture is not set.
        Unspecified,
        /// Machines with architecture ARM64
        Arm64,
        /// Machines with architecture X86_64
        X8664,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Architecture::value] or
        /// [Architecture::name].
        UnknownValue(architecture::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "images")]
    pub mod architecture {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "images")]
    impl Architecture {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Arm64 => std::option::Option::Some(1),
                Self::X8664 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ARCHITECTURE_UNSPECIFIED"),
                Self::Arm64 => std::option::Option::Some("ARM64"),
                Self::X8664 => std::option::Option::Some("X86_64"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "images")]
    impl std::default::Default for Architecture {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "images")]
    impl std::fmt::Display for Architecture {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "images")]
    impl std::convert::From<i32> for Architecture {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Arm64,
                2 => Self::X8664,
                _ => Self::UnknownValue(architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "images")]
    impl std::convert::From<&str> for Architecture {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
                "ARM64" => Self::Arm64,
                "X86_64" => Self::X8664,
                _ => Self::UnknownValue(architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "images")]
    impl serde::ser::Serialize for Architecture {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_str("ARCHITECTURE_UNSPECIFIED"),
                Self::Arm64 => serializer.serialize_str("ARM64"),
                Self::X8664 => serializer.serialize_str("X86_64"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "images")]
    impl<'de> serde::de::Deserialize<'de> for Architecture {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Architecture>::new(
                ".google.cloud.compute.v1.Image.architecture",
            ))
        }
    }

    /// The enumerated type for the [sourceType][google.cloud.compute.v1.Image.sourceType] field.
    ///
    /// [google.cloud.compute.v1.Image.sourceType]: crate::model::image::SourceType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "images")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceType {
        Raw,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SourceType::value] or
        /// [SourceType::name].
        UnknownValue(source_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "images")]
    pub mod source_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "images")]
    impl SourceType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Raw => std::option::Option::Some(0),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Raw => std::option::Option::Some("RAW"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "images")]
    impl std::default::Default for SourceType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "images")]
    impl std::fmt::Display for SourceType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "images")]
    impl std::convert::From<i32> for SourceType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Raw,
                _ => Self::UnknownValue(source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "images")]
    impl std::convert::From<&str> for SourceType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RAW" => Self::Raw,
                _ => Self::UnknownValue(source_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "images")]
    impl serde::ser::Serialize for SourceType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Raw => serializer.serialize_str("RAW"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "images")]
    impl<'de> serde::de::Deserialize<'de> for SourceType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SourceType>::new(
                ".google.cloud.compute.v1.Image.sourceType",
            ))
        }
    }

    /// The enumerated type for the [status][google.cloud.compute.v1.Image.status] field.
    ///
    /// [google.cloud.compute.v1.Image.status]: crate::model::image::Status
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "images")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Image is deleting.
        Deleting,
        /// Image creation failed due to an error.
        Failed,
        /// Image hasn't been created as yet.
        Pending,
        /// Image has been successfully created.
        Ready,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "images")]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "images")]
    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Deleting => std::option::Option::Some(0),
                Self::Failed => std::option::Option::Some(1),
                Self::Pending => std::option::Option::Some(2),
                Self::Ready => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "images")]
    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "images")]
    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "images")]
    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Deleting,
                1 => Self::Failed,
                2 => Self::Pending,
                3 => Self::Ready,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "images")]
    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DELETING" => Self::Deleting,
                "FAILED" => Self::Failed,
                "PENDING" => Self::Pending,
                "READY" => Self::Ready,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "images")]
    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Deleting => serializer.serialize_str("DELETING"),
                Self::Failed => serializer.serialize_str("FAILED"),
                Self::Pending => serializer.serialize_str("PENDING"),
                Self::Ready => serializer.serialize_str("READY"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "images")]
    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.cloud.compute.v1.Image.status",
            ))
        }
    }
}

/// Contains a list of images.
#[cfg(feature = "images")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImageList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of Image resources.
    pub items: std::vec::Vec<crate::model::Image>,

    /// Type of resource.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::image_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "images")]
impl ImageList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::ImageList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::ImageList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::ImageList::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Image>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::ImageList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::ImageList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::ImageList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::ImageList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::ImageList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::ImageList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::ImageList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::image_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::ImageList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::image_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "images")]
impl wkt::message::Message for ImageList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ImageList"
    }
}

#[cfg(feature = "images")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ImageList {
    type PageItem = crate::model::Image;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [ImageList].
#[cfg(feature = "images")]
pub mod image_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.ImageList.warning] field.
    ///
    /// [google.cloud.compute.v1.ImageList.warning]: crate::model::image_list::Warning
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
        pub code: std::option::Option<crate::model::image_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" }
        pub data: std::vec::Vec<crate::model::image_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::image_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::image_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::image_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::image_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::image_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::image_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::image_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::image_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "images")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.ImageList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "images")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.ImageList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.ImageList.warning.data]: crate::model::image_list::warning::Data
        #[cfg(feature = "images")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "images")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::image_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::image_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::image_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::image_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "images")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.ImageList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.ImageList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.ImageList.warning.code]: crate::model::image_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "images")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden. Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed which captures the amount of resources filtered out by user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g: regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but its application does not make a lot of sense, because it allows only single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "images")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "images")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "images")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "images")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "images")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "images")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "images")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "images")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.ImageList.warning.code",
                ))
            }
        }
    }
}

/// Initial State for shielded instance, these are public keys which are safe to store in public
#[cfg(any(feature = "images", feature = "instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InitialStateConfig {
    /// The Key Database (db).
    pub dbs: std::vec::Vec<crate::model::FileContentBuffer>,

    /// The forbidden key database (dbx).
    pub dbxs: std::vec::Vec<crate::model::FileContentBuffer>,

    /// The Key Exchange Key (KEK).
    pub keks: std::vec::Vec<crate::model::FileContentBuffer>,

    /// The Platform Key (PK).
    pub pk: std::option::Option<crate::model::FileContentBuffer>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances",))]
impl InitialStateConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dbs][crate::model::InitialStateConfig::dbs].
    pub fn set_dbs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileContentBuffer>,
    {
        use std::iter::Iterator;
        self.dbs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [dbxs][crate::model::InitialStateConfig::dbxs].
    pub fn set_dbxs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileContentBuffer>,
    {
        use std::iter::Iterator;
        self.dbxs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [keks][crate::model::InitialStateConfig::keks].
    pub fn set_keks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FileContentBuffer>,
    {
        use std::iter::Iterator;
        self.keks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [pk][crate::model::InitialStateConfig::pk].
    pub fn set_pk<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::FileContentBuffer>,
    {
        self.pk = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [pk][crate::model::InitialStateConfig::pk].
    pub fn set_or_clear_pk<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::FileContentBuffer>,
    {
        self.pk = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
impl wkt::message::Message for InitialStateConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InitialStateConfig"
    }
}

/// Represents an Instance resource. An instance is a virtual machine that is hosted on Google Cloud Platform. For more information, read Virtual Machine Instances.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Instance {
    /// Controls for advanced machine-related behavior features.
    pub advanced_machine_features: std::option::Option<crate::model::AdvancedMachineFeatures>,

    /// Allows this instance to send and receive packets with non-matching destination or source IPs. This is required if you plan to use this instance to forward routes. For more information, see Enabling IP Forwarding .
    pub can_ip_forward: std::option::Option<bool>,

    pub confidential_instance_config: std::option::Option<crate::model::ConfidentialInstanceConfig>,

    /// [Output Only] The CPU platform used by this instance.
    pub cpu_platform: std::option::Option<std::string::String>,

    /// [Output Only] Creation timestamp in RFC3339 text format.
    pub creation_timestamp: std::option::Option<std::string::String>,

    /// Whether the resource should be protected against deletion.
    pub deletion_protection: std::option::Option<bool>,

    /// An optional description of this resource. Provide this property when you create the resource.
    pub description: std::option::Option<std::string::String>,

    /// Array of disks associated with this instance. Persistent disks must be created before you can assign them.
    pub disks: std::vec::Vec<crate::model::AttachedDisk>,

    /// Enables display device for the instance.
    pub display_device: std::option::Option<crate::model::DisplayDevice>,

    /// Specifies a fingerprint for this resource, which is essentially a hash of the instance's contents and used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update the instance. You must always provide an up-to-date fingerprint hash in order to update the instance. To see the latest fingerprint, make get() request to the instance.
    pub fingerprint: std::option::Option<::bytes::Bytes>,

    /// A list of the type and count of accelerator cards attached to the instance.
    pub guest_accelerators: std::vec::Vec<crate::model::AcceleratorConfig>,

    /// Specifies the hostname of the instance. The specified hostname must be RFC1035 compliant. If hostname is not specified, the default hostname is [INSTANCE_NAME].c.[PROJECT_ID].internal when using the global DNS, and [INSTANCE_NAME].[ZONE].c.[PROJECT_ID].internal when using zonal DNS.
    pub hostname: std::option::Option<std::string::String>,

    /// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
    pub id: std::option::Option<u64>,

    /// Encrypts suspended data for an instance with a customer-managed encryption key. If you are creating a new instance, this field will encrypt the local SSD and in-memory contents of the instance during the suspend operation. If you do not provide an encryption key when creating the instance, then the local SSD and in-memory contents will be encrypted using an automatically generated key during the suspend operation.
    pub instance_encryption_key: std::option::Option<crate::model::CustomerEncryptionKey>,

    /// KeyRevocationActionType of the instance. Supported options are "STOP" and "NONE". The default value is "NONE" if it is not specified.
    pub key_revocation_action_type:
        std::option::Option<crate::model::instance::KeyRevocationActionType>,

    /// [Output Only] Type of the resource. Always compute#instance for instances.
    pub kind: std::option::Option<std::string::String>,

    /// A fingerprint for this request, which is essentially a hash of the label's contents and used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update labels. You must always provide an up-to-date fingerprint hash in order to update or change labels. To see the latest fingerprint, make get() request to the instance.
    pub label_fingerprint: std::option::Option<::bytes::Bytes>,

    /// Labels to apply to this instance. These can be later modified by the setLabels method.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// [Output Only] Last start timestamp in RFC3339 text format.
    pub last_start_timestamp: std::option::Option<std::string::String>,

    /// [Output Only] Last stop timestamp in RFC3339 text format.
    pub last_stop_timestamp: std::option::Option<std::string::String>,

    /// [Output Only] Last suspended timestamp in RFC3339 text format.
    pub last_suspended_timestamp: std::option::Option<std::string::String>,

    /// Full or partial URL of the machine type resource to use for this instance, in the format: zones/zone/machineTypes/machine-type. This is provided by the client when the instance is created. For example, the following is a valid partial url to a predefined machine type: zones/us-central1-f/machineTypes/n1-standard-1 To create a custom machine type, provide a URL to a machine type in the following format, where CPUS is 1 or an even number up to 32 (2, 4, 6, ... 24, etc), and MEMORY is the total memory for this instance. Memory must be a multiple of 256 MB and must be supplied in MB (e.g. 5 GB of memory is 5120 MB): zones/zone/machineTypes/custom-CPUS-MEMORY For example: zones/us-central1-f/machineTypes/custom-4-5120 For a full list of restrictions, read the Specifications for custom machine types.
    pub machine_type: std::option::Option<std::string::String>,

    /// The metadata key/value pairs assigned to this instance. This includes metadata keys that were explicitly defined for the instance.
    pub metadata: std::option::Option<crate::model::Metadata>,

    /// Specifies a minimum CPU platform for the VM instance. Applicable values are the friendly names of CPU platforms, such as minCpuPlatform: "Intel Haswell" or minCpuPlatform: "Intel Sandy Bridge".
    pub min_cpu_platform: std::option::Option<std::string::String>,

    /// The name of the resource, provided by the client when initially creating the resource. The resource name must be 1-63 characters long, and comply with RFC1035. Specifically, the name must be 1-63 characters long and match the regular expression `[a-z]([-a-z0-9]*[a-z0-9])?` which means the first character must be a lowercase letter, and all following characters must be a dash, lowercase letter, or digit, except the last character, which cannot be a dash.
    pub name: std::option::Option<std::string::String>,

    /// An array of network configurations for this instance. These specify how interfaces are configured to interact with other network services, such as connecting to the internet. Multiple interfaces are supported per instance.
    pub network_interfaces: std::vec::Vec<crate::model::NetworkInterface>,

    pub network_performance_config: std::option::Option<crate::model::NetworkPerformanceConfig>,

    /// Input only. [Input Only] Additional params passed with the request, but not persisted as part of resource payload.
    pub params: std::option::Option<crate::model::InstanceParams>,

    /// The private IPv6 google access type for the VM. If not specified, use INHERIT_FROM_SUBNETWORK as default.
    pub private_ipv_6_google_access:
        std::option::Option<crate::model::instance::PrivateIpv6GoogleAccess>,

    /// Specifies the reservations that this instance can consume from.
    pub reservation_affinity: std::option::Option<crate::model::ReservationAffinity>,

    /// Resource policies applied to this instance.
    pub resource_policies: std::vec::Vec<std::string::String>,

    /// [Output Only] Specifies values set for instance attributes as compared to the values requested by user in the corresponding input only field.
    pub resource_status: std::option::Option<crate::model::ResourceStatus>,

    /// [Output Only] Reserved for future use.
    pub satisfies_pzi: std::option::Option<bool>,

    /// [Output Only] Reserved for future use.
    pub satisfies_pzs: std::option::Option<bool>,

    /// Sets the scheduling options for this instance.
    pub scheduling: std::option::Option<crate::model::Scheduling>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// A list of service accounts, with their specified scopes, authorized for this instance. Only one service account per VM instance is supported. Service accounts generate access tokens that can be accessed through the metadata server and used to authenticate applications on the instance. See Service Accounts for more information.
    pub service_accounts: std::vec::Vec<crate::model::ServiceAccount>,

    pub shielded_instance_config: std::option::Option<crate::model::ShieldedInstanceConfig>,

    pub shielded_instance_integrity_policy:
        std::option::Option<crate::model::ShieldedInstanceIntegrityPolicy>,

    /// Source machine image
    pub source_machine_image: std::option::Option<std::string::String>,

    /// Source machine image encryption key when creating an instance from a machine image.
    pub source_machine_image_encryption_key:
        std::option::Option<crate::model::CustomerEncryptionKey>,

    /// [Output Only] Whether a VM has been restricted for start because Compute Engine has detected suspicious activity.
    pub start_restricted: std::option::Option<bool>,

    /// [Output Only] The status of the instance. One of the following values: PROVISIONING, STAGING, RUNNING, STOPPING, SUSPENDING, SUSPENDED, REPAIRING, and TERMINATED. For more information about the status of the instance, see Instance life cycle.
    pub status: std::option::Option<crate::model::instance::Status>,

    /// [Output Only] An optional, human-readable explanation of the status.
    pub status_message: std::option::Option<std::string::String>,

    /// Tags to apply to this instance. Tags are used to identify valid sources or targets for network firewalls and are specified by the client during instance creation. The tags can be later modified by the setTags method. Each tag within the list must comply with RFC1035. Multiple tags can be specified via the 'tags.items' field.
    pub tags: std::option::Option<crate::model::Tags>,

    /// [Output Only] URL of the zone where the instance resides. You must specify this field as part of the HTTP request URL. It is not settable as a field in the request body.
    pub zone: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [advanced_machine_features][crate::model::Instance::advanced_machine_features].
    pub fn set_advanced_machine_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedMachineFeatures>,
    {
        self.advanced_machine_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [advanced_machine_features][crate::model::Instance::advanced_machine_features].
    pub fn set_or_clear_advanced_machine_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedMachineFeatures>,
    {
        self.advanced_machine_features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [can_ip_forward][crate::model::Instance::can_ip_forward].
    pub fn set_can_ip_forward<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.can_ip_forward = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [can_ip_forward][crate::model::Instance::can_ip_forward].
    pub fn set_or_clear_can_ip_forward<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.can_ip_forward = v.map(|x| x.into());
        self
    }

    /// Sets the value of [confidential_instance_config][crate::model::Instance::confidential_instance_config].
    pub fn set_confidential_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialInstanceConfig>,
    {
        self.confidential_instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [confidential_instance_config][crate::model::Instance::confidential_instance_config].
    pub fn set_or_clear_confidential_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialInstanceConfig>,
    {
        self.confidential_instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cpu_platform][crate::model::Instance::cpu_platform].
    pub fn set_cpu_platform<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.cpu_platform = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cpu_platform][crate::model::Instance::cpu_platform].
    pub fn set_or_clear_cpu_platform<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.cpu_platform = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creation_timestamp][crate::model::Instance::creation_timestamp].
    pub fn set_creation_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_timestamp][crate::model::Instance::creation_timestamp].
    pub fn set_or_clear_creation_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deletion_protection][crate::model::Instance::deletion_protection].
    pub fn set_deletion_protection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deletion_protection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deletion_protection][crate::model::Instance::deletion_protection].
    pub fn set_or_clear_deletion_protection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deletion_protection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::Instance::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::Instance::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disks][crate::model::Instance::disks].
    pub fn set_disks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedDisk>,
    {
        use std::iter::Iterator;
        self.disks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [display_device][crate::model::Instance::display_device].
    pub fn set_display_device<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DisplayDevice>,
    {
        self.display_device = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [display_device][crate::model::Instance::display_device].
    pub fn set_or_clear_display_device<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DisplayDevice>,
    {
        self.display_device = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fingerprint][crate::model::Instance::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::Instance::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [guest_accelerators][crate::model::Instance::guest_accelerators].
    pub fn set_guest_accelerators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AcceleratorConfig>,
    {
        use std::iter::Iterator;
        self.guest_accelerators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hostname][crate::model::Instance::hostname].
    pub fn set_hostname<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.hostname = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [hostname][crate::model::Instance::hostname].
    pub fn set_or_clear_hostname<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.hostname = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::Instance::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::Instance::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_encryption_key][crate::model::Instance::instance_encryption_key].
    pub fn set_instance_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.instance_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_encryption_key][crate::model::Instance::instance_encryption_key].
    pub fn set_or_clear_instance_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.instance_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [key_revocation_action_type][crate::model::Instance::key_revocation_action_type].
    pub fn set_key_revocation_action_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::KeyRevocationActionType>,
    {
        self.key_revocation_action_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key_revocation_action_type][crate::model::Instance::key_revocation_action_type].
    pub fn set_or_clear_key_revocation_action_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::KeyRevocationActionType>,
    {
        self.key_revocation_action_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::Instance::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::Instance::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [label_fingerprint][crate::model::Instance::label_fingerprint].
    pub fn set_label_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.label_fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [label_fingerprint][crate::model::Instance::label_fingerprint].
    pub fn set_or_clear_label_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.label_fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [last_start_timestamp][crate::model::Instance::last_start_timestamp].
    pub fn set_last_start_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.last_start_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_start_timestamp][crate::model::Instance::last_start_timestamp].
    pub fn set_or_clear_last_start_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.last_start_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_stop_timestamp][crate::model::Instance::last_stop_timestamp].
    pub fn set_last_stop_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.last_stop_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_stop_timestamp][crate::model::Instance::last_stop_timestamp].
    pub fn set_or_clear_last_stop_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.last_stop_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_suspended_timestamp][crate::model::Instance::last_suspended_timestamp].
    pub fn set_last_suspended_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.last_suspended_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_suspended_timestamp][crate::model::Instance::last_suspended_timestamp].
    pub fn set_or_clear_last_suspended_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.last_suspended_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [machine_type][crate::model::Instance::machine_type].
    pub fn set_machine_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.machine_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [machine_type][crate::model::Instance::machine_type].
    pub fn set_or_clear_machine_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.machine_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::Instance::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::Instance::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [min_cpu_platform][crate::model::Instance::min_cpu_platform].
    pub fn set_min_cpu_platform<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.min_cpu_platform = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_cpu_platform][crate::model::Instance::min_cpu_platform].
    pub fn set_or_clear_min_cpu_platform<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.min_cpu_platform = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::Instance::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_interfaces][crate::model::Instance::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [network_performance_config][crate::model::Instance::network_performance_config].
    pub fn set_network_performance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPerformanceConfig>,
    {
        self.network_performance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_performance_config][crate::model::Instance::network_performance_config].
    pub fn set_or_clear_network_performance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPerformanceConfig>,
    {
        self.network_performance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [params][crate::model::Instance::params].
    pub fn set_params<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstanceParams>,
    {
        self.params = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [params][crate::model::Instance::params].
    pub fn set_or_clear_params<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstanceParams>,
    {
        self.params = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_ipv_6_google_access][crate::model::Instance::private_ipv_6_google_access].
    pub fn set_private_ipv_6_google_access<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::PrivateIpv6GoogleAccess>,
    {
        self.private_ipv_6_google_access = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_ipv_6_google_access][crate::model::Instance::private_ipv_6_google_access].
    pub fn set_or_clear_private_ipv_6_google_access<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::PrivateIpv6GoogleAccess>,
    {
        self.private_ipv_6_google_access = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reservation_affinity][crate::model::Instance::reservation_affinity].
    pub fn set_reservation_affinity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReservationAffinity>,
    {
        self.reservation_affinity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reservation_affinity][crate::model::Instance::reservation_affinity].
    pub fn set_or_clear_reservation_affinity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReservationAffinity>,
    {
        self.reservation_affinity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_policies][crate::model::Instance::resource_policies].
    pub fn set_resource_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [resource_status][crate::model::Instance::resource_status].
    pub fn set_resource_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceStatus>,
    {
        self.resource_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [resource_status][crate::model::Instance::resource_status].
    pub fn set_or_clear_resource_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourceStatus>,
    {
        self.resource_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzi][crate::model::Instance::satisfies_pzi].
    pub fn set_satisfies_pzi<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzi][crate::model::Instance::satisfies_pzi].
    pub fn set_or_clear_satisfies_pzi<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzi = v.map(|x| x.into());
        self
    }

    /// Sets the value of [satisfies_pzs][crate::model::Instance::satisfies_pzs].
    pub fn set_satisfies_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [satisfies_pzs][crate::model::Instance::satisfies_pzs].
    pub fn set_or_clear_satisfies_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.satisfies_pzs = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scheduling][crate::model::Instance::scheduling].
    pub fn set_scheduling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Scheduling>,
    {
        self.scheduling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scheduling][crate::model::Instance::scheduling].
    pub fn set_or_clear_scheduling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Scheduling>,
    {
        self.scheduling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::Instance::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::Instance::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_accounts][crate::model::Instance::service_accounts].
    pub fn set_service_accounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ServiceAccount>,
    {
        use std::iter::Iterator;
        self.service_accounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [shielded_instance_config][crate::model::Instance::shielded_instance_config].
    pub fn set_shielded_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
    {
        self.shielded_instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shielded_instance_config][crate::model::Instance::shielded_instance_config].
    pub fn set_or_clear_shielded_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
    {
        self.shielded_instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [shielded_instance_integrity_policy][crate::model::Instance::shielded_instance_integrity_policy].
    pub fn set_shielded_instance_integrity_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceIntegrityPolicy>,
    {
        self.shielded_instance_integrity_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shielded_instance_integrity_policy][crate::model::Instance::shielded_instance_integrity_policy].
    pub fn set_or_clear_shielded_instance_integrity_policy<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceIntegrityPolicy>,
    {
        self.shielded_instance_integrity_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_machine_image][crate::model::Instance::source_machine_image].
    pub fn set_source_machine_image<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_machine_image = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_machine_image][crate::model::Instance::source_machine_image].
    pub fn set_or_clear_source_machine_image<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.source_machine_image = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_machine_image_encryption_key][crate::model::Instance::source_machine_image_encryption_key].
    pub fn set_source_machine_image_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_machine_image_encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source_machine_image_encryption_key][crate::model::Instance::source_machine_image_encryption_key].
    pub fn set_or_clear_source_machine_image_encryption_key<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::CustomerEncryptionKey>,
    {
        self.source_machine_image_encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_restricted][crate::model::Instance::start_restricted].
    pub fn set_start_restricted<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.start_restricted = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_restricted][crate::model::Instance::start_restricted].
    pub fn set_or_clear_start_restricted<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.start_restricted = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::Instance::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::Instance::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status_message][crate::model::Instance::status_message].
    pub fn set_status_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.status_message = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status_message][crate::model::Instance::status_message].
    pub fn set_or_clear_status_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.status_message = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tags][crate::model::Instance::tags].
    pub fn set_tags<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Tags>,
    {
        self.tags = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tags][crate::model::Instance::tags].
    pub fn set_or_clear_tags<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Tags>,
    {
        self.tags = v.map(|x| x.into());
        self
    }

    /// Sets the value of [zone][crate::model::Instance::zone].
    pub fn set_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [zone][crate::model::Instance::zone].
    pub fn set_or_clear_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Instance"
    }
}

/// Defines additional types related to [Instance].
#[cfg(feature = "instances")]
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [keyRevocationActionType][google.cloud.compute.v1.Instance.keyRevocationActionType] field.
    ///
    /// [google.cloud.compute.v1.Instance.keyRevocationActionType]: crate::model::instance::KeyRevocationActionType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum KeyRevocationActionType {
        /// Default value. This value is unused.
        Unspecified,
        /// Indicates user chose no operation.
        None,
        /// Indicates user chose to opt for VM shutdown on key revocation.
        Stop,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [KeyRevocationActionType::value] or
        /// [KeyRevocationActionType::name].
        UnknownValue(key_revocation_action_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod key_revocation_action_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl KeyRevocationActionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Stop => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED")
                }
                Self::None => std::option::Option::Some("NONE"),
                Self::Stop => std::option::Option::Some("STOP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for KeyRevocationActionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for KeyRevocationActionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for KeyRevocationActionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Stop,
                _ => Self::UnknownValue(key_revocation_action_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for KeyRevocationActionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "STOP" => Self::Stop,
                _ => Self::UnknownValue(key_revocation_action_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for KeyRevocationActionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => {
                    serializer.serialize_str("KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED")
                }
                Self::None => serializer.serialize_str("NONE"),
                Self::Stop => serializer.serialize_str("STOP"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for KeyRevocationActionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<KeyRevocationActionType>::new(
                    ".google.cloud.compute.v1.Instance.keyRevocationActionType",
                ),
            )
        }
    }

    /// The enumerated type for the [privateIpv6GoogleAccess][google.cloud.compute.v1.Instance.privateIpv6GoogleAccess] field.
    ///
    /// [google.cloud.compute.v1.Instance.privateIpv6GoogleAccess]: crate::model::instance::PrivateIpv6GoogleAccess
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrivateIpv6GoogleAccess {
        /// Bidirectional private IPv6 access to/from Google services. If specified, the subnetwork who is attached to the instance's default network interface will be assigned an internal IPv6 prefix if it doesn't have before.
        EnableBidirectionalAccessToGoogle,
        /// Outbound private IPv6 access from VMs in this subnet to Google services. If specified, the subnetwork who is attached to the instance's default network interface will be assigned an internal IPv6 prefix if it doesn't have before.
        EnableOutboundVmAccessToGoogle,
        /// Each network interface inherits PrivateIpv6GoogleAccess from its subnetwork.
        InheritFromSubnetwork,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PrivateIpv6GoogleAccess::value] or
        /// [PrivateIpv6GoogleAccess::name].
        UnknownValue(private_ipv_6_google_access::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod private_ipv_6_google_access {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl PrivateIpv6GoogleAccess {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::EnableBidirectionalAccessToGoogle => std::option::Option::Some(0),
                Self::EnableOutboundVmAccessToGoogle => std::option::Option::Some(1),
                Self::InheritFromSubnetwork => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::EnableBidirectionalAccessToGoogle => {
                    std::option::Option::Some("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE")
                }
                Self::EnableOutboundVmAccessToGoogle => {
                    std::option::Option::Some("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE")
                }
                Self::InheritFromSubnetwork => std::option::Option::Some("INHERIT_FROM_SUBNETWORK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for PrivateIpv6GoogleAccess {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for PrivateIpv6GoogleAccess {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for PrivateIpv6GoogleAccess {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::EnableBidirectionalAccessToGoogle,
                1 => Self::EnableOutboundVmAccessToGoogle,
                2 => Self::InheritFromSubnetwork,
                _ => Self::UnknownValue(private_ipv_6_google_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for PrivateIpv6GoogleAccess {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE" => Self::EnableBidirectionalAccessToGoogle,
                "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE" => Self::EnableOutboundVmAccessToGoogle,
                "INHERIT_FROM_SUBNETWORK" => Self::InheritFromSubnetwork,
                _ => Self::UnknownValue(private_ipv_6_google_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for PrivateIpv6GoogleAccess {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::EnableBidirectionalAccessToGoogle => {
                    serializer.serialize_str("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE")
                }
                Self::EnableOutboundVmAccessToGoogle => {
                    serializer.serialize_str("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE")
                }
                Self::InheritFromSubnetwork => serializer.serialize_str("INHERIT_FROM_SUBNETWORK"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for PrivateIpv6GoogleAccess {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<PrivateIpv6GoogleAccess>::new(
                    ".google.cloud.compute.v1.Instance.privateIpv6GoogleAccess",
                ),
            )
        }
    }

    /// The enumerated type for the [status][google.cloud.compute.v1.Instance.status] field.
    ///
    /// [google.cloud.compute.v1.Instance.status]: crate::model::instance::Status
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// The instance is halted and we are performing tear down tasks like network deprogramming, releasing quota, IP, tearing down disks etc.
        Deprovisioning,
        /// For Flex Start provisioning instance is waiting for available capacity from Dynamic Workload Scheduler (DWS).
        Pending,
        /// Resources are being allocated for the instance.
        Provisioning,
        /// The instance is in repair.
        Repairing,
        /// The instance is running.
        Running,
        /// All required resources have been allocated and the instance is being started.
        Staging,
        /// The instance has stopped successfully.
        Stopped,
        /// The instance is currently stopping (either being deleted or killed).
        Stopping,
        /// The instance has suspended.
        Suspended,
        /// The instance is suspending.
        Suspending,
        /// The instance has stopped (either by explicit action or underlying failure).
        Terminated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Deprovisioning => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Provisioning => std::option::Option::Some(2),
                Self::Repairing => std::option::Option::Some(3),
                Self::Running => std::option::Option::Some(4),
                Self::Staging => std::option::Option::Some(5),
                Self::Stopped => std::option::Option::Some(6),
                Self::Stopping => std::option::Option::Some(7),
                Self::Suspended => std::option::Option::Some(8),
                Self::Suspending => std::option::Option::Some(9),
                Self::Terminated => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Deprovisioning => std::option::Option::Some("DEPROVISIONING"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Repairing => std::option::Option::Some("REPAIRING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Staging => std::option::Option::Some("STAGING"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Suspended => std::option::Option::Some("SUSPENDED"),
                Self::Suspending => std::option::Option::Some("SUSPENDING"),
                Self::Terminated => std::option::Option::Some("TERMINATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Deprovisioning,
                1 => Self::Pending,
                2 => Self::Provisioning,
                3 => Self::Repairing,
                4 => Self::Running,
                5 => Self::Staging,
                6 => Self::Stopped,
                7 => Self::Stopping,
                8 => Self::Suspended,
                9 => Self::Suspending,
                10 => Self::Terminated,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DEPROVISIONING" => Self::Deprovisioning,
                "PENDING" => Self::Pending,
                "PROVISIONING" => Self::Provisioning,
                "REPAIRING" => Self::Repairing,
                "RUNNING" => Self::Running,
                "STAGING" => Self::Staging,
                "STOPPED" => Self::Stopped,
                "STOPPING" => Self::Stopping,
                "SUSPENDED" => Self::Suspended,
                "SUSPENDING" => Self::Suspending,
                "TERMINATED" => Self::Terminated,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Deprovisioning => serializer.serialize_str("DEPROVISIONING"),
                Self::Pending => serializer.serialize_str("PENDING"),
                Self::Provisioning => serializer.serialize_str("PROVISIONING"),
                Self::Repairing => serializer.serialize_str("REPAIRING"),
                Self::Running => serializer.serialize_str("RUNNING"),
                Self::Staging => serializer.serialize_str("STAGING"),
                Self::Stopped => serializer.serialize_str("STOPPED"),
                Self::Stopping => serializer.serialize_str("STOPPING"),
                Self::Suspended => serializer.serialize_str("SUSPENDED"),
                Self::Suspending => serializer.serialize_str("SUSPENDING"),
                Self::Terminated => serializer.serialize_str("TERMINATED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.cloud.compute.v1.Instance.status",
            ))
        }
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceAggregatedList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// An object that contains a list of instances scoped by zone.
    pub items: std::collections::HashMap<std::string::String, crate::model::InstancesScopedList>,

    /// [Output Only] Type of resource. Always compute#instanceAggregatedList for aggregated lists of Instance resources.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Unreachable resources.
    pub unreachables: std::vec::Vec<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::instance_aggregated_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstanceAggregatedList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::InstanceAggregatedList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::InstanceAggregatedList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::InstanceAggregatedList::items].
    pub fn set_items<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::InstancesScopedList>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [kind][crate::model::InstanceAggregatedList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::InstanceAggregatedList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstanceAggregatedList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::InstanceAggregatedList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::InstanceAggregatedList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::InstanceAggregatedList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [unreachables][crate::model::InstanceAggregatedList::unreachables].
    pub fn set_unreachables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warning][crate::model::InstanceAggregatedList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_aggregated_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::InstanceAggregatedList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_aggregated_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstanceAggregatedList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceAggregatedList"
    }
}

/// Defines additional types related to [InstanceAggregatedList].
#[cfg(feature = "instances")]
pub mod instance_aggregated_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.InstanceAggregatedList.warning] field.
    ///
    /// [google.cloud.compute.v1.InstanceAggregatedList.warning]: crate::model::instance_aggregated_list::Warning
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
        pub code: std::option::Option<crate::model::instance_aggregated_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" }
        pub data: std::vec::Vec<crate::model::instance_aggregated_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::instance_aggregated_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::instance_aggregated_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::instance_aggregated_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::instance_aggregated_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::instance_aggregated_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance_aggregated_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::instance_aggregated_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::instance_aggregated_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "instances")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstanceAggregatedList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "instances")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.InstanceAggregatedList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.InstanceAggregatedList.warning.data]: crate::model::instance_aggregated_list::warning::Data
        #[cfg(feature = "instances")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instances")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::instance_aggregated_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::instance_aggregated_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::instance_aggregated_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::instance_aggregated_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instances")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstanceAggregatedList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.InstanceAggregatedList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.InstanceAggregatedList.warning.code]: crate::model::instance_aggregated_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instances")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden. Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed which captures the amount of resources filtered out by user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g: regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but its application does not make a lot of sense, because it allows only single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instances")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instances")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instances")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.InstanceAggregatedList.warning.code",
                ))
            }
        }
    }
}

/// Contains a list of instances.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of Instance resources.
    pub items: std::vec::Vec<crate::model::Instance>,

    /// [Output Only] Type of resource. Always compute#instanceList for lists of Instance resources.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::instance_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstanceList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::InstanceList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::InstanceList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::InstanceList::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::InstanceList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::InstanceList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstanceList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::InstanceList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::InstanceList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::InstanceList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::InstanceList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::InstanceList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstanceList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceList"
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for InstanceList {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [InstanceList].
#[cfg(feature = "instances")]
pub mod instance_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.InstanceList.warning] field.
    ///
    /// [google.cloud.compute.v1.InstanceList.warning]: crate::model::instance_list::Warning
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
        pub code: std::option::Option<crate::model::instance_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" }
        pub data: std::vec::Vec<crate::model::instance_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::instance_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::instance_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::instance_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::instance_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::instance_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::instance_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::instance_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "instances")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstanceList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "instances")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.InstanceList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.InstanceList.warning.data]: crate::model::instance_list::warning::Data
        #[cfg(feature = "instances")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instances")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::instance_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::instance_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::instance_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::instance_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instances")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstanceList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.InstanceList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.InstanceList.warning.code]: crate::model::instance_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instances")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden. Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed which captures the amount of resources filtered out by user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g: regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but its application does not make a lot of sense, because it allows only single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instances")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instances")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instances")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.InstanceList.warning.code",
                ))
            }
        }
    }
}

/// Contains a list of instance referrers.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceListReferrers {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of Reference resources.
    pub items: std::vec::Vec<crate::model::Reference>,

    /// [Output Only] Type of resource. Always compute#instanceListReferrers for lists of Instance referrers.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::instance_list_referrers::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstanceListReferrers {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::InstanceListReferrers::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::InstanceListReferrers::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::InstanceListReferrers::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Reference>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::InstanceListReferrers::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::InstanceListReferrers::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::InstanceListReferrers::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::InstanceListReferrers::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::InstanceListReferrers::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::InstanceListReferrers::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::InstanceListReferrers::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_list_referrers::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::InstanceListReferrers::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_list_referrers::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstanceListReferrers {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceListReferrers"
    }
}

#[cfg(feature = "instances")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for InstanceListReferrers {
    type PageItem = crate::model::Reference;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [InstanceListReferrers].
#[cfg(feature = "instances")]
pub mod instance_list_referrers {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.InstanceListReferrers.warning] field.
    ///
    /// [google.cloud.compute.v1.InstanceListReferrers.warning]: crate::model::instance_list_referrers::Warning
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
        pub code: std::option::Option<crate::model::instance_list_referrers::warning::Code>,

        /// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" }
        pub data: std::vec::Vec<crate::model::instance_list_referrers::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::instance_list_referrers::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::instance_list_referrers::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::instance_list_referrers::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::instance_list_referrers::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::instance_list_referrers::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instance_list_referrers::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::instance_list_referrers::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::instance_list_referrers::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "instances")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstanceListReferrers.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "instances")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.InstanceListReferrers.warning.data] field.
        ///
        /// [google.cloud.compute.v1.InstanceListReferrers.warning.data]: crate::model::instance_list_referrers::warning::Data
        #[cfg(feature = "instances")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instances")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::instance_list_referrers::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::instance_list_referrers::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::instance_list_referrers::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::instance_list_referrers::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instances")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstanceListReferrers.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.InstanceListReferrers.warning.code] field.
        ///
        /// [google.cloud.compute.v1.InstanceListReferrers.warning.code]: crate::model::instance_list_referrers::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instances")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden. Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed which captures the amount of resources filtered out by user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g: regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but its application does not make a lot of sense, because it allows only single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instances")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instances")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instances")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.InstanceListReferrers.warning.code",
                ))
            }
        }
    }
}

/// Additional instance params.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceParams {
    /// Relative deadline for waiting for capacity. Relevant only for Instances.Insert API.
    pub request_valid_for_duration: std::option::Option<crate::model::Duration>,

    /// Resource manager tags to be bound to the instance. Tag keys and values have the same definition as resource manager tags. Keys must be in the format `tagKeys/{tag_key_id}`, and values are in the format `tagValues/456`. The field is ignored (both PUT & PATCH) when empty.
    pub resource_manager_tags: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstanceParams {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [request_valid_for_duration][crate::model::InstanceParams::request_valid_for_duration].
    pub fn set_request_valid_for_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Duration>,
    {
        self.request_valid_for_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [request_valid_for_duration][crate::model::InstanceParams::request_valid_for_duration].
    pub fn set_or_clear_request_valid_for_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Duration>,
    {
        self.request_valid_for_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_manager_tags][crate::model::InstanceParams::resource_manager_tags].
    pub fn set_resource_manager_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_manager_tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstanceParams {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceParams"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstanceProperties {
    /// Controls for advanced machine-related behavior features. Note that for MachineImage, this is not supported yet.
    pub advanced_machine_features: std::option::Option<crate::model::AdvancedMachineFeatures>,

    /// Enables instances created based on these properties to send packets with source IP addresses other than their own and receive packets with destination IP addresses other than their own. If these instances will be used as an IP gateway or it will be set as the next-hop in a Route resource, specify true. If unsure, leave this set to false. See the Enable IP forwarding documentation for more information.
    pub can_ip_forward: std::option::Option<bool>,

    /// Specifies the Confidential Instance options. Note that for MachineImage, this is not supported yet.
    pub confidential_instance_config: std::option::Option<crate::model::ConfidentialInstanceConfig>,

    /// An optional text description for the instances that are created from these properties.
    pub description: std::option::Option<std::string::String>,

    /// An array of disks that are associated with the instances that are created from these properties.
    pub disks: std::vec::Vec<crate::model::AttachedDisk>,

    /// A list of guest accelerator cards' type and count to use for instances created from these properties.
    pub guest_accelerators: std::vec::Vec<crate::model::AcceleratorConfig>,

    /// KeyRevocationActionType of the instance. Supported options are "STOP" and "NONE". The default value is "NONE" if it is not specified.
    pub key_revocation_action_type:
        std::option::Option<crate::model::instance_properties::KeyRevocationActionType>,

    /// Labels to apply to instances that are created from these properties.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The machine type to use for instances that are created from these properties. This field only accepts a machine type name, for example `n2-standard-4`. If you use the machine type full or partial URL, for example `projects/my-l7ilb-project/zones/us-central1-a/machineTypes/n2-standard-4`, the request will result in an `INTERNAL_ERROR`.
    pub machine_type: std::option::Option<std::string::String>,

    /// The metadata key/value pairs to assign to instances that are created from these properties. These pairs can consist of custom metadata or predefined keys. See Project and instance metadata for more information.
    pub metadata: std::option::Option<crate::model::Metadata>,

    /// Minimum cpu/platform to be used by instances. The instance may be scheduled on the specified or newer cpu/platform. Applicable values are the friendly names of CPU platforms, such as minCpuPlatform: "Intel Haswell" or minCpuPlatform: "Intel Sandy Bridge". For more information, read Specifying a Minimum CPU Platform.
    pub min_cpu_platform: std::option::Option<std::string::String>,

    /// An array of network access configurations for this interface.
    pub network_interfaces: std::vec::Vec<crate::model::NetworkInterface>,

    /// Note that for MachineImage, this is not supported yet.
    pub network_performance_config: std::option::Option<crate::model::NetworkPerformanceConfig>,

    /// The private IPv6 google access type for VMs. If not specified, use INHERIT_FROM_SUBNETWORK as default. Note that for MachineImage, this is not supported yet.
    pub private_ipv_6_google_access:
        std::option::Option<crate::model::instance_properties::PrivateIpv6GoogleAccess>,

    /// Specifies the reservations that instances can consume from. Note that for MachineImage, this is not supported yet.
    pub reservation_affinity: std::option::Option<crate::model::ReservationAffinity>,

    /// Resource manager tags to be bound to the instance. Tag keys and values have the same definition as resource manager tags. Keys must be in the format `tagKeys/{tag_key_id}`, and values are in the format `tagValues/456`. The field is ignored (both PUT & PATCH) when empty.
    pub resource_manager_tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// Resource policies (names, not URLs) applied to instances created from these properties. Note that for MachineImage, this is not supported yet.
    pub resource_policies: std::vec::Vec<std::string::String>,

    /// Specifies the scheduling options for the instances that are created from these properties.
    pub scheduling: std::option::Option<crate::model::Scheduling>,

    /// A list of service accounts with specified scopes. Access tokens for these service accounts are available to the instances that are created from these properties. Use metadata queries to obtain the access tokens for these instances.
    pub service_accounts: std::vec::Vec<crate::model::ServiceAccount>,

    /// Note that for MachineImage, this is not supported yet.
    pub shielded_instance_config: std::option::Option<crate::model::ShieldedInstanceConfig>,

    /// A list of tags to apply to the instances that are created from these properties. The tags identify valid sources or targets for network firewalls. The setTags method can modify this list of tags. Each tag within the list must comply with RFC1035.
    pub tags: std::option::Option<crate::model::Tags>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstanceProperties {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [advanced_machine_features][crate::model::InstanceProperties::advanced_machine_features].
    pub fn set_advanced_machine_features<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedMachineFeatures>,
    {
        self.advanced_machine_features = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [advanced_machine_features][crate::model::InstanceProperties::advanced_machine_features].
    pub fn set_or_clear_advanced_machine_features<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AdvancedMachineFeatures>,
    {
        self.advanced_machine_features = v.map(|x| x.into());
        self
    }

    /// Sets the value of [can_ip_forward][crate::model::InstanceProperties::can_ip_forward].
    pub fn set_can_ip_forward<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.can_ip_forward = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [can_ip_forward][crate::model::InstanceProperties::can_ip_forward].
    pub fn set_or_clear_can_ip_forward<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.can_ip_forward = v.map(|x| x.into());
        self
    }

    /// Sets the value of [confidential_instance_config][crate::model::InstanceProperties::confidential_instance_config].
    pub fn set_confidential_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialInstanceConfig>,
    {
        self.confidential_instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [confidential_instance_config][crate::model::InstanceProperties::confidential_instance_config].
    pub fn set_or_clear_confidential_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConfidentialInstanceConfig>,
    {
        self.confidential_instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::InstanceProperties::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::InstanceProperties::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disks][crate::model::InstanceProperties::disks].
    pub fn set_disks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AttachedDisk>,
    {
        use std::iter::Iterator;
        self.disks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [guest_accelerators][crate::model::InstanceProperties::guest_accelerators].
    pub fn set_guest_accelerators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AcceleratorConfig>,
    {
        use std::iter::Iterator;
        self.guest_accelerators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [key_revocation_action_type][crate::model::InstanceProperties::key_revocation_action_type].
    pub fn set_key_revocation_action_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_properties::KeyRevocationActionType>,
    {
        self.key_revocation_action_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key_revocation_action_type][crate::model::InstanceProperties::key_revocation_action_type].
    pub fn set_or_clear_key_revocation_action_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_properties::KeyRevocationActionType>,
    {
        self.key_revocation_action_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::InstanceProperties::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [machine_type][crate::model::InstanceProperties::machine_type].
    pub fn set_machine_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.machine_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [machine_type][crate::model::InstanceProperties::machine_type].
    pub fn set_or_clear_machine_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.machine_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metadata][crate::model::InstanceProperties::metadata].
    pub fn set_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metadata][crate::model::InstanceProperties::metadata].
    pub fn set_or_clear_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Metadata>,
    {
        self.metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [min_cpu_platform][crate::model::InstanceProperties::min_cpu_platform].
    pub fn set_min_cpu_platform<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.min_cpu_platform = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_cpu_platform][crate::model::InstanceProperties::min_cpu_platform].
    pub fn set_or_clear_min_cpu_platform<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.min_cpu_platform = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_interfaces][crate::model::InstanceProperties::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [network_performance_config][crate::model::InstanceProperties::network_performance_config].
    pub fn set_network_performance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPerformanceConfig>,
    {
        self.network_performance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_performance_config][crate::model::InstanceProperties::network_performance_config].
    pub fn set_or_clear_network_performance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NetworkPerformanceConfig>,
    {
        self.network_performance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [private_ipv_6_google_access][crate::model::InstanceProperties::private_ipv_6_google_access].
    pub fn set_private_ipv_6_google_access<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instance_properties::PrivateIpv6GoogleAccess>,
    {
        self.private_ipv_6_google_access = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_ipv_6_google_access][crate::model::InstanceProperties::private_ipv_6_google_access].
    pub fn set_or_clear_private_ipv_6_google_access<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instance_properties::PrivateIpv6GoogleAccess>,
    {
        self.private_ipv_6_google_access = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reservation_affinity][crate::model::InstanceProperties::reservation_affinity].
    pub fn set_reservation_affinity<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReservationAffinity>,
    {
        self.reservation_affinity = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reservation_affinity][crate::model::InstanceProperties::reservation_affinity].
    pub fn set_or_clear_reservation_affinity<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReservationAffinity>,
    {
        self.reservation_affinity = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resource_manager_tags][crate::model::InstanceProperties::resource_manager_tags].
    pub fn set_resource_manager_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_manager_tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [resource_policies][crate::model::InstanceProperties::resource_policies].
    pub fn set_resource_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [scheduling][crate::model::InstanceProperties::scheduling].
    pub fn set_scheduling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Scheduling>,
    {
        self.scheduling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scheduling][crate::model::InstanceProperties::scheduling].
    pub fn set_or_clear_scheduling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Scheduling>,
    {
        self.scheduling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_accounts][crate::model::InstanceProperties::service_accounts].
    pub fn set_service_accounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ServiceAccount>,
    {
        use std::iter::Iterator;
        self.service_accounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [shielded_instance_config][crate::model::InstanceProperties::shielded_instance_config].
    pub fn set_shielded_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
    {
        self.shielded_instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shielded_instance_config][crate::model::InstanceProperties::shielded_instance_config].
    pub fn set_or_clear_shielded_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
    {
        self.shielded_instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [tags][crate::model::InstanceProperties::tags].
    pub fn set_tags<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Tags>,
    {
        self.tags = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [tags][crate::model::InstanceProperties::tags].
    pub fn set_or_clear_tags<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Tags>,
    {
        self.tags = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstanceProperties {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstanceProperties"
    }
}

/// Defines additional types related to [InstanceProperties].
#[cfg(feature = "instances")]
pub mod instance_properties {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [keyRevocationActionType][google.cloud.compute.v1.InstanceProperties.keyRevocationActionType] field.
    ///
    /// [google.cloud.compute.v1.InstanceProperties.keyRevocationActionType]: crate::model::instance_properties::KeyRevocationActionType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum KeyRevocationActionType {
        /// Default value. This value is unused.
        Unspecified,
        /// Indicates user chose no operation.
        None,
        /// Indicates user chose to opt for VM shutdown on key revocation.
        Stop,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [KeyRevocationActionType::value] or
        /// [KeyRevocationActionType::name].
        UnknownValue(key_revocation_action_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod key_revocation_action_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl KeyRevocationActionType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Stop => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED")
                }
                Self::None => std::option::Option::Some("NONE"),
                Self::Stop => std::option::Option::Some("STOP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for KeyRevocationActionType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for KeyRevocationActionType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for KeyRevocationActionType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Stop,
                _ => Self::UnknownValue(key_revocation_action_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for KeyRevocationActionType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "STOP" => Self::Stop,
                _ => Self::UnknownValue(key_revocation_action_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for KeyRevocationActionType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => {
                    serializer.serialize_str("KEY_REVOCATION_ACTION_TYPE_UNSPECIFIED")
                }
                Self::None => serializer.serialize_str("NONE"),
                Self::Stop => serializer.serialize_str("STOP"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for KeyRevocationActionType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<KeyRevocationActionType>::new(
                    ".google.cloud.compute.v1.InstanceProperties.keyRevocationActionType",
                ),
            )
        }
    }

    /// The enumerated type for the [privateIpv6GoogleAccess][google.cloud.compute.v1.InstanceProperties.privateIpv6GoogleAccess] field.
    ///
    /// [google.cloud.compute.v1.InstanceProperties.privateIpv6GoogleAccess]: crate::model::instance_properties::PrivateIpv6GoogleAccess
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PrivateIpv6GoogleAccess {
        /// Bidirectional private IPv6 access to/from Google services. If specified, the subnetwork who is attached to the instance's default network interface will be assigned an internal IPv6 prefix if it doesn't have before.
        EnableBidirectionalAccessToGoogle,
        /// Outbound private IPv6 access from VMs in this subnet to Google services. If specified, the subnetwork who is attached to the instance's default network interface will be assigned an internal IPv6 prefix if it doesn't have before.
        EnableOutboundVmAccessToGoogle,
        /// Each network interface inherits PrivateIpv6GoogleAccess from its subnetwork.
        InheritFromSubnetwork,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PrivateIpv6GoogleAccess::value] or
        /// [PrivateIpv6GoogleAccess::name].
        UnknownValue(private_ipv_6_google_access::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod private_ipv_6_google_access {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl PrivateIpv6GoogleAccess {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::EnableBidirectionalAccessToGoogle => std::option::Option::Some(0),
                Self::EnableOutboundVmAccessToGoogle => std::option::Option::Some(1),
                Self::InheritFromSubnetwork => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::EnableBidirectionalAccessToGoogle => {
                    std::option::Option::Some("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE")
                }
                Self::EnableOutboundVmAccessToGoogle => {
                    std::option::Option::Some("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE")
                }
                Self::InheritFromSubnetwork => std::option::Option::Some("INHERIT_FROM_SUBNETWORK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for PrivateIpv6GoogleAccess {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for PrivateIpv6GoogleAccess {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for PrivateIpv6GoogleAccess {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::EnableBidirectionalAccessToGoogle,
                1 => Self::EnableOutboundVmAccessToGoogle,
                2 => Self::InheritFromSubnetwork,
                _ => Self::UnknownValue(private_ipv_6_google_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for PrivateIpv6GoogleAccess {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE" => Self::EnableBidirectionalAccessToGoogle,
                "ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE" => Self::EnableOutboundVmAccessToGoogle,
                "INHERIT_FROM_SUBNETWORK" => Self::InheritFromSubnetwork,
                _ => Self::UnknownValue(private_ipv_6_google_access::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for PrivateIpv6GoogleAccess {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::EnableBidirectionalAccessToGoogle => {
                    serializer.serialize_str("ENABLE_BIDIRECTIONAL_ACCESS_TO_GOOGLE")
                }
                Self::EnableOutboundVmAccessToGoogle => {
                    serializer.serialize_str("ENABLE_OUTBOUND_VM_ACCESS_TO_GOOGLE")
                }
                Self::InheritFromSubnetwork => serializer.serialize_str("INHERIT_FROM_SUBNETWORK"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for PrivateIpv6GoogleAccess {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<PrivateIpv6GoogleAccess>::new(
                    ".google.cloud.compute.v1.InstanceProperties.privateIpv6GoogleAccess",
                ),
            )
        }
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesAddResourcePoliciesRequest {
    /// Resource policies to be added to this instance.
    pub resource_policies: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesAddResourcePoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_policies][crate::model::InstancesAddResourcePoliciesRequest::resource_policies].
    pub fn set_resource_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesAddResourcePoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesAddResourcePoliciesRequest"
    }
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesBulkInsertOperationMetadata {
    /// Status information per location (location name is key). Example key: zones/us-central1-a
    pub per_location_status:
        std::collections::HashMap<std::string::String, crate::model::BulkInsertOperationStatus>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl InstancesBulkInsertOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [per_location_status][crate::model::InstancesBulkInsertOperationMetadata::per_location_status].
    pub fn set_per_location_status<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::BulkInsertOperationStatus>,
    {
        use std::iter::Iterator;
        self.per_location_status = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl wkt::message::Message for InstancesBulkInsertOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesBulkInsertOperationMetadata"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesGetEffectiveFirewallsResponse {
    /// [Output Only] Effective firewalls from firewall policies.
    pub firewall_policys:
        std::vec::Vec<crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy>,

    /// Effective firewalls on the instance.
    pub firewalls: std::vec::Vec<crate::model::Firewall>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesGetEffectiveFirewallsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [firewall_policys][crate::model::InstancesGetEffectiveFirewallsResponse::firewall_policys].
    pub fn set_firewall_policys<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy,
            >,
    {
        use std::iter::Iterator;
        self.firewall_policys = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [firewalls][crate::model::InstancesGetEffectiveFirewallsResponse::firewalls].
    pub fn set_firewalls<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Firewall>,
    {
        use std::iter::Iterator;
        self.firewalls = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesGetEffectiveFirewallsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesGetEffectiveFirewallsResponse"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy {
    /// [Output Only] Deprecated, please use short name instead. The display name of the firewall policy.
    #[deprecated]
    pub display_name: std::option::Option<std::string::String>,

    /// [Output Only] The name of the firewall policy.
    pub name: std::option::Option<std::string::String>,

    /// [Output Only] The packet mirroring rules that apply to the instance.
    pub packet_mirroring_rules: std::vec::Vec<crate::model::FirewallPolicyRule>,

    /// [Output only] Priority of firewall policy association. Not applicable for type=HIERARCHY.
    pub priority: std::option::Option<i32>,

    /// [Output Only] The rules that apply to the instance. Only rules that target the specific VM instance are returned if target service accounts or target secure tags are specified in the rules.
    pub rules: std::vec::Vec<crate::model::FirewallPolicyRule>,

    /// [Output Only] The short name of the firewall policy.
    pub short_name: std::option::Option<std::string::String>,

    /// [Output Only] The type of the firewall policy. Can be one of HIERARCHY, NETWORK, NETWORK_REGIONAL, SYSTEM_GLOBAL, SYSTEM_REGIONAL.
    pub r#type: std::option::Option<
        crate::model::instances_get_effective_firewalls_response_effective_firewall_policy::Type,
    >,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [display_name][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::display_name].
    #[deprecated]
    pub fn set_display_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.display_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [display_name][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::display_name].
    #[deprecated]
    pub fn set_or_clear_display_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.display_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [packet_mirroring_rules][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::packet_mirroring_rules].
    pub fn set_packet_mirroring_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallPolicyRule>,
    {
        use std::iter::Iterator;
        self.packet_mirroring_rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [priority][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::priority].
    pub fn set_priority<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.priority = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [priority][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::priority].
    pub fn set_or_clear_priority<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.priority = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rules][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::rules].
    pub fn set_rules<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::FirewallPolicyRule>,
    {
        use std::iter::Iterator;
        self.rules = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [short_name][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::short_name].
    pub fn set_short_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.short_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [short_name][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::short_name].
    pub fn set_or_clear_short_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.short_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::instances_get_effective_firewalls_response_effective_firewall_policy::Type>
    {
        self.r#type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#type][crate::model::InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::instances_get_effective_firewalls_response_effective_firewall_policy::Type>
    {
        self.r#type = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy"
    }
}

/// Defines additional types related to [InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy].
#[cfg(feature = "instances")]
pub mod instances_get_effective_firewalls_response_effective_firewall_policy {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [type][google.cloud.compute.v1.InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy.type] field.
    ///
    /// [google.cloud.compute.v1.InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy.type]: crate::model::instances_get_effective_firewalls_response_effective_firewall_policy::Type
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        Hierarchy,
        Network,
        NetworkRegional,
        SystemGlobal,
        SystemRegional,
        Unspecified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Hierarchy => std::option::Option::Some(0),
                Self::Network => std::option::Option::Some(1),
                Self::NetworkRegional => std::option::Option::Some(2),
                Self::SystemGlobal => std::option::Option::Some(3),
                Self::SystemRegional => std::option::Option::Some(4),
                Self::Unspecified => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Hierarchy => std::option::Option::Some("HIERARCHY"),
                Self::Network => std::option::Option::Some("NETWORK"),
                Self::NetworkRegional => std::option::Option::Some("NETWORK_REGIONAL"),
                Self::SystemGlobal => std::option::Option::Some("SYSTEM_GLOBAL"),
                Self::SystemRegional => std::option::Option::Some("SYSTEM_REGIONAL"),
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Hierarchy,
                1 => Self::Network,
                2 => Self::NetworkRegional,
                3 => Self::SystemGlobal,
                4 => Self::SystemRegional,
                5 => Self::Unspecified,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "HIERARCHY" => Self::Hierarchy,
                "NETWORK" => Self::Network,
                "NETWORK_REGIONAL" => Self::NetworkRegional,
                "SYSTEM_GLOBAL" => Self::SystemGlobal,
                "SYSTEM_REGIONAL" => Self::SystemRegional,
                "UNSPECIFIED" => Self::Unspecified,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Hierarchy => serializer.serialize_str("HIERARCHY"),
                Self::Network => serializer.serialize_str("NETWORK"),
                Self::NetworkRegional => serializer.serialize_str("NETWORK_REGIONAL"),
                Self::SystemGlobal => serializer.serialize_str("SYSTEM_GLOBAL"),
                Self::SystemRegional => serializer.serialize_str("SYSTEM_REGIONAL"),
                Self::Unspecified => serializer.serialize_str("UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.compute.v1.InstancesGetEffectiveFirewallsResponseEffectiveFirewallPolicy.type"))
        }
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesRemoveResourcePoliciesRequest {
    /// Resource policies to be removed from this instance.
    pub resource_policies: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesRemoveResourcePoliciesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resource_policies][crate::model::InstancesRemoveResourcePoliciesRequest::resource_policies].
    pub fn set_resource_policies<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.resource_policies = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesRemoveResourcePoliciesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesRemoveResourcePoliciesRequest"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesReportHostAsFaultyRequest {
    /// The disruption schedule for the VM. Required field, only allows IMMEDIATE.
    pub disruption_schedule: std::option::Option<
        crate::model::instances_report_host_as_faulty_request::DisruptionSchedule,
    >,

    pub fault_reasons: std::vec::Vec<crate::model::InstancesReportHostAsFaultyRequestFaultReason>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesReportHostAsFaultyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disruption_schedule][crate::model::InstancesReportHostAsFaultyRequest::disruption_schedule].
    pub fn set_disruption_schedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::instances_report_host_as_faulty_request::DisruptionSchedule,
            >,
    {
        self.disruption_schedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disruption_schedule][crate::model::InstancesReportHostAsFaultyRequest::disruption_schedule].
    pub fn set_or_clear_disruption_schedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::instances_report_host_as_faulty_request::DisruptionSchedule,
            >,
    {
        self.disruption_schedule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [fault_reasons][crate::model::InstancesReportHostAsFaultyRequest::fault_reasons].
    pub fn set_fault_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::InstancesReportHostAsFaultyRequestFaultReason>,
    {
        use std::iter::Iterator;
        self.fault_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesReportHostAsFaultyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesReportHostAsFaultyRequest"
    }
}

/// Defines additional types related to [InstancesReportHostAsFaultyRequest].
#[cfg(feature = "instances")]
pub mod instances_report_host_as_faulty_request {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [disruptionSchedule][google.cloud.compute.v1.InstancesReportHostAsFaultyRequest.disruptionSchedule] field.
    ///
    /// [google.cloud.compute.v1.InstancesReportHostAsFaultyRequest.disruptionSchedule]: crate::model::instances_report_host_as_faulty_request::DisruptionSchedule
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum DisruptionSchedule {
        /// Not used. Required as per aip/126.
        Unspecified,
        /// Delay disruption for caller control. Will be default soon.
        Future,
        /// Default value. Disrupt the VM immediately.
        Immediate,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [DisruptionSchedule::value] or
        /// [DisruptionSchedule::name].
        UnknownValue(disruption_schedule::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod disruption_schedule {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl DisruptionSchedule {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Future => std::option::Option::Some(1),
                Self::Immediate => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("DISRUPTION_SCHEDULE_UNSPECIFIED"),
                Self::Future => std::option::Option::Some("FUTURE"),
                Self::Immediate => std::option::Option::Some("IMMEDIATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for DisruptionSchedule {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for DisruptionSchedule {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for DisruptionSchedule {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Future,
                2 => Self::Immediate,
                _ => Self::UnknownValue(disruption_schedule::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for DisruptionSchedule {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DISRUPTION_SCHEDULE_UNSPECIFIED" => Self::Unspecified,
                "FUTURE" => Self::Future,
                "IMMEDIATE" => Self::Immediate,
                _ => Self::UnknownValue(disruption_schedule::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for DisruptionSchedule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_str("DISRUPTION_SCHEDULE_UNSPECIFIED"),
                Self::Future => serializer.serialize_str("FUTURE"),
                Self::Immediate => serializer.serialize_str("IMMEDIATE"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for DisruptionSchedule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<DisruptionSchedule>::new(
                ".google.cloud.compute.v1.InstancesReportHostAsFaultyRequest.disruptionSchedule",
            ))
        }
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesReportHostAsFaultyRequestFaultReason {
    pub behavior: std::option::Option<
        crate::model::instances_report_host_as_faulty_request_fault_reason::Behavior,
    >,

    pub description: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesReportHostAsFaultyRequestFaultReason {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [behavior][crate::model::InstancesReportHostAsFaultyRequestFaultReason::behavior].
    pub fn set_behavior<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<
                crate::model::instances_report_host_as_faulty_request_fault_reason::Behavior,
            >,
    {
        self.behavior = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [behavior][crate::model::InstancesReportHostAsFaultyRequestFaultReason::behavior].
    pub fn set_or_clear_behavior<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<
                crate::model::instances_report_host_as_faulty_request_fault_reason::Behavior,
            >,
    {
        self.behavior = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::InstancesReportHostAsFaultyRequestFaultReason::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::InstancesReportHostAsFaultyRequestFaultReason::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesReportHostAsFaultyRequestFaultReason {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesReportHostAsFaultyRequestFaultReason"
    }
}

/// Defines additional types related to [InstancesReportHostAsFaultyRequestFaultReason].
#[cfg(feature = "instances")]
pub mod instances_report_host_as_faulty_request_fault_reason {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [behavior][google.cloud.compute.v1.InstancesReportHostAsFaultyRequestFaultReason.behavior] field.
    ///
    /// [google.cloud.compute.v1.InstancesReportHostAsFaultyRequestFaultReason.behavior]: crate::model::instances_report_host_as_faulty_request_fault_reason::Behavior
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Behavior {
        /// Public reportable behaviors
        Unspecified,
        Performance,
        SilentDataCorruption,
        UnrecoverableGpuError,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Behavior::value] or
        /// [Behavior::name].
        UnknownValue(behavior::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod behavior {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Behavior {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Performance => std::option::Option::Some(1),
                Self::SilentDataCorruption => std::option::Option::Some(2),
                Self::UnrecoverableGpuError => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BEHAVIOR_UNSPECIFIED"),
                Self::Performance => std::option::Option::Some("PERFORMANCE"),
                Self::SilentDataCorruption => std::option::Option::Some("SILENT_DATA_CORRUPTION"),
                Self::UnrecoverableGpuError => std::option::Option::Some("UNRECOVERABLE_GPU_ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Behavior {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Behavior {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Behavior {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Performance,
                2 => Self::SilentDataCorruption,
                3 => Self::UnrecoverableGpuError,
                _ => Self::UnknownValue(behavior::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Behavior {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BEHAVIOR_UNSPECIFIED" => Self::Unspecified,
                "PERFORMANCE" => Self::Performance,
                "SILENT_DATA_CORRUPTION" => Self::SilentDataCorruption,
                "UNRECOVERABLE_GPU_ERROR" => Self::UnrecoverableGpuError,
                _ => Self::UnknownValue(behavior::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Behavior {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_str("BEHAVIOR_UNSPECIFIED"),
                Self::Performance => serializer.serialize_str("PERFORMANCE"),
                Self::SilentDataCorruption => serializer.serialize_str("SILENT_DATA_CORRUPTION"),
                Self::UnrecoverableGpuError => serializer.serialize_str("UNRECOVERABLE_GPU_ERROR"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Behavior {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Behavior>::new(
                ".google.cloud.compute.v1.InstancesReportHostAsFaultyRequestFaultReason.behavior",
            ))
        }
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesScopedList {
    /// [Output Only] A list of instances contained in this scope.
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// [Output Only] Informational warning which replaces the list of instances when the list is empty.
    pub warning: std::option::Option<crate::model::instances_scoped_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesScopedList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::InstancesScopedList::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warning][crate::model::InstancesScopedList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::instances_scoped_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::InstancesScopedList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::instances_scoped_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesScopedList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesScopedList"
    }
}

/// Defines additional types related to [InstancesScopedList].
#[cfg(feature = "instances")]
pub mod instances_scoped_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.InstancesScopedList.warning] field.
    ///
    /// [google.cloud.compute.v1.InstancesScopedList.warning]: crate::model::instances_scoped_list::Warning
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
        pub code: std::option::Option<crate::model::instances_scoped_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" }
        pub data: std::vec::Vec<crate::model::instances_scoped_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::instances_scoped_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::instances_scoped_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::instances_scoped_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::instances_scoped_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::instances_scoped_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::instances_scoped_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::instances_scoped_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::instances_scoped_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "instances")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.InstancesScopedList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "instances")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.InstancesScopedList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.InstancesScopedList.warning.data]: crate::model::instances_scoped_list::warning::Data
        #[cfg(feature = "instances")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "instances")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::instances_scoped_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::instances_scoped_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::instances_scoped_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::instances_scoped_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "instances")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.InstancesScopedList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.InstancesScopedList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.InstancesScopedList.warning.code]: crate::model::instances_scoped_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instances")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden. Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed which captures the amount of resources filtered out by user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g: regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but its application does not make a lot of sense, because it allows only single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instances")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instances")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instances")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.InstancesScopedList.warning.code",
                ))
            }
        }
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesSetLabelsRequest {
    /// Fingerprint of the previous set of labels for this resource, used to prevent conflicts. Provide the latest fingerprint value when making a request to add or change labels.
    pub label_fingerprint: std::option::Option<::bytes::Bytes>,

    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesSetLabelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [label_fingerprint][crate::model::InstancesSetLabelsRequest::label_fingerprint].
    pub fn set_label_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.label_fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [label_fingerprint][crate::model::InstancesSetLabelsRequest::label_fingerprint].
    pub fn set_or_clear_label_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.label_fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::InstancesSetLabelsRequest::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesSetLabelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesSetLabelsRequest"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesSetMachineResourcesRequest {
    /// A list of the type and count of accelerator cards attached to the instance.
    pub guest_accelerators: std::vec::Vec<crate::model::AcceleratorConfig>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesSetMachineResourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [guest_accelerators][crate::model::InstancesSetMachineResourcesRequest::guest_accelerators].
    pub fn set_guest_accelerators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AcceleratorConfig>,
    {
        use std::iter::Iterator;
        self.guest_accelerators = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesSetMachineResourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesSetMachineResourcesRequest"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesSetMachineTypeRequest {
    /// Full or partial URL of the machine type resource. See Machine Types for a full list of machine types. For example: zones/us-central1-f/machineTypes/n1-standard-1
    pub machine_type: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesSetMachineTypeRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_type][crate::model::InstancesSetMachineTypeRequest::machine_type].
    pub fn set_machine_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.machine_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [machine_type][crate::model::InstancesSetMachineTypeRequest::machine_type].
    pub fn set_or_clear_machine_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.machine_type = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesSetMachineTypeRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesSetMachineTypeRequest"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesSetMinCpuPlatformRequest {
    /// Minimum cpu/platform this instance should be started at.
    pub min_cpu_platform: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesSetMinCpuPlatformRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [min_cpu_platform][crate::model::InstancesSetMinCpuPlatformRequest::min_cpu_platform].
    pub fn set_min_cpu_platform<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.min_cpu_platform = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_cpu_platform][crate::model::InstancesSetMinCpuPlatformRequest::min_cpu_platform].
    pub fn set_or_clear_min_cpu_platform<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.min_cpu_platform = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesSetMinCpuPlatformRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesSetMinCpuPlatformRequest"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesSetNameRequest {
    /// The current name of this resource, used to prevent conflicts. Provide the latest name when making a request to change name.
    pub current_name: std::option::Option<std::string::String>,

    /// The name to be applied to the instance. Needs to be RFC 1035 compliant.
    pub name: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesSetNameRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [current_name][crate::model::InstancesSetNameRequest::current_name].
    pub fn set_current_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.current_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [current_name][crate::model::InstancesSetNameRequest::current_name].
    pub fn set_or_clear_current_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.current_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::InstancesSetNameRequest::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::InstancesSetNameRequest::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesSetNameRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesSetNameRequest"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesSetSecurityPolicyRequest {
    /// The network interfaces that the security policy will be applied to. Network interfaces use the nicN naming format. You can only set a security policy for network interfaces with an access config.
    pub network_interfaces: std::vec::Vec<std::string::String>,

    /// A full or partial URL to a security policy to add to this instance. If this field is set to an empty string it will remove the associated security policy.
    pub security_policy: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesSetSecurityPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network_interfaces][crate::model::InstancesSetSecurityPolicyRequest::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [security_policy][crate::model::InstancesSetSecurityPolicyRequest::security_policy].
    pub fn set_security_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.security_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [security_policy][crate::model::InstancesSetSecurityPolicyRequest::security_policy].
    pub fn set_or_clear_security_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.security_policy = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesSetSecurityPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesSetSecurityPolicyRequest"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesSetServiceAccountRequest {
    /// Email address of the service account.
    pub email: std::option::Option<std::string::String>,

    /// The list of scopes to be made available for this service account.
    pub scopes: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesSetServiceAccountRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [email][crate::model::InstancesSetServiceAccountRequest::email].
    pub fn set_email<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.email = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [email][crate::model::InstancesSetServiceAccountRequest::email].
    pub fn set_or_clear_email<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.email = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scopes][crate::model::InstancesSetServiceAccountRequest::scopes].
    pub fn set_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesSetServiceAccountRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesSetServiceAccountRequest"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstancesStartWithEncryptionKeyRequest {
    /// Array of disks associated with this instance that are protected with a customer-supplied encryption key. In order to start the instance, the disk url and its corresponding key must be provided. If the disk is not protected with a customer-supplied encryption key it should not be specified.
    pub disks: std::vec::Vec<crate::model::CustomerEncryptionKeyProtectedDisk>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl InstancesStartWithEncryptionKeyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disks][crate::model::InstancesStartWithEncryptionKeyRequest::disks].
    pub fn set_disks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CustomerEncryptionKeyProtectedDisk>,
    {
        use std::iter::Iterator;
        self.disks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for InstancesStartWithEncryptionKeyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.InstancesStartWithEncryptionKeyRequest"
    }
}

/// Provides a localized error message that is safe to return to the user which can be attached to an RPC error.
#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocalizedMessage {
    /// The locale used following the specification defined at <https://www.rfc-editor.org/rfc/bcp/bcp47.txt>. Examples are: "en-US", "fr-CH", "es-MX"
    pub locale: std::option::Option<std::string::String>,

    /// The localized error message in the above locale.
    pub message: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl LocalizedMessage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [locale][crate::model::LocalizedMessage::locale].
    pub fn set_locale<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.locale = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [locale][crate::model::LocalizedMessage::locale].
    pub fn set_or_clear_locale<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.locale = v.map(|x| x.into());
        self
    }

    /// Sets the value of [message][crate::model::LocalizedMessage::message].
    pub fn set_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.message = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [message][crate::model::LocalizedMessage::message].
    pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.message = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl wkt::message::Message for LocalizedMessage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.LocalizedMessage"
    }
}

/// Configuration for location policy among multiple possible locations (e.g. preferences for zone selection among zones in a single region).
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationPolicy {
    /// Location configurations mapped by location name. Currently only zone names are supported and must be represented as valid internal URLs, such as zones/us-central1-a.
    pub locations:
        std::collections::HashMap<std::string::String, crate::model::LocationPolicyLocation>,

    /// Strategy for distributing VMs across zones in a region.
    pub target_shape: std::option::Option<crate::model::location_policy::TargetShape>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl LocationPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [locations][crate::model::LocationPolicy::locations].
    pub fn set_locations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::LocationPolicyLocation>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [target_shape][crate::model::LocationPolicy::target_shape].
    pub fn set_target_shape<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::location_policy::TargetShape>,
    {
        self.target_shape = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_shape][crate::model::LocationPolicy::target_shape].
    pub fn set_or_clear_target_shape<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::location_policy::TargetShape>,
    {
        self.target_shape = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for LocationPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.LocationPolicy"
    }
}

/// Defines additional types related to [LocationPolicy].
#[cfg(feature = "instances")]
pub mod location_policy {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [targetShape][google.cloud.compute.v1.LocationPolicy.targetShape] field.
    ///
    /// [google.cloud.compute.v1.LocationPolicy.targetShape]: crate::model::location_policy::TargetShape
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetShape {
        /// GCE picks zones for creating VM instances to fulfill the requested number of VMs within present resource constraints and to maximize utilization of unused zonal reservations. Recommended for batch workloads that do not require high availability.
        Any,
        /// GCE always selects a single zone for all the VMs, optimizing for resource quotas, available reservations and general capacity. Recommended for batch workloads that cannot tollerate distribution over multiple zones. This the default shape in Bulk Insert and Capacity Advisor APIs.
        AnySingleZone,
        /// GCE prioritizes acquisition of resources, scheduling VMs in zones where resources are available while distributing VMs as evenly as possible across allowed zones to minimize the impact of zonal failure. Recommended for highly available serving workloads.
        Balanced,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TargetShape::value] or
        /// [TargetShape::name].
        UnknownValue(target_shape::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod target_shape {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl TargetShape {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Any => std::option::Option::Some(0),
                Self::AnySingleZone => std::option::Option::Some(1),
                Self::Balanced => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Any => std::option::Option::Some("ANY"),
                Self::AnySingleZone => std::option::Option::Some("ANY_SINGLE_ZONE"),
                Self::Balanced => std::option::Option::Some("BALANCED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for TargetShape {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for TargetShape {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for TargetShape {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Any,
                1 => Self::AnySingleZone,
                2 => Self::Balanced,
                _ => Self::UnknownValue(target_shape::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for TargetShape {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANY" => Self::Any,
                "ANY_SINGLE_ZONE" => Self::AnySingleZone,
                "BALANCED" => Self::Balanced,
                _ => Self::UnknownValue(target_shape::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for TargetShape {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Any => serializer.serialize_str("ANY"),
                Self::AnySingleZone => serializer.serialize_str("ANY_SINGLE_ZONE"),
                Self::Balanced => serializer.serialize_str("BALANCED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for TargetShape {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TargetShape>::new(
                ".google.cloud.compute.v1.LocationPolicy.targetShape",
            ))
        }
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationPolicyLocation {
    /// Constraints that the caller requires on the result distribution in this zone.
    pub constraints: std::option::Option<crate::model::LocationPolicyLocationConstraints>,

    /// Preference for a given location. Set to either ALLOW or DENY.
    pub preference: std::option::Option<crate::model::location_policy_location::Preference>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl LocationPolicyLocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [constraints][crate::model::LocationPolicyLocation::constraints].
    pub fn set_constraints<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::LocationPolicyLocationConstraints>,
    {
        self.constraints = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [constraints][crate::model::LocationPolicyLocation::constraints].
    pub fn set_or_clear_constraints<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::LocationPolicyLocationConstraints>,
    {
        self.constraints = v.map(|x| x.into());
        self
    }

    /// Sets the value of [preference][crate::model::LocationPolicyLocation::preference].
    pub fn set_preference<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::location_policy_location::Preference>,
    {
        self.preference = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [preference][crate::model::LocationPolicyLocation::preference].
    pub fn set_or_clear_preference<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::location_policy_location::Preference>,
    {
        self.preference = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for LocationPolicyLocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.LocationPolicyLocation"
    }
}

/// Defines additional types related to [LocationPolicyLocation].
#[cfg(feature = "instances")]
pub mod location_policy_location {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [preference][google.cloud.compute.v1.LocationPolicyLocation.preference] field.
    ///
    /// [google.cloud.compute.v1.LocationPolicyLocation.preference]: crate::model::location_policy_location::Preference
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Preference {
        /// Location is allowed for use.
        Allow,
        /// Location is prohibited.
        Deny,
        /// Default value, unused.
        Unspecified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Preference::value] or
        /// [Preference::name].
        UnknownValue(preference::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod preference {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Preference {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Allow => std::option::Option::Some(0),
                Self::Deny => std::option::Option::Some(1),
                Self::Unspecified => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Allow => std::option::Option::Some("ALLOW"),
                Self::Deny => std::option::Option::Some("DENY"),
                Self::Unspecified => std::option::Option::Some("PREFERENCE_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Preference {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Preference {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Preference {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Allow,
                1 => Self::Deny,
                2 => Self::Unspecified,
                _ => Self::UnknownValue(preference::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Preference {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ALLOW" => Self::Allow,
                "DENY" => Self::Deny,
                "PREFERENCE_UNSPECIFIED" => Self::Unspecified,
                _ => Self::UnknownValue(preference::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Preference {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Allow => serializer.serialize_str("ALLOW"),
                Self::Deny => serializer.serialize_str("DENY"),
                Self::Unspecified => serializer.serialize_str("PREFERENCE_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Preference {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Preference>::new(
                ".google.cloud.compute.v1.LocationPolicyLocation.preference",
            ))
        }
    }
}

/// Per-zone constraints on location policy for this zone.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationPolicyLocationConstraints {
    /// Maximum number of items that are allowed to be placed in this zone. The value must be non-negative.
    pub max_count: std::option::Option<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl LocationPolicyLocationConstraints {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [max_count][crate::model::LocationPolicyLocationConstraints::max_count].
    pub fn set_max_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.max_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_count][crate::model::LocationPolicyLocationConstraints::max_count].
    pub fn set_or_clear_max_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.max_count = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for LocationPolicyLocationConstraints {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.LocationPolicyLocationConstraints"
    }
}

/// Represents a Machine Type resource. You can use specific machine types for your VM instances based on performance and pricing requirements. For more information, read Machine Types.
#[cfg(feature = "machine-types")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MachineType {
    /// [Output Only] A list of accelerator configurations assigned to this machine type.
    pub accelerators: std::vec::Vec<crate::model::machine_type::Accelerators>,

    /// [Output Only] The architecture of the machine type.
    pub architecture: std::option::Option<crate::model::machine_type::Architecture>,

    /// [Output Only] Creation timestamp in RFC3339 text format.
    pub creation_timestamp: std::option::Option<std::string::String>,

    /// [Output Only] The deprecation status associated with this machine type. Only applicable if the machine type is unavailable.
    pub deprecated: std::option::Option<crate::model::DeprecationStatus>,

    /// [Output Only] An optional textual description of the resource.
    pub description: std::option::Option<std::string::String>,

    /// [Output Only] The number of virtual CPUs that are available to the instance.
    pub guest_cpus: std::option::Option<i32>,

    /// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
    pub id: std::option::Option<u64>,

    /// [Deprecated] This property is deprecated and will never be populated with any relevant values.
    pub image_space_gb: std::option::Option<i32>,

    /// [Output Only] Whether this machine type has a shared CPU. See Shared-core machine types for more information.
    pub is_shared_cpu: std::option::Option<bool>,

    /// [Output Only] The type of the resource. Always compute#machineType for machine types.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] Maximum persistent disks allowed.
    pub maximum_persistent_disks: std::option::Option<i32>,

    /// [Output Only] Maximum total persistent disks size (GB) allowed.
    pub maximum_persistent_disks_size_gb: std::option::Option<i64>,

    /// [Output Only] The amount of physical memory available to the instance, defined in MB.
    pub memory_mb: std::option::Option<i32>,

    /// [Output Only] Name of the resource.
    pub name: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for the resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] The name of the zone where the machine type resides, such as us-central1-a.
    pub zone: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "machine-types")]
impl MachineType {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [accelerators][crate::model::MachineType::accelerators].
    pub fn set_accelerators<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::machine_type::Accelerators>,
    {
        use std::iter::Iterator;
        self.accelerators = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [architecture][crate::model::MachineType::architecture].
    pub fn set_architecture<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::machine_type::Architecture>,
    {
        self.architecture = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [architecture][crate::model::MachineType::architecture].
    pub fn set_or_clear_architecture<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::machine_type::Architecture>,
    {
        self.architecture = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creation_timestamp][crate::model::MachineType::creation_timestamp].
    pub fn set_creation_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_timestamp][crate::model::MachineType::creation_timestamp].
    pub fn set_or_clear_creation_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deprecated][crate::model::MachineType::deprecated].
    pub fn set_deprecated<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeprecationStatus>,
    {
        self.deprecated = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deprecated][crate::model::MachineType::deprecated].
    pub fn set_or_clear_deprecated<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeprecationStatus>,
    {
        self.deprecated = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::MachineType::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::MachineType::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [guest_cpus][crate::model::MachineType::guest_cpus].
    pub fn set_guest_cpus<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.guest_cpus = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [guest_cpus][crate::model::MachineType::guest_cpus].
    pub fn set_or_clear_guest_cpus<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.guest_cpus = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::MachineType::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::MachineType::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [image_space_gb][crate::model::MachineType::image_space_gb].
    pub fn set_image_space_gb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.image_space_gb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [image_space_gb][crate::model::MachineType::image_space_gb].
    pub fn set_or_clear_image_space_gb<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.image_space_gb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [is_shared_cpu][crate::model::MachineType::is_shared_cpu].
    pub fn set_is_shared_cpu<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.is_shared_cpu = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [is_shared_cpu][crate::model::MachineType::is_shared_cpu].
    pub fn set_or_clear_is_shared_cpu<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.is_shared_cpu = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::MachineType::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::MachineType::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maximum_persistent_disks][crate::model::MachineType::maximum_persistent_disks].
    pub fn set_maximum_persistent_disks<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.maximum_persistent_disks = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maximum_persistent_disks][crate::model::MachineType::maximum_persistent_disks].
    pub fn set_or_clear_maximum_persistent_disks<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.maximum_persistent_disks = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maximum_persistent_disks_size_gb][crate::model::MachineType::maximum_persistent_disks_size_gb].
    pub fn set_maximum_persistent_disks_size_gb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.maximum_persistent_disks_size_gb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maximum_persistent_disks_size_gb][crate::model::MachineType::maximum_persistent_disks_size_gb].
    pub fn set_or_clear_maximum_persistent_disks_size_gb<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.maximum_persistent_disks_size_gb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [memory_mb][crate::model::MachineType::memory_mb].
    pub fn set_memory_mb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.memory_mb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [memory_mb][crate::model::MachineType::memory_mb].
    pub fn set_or_clear_memory_mb<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.memory_mb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::MachineType::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::MachineType::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::MachineType::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::MachineType::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [zone][crate::model::MachineType::zone].
    pub fn set_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [zone][crate::model::MachineType::zone].
    pub fn set_or_clear_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "machine-types")]
impl wkt::message::Message for MachineType {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.MachineType"
    }
}

/// Defines additional types related to [MachineType].
#[cfg(feature = "machine-types")]
pub mod machine_type {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [accelerators][google.cloud.compute.v1.MachineType.accelerators] field.
    ///
    /// [google.cloud.compute.v1.MachineType.accelerators]: crate::model::machine_type::Accelerators
    #[cfg(feature = "machine-types")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Accelerators {
        /// Number of accelerator cards exposed to the guest.
        pub guest_accelerator_count: std::option::Option<i32>,

        /// The accelerator type resource name, not a full URL, e.g. nvidia-tesla-t4.
        pub guest_accelerator_type: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "machine-types")]
    impl Accelerators {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [guest_accelerator_count][crate::model::machine_type::Accelerators::guest_accelerator_count].
        pub fn set_guest_accelerator_count<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.guest_accelerator_count = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [guest_accelerator_count][crate::model::machine_type::Accelerators::guest_accelerator_count].
        pub fn set_or_clear_guest_accelerator_count<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.guest_accelerator_count = v.map(|x| x.into());
            self
        }

        /// Sets the value of [guest_accelerator_type][crate::model::machine_type::Accelerators::guest_accelerator_type].
        pub fn set_guest_accelerator_type<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.guest_accelerator_type = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [guest_accelerator_type][crate::model::machine_type::Accelerators::guest_accelerator_type].
        pub fn set_or_clear_guest_accelerator_type<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.guest_accelerator_type = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "machine-types")]
    impl wkt::message::Message for Accelerators {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.MachineType.accelerators"
        }
    }

    /// The enumerated type for the [architecture][google.cloud.compute.v1.MachineType.architecture] field.
    ///
    /// [google.cloud.compute.v1.MachineType.architecture]: crate::model::machine_type::Architecture
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "machine-types")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Architecture {
        /// Default value indicating Architecture is not set.
        Unspecified,
        /// Machines with architecture ARM64
        Arm64,
        /// Machines with architecture X86_64
        X8664,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Architecture::value] or
        /// [Architecture::name].
        UnknownValue(architecture::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "machine-types")]
    pub mod architecture {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "machine-types")]
    impl Architecture {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Arm64 => std::option::Option::Some(1),
                Self::X8664 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ARCHITECTURE_UNSPECIFIED"),
                Self::Arm64 => std::option::Option::Some("ARM64"),
                Self::X8664 => std::option::Option::Some("X86_64"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "machine-types")]
    impl std::default::Default for Architecture {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "machine-types")]
    impl std::fmt::Display for Architecture {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "machine-types")]
    impl std::convert::From<i32> for Architecture {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Arm64,
                2 => Self::X8664,
                _ => Self::UnknownValue(architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "machine-types")]
    impl std::convert::From<&str> for Architecture {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
                "ARM64" => Self::Arm64,
                "X86_64" => Self::X8664,
                _ => Self::UnknownValue(architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "machine-types")]
    impl serde::ser::Serialize for Architecture {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_str("ARCHITECTURE_UNSPECIFIED"),
                Self::Arm64 => serializer.serialize_str("ARM64"),
                Self::X8664 => serializer.serialize_str("X86_64"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "machine-types")]
    impl<'de> serde::de::Deserialize<'de> for Architecture {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Architecture>::new(
                ".google.cloud.compute.v1.MachineType.architecture",
            ))
        }
    }
}

#[cfg(feature = "machine-types")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MachineTypeAggregatedList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of MachineTypesScopedList resources.
    pub items: std::collections::HashMap<std::string::String, crate::model::MachineTypesScopedList>,

    /// [Output Only] Type of resource. Always compute#machineTypeAggregatedList for aggregated lists of machine types.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Unreachable resources.
    pub unreachables: std::vec::Vec<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::machine_type_aggregated_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "machine-types")]
impl MachineTypeAggregatedList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::MachineTypeAggregatedList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::MachineTypeAggregatedList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::MachineTypeAggregatedList::items].
    pub fn set_items<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::MachineTypesScopedList>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [kind][crate::model::MachineTypeAggregatedList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::MachineTypeAggregatedList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::MachineTypeAggregatedList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::MachineTypeAggregatedList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::MachineTypeAggregatedList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::MachineTypeAggregatedList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [unreachables][crate::model::MachineTypeAggregatedList::unreachables].
    pub fn set_unreachables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachables = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warning][crate::model::MachineTypeAggregatedList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::machine_type_aggregated_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::MachineTypeAggregatedList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::machine_type_aggregated_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "machine-types")]
impl wkt::message::Message for MachineTypeAggregatedList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.MachineTypeAggregatedList"
    }
}

/// Defines additional types related to [MachineTypeAggregatedList].
#[cfg(feature = "machine-types")]
pub mod machine_type_aggregated_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.MachineTypeAggregatedList.warning] field.
    ///
    /// [google.cloud.compute.v1.MachineTypeAggregatedList.warning]: crate::model::machine_type_aggregated_list::Warning
    #[cfg(feature = "machine-types")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
        pub code: std::option::Option<crate::model::machine_type_aggregated_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" }
        pub data: std::vec::Vec<crate::model::machine_type_aggregated_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "machine-types")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::machine_type_aggregated_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::machine_type_aggregated_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::machine_type_aggregated_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::machine_type_aggregated_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::machine_type_aggregated_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::machine_type_aggregated_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::machine_type_aggregated_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::machine_type_aggregated_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "machine-types")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.MachineTypeAggregatedList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "machine-types")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.MachineTypeAggregatedList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.MachineTypeAggregatedList.warning.data]: crate::model::machine_type_aggregated_list::warning::Data
        #[cfg(feature = "machine-types")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "machine-types")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::machine_type_aggregated_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::machine_type_aggregated_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::machine_type_aggregated_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::machine_type_aggregated_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "machine-types")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.MachineTypeAggregatedList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.MachineTypeAggregatedList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.MachineTypeAggregatedList.warning.code]: crate::model::machine_type_aggregated_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "machine-types")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden. Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed which captures the amount of resources filtered out by user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g: regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but its application does not make a lot of sense, because it allows only single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "machine-types")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "machine-types")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.MachineTypeAggregatedList.warning.code",
                ))
            }
        }
    }
}

/// Contains a list of machine types.
#[cfg(feature = "machine-types")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MachineTypeList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of MachineType resources.
    pub items: std::vec::Vec<crate::model::MachineType>,

    /// [Output Only] Type of resource. Always compute#machineTypeList for lists of machine types.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::machine_type_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "machine-types")]
impl MachineTypeList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::MachineTypeList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::MachineTypeList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::MachineTypeList::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MachineType>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::MachineTypeList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::MachineTypeList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::MachineTypeList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::MachineTypeList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::MachineTypeList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::MachineTypeList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::MachineTypeList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::machine_type_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::MachineTypeList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::machine_type_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "machine-types")]
impl wkt::message::Message for MachineTypeList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.MachineTypeList"
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for MachineTypeList {
    type PageItem = crate::model::MachineType;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [MachineTypeList].
#[cfg(feature = "machine-types")]
pub mod machine_type_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.MachineTypeList.warning] field.
    ///
    /// [google.cloud.compute.v1.MachineTypeList.warning]: crate::model::machine_type_list::Warning
    #[cfg(feature = "machine-types")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
        pub code: std::option::Option<crate::model::machine_type_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" }
        pub data: std::vec::Vec<crate::model::machine_type_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "machine-types")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::machine_type_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::machine_type_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::machine_type_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::machine_type_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::machine_type_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::machine_type_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::machine_type_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::machine_type_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "machine-types")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.MachineTypeList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "machine-types")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.MachineTypeList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.MachineTypeList.warning.data]: crate::model::machine_type_list::warning::Data
        #[cfg(feature = "machine-types")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "machine-types")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::machine_type_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::machine_type_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::machine_type_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::machine_type_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "machine-types")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.MachineTypeList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.MachineTypeList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.MachineTypeList.warning.code]: crate::model::machine_type_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "machine-types")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden. Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed which captures the amount of resources filtered out by user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g: regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but its application does not make a lot of sense, because it allows only single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "machine-types")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "machine-types")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.MachineTypeList.warning.code",
                ))
            }
        }
    }
}

#[cfg(feature = "machine-types")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MachineTypesScopedList {
    /// [Output Only] A list of machine types contained in this scope.
    pub machine_types: std::vec::Vec<crate::model::MachineType>,

    /// [Output Only] An informational warning that appears when the machine types list is empty.
    pub warning: std::option::Option<crate::model::machine_types_scoped_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "machine-types")]
impl MachineTypesScopedList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_types][crate::model::MachineTypesScopedList::machine_types].
    pub fn set_machine_types<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MachineType>,
    {
        use std::iter::Iterator;
        self.machine_types = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warning][crate::model::MachineTypesScopedList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::machine_types_scoped_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::MachineTypesScopedList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::machine_types_scoped_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "machine-types")]
impl wkt::message::Message for MachineTypesScopedList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.MachineTypesScopedList"
    }
}

/// Defines additional types related to [MachineTypesScopedList].
#[cfg(feature = "machine-types")]
pub mod machine_types_scoped_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.MachineTypesScopedList.warning] field.
    ///
    /// [google.cloud.compute.v1.MachineTypesScopedList.warning]: crate::model::machine_types_scoped_list::Warning
    #[cfg(feature = "machine-types")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
        pub code: std::option::Option<crate::model::machine_types_scoped_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" }
        pub data: std::vec::Vec<crate::model::machine_types_scoped_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "machine-types")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::machine_types_scoped_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::machine_types_scoped_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::machine_types_scoped_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::machine_types_scoped_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::machine_types_scoped_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::machine_types_scoped_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::machine_types_scoped_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::machine_types_scoped_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "machine-types")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.MachineTypesScopedList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "machine-types")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.MachineTypesScopedList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.MachineTypesScopedList.warning.data]: crate::model::machine_types_scoped_list::warning::Data
        #[cfg(feature = "machine-types")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "machine-types")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::machine_types_scoped_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::machine_types_scoped_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::machine_types_scoped_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::machine_types_scoped_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "machine-types")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.MachineTypesScopedList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.MachineTypesScopedList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.MachineTypesScopedList.warning.code]: crate::model::machine_types_scoped_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "machine-types")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden. Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed which captures the amount of resources filtered out by user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g: regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but its application does not make a lot of sense, because it allows only single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "machine-types")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "machine-types")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "machine-types")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.MachineTypesScopedList.warning.code",
                ))
            }
        }
    }
}

/// A metadata key/value entry.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Metadata {
    /// Specifies a fingerprint for this request, which is essentially a hash of the metadata's contents and used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update metadata. You must always provide an up-to-date fingerprint hash in order to update or change metadata, otherwise the request will fail with error 412 conditionNotMet. To see the latest fingerprint, make a get() request to retrieve the resource.
    pub fingerprint: std::option::Option<::bytes::Bytes>,

    /// Array of key/value pairs. The total size of all keys and values must be less than 512 KB.
    pub items: std::vec::Vec<crate::model::metadata::Items>,

    /// [Output Only] Type of the resource. Always compute#metadata for metadata.
    pub kind: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl Metadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fingerprint][crate::model::Metadata::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::Metadata::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::Metadata::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::metadata::Items>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::Metadata::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::Metadata::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for Metadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Metadata"
    }
}

/// Defines additional types related to [Metadata].
#[cfg(feature = "instances")]
pub mod metadata {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [items][google.cloud.compute.v1.Metadata.items] field.
    ///
    /// [google.cloud.compute.v1.Metadata.items]: crate::model::metadata::Items
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Items {
        /// Key for the metadata entry. Keys must conform to the following regexp: [a-zA-Z0-9-_]+, and be less than 128 bytes in length. This is reflected as part of a URL in the metadata server. Additionally, to avoid ambiguity, keys must not conflict with any other metadata keys for the project.
        pub key: std::option::Option<std::string::String>,

        /// Value for the metadata entry. These are free-form strings, and only have meaning as interpreted by the image running in the instance. The only restriction placed on values is that their size must be less than or equal to 262144 bytes (256 KiB).
        pub value: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl Items {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::metadata::Items::key].
        pub fn set_key<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.key = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [key][crate::model::metadata::Items::key].
        pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.key = v.map(|x| x.into());
            self
        }

        /// Sets the value of [value][crate::model::metadata::Items::value].
        pub fn set_value<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.value = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [value][crate::model::metadata::Items::value].
        pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.value = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "instances")]
    impl wkt::message::Message for Items {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.Metadata.items"
        }
    }
}

/// A network interface resource attached to an instance.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkInterface {
    /// An array of configurations for this interface. Currently, only one access config, ONE_TO_ONE_NAT, is supported. If there are no accessConfigs specified, then this instance will have no external internet access.
    pub access_configs: std::vec::Vec<crate::model::AccessConfig>,

    /// An array of alias IP ranges for this network interface. You can only specify this field for network interfaces in VPC networks.
    pub alias_ip_ranges: std::vec::Vec<crate::model::AliasIpRange>,

    /// Fingerprint hash of contents stored in this network interface. This field will be ignored when inserting an Instance or adding a NetworkInterface. An up-to-date fingerprint must be provided in order to update the NetworkInterface. The request will fail with error 400 Bad Request if the fingerprint is not provided, or 412 Precondition Failed if the fingerprint is out of date.
    pub fingerprint: std::option::Option<::bytes::Bytes>,

    /// The prefix length of the primary internal IPv6 range.
    pub internal_ipv_6_prefix_length: std::option::Option<i32>,

    /// An array of IPv6 access configurations for this interface. Currently, only one IPv6 access config, DIRECT_IPV6, is supported. If there is no ipv6AccessConfig specified, then this instance will have no external IPv6 Internet access.
    pub ipv_6_access_configs: std::vec::Vec<crate::model::AccessConfig>,

    /// [Output Only] One of EXTERNAL, INTERNAL to indicate whether the IP can be accessed from the Internet. This field is always inherited from its subnetwork. Valid only if stackType is IPV4_IPV6.
    pub ipv_6_access_type: std::option::Option<crate::model::network_interface::Ipv6AccessType>,

    /// An IPv6 internal network address for this network interface. To use a static internal IP address, it must be unused and in the same region as the instance's zone. If not specified, Google Cloud will automatically assign an internal IPv6 address from the instance's subnetwork.
    pub ipv_6_address: std::option::Option<std::string::String>,

    /// [Output Only] Type of the resource. Always compute#networkInterface for network interfaces.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] The name of the network interface, which is generated by the server. For a VM, the network interface uses the nicN naming format. Where N is a value between 0 and 7. The default interface value is nic0.
    pub name: std::option::Option<std::string::String>,

    /// URL of the VPC network resource for this instance. When creating an instance, if neither the network nor the subnetwork is specified, the default network global/networks/default is used. If the selected project doesn't have the default network, you must specify a network or subnet. If the network is not specified but the subnetwork is specified, the network is inferred. If you specify this property, you can specify the network as a full or partial URL. For example, the following are all valid URLs: - <https://www.googleapis.com/compute/v1/projects/project/global/networks/> network - projects/project/global/networks/network - global/networks/default
    pub network: std::option::Option<std::string::String>,

    /// The URL of the network attachment that this interface should connect to in the following format: projects/{project_number}/regions/{region_name}/networkAttachments/{network_attachment_name}.
    pub network_attachment: std::option::Option<std::string::String>,

    /// An IPv4 internal IP address to assign to the instance for this network interface. If not specified by the user, an unused internal IP is assigned by the system.
    pub network_ip: std::option::Option<std::string::String>,

    /// The type of vNIC to be used on this interface. This may be gVNIC or VirtioNet.
    pub nic_type: std::option::Option<crate::model::network_interface::NicType>,

    /// Name of the parent network interface of a dynamic network interface.
    pub parent_nic_name: std::option::Option<std::string::String>,

    /// The networking queue count that's specified by users for the network interface. Both Rx and Tx queues will be set to this number. It'll be empty if not specified by the users.
    pub queue_count: std::option::Option<i32>,

    /// The stack type for this network interface. To assign only IPv4 addresses, use IPV4_ONLY. To assign both IPv4 and IPv6 addresses, use IPV4_IPV6. If not specified, IPV4_ONLY is used. This field can be both set at instance creation and update network interface operations.
    pub stack_type: std::option::Option<crate::model::network_interface::StackType>,

    /// The URL of the Subnetwork resource for this instance. If the network resource is in legacy mode, do not specify this field. If the network is in auto subnet mode, specifying the subnetwork is optional. If the network is in custom subnet mode, specifying the subnetwork is required. If you specify this field, you can specify the subnetwork as a full or partial URL. For example, the following are all valid URLs: - <https://www.googleapis.com/compute/v1/projects/project/regions/region> /subnetworks/subnetwork - regions/region/subnetworks/subnetwork
    pub subnetwork: std::option::Option<std::string::String>,

    /// VLAN tag of a dynamic network interface, must be an integer in the range from 2 to 255 inclusively.
    pub vlan: std::option::Option<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl NetworkInterface {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_configs][crate::model::NetworkInterface::access_configs].
    pub fn set_access_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AccessConfig>,
    {
        use std::iter::Iterator;
        self.access_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [alias_ip_ranges][crate::model::NetworkInterface::alias_ip_ranges].
    pub fn set_alias_ip_ranges<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AliasIpRange>,
    {
        use std::iter::Iterator;
        self.alias_ip_ranges = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [fingerprint][crate::model::NetworkInterface::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::NetworkInterface::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [internal_ipv_6_prefix_length][crate::model::NetworkInterface::internal_ipv_6_prefix_length].
    pub fn set_internal_ipv_6_prefix_length<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.internal_ipv_6_prefix_length = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [internal_ipv_6_prefix_length][crate::model::NetworkInterface::internal_ipv_6_prefix_length].
    pub fn set_or_clear_internal_ipv_6_prefix_length<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.internal_ipv_6_prefix_length = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ipv_6_access_configs][crate::model::NetworkInterface::ipv_6_access_configs].
    pub fn set_ipv_6_access_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AccessConfig>,
    {
        use std::iter::Iterator;
        self.ipv_6_access_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [ipv_6_access_type][crate::model::NetworkInterface::ipv_6_access_type].
    pub fn set_ipv_6_access_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::network_interface::Ipv6AccessType>,
    {
        self.ipv_6_access_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ipv_6_access_type][crate::model::NetworkInterface::ipv_6_access_type].
    pub fn set_or_clear_ipv_6_access_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::network_interface::Ipv6AccessType>,
    {
        self.ipv_6_access_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ipv_6_address][crate::model::NetworkInterface::ipv_6_address].
    pub fn set_ipv_6_address<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ipv_6_address = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ipv_6_address][crate::model::NetworkInterface::ipv_6_address].
    pub fn set_or_clear_ipv_6_address<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ipv_6_address = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::NetworkInterface::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::NetworkInterface::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::NetworkInterface::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::NetworkInterface::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network][crate::model::NetworkInterface::network].
    pub fn set_network<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network][crate::model::NetworkInterface::network].
    pub fn set_or_clear_network<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_attachment][crate::model::NetworkInterface::network_attachment].
    pub fn set_network_attachment<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network_attachment = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_attachment][crate::model::NetworkInterface::network_attachment].
    pub fn set_or_clear_network_attachment<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network_attachment = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_ip][crate::model::NetworkInterface::network_ip].
    pub fn set_network_ip<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network_ip = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [network_ip][crate::model::NetworkInterface::network_ip].
    pub fn set_or_clear_network_ip<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.network_ip = v.map(|x| x.into());
        self
    }

    /// Sets the value of [nic_type][crate::model::NetworkInterface::nic_type].
    pub fn set_nic_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::network_interface::NicType>,
    {
        self.nic_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [nic_type][crate::model::NetworkInterface::nic_type].
    pub fn set_or_clear_nic_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::network_interface::NicType>,
    {
        self.nic_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [parent_nic_name][crate::model::NetworkInterface::parent_nic_name].
    pub fn set_parent_nic_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.parent_nic_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [parent_nic_name][crate::model::NetworkInterface::parent_nic_name].
    pub fn set_or_clear_parent_nic_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.parent_nic_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [queue_count][crate::model::NetworkInterface::queue_count].
    pub fn set_queue_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.queue_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [queue_count][crate::model::NetworkInterface::queue_count].
    pub fn set_or_clear_queue_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.queue_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [stack_type][crate::model::NetworkInterface::stack_type].
    pub fn set_stack_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::network_interface::StackType>,
    {
        self.stack_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [stack_type][crate::model::NetworkInterface::stack_type].
    pub fn set_or_clear_stack_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::network_interface::StackType>,
    {
        self.stack_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subnetwork][crate::model::NetworkInterface::subnetwork].
    pub fn set_subnetwork<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subnetwork = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subnetwork][crate::model::NetworkInterface::subnetwork].
    pub fn set_or_clear_subnetwork<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subnetwork = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vlan][crate::model::NetworkInterface::vlan].
    pub fn set_vlan<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.vlan = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vlan][crate::model::NetworkInterface::vlan].
    pub fn set_or_clear_vlan<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.vlan = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for NetworkInterface {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.NetworkInterface"
    }
}

/// Defines additional types related to [NetworkInterface].
#[cfg(feature = "instances")]
pub mod network_interface {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [ipv6AccessType][google.cloud.compute.v1.NetworkInterface.ipv6AccessType] field.
    ///
    /// [google.cloud.compute.v1.NetworkInterface.ipv6AccessType]: crate::model::network_interface::Ipv6AccessType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Ipv6AccessType {
        /// This network interface can have external IPv6.
        External,
        /// This network interface can have internal IPv6.
        Internal,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Ipv6AccessType::value] or
        /// [Ipv6AccessType::name].
        UnknownValue(ipv_6_access_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod ipv_6_access_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Ipv6AccessType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::External => std::option::Option::Some(0),
                Self::Internal => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::External => std::option::Option::Some("EXTERNAL"),
                Self::Internal => std::option::Option::Some("INTERNAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Ipv6AccessType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Ipv6AccessType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Ipv6AccessType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::External,
                1 => Self::Internal,
                _ => Self::UnknownValue(ipv_6_access_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Ipv6AccessType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EXTERNAL" => Self::External,
                "INTERNAL" => Self::Internal,
                _ => Self::UnknownValue(ipv_6_access_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Ipv6AccessType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::External => serializer.serialize_str("EXTERNAL"),
                Self::Internal => serializer.serialize_str("INTERNAL"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Ipv6AccessType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Ipv6AccessType>::new(
                ".google.cloud.compute.v1.NetworkInterface.ipv6AccessType",
            ))
        }
    }

    /// The enumerated type for the [nicType][google.cloud.compute.v1.NetworkInterface.nicType] field.
    ///
    /// [google.cloud.compute.v1.NetworkInterface.nicType]: crate::model::network_interface::NicType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NicType {
        /// GVNIC
        Gvnic,
        /// IDPF
        Idpf,
        /// IRDMA
        Irdma,
        /// MRDMA
        Mrdma,
        /// No type specified.
        UnspecifiedNicType,
        /// VIRTIO
        VirtioNet,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NicType::value] or
        /// [NicType::name].
        UnknownValue(nic_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod nic_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl NicType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Gvnic => std::option::Option::Some(0),
                Self::Idpf => std::option::Option::Some(1),
                Self::Irdma => std::option::Option::Some(2),
                Self::Mrdma => std::option::Option::Some(3),
                Self::UnspecifiedNicType => std::option::Option::Some(4),
                Self::VirtioNet => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Gvnic => std::option::Option::Some("GVNIC"),
                Self::Idpf => std::option::Option::Some("IDPF"),
                Self::Irdma => std::option::Option::Some("IRDMA"),
                Self::Mrdma => std::option::Option::Some("MRDMA"),
                Self::UnspecifiedNicType => std::option::Option::Some("UNSPECIFIED_NIC_TYPE"),
                Self::VirtioNet => std::option::Option::Some("VIRTIO_NET"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for NicType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for NicType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for NicType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Gvnic,
                1 => Self::Idpf,
                2 => Self::Irdma,
                3 => Self::Mrdma,
                4 => Self::UnspecifiedNicType,
                5 => Self::VirtioNet,
                _ => Self::UnknownValue(nic_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for NicType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "GVNIC" => Self::Gvnic,
                "IDPF" => Self::Idpf,
                "IRDMA" => Self::Irdma,
                "MRDMA" => Self::Mrdma,
                "UNSPECIFIED_NIC_TYPE" => Self::UnspecifiedNicType,
                "VIRTIO_NET" => Self::VirtioNet,
                _ => Self::UnknownValue(nic_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for NicType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Gvnic => serializer.serialize_str("GVNIC"),
                Self::Idpf => serializer.serialize_str("IDPF"),
                Self::Irdma => serializer.serialize_str("IRDMA"),
                Self::Mrdma => serializer.serialize_str("MRDMA"),
                Self::UnspecifiedNicType => serializer.serialize_str("UNSPECIFIED_NIC_TYPE"),
                Self::VirtioNet => serializer.serialize_str("VIRTIO_NET"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for NicType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NicType>::new(
                ".google.cloud.compute.v1.NetworkInterface.nicType",
            ))
        }
    }

    /// The enumerated type for the [stackType][google.cloud.compute.v1.NetworkInterface.stackType] field.
    ///
    /// [google.cloud.compute.v1.NetworkInterface.stackType]: crate::model::network_interface::StackType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StackType {
        /// The network interface can have both IPv4 and IPv6 addresses.
        Ipv4Ipv6,
        /// The network interface will only be assigned IPv4 addresses.
        Ipv4Only,
        /// The network interface will only be assigned IPv6 addresses.
        Ipv6Only,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StackType::value] or
        /// [StackType::name].
        UnknownValue(stack_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod stack_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl StackType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Ipv4Ipv6 => std::option::Option::Some(0),
                Self::Ipv4Only => std::option::Option::Some(1),
                Self::Ipv6Only => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Ipv4Ipv6 => std::option::Option::Some("IPV4_IPV6"),
                Self::Ipv4Only => std::option::Option::Some("IPV4_ONLY"),
                Self::Ipv6Only => std::option::Option::Some("IPV6_ONLY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for StackType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for StackType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for StackType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Ipv4Ipv6,
                1 => Self::Ipv4Only,
                2 => Self::Ipv6Only,
                _ => Self::UnknownValue(stack_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for StackType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IPV4_IPV6" => Self::Ipv4Ipv6,
                "IPV4_ONLY" => Self::Ipv4Only,
                "IPV6_ONLY" => Self::Ipv6Only,
                _ => Self::UnknownValue(stack_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for StackType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Ipv4Ipv6 => serializer.serialize_str("IPV4_IPV6"),
                Self::Ipv4Only => serializer.serialize_str("IPV4_ONLY"),
                Self::Ipv6Only => serializer.serialize_str("IPV6_ONLY"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for StackType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StackType>::new(
                ".google.cloud.compute.v1.NetworkInterface.stackType",
            ))
        }
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkPerformanceConfig {
    pub total_egress_bandwidth_tier:
        std::option::Option<crate::model::network_performance_config::TotalEgressBandwidthTier>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl NetworkPerformanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_egress_bandwidth_tier][crate::model::NetworkPerformanceConfig::total_egress_bandwidth_tier].
    pub fn set_total_egress_bandwidth_tier<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::network_performance_config::TotalEgressBandwidthTier>,
    {
        self.total_egress_bandwidth_tier = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [total_egress_bandwidth_tier][crate::model::NetworkPerformanceConfig::total_egress_bandwidth_tier].
    pub fn set_or_clear_total_egress_bandwidth_tier<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::network_performance_config::TotalEgressBandwidthTier>,
    {
        self.total_egress_bandwidth_tier = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for NetworkPerformanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.NetworkPerformanceConfig"
    }
}

/// Defines additional types related to [NetworkPerformanceConfig].
#[cfg(feature = "instances")]
pub mod network_performance_config {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [totalEgressBandwidthTier][google.cloud.compute.v1.NetworkPerformanceConfig.totalEgressBandwidthTier] field.
    ///
    /// [google.cloud.compute.v1.NetworkPerformanceConfig.totalEgressBandwidthTier]: crate::model::network_performance_config::TotalEgressBandwidthTier
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TotalEgressBandwidthTier {
        Default,
        Tier1,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TotalEgressBandwidthTier::value] or
        /// [TotalEgressBandwidthTier::name].
        UnknownValue(total_egress_bandwidth_tier::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod total_egress_bandwidth_tier {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl TotalEgressBandwidthTier {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Default => std::option::Option::Some(0),
                Self::Tier1 => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Default => std::option::Option::Some("DEFAULT"),
                Self::Tier1 => std::option::Option::Some("TIER_1"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for TotalEgressBandwidthTier {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for TotalEgressBandwidthTier {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for TotalEgressBandwidthTier {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Default,
                1 => Self::Tier1,
                _ => Self::UnknownValue(total_egress_bandwidth_tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for TotalEgressBandwidthTier {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DEFAULT" => Self::Default,
                "TIER_1" => Self::Tier1,
                _ => Self::UnknownValue(total_egress_bandwidth_tier::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for TotalEgressBandwidthTier {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Default => serializer.serialize_str("DEFAULT"),
                Self::Tier1 => serializer.serialize_str("TIER_1"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for TotalEgressBandwidthTier {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<TotalEgressBandwidthTier>::new(
                    ".google.cloud.compute.v1.NetworkPerformanceConfig.totalEgressBandwidthTier",
                ),
            )
        }
    }
}

/// Represents an Operation resource. Google Compute Engine has three Operation resources: * [Global](/compute/docs/reference/rest/v1/globalOperations) * [Regional](/compute/docs/reference/rest/v1/regionOperations) * [Zonal](/compute/docs/reference/rest/v1/zoneOperations) You can use an operation resource to manage asynchronous API requests. For more information, read Handling API responses. Operations can be global, regional or zonal. - For global operations, use the `globalOperations` resource. - For regional operations, use the `regionOperations` resource. - For zonal operations, use the `zoneOperations` resource. For more information, read Global, Regional, and Zonal Resources. Note that completed Operation resources have a limited retention period.
#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Operation {
    /// [Output Only] The value of `requestId` if you provided it in the request. Not present otherwise.
    pub client_operation_id: std::option::Option<std::string::String>,

    /// [Deprecated] This field is deprecated.
    pub creation_timestamp: std::option::Option<std::string::String>,

    /// [Output Only] A textual description of the operation, which is set when the operation is created.
    pub description: std::option::Option<std::string::String>,

    /// [Output Only] The time that this operation was completed. This value is in RFC3339 text format.
    pub end_time: std::option::Option<std::string::String>,

    /// [Output Only] If errors are generated during processing of the operation, this field will be populated.
    pub error: std::option::Option<crate::model::operation::Error>,

    /// [Output Only] If the operation fails, this field contains the HTTP error message that was returned, such as `NOT FOUND`.
    pub http_error_message: std::option::Option<std::string::String>,

    /// [Output Only] If the operation fails, this field contains the HTTP error status code that was returned. For example, a `404` means the resource was not found.
    pub http_error_status_code: std::option::Option<i32>,

    /// [Output Only] The unique identifier for the operation. This identifier is defined by the server.
    pub id: std::option::Option<u64>,

    /// [Output Only] The time that this operation was requested. This value is in RFC3339 text format.
    pub insert_time: std::option::Option<std::string::String>,

    pub instances_bulk_insert_operation_metadata:
        std::option::Option<crate::model::InstancesBulkInsertOperationMetadata>,

    /// [Output Only] Type of the resource. Always `compute#operation` for Operation resources.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] Name of the operation.
    pub name: std::option::Option<std::string::String>,

    /// [Output Only] An ID that represents a group of operations, such as when a group of operations results from a `bulkInsert` API request.
    pub operation_group_id: std::option::Option<std::string::String>,

    /// [Output Only] The type of operation, such as `insert`, `update`, or `delete`, and so on.
    pub operation_type: std::option::Option<std::string::String>,

    /// [Output Only] An optional progress indicator that ranges from 0 to 100. There is no requirement that this be linear or support any granularity of operations. This should not be used to guess when the operation will be complete. This number should monotonically increase as the operation progresses.
    pub progress: std::option::Option<i32>,

    /// [Output Only] The URL of the region where the operation resides. Only applicable when performing regional operations.
    pub region: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for the resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] If the operation is for projects.setCommonInstanceMetadata, this field will contain information on all underlying zonal actions and their state.
    pub set_common_instance_metadata_operation_metadata:
        std::option::Option<crate::model::SetCommonInstanceMetadataOperationMetadata>,

    /// [Output Only] The time that this operation was started by the server. This value is in RFC3339 text format.
    pub start_time: std::option::Option<std::string::String>,

    /// [Output Only] The status of the operation, which can be one of the following: `PENDING`, `RUNNING`, or `DONE`.
    pub status: std::option::Option<crate::model::operation::Status>,

    /// [Output Only] An optional textual description of the current status of the operation.
    pub status_message: std::option::Option<std::string::String>,

    /// [Output Only] The unique target ID, which identifies a specific incarnation of the target resource.
    pub target_id: std::option::Option<u64>,

    /// [Output Only] The URL of the resource that the operation modifies. For operations related to creating a snapshot, this points to the disk that the snapshot was created from.
    pub target_link: std::option::Option<std::string::String>,

    /// [Output Only] User who requested the operation, for example: `user@example.com` or `alice_smith_identifier (global/workforcePools/example-com-us-employees)`.
    pub user: std::option::Option<std::string::String>,

    /// [Output Only] If warning messages are generated during processing of the operation, this field will be populated.
    pub warnings: std::vec::Vec<crate::model::operation::Warnings>,

    /// [Output Only] The URL of the zone where the operation resides. Only applicable when performing per-zone operations.
    pub zone: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl Operation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [client_operation_id][crate::model::Operation::client_operation_id].
    pub fn set_client_operation_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.client_operation_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_operation_id][crate::model::Operation::client_operation_id].
    pub fn set_or_clear_client_operation_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.client_operation_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [creation_timestamp][crate::model::Operation::creation_timestamp].
    pub fn set_creation_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_timestamp][crate::model::Operation::creation_timestamp].
    pub fn set_or_clear_creation_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::Operation::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::Operation::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::Operation::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::Operation::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::Operation::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::operation::Error>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::Operation::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::operation::Error>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [http_error_message][crate::model::Operation::http_error_message].
    pub fn set_http_error_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.http_error_message = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [http_error_message][crate::model::Operation::http_error_message].
    pub fn set_or_clear_http_error_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.http_error_message = v.map(|x| x.into());
        self
    }

    /// Sets the value of [http_error_status_code][crate::model::Operation::http_error_status_code].
    pub fn set_http_error_status_code<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.http_error_status_code = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [http_error_status_code][crate::model::Operation::http_error_status_code].
    pub fn set_or_clear_http_error_status_code<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.http_error_status_code = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::Operation::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::Operation::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [insert_time][crate::model::Operation::insert_time].
    pub fn set_insert_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.insert_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [insert_time][crate::model::Operation::insert_time].
    pub fn set_or_clear_insert_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.insert_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instances_bulk_insert_operation_metadata][crate::model::Operation::instances_bulk_insert_operation_metadata].
    pub fn set_instances_bulk_insert_operation_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstancesBulkInsertOperationMetadata>,
    {
        self.instances_bulk_insert_operation_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instances_bulk_insert_operation_metadata][crate::model::Operation::instances_bulk_insert_operation_metadata].
    pub fn set_or_clear_instances_bulk_insert_operation_metadata<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::InstancesBulkInsertOperationMetadata>,
    {
        self.instances_bulk_insert_operation_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::Operation::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::Operation::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::Operation::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::Operation::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operation_group_id][crate::model::Operation::operation_group_id].
    pub fn set_operation_group_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.operation_group_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [operation_group_id][crate::model::Operation::operation_group_id].
    pub fn set_or_clear_operation_group_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.operation_group_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operation_type][crate::model::Operation::operation_type].
    pub fn set_operation_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.operation_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [operation_type][crate::model::Operation::operation_type].
    pub fn set_or_clear_operation_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.operation_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress][crate::model::Operation::progress].
    pub fn set_progress<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.progress = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [progress][crate::model::Operation::progress].
    pub fn set_or_clear_progress<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.progress = v.map(|x| x.into());
        self
    }

    /// Sets the value of [region][crate::model::Operation::region].
    pub fn set_region<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.region = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [region][crate::model::Operation::region].
    pub fn set_or_clear_region<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.region = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::Operation::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::Operation::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [set_common_instance_metadata_operation_metadata][crate::model::Operation::set_common_instance_metadata_operation_metadata].
    pub fn set_set_common_instance_metadata_operation_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SetCommonInstanceMetadataOperationMetadata>,
    {
        self.set_common_instance_metadata_operation_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [set_common_instance_metadata_operation_metadata][crate::model::Operation::set_common_instance_metadata_operation_metadata].
    pub fn set_or_clear_set_common_instance_metadata_operation_metadata<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::SetCommonInstanceMetadataOperationMetadata>,
    {
        self.set_common_instance_metadata_operation_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::Operation::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Operation::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::Operation::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::operation::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::Operation::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::operation::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status_message][crate::model::Operation::status_message].
    pub fn set_status_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.status_message = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status_message][crate::model::Operation::status_message].
    pub fn set_or_clear_status_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.status_message = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_id][crate::model::Operation::target_id].
    pub fn set_target_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.target_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_id][crate::model::Operation::target_id].
    pub fn set_or_clear_target_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.target_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_link][crate::model::Operation::target_link].
    pub fn set_target_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.target_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_link][crate::model::Operation::target_link].
    pub fn set_or_clear_target_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.target_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [user][crate::model::Operation::user].
    pub fn set_user<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.user = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [user][crate::model::Operation::user].
    pub fn set_or_clear_user<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.user = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warnings][crate::model::Operation::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::operation::Warnings>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [zone][crate::model::Operation::zone].
    pub fn set_zone<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [zone][crate::model::Operation::zone].
    pub fn set_or_clear_zone<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.zone = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl wkt::message::Message for Operation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Operation"
    }
}

/// Defines additional types related to [Operation].
#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
pub mod operation {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [error][google.cloud.compute.v1.Operation.error] field.
    ///
    /// [google.cloud.compute.v1.Operation.error]: crate::model::operation::Error
    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Error {
        /// [Output Only] The array of errors encountered while processing this operation.
        pub errors: std::vec::Vec<crate::model::operation::error::Errors>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl Error {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [errors][crate::model::operation::Error::errors].
        pub fn set_errors<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::operation::error::Errors>,
        {
            use std::iter::Iterator;
            self.errors = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl wkt::message::Message for Error {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.Operation.error"
        }
    }

    /// Defines additional types related to [Error].
    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    pub mod error {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [errors][google.cloud.compute.v1.Operation.error.errors] field.
        ///
        /// [google.cloud.compute.v1.Operation.error.errors]: crate::model::operation::error::Errors
        #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Errors {
            /// [Output Only] The error type identifier for this error.
            pub code: std::option::Option<std::string::String>,

            /// [Output Only] An optional list of messages that contain the error details. There is a set of defined message types to use for providing details.The syntax depends on the error code. For example, QuotaExceededInfo will have details when the error code is QUOTA_EXCEEDED.
            pub error_details: std::vec::Vec<crate::model::operation::error::errors::ErrorDetails>,

            /// [Output Only] Indicates the field in the request that caused the error. This property is optional.
            pub location: std::option::Option<std::string::String>,

            /// [Output Only] An optional, human-readable error message.
            pub message: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
        impl Errors {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [code][crate::model::operation::error::Errors::code].
            pub fn set_code<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.code = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [code][crate::model::operation::error::Errors::code].
            pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.code = v.map(|x| x.into());
                self
            }

            /// Sets the value of [error_details][crate::model::operation::error::Errors::error_details].
            pub fn set_error_details<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<crate::model::operation::error::errors::ErrorDetails>,
            {
                use std::iter::Iterator;
                self.error_details = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [location][crate::model::operation::error::Errors::location].
            pub fn set_location<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.location = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [location][crate::model::operation::error::Errors::location].
            pub fn set_or_clear_location<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.location = v.map(|x| x.into());
                self
            }

            /// Sets the value of [message][crate::model::operation::error::Errors::message].
            pub fn set_message<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.message = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [message][crate::model::operation::error::Errors::message].
            pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.message = v.map(|x| x.into());
                self
            }
        }

        #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
        impl wkt::message::Message for Errors {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.Operation.error.errors"
            }
        }

        /// Defines additional types related to [Errors].
        #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
        pub mod errors {
            #[allow(unused_imports)]
            use super::*;

            /// The message type for the [errorDetails][google.cloud.compute.v1.Operation.error.errors.errorDetails] field.
            ///
            /// [google.cloud.compute.v1.Operation.error.errors.errorDetails]: crate::model::operation::error::errors::ErrorDetails
            #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ErrorDetails {
                pub error_info: std::option::Option<crate::model::ErrorInfo>,

                pub help: std::option::Option<crate::model::Help>,

                pub localized_message: std::option::Option<crate::model::LocalizedMessage>,

                pub quota_info: std::option::Option<crate::model::QuotaExceededInfo>,

                pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
            impl ErrorDetails {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [error_info][crate::model::operation::error::errors::ErrorDetails::error_info].
                pub fn set_error_info<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::ErrorInfo>,
                {
                    self.error_info = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [error_info][crate::model::operation::error::errors::ErrorDetails::error_info].
                pub fn set_or_clear_error_info<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::ErrorInfo>,
                {
                    self.error_info = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [help][crate::model::operation::error::errors::ErrorDetails::help].
                pub fn set_help<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::Help>,
                {
                    self.help = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [help][crate::model::operation::error::errors::ErrorDetails::help].
                pub fn set_or_clear_help<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::Help>,
                {
                    self.help = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [localized_message][crate::model::operation::error::errors::ErrorDetails::localized_message].
                pub fn set_localized_message<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::LocalizedMessage>,
                {
                    self.localized_message = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [localized_message][crate::model::operation::error::errors::ErrorDetails::localized_message].
                pub fn set_or_clear_localized_message<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<crate::model::LocalizedMessage>,
                {
                    self.localized_message = v.map(|x| x.into());
                    self
                }

                /// Sets the value of [quota_info][crate::model::operation::error::errors::ErrorDetails::quota_info].
                pub fn set_quota_info<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<crate::model::QuotaExceededInfo>,
                {
                    self.quota_info = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [quota_info][crate::model::operation::error::errors::ErrorDetails::quota_info].
                pub fn set_or_clear_quota_info<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<crate::model::QuotaExceededInfo>,
                {
                    self.quota_info = v.map(|x| x.into());
                    self
                }
            }

            #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
            impl wkt::message::Message for ErrorDetails {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.compute.v1.Operation.error.errors.errorDetails"
                }
            }
        }
    }

    /// The message type for the [warnings][google.cloud.compute.v1.Operation.warnings] field.
    ///
    /// [google.cloud.compute.v1.Operation.warnings]: crate::model::operation::Warnings
    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warnings {
        /// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
        pub code: std::option::Option<crate::model::operation::warnings::Code>,

        /// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" }
        pub data: std::vec::Vec<crate::model::operation::warnings::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl Warnings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::operation::Warnings::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::operation::warnings::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::operation::Warnings::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::operation::warnings::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::operation::Warnings::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::operation::warnings::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::operation::Warnings::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::operation::Warnings::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl wkt::message::Message for Warnings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.Operation.warnings"
        }
    }

    /// Defines additional types related to [Warnings].
    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    pub mod warnings {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.Operation.warnings.data] field.
        ///
        /// [google.cloud.compute.v1.Operation.warnings.data]: crate::model::operation::warnings::Data
        #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::operation::warnings::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::operation::warnings::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::operation::warnings::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::operation::warnings::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.Operation.warnings.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.Operation.warnings.code] field.
        ///
        /// [google.cloud.compute.v1.Operation.warnings.code]: crate::model::operation::warnings::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden. Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed which captures the amount of resources filtered out by user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g: regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but its application does not make a lot of sense, because it allows only single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.Operation.warnings.code",
                ))
            }
        }
    }

    /// The enumerated type for the [status][google.cloud.compute.v1.Operation.status] field.
    ///
    /// [google.cloud.compute.v1.Operation.status]: crate::model::operation::Status
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        Done,
        Pending,
        Running,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Done => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Done => std::option::Option::Some("DONE"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Done,
                1 => Self::Pending,
                2 => Self::Running,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DONE" => Self::Done,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Done => serializer.serialize_str("DONE"),
                Self::Pending => serializer.serialize_str("PENDING"),
                Self::Running => serializer.serialize_str("RUNNING"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.cloud.compute.v1.Operation.status",
            ))
        }
    }
}

/// Contains a list of Operation resources.
#[cfg(feature = "zone-operations")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationList {
    /// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// [Output Only] A list of Operation resources.
    pub items: std::vec::Vec<crate::model::Operation>,

    /// [Output Only] Type of resource. Always `compute#operations` for Operations resource.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than `maxResults`, use the `nextPageToken` as a value for the query parameter `pageToken` in the next list request. Subsequent list requests will have their own `nextPageToken` to continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::operation_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "zone-operations")]
impl OperationList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::OperationList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::OperationList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::OperationList::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Operation>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::OperationList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::OperationList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::OperationList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::OperationList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::OperationList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::OperationList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::OperationList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::operation_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::OperationList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::operation_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "zone-operations")]
impl wkt::message::Message for OperationList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.OperationList"
    }
}

#[cfg(feature = "zone-operations")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for OperationList {
    type PageItem = crate::model::Operation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [OperationList].
#[cfg(feature = "zone-operations")]
pub mod operation_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.OperationList.warning] field.
    ///
    /// [google.cloud.compute.v1.OperationList.warning]: crate::model::operation_list::Warning
    #[cfg(feature = "zone-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
        pub code: std::option::Option<crate::model::operation_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" }
        pub data: std::vec::Vec<crate::model::operation_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "zone-operations")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::operation_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::operation_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::operation_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::operation_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::operation_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::operation_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::operation_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::operation_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "zone-operations")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.OperationList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "zone-operations")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.OperationList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.OperationList.warning.data]: crate::model::operation_list::warning::Data
        #[cfg(feature = "zone-operations")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "zone-operations")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::operation_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::operation_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::operation_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::operation_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "zone-operations")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.OperationList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.OperationList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.OperationList.warning.code]: crate::model::operation_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "zone-operations")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden. Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed which captures the amount of resources filtered out by user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g: regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but its application does not make a lot of sense, because it allows only single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "zone-operations")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "zone-operations")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "zone-operations")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "zone-operations")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "zone-operations")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "zone-operations")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "zone-operations")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "zone-operations")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.OperationList.warning.code",
                ))
            }
        }
    }
}

/// An Identity and Access Management (IAM) policy, which specifies access controls for Google Cloud resources. A `Policy` is a collection of `bindings`. A `binding` binds one or more `members`, or principals, to a single `role`. Principals can be user accounts, service accounts, Google groups, and domains (such as G Suite). A `role` is a named list of permissions; each `role` can be an IAM predefined role or a user-created custom role. For some types of Google Cloud resources, a `binding` can also specify a `condition`, which is a logical expression that allows access to a resource only if the expression evaluates to `true`. A condition can add constraints based on attributes of the request, the resource, or both. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies). **JSON example:** ``` { "bindings": [ { "role": "roles/resourcemanager.organizationAdmin", "members": [ "user:mike@example.com", "group:admins@example.com", "domain:google.com", "serviceAccount:my-project-id@appspot.gserviceaccount.com" ] }, { "role": "roles/resourcemanager.organizationViewer", "members": [ "user:eve@example.com" ], "condition": { "title": "expirable access", "description": "Does not grant access after Sep 2020", "expression": "request.time < timestamp('2020-10-01T00:00:00.000Z')", } } ], "etag": "BwWWja0YfJA=", "version": 3 } ``` **YAML example:** ``` bindings: - members: - user:mike@example.com - group:admins@example.com - domain:google.com - serviceAccount:my-project-id@appspot.gserviceaccount.com role: roles/resourcemanager.organizationAdmin - members: - user:eve@example.com role: roles/resourcemanager.organizationViewer condition: title: expirable access description: Does not grant access after Sep 2020 expression: request.time < timestamp('2020-10-01T00:00:00.000Z') etag: BwWWja0YfJA= version: 3 ``` For a description of IAM and its features, see the [IAM documentation](https://cloud.google.com/iam/docs/).
#[cfg(any(feature = "images", feature = "instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Policy {
    /// Specifies cloud audit logging configuration for this policy.
    pub audit_configs: std::vec::Vec<crate::model::AuditConfig>,

    /// Associates a list of `members`, or principals, with a `role`. Optionally, may specify a `condition` that determines how and when the `bindings` are applied. Each of the `bindings` must contain at least one principal. The `bindings` in a `Policy` can refer to up to 1,500 principals; up to 250 of these principals can be Google groups. Each occurrence of a principal counts towards these limits. For example, if the `bindings` grant 50 different roles to `user:alice@example.com`, and not to any other principal, then you can add another 1,450 principals to the `bindings` in the `Policy`.
    pub bindings: std::vec::Vec<crate::model::Binding>,

    /// `etag` is used for optimistic concurrency control as a way to help prevent simultaneous updates of a policy from overwriting each other. It is strongly suggested that systems make use of the `etag` in the read-modify-write cycle to perform policy updates in order to avoid race conditions: An `etag` is returned in the response to `getIamPolicy`, and systems are expected to put that etag in the request to `setIamPolicy` to ensure that their change will be applied to the same version of the policy. **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost.
    pub etag: std::option::Option<::bytes::Bytes>,

    /// Specifies the format of the policy. Valid values are `0`, `1`, and `3`. Requests that specify an invalid value are rejected. Any operation that affects conditional role bindings must specify version `3`. This requirement applies to the following operations: * Getting a policy that includes a conditional role binding * Adding a conditional role binding to a policy * Changing a conditional role binding in a policy * Removing any role binding, with or without a condition, from a policy that includes conditions **Important:** If you use IAM Conditions, you must include the `etag` field whenever you call `setIamPolicy`. If you omit this field, then IAM allows you to overwrite a version `3` policy with a version `1` policy, and all of the conditions in the version `3` policy are lost. If a policy does not include any conditions, operations on that policy may specify any valid version or leave the field unset. To learn which resources support conditions in their IAM policies, see the [IAM documentation](https://cloud.google.com/iam/help/conditions/resource-policies).
    pub version: std::option::Option<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances",))]
impl Policy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [audit_configs][crate::model::Policy::audit_configs].
    pub fn set_audit_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AuditConfig>,
    {
        use std::iter::Iterator;
        self.audit_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [bindings][crate::model::Policy::bindings].
    pub fn set_bindings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Binding>,
    {
        use std::iter::Iterator;
        self.bindings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [etag][crate::model::Policy::etag].
    pub fn set_etag<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.etag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [etag][crate::model::Policy::etag].
    pub fn set_or_clear_etag<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.etag = v.map(|x| x.into());
        self
    }

    /// Sets the value of [version][crate::model::Policy::version].
    pub fn set_version<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.version = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [version][crate::model::Policy::version].
    pub fn set_or_clear_version<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.version = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
impl wkt::message::Message for Policy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Policy"
    }
}

/// Additional details for quota exceeded error for resource quota.
#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct QuotaExceededInfo {
    /// The map holding related quota dimensions.
    pub dimensions: std::collections::HashMap<std::string::String, std::string::String>,

    /// Future quota limit being rolled out. The limit's unit depends on the quota type or metric.
    pub future_limit: std::option::Option<f64>,

    /// Current effective quota limit. The limit's unit depends on the quota type or metric.
    pub limit: std::option::Option<f64>,

    /// The name of the quota limit.
    pub limit_name: std::option::Option<std::string::String>,

    /// The Compute Engine quota metric name.
    pub metric_name: std::option::Option<std::string::String>,

    /// Rollout status of the future quota limit.
    pub rollout_status: std::option::Option<crate::model::quota_exceeded_info::RolloutStatus>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl QuotaExceededInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [dimensions][crate::model::QuotaExceededInfo::dimensions].
    pub fn set_dimensions<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.dimensions = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [future_limit][crate::model::QuotaExceededInfo::future_limit].
    pub fn set_future_limit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.future_limit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [future_limit][crate::model::QuotaExceededInfo::future_limit].
    pub fn set_or_clear_future_limit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.future_limit = v.map(|x| x.into());
        self
    }

    /// Sets the value of [limit][crate::model::QuotaExceededInfo::limit].
    pub fn set_limit<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.limit = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [limit][crate::model::QuotaExceededInfo::limit].
    pub fn set_or_clear_limit<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.limit = v.map(|x| x.into());
        self
    }

    /// Sets the value of [limit_name][crate::model::QuotaExceededInfo::limit_name].
    pub fn set_limit_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.limit_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [limit_name][crate::model::QuotaExceededInfo::limit_name].
    pub fn set_or_clear_limit_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.limit_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [metric_name][crate::model::QuotaExceededInfo::metric_name].
    pub fn set_metric_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.metric_name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [metric_name][crate::model::QuotaExceededInfo::metric_name].
    pub fn set_or_clear_metric_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.metric_name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [rollout_status][crate::model::QuotaExceededInfo::rollout_status].
    pub fn set_rollout_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::quota_exceeded_info::RolloutStatus>,
    {
        self.rollout_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rollout_status][crate::model::QuotaExceededInfo::rollout_status].
    pub fn set_or_clear_rollout_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::quota_exceeded_info::RolloutStatus>,
    {
        self.rollout_status = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl wkt::message::Message for QuotaExceededInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.QuotaExceededInfo"
    }
}

/// Defines additional types related to [QuotaExceededInfo].
#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
pub mod quota_exceeded_info {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [rolloutStatus][google.cloud.compute.v1.QuotaExceededInfo.rolloutStatus] field.
    ///
    /// [google.cloud.compute.v1.QuotaExceededInfo.rolloutStatus]: crate::model::quota_exceeded_info::RolloutStatus
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RolloutStatus {
        /// IN_PROGRESS - A rollout is in process which will change the limit value to future limit.
        InProgress,
        /// ROLLOUT_STATUS_UNSPECIFIED - Rollout status is not specified. The default value.
        Unspecified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RolloutStatus::value] or
        /// [RolloutStatus::name].
        UnknownValue(rollout_status::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    pub mod rollout_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl RolloutStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::InProgress => std::option::Option::Some(0),
                Self::Unspecified => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::InProgress => std::option::Option::Some("IN_PROGRESS"),
                Self::Unspecified => std::option::Option::Some("ROLLOUT_STATUS_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl std::default::Default for RolloutStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl std::fmt::Display for RolloutStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl std::convert::From<i32> for RolloutStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::InProgress,
                1 => Self::Unspecified,
                _ => Self::UnknownValue(rollout_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl std::convert::From<&str> for RolloutStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IN_PROGRESS" => Self::InProgress,
                "ROLLOUT_STATUS_UNSPECIFIED" => Self::Unspecified,
                _ => Self::UnknownValue(rollout_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl serde::ser::Serialize for RolloutStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::InProgress => serializer.serialize_str("IN_PROGRESS"),
                Self::Unspecified => serializer.serialize_str("ROLLOUT_STATUS_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl<'de> serde::de::Deserialize<'de> for RolloutStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RolloutStatus>::new(
                ".google.cloud.compute.v1.QuotaExceededInfo.rolloutStatus",
            ))
        }
    }
}

/// Represents a reference to a resource.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Reference {
    /// [Output Only] Type of the resource. Always compute#reference for references.
    pub kind: std::option::Option<std::string::String>,

    /// A description of the reference type with no implied semantics. Possible values include: 1. MEMBER_OF
    pub reference_type: std::option::Option<std::string::String>,

    /// URL of the resource which refers to the target.
    pub referrer: std::option::Option<std::string::String>,

    /// URL of the resource to which this reference points.
    pub target: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl Reference {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kind][crate::model::Reference::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::Reference::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [reference_type][crate::model::Reference::reference_type].
    pub fn set_reference_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.reference_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [reference_type][crate::model::Reference::reference_type].
    pub fn set_or_clear_reference_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.reference_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [referrer][crate::model::Reference::referrer].
    pub fn set_referrer<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.referrer = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [referrer][crate::model::Reference::referrer].
    pub fn set_or_clear_referrer<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.referrer = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::Reference::target].
    pub fn set_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target][crate::model::Reference::target].
    pub fn set_or_clear_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.target = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for Reference {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Reference"
    }
}

/// Specifies the reservations that this instance can consume from.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReservationAffinity {
    /// Specifies the type of reservation from which this instance can consume resources: ANY_RESERVATION (default), SPECIFIC_RESERVATION, or NO_RESERVATION. See Consuming reserved instances for examples.
    pub consume_reservation_type:
        std::option::Option<crate::model::reservation_affinity::ConsumeReservationType>,

    /// Corresponds to the label key of a reservation resource. To target a SPECIFIC_RESERVATION by name, specify googleapis.com/reservation-name as the key and specify the name of your reservation as its value.
    pub key: std::option::Option<std::string::String>,

    /// Corresponds to the label values of a reservation resource. This can be either a name to a reservation in the same project or "projects/different-project/reservations/some-reservation-name" to target a shared reservation in the same zone but in a different project.
    pub values: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ReservationAffinity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [consume_reservation_type][crate::model::ReservationAffinity::consume_reservation_type].
    pub fn set_consume_reservation_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::reservation_affinity::ConsumeReservationType>,
    {
        self.consume_reservation_type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [consume_reservation_type][crate::model::ReservationAffinity::consume_reservation_type].
    pub fn set_or_clear_consume_reservation_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::reservation_affinity::ConsumeReservationType>,
    {
        self.consume_reservation_type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [key][crate::model::ReservationAffinity::key].
    pub fn set_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key][crate::model::ReservationAffinity::key].
    pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [values][crate::model::ReservationAffinity::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ReservationAffinity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ReservationAffinity"
    }
}

/// Defines additional types related to [ReservationAffinity].
#[cfg(feature = "instances")]
pub mod reservation_affinity {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [consumeReservationType][google.cloud.compute.v1.ReservationAffinity.consumeReservationType] field.
    ///
    /// [google.cloud.compute.v1.ReservationAffinity.consumeReservationType]: crate::model::reservation_affinity::ConsumeReservationType
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ConsumeReservationType {
        /// Consume any allocation available.
        AnyReservation,
        /// Do not consume from any allocated capacity.
        NoReservation,
        /// Must consume from a specific reservation. Must specify key value fields for specifying the reservations.
        SpecificReservation,
        Unspecified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ConsumeReservationType::value] or
        /// [ConsumeReservationType::name].
        UnknownValue(consume_reservation_type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod consume_reservation_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl ConsumeReservationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::AnyReservation => std::option::Option::Some(0),
                Self::NoReservation => std::option::Option::Some(1),
                Self::SpecificReservation => std::option::Option::Some(2),
                Self::Unspecified => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::AnyReservation => std::option::Option::Some("ANY_RESERVATION"),
                Self::NoReservation => std::option::Option::Some("NO_RESERVATION"),
                Self::SpecificReservation => std::option::Option::Some("SPECIFIC_RESERVATION"),
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for ConsumeReservationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for ConsumeReservationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for ConsumeReservationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::AnyReservation,
                1 => Self::NoReservation,
                2 => Self::SpecificReservation,
                3 => Self::Unspecified,
                _ => Self::UnknownValue(consume_reservation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for ConsumeReservationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ANY_RESERVATION" => Self::AnyReservation,
                "NO_RESERVATION" => Self::NoReservation,
                "SPECIFIC_RESERVATION" => Self::SpecificReservation,
                "UNSPECIFIED" => Self::Unspecified,
                _ => Self::UnknownValue(consume_reservation_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for ConsumeReservationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::AnyReservation => serializer.serialize_str("ANY_RESERVATION"),
                Self::NoReservation => serializer.serialize_str("NO_RESERVATION"),
                Self::SpecificReservation => serializer.serialize_str("SPECIFIC_RESERVATION"),
                Self::Unspecified => serializer.serialize_str("UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for ConsumeReservationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConsumeReservationType>::new(
                ".google.cloud.compute.v1.ReservationAffinity.consumeReservationType",
            ))
        }
    }
}

/// Contains output only fields. Use this sub-message for actual values set on Instance attributes as compared to the value requested by the user (intent) in their instance CRUD calls.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceStatus {
    /// [Output Only] Effective metadata is a field that consolidates project, zonal instance settings, and instance-level predefined metadata keys to provide the overridden value for those metadata keys at the instance level.
    pub effective_instance_metadata:
        std::option::Option<crate::model::ResourceStatusEffectiveInstanceMetadata>,

    /// [Output Only] The precise location of your instance within the zone's data center, including the block, sub-block, and host. The field is formatted as follows: blockId/subBlockId/hostId.
    pub physical_host: std::option::Option<std::string::String>,

    /// [Output Only] A series of fields containing the global name of the Compute Engine cluster, as well as the ID of the block, sub-block, and host on which the running instance is located.
    pub physical_host_topology:
        std::option::Option<crate::model::ResourceStatusPhysicalHostTopology>,

    pub scheduling: std::option::Option<crate::model::ResourceStatusScheduling>,

    pub upcoming_maintenance: std::option::Option<crate::model::UpcomingMaintenance>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ResourceStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [effective_instance_metadata][crate::model::ResourceStatus::effective_instance_metadata].
    pub fn set_effective_instance_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceStatusEffectiveInstanceMetadata>,
    {
        self.effective_instance_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [effective_instance_metadata][crate::model::ResourceStatus::effective_instance_metadata].
    pub fn set_or_clear_effective_instance_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourceStatusEffectiveInstanceMetadata>,
    {
        self.effective_instance_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [physical_host][crate::model::ResourceStatus::physical_host].
    pub fn set_physical_host<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.physical_host = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [physical_host][crate::model::ResourceStatus::physical_host].
    pub fn set_or_clear_physical_host<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.physical_host = v.map(|x| x.into());
        self
    }

    /// Sets the value of [physical_host_topology][crate::model::ResourceStatus::physical_host_topology].
    pub fn set_physical_host_topology<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceStatusPhysicalHostTopology>,
    {
        self.physical_host_topology = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [physical_host_topology][crate::model::ResourceStatus::physical_host_topology].
    pub fn set_or_clear_physical_host_topology<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourceStatusPhysicalHostTopology>,
    {
        self.physical_host_topology = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scheduling][crate::model::ResourceStatus::scheduling].
    pub fn set_scheduling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ResourceStatusScheduling>,
    {
        self.scheduling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [scheduling][crate::model::ResourceStatus::scheduling].
    pub fn set_or_clear_scheduling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ResourceStatusScheduling>,
    {
        self.scheduling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [upcoming_maintenance][crate::model::ResourceStatus::upcoming_maintenance].
    pub fn set_upcoming_maintenance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UpcomingMaintenance>,
    {
        self.upcoming_maintenance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [upcoming_maintenance][crate::model::ResourceStatus::upcoming_maintenance].
    pub fn set_or_clear_upcoming_maintenance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UpcomingMaintenance>,
    {
        self.upcoming_maintenance = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ResourceStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ResourceStatus"
    }
}

/// Effective values of predefined metadata keys for an instance.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceStatusEffectiveInstanceMetadata {
    /// Effective block-project-ssh-keys value at Instance level.
    pub block_project_ssh_keys_metadata_value: std::option::Option<bool>,

    /// Effective enable-guest-attributes value at Instance level.
    pub enable_guest_attributes_metadata_value: std::option::Option<bool>,

    /// Effective enable-os-inventory value at Instance level.
    pub enable_os_inventory_metadata_value: std::option::Option<bool>,

    /// Effective enable-osconfig value at Instance level.
    pub enable_osconfig_metadata_value: std::option::Option<bool>,

    /// Effective enable-oslogin value at Instance level.
    pub enable_oslogin_metadata_value: std::option::Option<bool>,

    /// Effective serial-port-enable value at Instance level.
    pub serial_port_enable_metadata_value: std::option::Option<bool>,

    /// Effective serial-port-logging-enable value at Instance level.
    pub serial_port_logging_enable_metadata_value: std::option::Option<bool>,

    /// Effective VM DNS setting at Instance level.
    pub vm_dns_setting_metadata_value: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ResourceStatusEffectiveInstanceMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [block_project_ssh_keys_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::block_project_ssh_keys_metadata_value].
    pub fn set_block_project_ssh_keys_metadata_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.block_project_ssh_keys_metadata_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [block_project_ssh_keys_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::block_project_ssh_keys_metadata_value].
    pub fn set_or_clear_block_project_ssh_keys_metadata_value<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.block_project_ssh_keys_metadata_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_guest_attributes_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::enable_guest_attributes_metadata_value].
    pub fn set_enable_guest_attributes_metadata_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_guest_attributes_metadata_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_guest_attributes_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::enable_guest_attributes_metadata_value].
    pub fn set_or_clear_enable_guest_attributes_metadata_value<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_guest_attributes_metadata_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_os_inventory_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::enable_os_inventory_metadata_value].
    pub fn set_enable_os_inventory_metadata_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_os_inventory_metadata_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_os_inventory_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::enable_os_inventory_metadata_value].
    pub fn set_or_clear_enable_os_inventory_metadata_value<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_os_inventory_metadata_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_osconfig_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::enable_osconfig_metadata_value].
    pub fn set_enable_osconfig_metadata_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_osconfig_metadata_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_osconfig_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::enable_osconfig_metadata_value].
    pub fn set_or_clear_enable_osconfig_metadata_value<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_osconfig_metadata_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_oslogin_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::enable_oslogin_metadata_value].
    pub fn set_enable_oslogin_metadata_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_oslogin_metadata_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_oslogin_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::enable_oslogin_metadata_value].
    pub fn set_or_clear_enable_oslogin_metadata_value<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_oslogin_metadata_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [serial_port_enable_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::serial_port_enable_metadata_value].
    pub fn set_serial_port_enable_metadata_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.serial_port_enable_metadata_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [serial_port_enable_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::serial_port_enable_metadata_value].
    pub fn set_or_clear_serial_port_enable_metadata_value<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.serial_port_enable_metadata_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [serial_port_logging_enable_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::serial_port_logging_enable_metadata_value].
    pub fn set_serial_port_logging_enable_metadata_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.serial_port_logging_enable_metadata_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [serial_port_logging_enable_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::serial_port_logging_enable_metadata_value].
    pub fn set_or_clear_serial_port_logging_enable_metadata_value<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.serial_port_logging_enable_metadata_value = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vm_dns_setting_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::vm_dns_setting_metadata_value].
    pub fn set_vm_dns_setting_metadata_value<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.vm_dns_setting_metadata_value = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vm_dns_setting_metadata_value][crate::model::ResourceStatusEffectiveInstanceMetadata::vm_dns_setting_metadata_value].
    pub fn set_or_clear_vm_dns_setting_metadata_value<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.vm_dns_setting_metadata_value = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ResourceStatusEffectiveInstanceMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ResourceStatusEffectiveInstanceMetadata"
    }
}

/// Represents the physical host topology of the host on which the VM is running.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceStatusPhysicalHostTopology {
    /// [Output Only] The ID of the block in which the running instance is located. Instances within the same block experience low network latency.
    pub block: std::option::Option<std::string::String>,

    /// [Output Only] The global name of the Compute Engine cluster where the running instance is located.
    pub cluster: std::option::Option<std::string::String>,

    /// [Output Only] The ID of the host on which the running instance is located. Instances on the same host experience the lowest possible network latency.
    pub host: std::option::Option<std::string::String>,

    /// [Output Only] The ID of the sub-block in which the running instance is located. Instances in the same sub-block experience lower network latency than instances in the same block.
    pub subblock: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ResourceStatusPhysicalHostTopology {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [block][crate::model::ResourceStatusPhysicalHostTopology::block].
    pub fn set_block<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.block = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [block][crate::model::ResourceStatusPhysicalHostTopology::block].
    pub fn set_or_clear_block<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.block = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cluster][crate::model::ResourceStatusPhysicalHostTopology::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::ResourceStatusPhysicalHostTopology::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [host][crate::model::ResourceStatusPhysicalHostTopology::host].
    pub fn set_host<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.host = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [host][crate::model::ResourceStatusPhysicalHostTopology::host].
    pub fn set_or_clear_host<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.host = v.map(|x| x.into());
        self
    }

    /// Sets the value of [subblock][crate::model::ResourceStatusPhysicalHostTopology::subblock].
    pub fn set_subblock<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subblock = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [subblock][crate::model::ResourceStatusPhysicalHostTopology::subblock].
    pub fn set_or_clear_subblock<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.subblock = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ResourceStatusPhysicalHostTopology {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ResourceStatusPhysicalHostTopology"
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResourceStatusScheduling {
    /// Specifies the availability domain to place the instance in. The value must be a number between 1 and the number of availability domains specified in the spread placement policy attached to the instance.
    pub availability_domain: std::option::Option<i32>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ResourceStatusScheduling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [availability_domain][crate::model::ResourceStatusScheduling::availability_domain].
    pub fn set_availability_domain<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.availability_domain = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [availability_domain][crate::model::ResourceStatusScheduling::availability_domain].
    pub fn set_or_clear_availability_domain<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.availability_domain = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ResourceStatusScheduling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ResourceStatusScheduling"
    }
}

/// Sets the scheduling options for an Instance.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Scheduling {
    /// Specifies whether the instance should be automatically restarted if it is terminated by Compute Engine (not terminated by a user). You can only set the automatic restart option for standard instances. Preemptible instances cannot be automatically restarted. By default, this is set to true so an instance is automatically restarted if it is terminated by Compute Engine.
    pub automatic_restart: std::option::Option<bool>,

    /// Specifies the availability domain to place the instance in. The value must be a number between 1 and the number of availability domains specified in the spread placement policy attached to the instance.
    pub availability_domain: std::option::Option<i32>,

    /// Specify the time in seconds for host error detection, the value must be within the range of [90, 330] with the increment of 30, if unset, the default behavior of host error recovery will be used.
    pub host_error_timeout_seconds: std::option::Option<i32>,

    /// Specifies the termination action for the instance.
    pub instance_termination_action:
        std::option::Option<crate::model::scheduling::InstanceTerminationAction>,

    /// Specifies the maximum amount of time a Local Ssd Vm should wait while recovery of the Local Ssd state is attempted. Its value should be in between 0 and 168 hours with hour granularity and the default value being 1 hour.
    pub local_ssd_recovery_timeout: std::option::Option<crate::model::Duration>,

    /// An opaque location hint used to place the instance close to other resources. This field is for use by internal tools that use the public API.
    pub location_hint: std::option::Option<std::string::String>,

    /// Specifies the max run duration for the given instance. If specified, the instance termination action will be performed at the end of the run duration.
    pub max_run_duration: std::option::Option<crate::model::Duration>,

    /// The minimum number of virtual CPUs this instance will consume when running on a sole-tenant node.
    pub min_node_cpus: std::option::Option<i32>,

    /// A set of node affinity and anti-affinity configurations. Refer to Configuring node affinity for more information. Overrides reservationAffinity.
    pub node_affinities: std::vec::Vec<crate::model::SchedulingNodeAffinity>,

    /// Defines the maintenance behavior for this instance. For standard instances, the default behavior is MIGRATE. For preemptible instances, the default and only possible behavior is TERMINATE. For more information, see Set VM host maintenance policy.
    pub on_host_maintenance: std::option::Option<crate::model::scheduling::OnHostMaintenance>,

    pub on_instance_stop_action: std::option::Option<crate::model::SchedulingOnInstanceStopAction>,

    /// Defines whether the instance is preemptible. This can only be set during instance creation or while the instance is stopped and therefore, in a `TERMINATED` state. See Instance Life Cycle for more information on the possible instance states.
    pub preemptible: std::option::Option<bool>,

    /// Specifies the provisioning model of the instance.
    pub provisioning_model: std::option::Option<crate::model::scheduling::ProvisioningModel>,

    /// Default is false and there will be 120 seconds between GCE ACPI G2 Soft Off and ACPI G3 Mechanical Off for Standard VMs and 30 seconds for Spot VMs.
    pub skip_guest_os_shutdown: std::option::Option<bool>,

    /// Specifies the timestamp, when the instance will be terminated, in RFC3339 text format. If specified, the instance termination action will be performed at the termination time.
    pub termination_time: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl Scheduling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [automatic_restart][crate::model::Scheduling::automatic_restart].
    pub fn set_automatic_restart<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.automatic_restart = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automatic_restart][crate::model::Scheduling::automatic_restart].
    pub fn set_or_clear_automatic_restart<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.automatic_restart = v.map(|x| x.into());
        self
    }

    /// Sets the value of [availability_domain][crate::model::Scheduling::availability_domain].
    pub fn set_availability_domain<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.availability_domain = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [availability_domain][crate::model::Scheduling::availability_domain].
    pub fn set_or_clear_availability_domain<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.availability_domain = v.map(|x| x.into());
        self
    }

    /// Sets the value of [host_error_timeout_seconds][crate::model::Scheduling::host_error_timeout_seconds].
    pub fn set_host_error_timeout_seconds<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.host_error_timeout_seconds = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [host_error_timeout_seconds][crate::model::Scheduling::host_error_timeout_seconds].
    pub fn set_or_clear_host_error_timeout_seconds<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.host_error_timeout_seconds = v.map(|x| x.into());
        self
    }

    /// Sets the value of [instance_termination_action][crate::model::Scheduling::instance_termination_action].
    pub fn set_instance_termination_action<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::scheduling::InstanceTerminationAction>,
    {
        self.instance_termination_action = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance_termination_action][crate::model::Scheduling::instance_termination_action].
    pub fn set_or_clear_instance_termination_action<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::scheduling::InstanceTerminationAction>,
    {
        self.instance_termination_action = v.map(|x| x.into());
        self
    }

    /// Sets the value of [local_ssd_recovery_timeout][crate::model::Scheduling::local_ssd_recovery_timeout].
    pub fn set_local_ssd_recovery_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Duration>,
    {
        self.local_ssd_recovery_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [local_ssd_recovery_timeout][crate::model::Scheduling::local_ssd_recovery_timeout].
    pub fn set_or_clear_local_ssd_recovery_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Duration>,
    {
        self.local_ssd_recovery_timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [location_hint][crate::model::Scheduling::location_hint].
    pub fn set_location_hint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.location_hint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [location_hint][crate::model::Scheduling::location_hint].
    pub fn set_or_clear_location_hint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.location_hint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_run_duration][crate::model::Scheduling::max_run_duration].
    pub fn set_max_run_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Duration>,
    {
        self.max_run_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_run_duration][crate::model::Scheduling::max_run_duration].
    pub fn set_or_clear_max_run_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Duration>,
    {
        self.max_run_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [min_node_cpus][crate::model::Scheduling::min_node_cpus].
    pub fn set_min_node_cpus<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.min_node_cpus = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [min_node_cpus][crate::model::Scheduling::min_node_cpus].
    pub fn set_or_clear_min_node_cpus<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.min_node_cpus = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_affinities][crate::model::Scheduling::node_affinities].
    pub fn set_node_affinities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SchedulingNodeAffinity>,
    {
        use std::iter::Iterator;
        self.node_affinities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [on_host_maintenance][crate::model::Scheduling::on_host_maintenance].
    pub fn set_on_host_maintenance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::scheduling::OnHostMaintenance>,
    {
        self.on_host_maintenance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [on_host_maintenance][crate::model::Scheduling::on_host_maintenance].
    pub fn set_or_clear_on_host_maintenance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::scheduling::OnHostMaintenance>,
    {
        self.on_host_maintenance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [on_instance_stop_action][crate::model::Scheduling::on_instance_stop_action].
    pub fn set_on_instance_stop_action<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SchedulingOnInstanceStopAction>,
    {
        self.on_instance_stop_action = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [on_instance_stop_action][crate::model::Scheduling::on_instance_stop_action].
    pub fn set_or_clear_on_instance_stop_action<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SchedulingOnInstanceStopAction>,
    {
        self.on_instance_stop_action = v.map(|x| x.into());
        self
    }

    /// Sets the value of [preemptible][crate::model::Scheduling::preemptible].
    pub fn set_preemptible<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.preemptible = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [preemptible][crate::model::Scheduling::preemptible].
    pub fn set_or_clear_preemptible<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.preemptible = v.map(|x| x.into());
        self
    }

    /// Sets the value of [provisioning_model][crate::model::Scheduling::provisioning_model].
    pub fn set_provisioning_model<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::scheduling::ProvisioningModel>,
    {
        self.provisioning_model = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [provisioning_model][crate::model::Scheduling::provisioning_model].
    pub fn set_or_clear_provisioning_model<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::scheduling::ProvisioningModel>,
    {
        self.provisioning_model = v.map(|x| x.into());
        self
    }

    /// Sets the value of [skip_guest_os_shutdown][crate::model::Scheduling::skip_guest_os_shutdown].
    pub fn set_skip_guest_os_shutdown<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.skip_guest_os_shutdown = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [skip_guest_os_shutdown][crate::model::Scheduling::skip_guest_os_shutdown].
    pub fn set_or_clear_skip_guest_os_shutdown<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.skip_guest_os_shutdown = v.map(|x| x.into());
        self
    }

    /// Sets the value of [termination_time][crate::model::Scheduling::termination_time].
    pub fn set_termination_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.termination_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [termination_time][crate::model::Scheduling::termination_time].
    pub fn set_or_clear_termination_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.termination_time = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for Scheduling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Scheduling"
    }
}

/// Defines additional types related to [Scheduling].
#[cfg(feature = "instances")]
pub mod scheduling {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [instanceTerminationAction][google.cloud.compute.v1.Scheduling.instanceTerminationAction] field.
    ///
    /// [google.cloud.compute.v1.Scheduling.instanceTerminationAction]: crate::model::scheduling::InstanceTerminationAction
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum InstanceTerminationAction {
        /// Delete the VM.
        Delete,
        /// Default value. This value is unused.
        Unspecified,
        /// Stop the VM without storing in-memory content. default action.
        Stop,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [InstanceTerminationAction::value] or
        /// [InstanceTerminationAction::name].
        UnknownValue(instance_termination_action::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod instance_termination_action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl InstanceTerminationAction {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Delete => std::option::Option::Some(0),
                Self::Unspecified => std::option::Option::Some(1),
                Self::Stop => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Delete => std::option::Option::Some("DELETE"),
                Self::Unspecified => {
                    std::option::Option::Some("INSTANCE_TERMINATION_ACTION_UNSPECIFIED")
                }
                Self::Stop => std::option::Option::Some("STOP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for InstanceTerminationAction {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for InstanceTerminationAction {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for InstanceTerminationAction {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Delete,
                1 => Self::Unspecified,
                2 => Self::Stop,
                _ => Self::UnknownValue(instance_termination_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for InstanceTerminationAction {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DELETE" => Self::Delete,
                "INSTANCE_TERMINATION_ACTION_UNSPECIFIED" => Self::Unspecified,
                "STOP" => Self::Stop,
                _ => Self::UnknownValue(instance_termination_action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for InstanceTerminationAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Delete => serializer.serialize_str("DELETE"),
                Self::Unspecified => {
                    serializer.serialize_str("INSTANCE_TERMINATION_ACTION_UNSPECIFIED")
                }
                Self::Stop => serializer.serialize_str("STOP"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for InstanceTerminationAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(
                wkt::internal::EnumVisitor::<InstanceTerminationAction>::new(
                    ".google.cloud.compute.v1.Scheduling.instanceTerminationAction",
                ),
            )
        }
    }

    /// The enumerated type for the [onHostMaintenance][google.cloud.compute.v1.Scheduling.onHostMaintenance] field.
    ///
    /// [google.cloud.compute.v1.Scheduling.onHostMaintenance]: crate::model::scheduling::OnHostMaintenance
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OnHostMaintenance {
        /// *[Default]* Allows Compute Engine to automatically migrate instances out of the way of maintenance events.
        Migrate,
        /// Tells Compute Engine to terminate and (optionally) restart the instance away from the maintenance activity. If you would like your instance to be restarted, set the automaticRestart flag to true. Your instance may be restarted more than once, and it may be restarted outside the window of maintenance events.
        Terminate,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OnHostMaintenance::value] or
        /// [OnHostMaintenance::name].
        UnknownValue(on_host_maintenance::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod on_host_maintenance {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl OnHostMaintenance {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Migrate => std::option::Option::Some(0),
                Self::Terminate => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Migrate => std::option::Option::Some("MIGRATE"),
                Self::Terminate => std::option::Option::Some("TERMINATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for OnHostMaintenance {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for OnHostMaintenance {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for OnHostMaintenance {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Migrate,
                1 => Self::Terminate,
                _ => Self::UnknownValue(on_host_maintenance::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for OnHostMaintenance {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MIGRATE" => Self::Migrate,
                "TERMINATE" => Self::Terminate,
                _ => Self::UnknownValue(on_host_maintenance::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for OnHostMaintenance {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Migrate => serializer.serialize_str("MIGRATE"),
                Self::Terminate => serializer.serialize_str("TERMINATE"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for OnHostMaintenance {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OnHostMaintenance>::new(
                ".google.cloud.compute.v1.Scheduling.onHostMaintenance",
            ))
        }
    }

    /// The enumerated type for the [provisioningModel][google.cloud.compute.v1.Scheduling.provisioningModel] field.
    ///
    /// [google.cloud.compute.v1.Scheduling.provisioningModel]: crate::model::scheduling::ProvisioningModel
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ProvisioningModel {
        /// Instance is provisioned using the Flex Start provisioning model and has a limited runtime.
        FlexStart,
        /// Bound to the lifecycle of the reservation in which it is provisioned.
        ReservationBound,
        /// Heavily discounted, no guaranteed runtime.
        Spot,
        /// Standard provisioning with user controlled runtime, no discounts.
        Standard,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ProvisioningModel::value] or
        /// [ProvisioningModel::name].
        UnknownValue(provisioning_model::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod provisioning_model {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl ProvisioningModel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::FlexStart => std::option::Option::Some(0),
                Self::ReservationBound => std::option::Option::Some(1),
                Self::Spot => std::option::Option::Some(2),
                Self::Standard => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::FlexStart => std::option::Option::Some("FLEX_START"),
                Self::ReservationBound => std::option::Option::Some("RESERVATION_BOUND"),
                Self::Spot => std::option::Option::Some("SPOT"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for ProvisioningModel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for ProvisioningModel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for ProvisioningModel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::FlexStart,
                1 => Self::ReservationBound,
                2 => Self::Spot,
                3 => Self::Standard,
                _ => Self::UnknownValue(provisioning_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for ProvisioningModel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FLEX_START" => Self::FlexStart,
                "RESERVATION_BOUND" => Self::ReservationBound,
                "SPOT" => Self::Spot,
                "STANDARD" => Self::Standard,
                _ => Self::UnknownValue(provisioning_model::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for ProvisioningModel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::FlexStart => serializer.serialize_str("FLEX_START"),
                Self::ReservationBound => serializer.serialize_str("RESERVATION_BOUND"),
                Self::Spot => serializer.serialize_str("SPOT"),
                Self::Standard => serializer.serialize_str("STANDARD"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for ProvisioningModel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ProvisioningModel>::new(
                ".google.cloud.compute.v1.Scheduling.provisioningModel",
            ))
        }
    }
}

/// Node Affinity: the configuration of desired nodes onto which this Instance could be scheduled.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchedulingNodeAffinity {
    /// Corresponds to the label key of Node resource.
    pub key: std::option::Option<std::string::String>,

    /// Defines the operation of node selection. Valid operators are IN for affinity and NOT_IN for anti-affinity.
    pub operator: std::option::Option<crate::model::scheduling_node_affinity::Operator>,

    /// Corresponds to the label values of Node resource.
    pub values: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl SchedulingNodeAffinity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::SchedulingNodeAffinity::key].
    pub fn set_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [key][crate::model::SchedulingNodeAffinity::key].
    pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [operator][crate::model::SchedulingNodeAffinity::operator].
    pub fn set_operator<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::scheduling_node_affinity::Operator>,
    {
        self.operator = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [operator][crate::model::SchedulingNodeAffinity::operator].
    pub fn set_or_clear_operator<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::scheduling_node_affinity::Operator>,
    {
        self.operator = v.map(|x| x.into());
        self
    }

    /// Sets the value of [values][crate::model::SchedulingNodeAffinity::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for SchedulingNodeAffinity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.SchedulingNodeAffinity"
    }
}

/// Defines additional types related to [SchedulingNodeAffinity].
#[cfg(feature = "instances")]
pub mod scheduling_node_affinity {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [operator][google.cloud.compute.v1.SchedulingNodeAffinity.operator] field.
    ///
    /// [google.cloud.compute.v1.SchedulingNodeAffinity.operator]: crate::model::scheduling_node_affinity::Operator
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Operator {
        /// Requires Compute Engine to seek for matched nodes.
        In,
        /// Requires Compute Engine to avoid certain nodes.
        NotIn,
        Unspecified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Operator::value] or
        /// [Operator::name].
        UnknownValue(operator::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod operator {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Operator {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::In => std::option::Option::Some(0),
                Self::NotIn => std::option::Option::Some(1),
                Self::Unspecified => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::In => std::option::Option::Some("IN"),
                Self::NotIn => std::option::Option::Some("NOT_IN"),
                Self::Unspecified => std::option::Option::Some("OPERATOR_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Operator {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Operator {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Operator {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::In,
                1 => Self::NotIn,
                2 => Self::Unspecified,
                _ => Self::UnknownValue(operator::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Operator {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "IN" => Self::In,
                "NOT_IN" => Self::NotIn,
                "OPERATOR_UNSPECIFIED" => Self::Unspecified,
                _ => Self::UnknownValue(operator::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Operator {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::In => serializer.serialize_str("IN"),
                Self::NotIn => serializer.serialize_str("NOT_IN"),
                Self::Unspecified => serializer.serialize_str("OPERATOR_UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Operator {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Operator>::new(
                ".google.cloud.compute.v1.SchedulingNodeAffinity.operator",
            ))
        }
    }
}

/// Defines the behaviour for instances with the instance_termination_action STOP.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchedulingOnInstanceStopAction {
    /// If true, the contents of any attached Local SSD disks will be discarded else, the Local SSD data will be preserved when the instance is stopped at the end of the run duration/termination time.
    pub discard_local_ssd: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl SchedulingOnInstanceStopAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [discard_local_ssd][crate::model::SchedulingOnInstanceStopAction::discard_local_ssd].
    pub fn set_discard_local_ssd<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.discard_local_ssd = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [discard_local_ssd][crate::model::SchedulingOnInstanceStopAction::discard_local_ssd].
    pub fn set_or_clear_discard_local_ssd<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.discard_local_ssd = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for SchedulingOnInstanceStopAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.SchedulingOnInstanceStopAction"
    }
}

/// An instance's screenshot.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Screenshot {
    /// [Output Only] The Base64-encoded screenshot data.
    pub contents: std::option::Option<std::string::String>,

    /// [Output Only] Type of the resource. Always compute#screenshot for the screenshots.
    pub kind: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl Screenshot {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [contents][crate::model::Screenshot::contents].
    pub fn set_contents<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.contents = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [contents][crate::model::Screenshot::contents].
    pub fn set_or_clear_contents<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.contents = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::Screenshot::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::Screenshot::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for Screenshot {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Screenshot"
    }
}

/// An instance serial console output.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SerialPortOutput {
    /// [Output Only] The contents of the console output.
    pub contents: std::option::Option<std::string::String>,

    /// [Output Only] Type of the resource. Always compute#serialPortOutput for serial port output.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] The position of the next byte of content, regardless of whether the content exists, following the output returned in the `contents` property. Use this value in the next request as the start parameter.
    pub next: std::option::Option<i64>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// The starting byte position of the output that was returned. This should match the start parameter sent with the request. If the serial console output exceeds the size of the buffer (1 MB), older output is overwritten by newer content. The output start value will indicate the byte position of the output that was returned, which might be different than the `start` value that was specified in the request.
    pub start: std::option::Option<i64>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl SerialPortOutput {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [contents][crate::model::SerialPortOutput::contents].
    pub fn set_contents<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.contents = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [contents][crate::model::SerialPortOutput::contents].
    pub fn set_or_clear_contents<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.contents = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::SerialPortOutput::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::SerialPortOutput::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next][crate::model::SerialPortOutput::next].
    pub fn set_next<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.next = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next][crate::model::SerialPortOutput::next].
    pub fn set_or_clear_next<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.next = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::SerialPortOutput::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::SerialPortOutput::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start][crate::model::SerialPortOutput::start].
    pub fn set_start<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.start = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start][crate::model::SerialPortOutput::start].
    pub fn set_or_clear_start<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i64>,
    {
        self.start = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for SerialPortOutput {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.SerialPortOutput"
    }
}

/// A service account.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ServiceAccount {
    /// Email address of the service account.
    pub email: std::option::Option<std::string::String>,

    /// The list of scopes to be made available for this service account.
    pub scopes: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ServiceAccount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [email][crate::model::ServiceAccount::email].
    pub fn set_email<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.email = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [email][crate::model::ServiceAccount::email].
    pub fn set_or_clear_email<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.email = v.map(|x| x.into());
        self
    }

    /// Sets the value of [scopes][crate::model::ServiceAccount::scopes].
    pub fn set_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ServiceAccount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ServiceAccount"
    }
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetCommonInstanceMetadataOperationMetadata {
    /// [Output Only] The client operation id.
    pub client_operation_id: std::option::Option<std::string::String>,

    /// [Output Only] Status information per location (location name is key). Example key: zones/us-central1-a
    pub per_location_operations: std::collections::HashMap<
        std::string::String,
        crate::model::SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo,
    >,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl SetCommonInstanceMetadataOperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [client_operation_id][crate::model::SetCommonInstanceMetadataOperationMetadata::client_operation_id].
    pub fn set_client_operation_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.client_operation_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [client_operation_id][crate::model::SetCommonInstanceMetadataOperationMetadata::client_operation_id].
    pub fn set_or_clear_client_operation_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.client_operation_id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [per_location_operations][crate::model::SetCommonInstanceMetadataOperationMetadata::per_location_operations].
    pub fn set_per_location_operations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<
                crate::model::SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo,
            >,
    {
        use std::iter::Iterator;
        self.per_location_operations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl wkt::message::Message for SetCommonInstanceMetadataOperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.SetCommonInstanceMetadataOperationMetadata"
    }
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo {

    /// [Output Only] If state is `ABANDONED` or `FAILED`, this field is populated.
    pub error: std::option::Option<crate::model::Status>,

    /// [Output Only] Status of the action, which can be one of the following: `PROPAGATING`, `PROPAGATED`, `ABANDONED`, `FAILED`, or `DONE`.
    pub state: std::option::Option<crate::model::set_common_instance_metadata_operation_metadata_per_location_operation_info::State>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [error][crate::model::SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo::state].
    pub fn set_state<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::set_common_instance_metadata_operation_metadata_per_location_operation_info::State>
    {
        self.state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state][crate::model::SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo::state].
    pub fn set_or_clear_state<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::set_common_instance_metadata_operation_metadata_per_location_operation_info::State>
    {
        self.state = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl wkt::message::Message for SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo"
    }
}

/// Defines additional types related to [SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo].
#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
pub mod set_common_instance_metadata_operation_metadata_per_location_operation_info {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [state][google.cloud.compute.v1.SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo.state] field.
    ///
    /// [google.cloud.compute.v1.SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo.state]: crate::model::set_common_instance_metadata_operation_metadata_per_location_operation_info::State
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Operation not tracked in this location e.g. zone is marked as DOWN.
        Abandoned,
        /// Operation has completed successfully.
        Done,
        /// Operation is in an error state.
        Failed,
        /// Operation is confirmed to be in the location.
        Propagated,
        /// Operation is not yet confirmed to have been created in the location.
        Propagating,
        Unspecified,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Abandoned => std::option::Option::Some(0),
                Self::Done => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Propagated => std::option::Option::Some(3),
                Self::Propagating => std::option::Option::Some(4),
                Self::Unspecified => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Abandoned => std::option::Option::Some("ABANDONED"),
                Self::Done => std::option::Option::Some("DONE"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Propagated => std::option::Option::Some("PROPAGATED"),
                Self::Propagating => std::option::Option::Some("PROPAGATING"),
                Self::Unspecified => std::option::Option::Some("UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Abandoned,
                1 => Self::Done,
                2 => Self::Failed,
                3 => Self::Propagated,
                4 => Self::Propagating,
                5 => Self::Unspecified,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ABANDONED" => Self::Abandoned,
                "DONE" => Self::Done,
                "FAILED" => Self::Failed,
                "PROPAGATED" => Self::Propagated,
                "PROPAGATING" => Self::Propagating,
                "UNSPECIFIED" => Self::Unspecified,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Abandoned => serializer.serialize_str("ABANDONED"),
                Self::Done => serializer.serialize_str("DONE"),
                Self::Failed => serializer.serialize_str("FAILED"),
                Self::Propagated => serializer.serialize_str("PROPAGATED"),
                Self::Propagating => serializer.serialize_str("PROPAGATING"),
                Self::Unspecified => serializer.serialize_str("UNSPECIFIED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.compute.v1.SetCommonInstanceMetadataOperationMetadataPerLocationOperationInfo.state"))
        }
    }
}

/// A set of Shielded Instance options.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ShieldedInstanceConfig {
    /// Defines whether the instance has integrity monitoring enabled. Enabled by default.
    pub enable_integrity_monitoring: std::option::Option<bool>,

    /// Defines whether the instance has Secure Boot enabled. Disabled by default.
    pub enable_secure_boot: std::option::Option<bool>,

    /// Defines whether the instance has the vTPM enabled. Enabled by default.
    pub enable_vtpm: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ShieldedInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_integrity_monitoring][crate::model::ShieldedInstanceConfig::enable_integrity_monitoring].
    pub fn set_enable_integrity_monitoring<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_integrity_monitoring = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_integrity_monitoring][crate::model::ShieldedInstanceConfig::enable_integrity_monitoring].
    pub fn set_or_clear_enable_integrity_monitoring<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_integrity_monitoring = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_secure_boot][crate::model::ShieldedInstanceConfig::enable_secure_boot].
    pub fn set_enable_secure_boot<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_secure_boot = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_secure_boot][crate::model::ShieldedInstanceConfig::enable_secure_boot].
    pub fn set_or_clear_enable_secure_boot<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_secure_boot = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_vtpm][crate::model::ShieldedInstanceConfig::enable_vtpm].
    pub fn set_enable_vtpm<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_vtpm = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [enable_vtpm][crate::model::ShieldedInstanceConfig::enable_vtpm].
    pub fn set_or_clear_enable_vtpm<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.enable_vtpm = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ShieldedInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ShieldedInstanceConfig"
    }
}

/// A Shielded Instance Identity.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ShieldedInstanceIdentity {
    /// An Endorsement Key (EK) made by the RSA 2048 algorithm issued to the Shielded Instance's vTPM.
    pub encryption_key: std::option::Option<crate::model::ShieldedInstanceIdentityEntry>,

    /// [Output Only] Type of the resource. Always compute#shieldedInstanceIdentity for shielded Instance identity entry.
    pub kind: std::option::Option<std::string::String>,

    /// An Attestation Key (AK) made by the RSA 2048 algorithm issued to the Shielded Instance's vTPM.
    pub signing_key: std::option::Option<crate::model::ShieldedInstanceIdentityEntry>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ShieldedInstanceIdentity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_key][crate::model::ShieldedInstanceIdentity::encryption_key].
    pub fn set_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceIdentityEntry>,
    {
        self.encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_key][crate::model::ShieldedInstanceIdentity::encryption_key].
    pub fn set_or_clear_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceIdentityEntry>,
    {
        self.encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::ShieldedInstanceIdentity::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::ShieldedInstanceIdentity::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [signing_key][crate::model::ShieldedInstanceIdentity::signing_key].
    pub fn set_signing_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceIdentityEntry>,
    {
        self.signing_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [signing_key][crate::model::ShieldedInstanceIdentity::signing_key].
    pub fn set_or_clear_signing_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceIdentityEntry>,
    {
        self.signing_key = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ShieldedInstanceIdentity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ShieldedInstanceIdentity"
    }
}

/// A Shielded Instance Identity Entry.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ShieldedInstanceIdentityEntry {
    /// A PEM-encoded X.509 certificate. This field can be empty.
    pub ek_cert: std::option::Option<std::string::String>,

    /// A PEM-encoded public key.
    pub ek_pub: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ShieldedInstanceIdentityEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ek_cert][crate::model::ShieldedInstanceIdentityEntry::ek_cert].
    pub fn set_ek_cert<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ek_cert = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ek_cert][crate::model::ShieldedInstanceIdentityEntry::ek_cert].
    pub fn set_or_clear_ek_cert<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ek_cert = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ek_pub][crate::model::ShieldedInstanceIdentityEntry::ek_pub].
    pub fn set_ek_pub<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ek_pub = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ek_pub][crate::model::ShieldedInstanceIdentityEntry::ek_pub].
    pub fn set_or_clear_ek_pub<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.ek_pub = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ShieldedInstanceIdentityEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ShieldedInstanceIdentityEntry"
    }
}

/// The policy describes the baseline against which Instance boot integrity is measured.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ShieldedInstanceIntegrityPolicy {
    /// Updates the integrity policy baseline using the measurements from the VM instance's most recent boot.
    pub update_auto_learn_policy: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ShieldedInstanceIntegrityPolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_auto_learn_policy][crate::model::ShieldedInstanceIntegrityPolicy::update_auto_learn_policy].
    pub fn set_update_auto_learn_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.update_auto_learn_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_auto_learn_policy][crate::model::ShieldedInstanceIntegrityPolicy::update_auto_learn_policy].
    pub fn set_or_clear_update_auto_learn_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.update_auto_learn_policy = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ShieldedInstanceIntegrityPolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ShieldedInstanceIntegrityPolicy"
    }
}

/// The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). Each `Status` message contains three pieces of data: error code, error message, and error details. You can find out more about this error model and how to work with it in the [API Design Guide](https://cloud.google.com/apis/design/errors).
#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Status {
    /// The status code, which should be an enum value of google.rpc.Code.
    pub code: std::option::Option<i32>,

    /// A list of messages that carry the error details. There is a common set of message types for APIs to use.
    pub details: std::vec::Vec<wkt::Any>,

    /// A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
    pub message: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl Status {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::Status::code].
    pub fn set_code<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.code = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [code][crate::model::Status::code].
    pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.code = v.map(|x| x.into());
        self
    }

    /// Sets the value of [details][crate::model::Status::details].
    pub fn set_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<wkt::Any>,
    {
        use std::iter::Iterator;
        self.details = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [message][crate::model::Status::message].
    pub fn set_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.message = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [message][crate::model::Status::message].
    pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.message = v.map(|x| x.into());
        self
    }
}

#[cfg(any(feature = "images", feature = "instances", feature = "zone-operations",))]
impl wkt::message::Message for Status {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Status"
    }
}

/// A set of instance tags.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Tags {
    /// Specifies a fingerprint for this request, which is essentially a hash of the tags' contents and used for optimistic locking. The fingerprint is initially generated by Compute Engine and changes after every request to modify or update tags. You must always provide an up-to-date fingerprint hash in order to update or change tags. To see the latest fingerprint, make get() request to the instance.
    pub fingerprint: std::option::Option<::bytes::Bytes>,

    /// An array of tags. Each tag must be 1-63 characters long, and comply with RFC1035.
    pub items: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl Tags {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [fingerprint][crate::model::Tags::fingerprint].
    pub fn set_fingerprint<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fingerprint][crate::model::Tags::fingerprint].
    pub fn set_or_clear_fingerprint<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.fingerprint = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::Tags::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for Tags {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Tags"
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TestPermissionsRequest {
    /// The set of permissions to check for the 'resource'. Permissions with wildcards (such as '*' or 'storage.*') are not allowed.
    pub permissions: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances",))]
impl TestPermissionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [permissions][crate::model::TestPermissionsRequest::permissions].
    pub fn set_permissions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.permissions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
impl wkt::message::Message for TestPermissionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.TestPermissionsRequest"
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TestPermissionsResponse {
    /// A subset of `TestPermissionsRequest.permissions` that the caller is allowed.
    pub permissions: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(any(feature = "images", feature = "instances",))]
impl TestPermissionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [permissions][crate::model::TestPermissionsResponse::permissions].
    pub fn set_permissions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.permissions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

#[cfg(any(feature = "images", feature = "instances",))]
impl wkt::message::Message for TestPermissionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.TestPermissionsResponse"
    }
}

/// Upcoming Maintenance notification information.
#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpcomingMaintenance {
    /// Indicates if the maintenance can be customer triggered.
    pub can_reschedule: std::option::Option<bool>,

    /// The latest time for the planned maintenance window to start. This timestamp value is in RFC3339 text format.
    pub latest_window_start_time: std::option::Option<std::string::String>,

    /// Indicates whether the UpcomingMaintenance will be triggered on VM shutdown.
    pub maintenance_on_shutdown: std::option::Option<bool>,

    /// The reasons for the maintenance. Only valid for vms.
    pub maintenance_reasons: std::vec::Vec<crate::model::upcoming_maintenance::MaintenanceReasons>,

    pub maintenance_status:
        std::option::Option<crate::model::upcoming_maintenance::MaintenanceStatus>,

    /// Defines the type of maintenance.
    pub r#type: std::option::Option<crate::model::upcoming_maintenance::Type>,

    /// The time by which the maintenance disruption will be completed. This timestamp value is in RFC3339 text format.
    pub window_end_time: std::option::Option<std::string::String>,

    /// The current start time of the maintenance window. This timestamp value is in RFC3339 text format.
    pub window_start_time: std::option::Option<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl UpcomingMaintenance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [can_reschedule][crate::model::UpcomingMaintenance::can_reschedule].
    pub fn set_can_reschedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.can_reschedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [can_reschedule][crate::model::UpcomingMaintenance::can_reschedule].
    pub fn set_or_clear_can_reschedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.can_reschedule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [latest_window_start_time][crate::model::UpcomingMaintenance::latest_window_start_time].
    pub fn set_latest_window_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.latest_window_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [latest_window_start_time][crate::model::UpcomingMaintenance::latest_window_start_time].
    pub fn set_or_clear_latest_window_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.latest_window_start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_on_shutdown][crate::model::UpcomingMaintenance::maintenance_on_shutdown].
    pub fn set_maintenance_on_shutdown<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.maintenance_on_shutdown = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_on_shutdown][crate::model::UpcomingMaintenance::maintenance_on_shutdown].
    pub fn set_or_clear_maintenance_on_shutdown<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.maintenance_on_shutdown = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_reasons][crate::model::UpcomingMaintenance::maintenance_reasons].
    pub fn set_maintenance_reasons<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::upcoming_maintenance::MaintenanceReasons>,
    {
        use std::iter::Iterator;
        self.maintenance_reasons = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [maintenance_status][crate::model::UpcomingMaintenance::maintenance_status].
    pub fn set_maintenance_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::upcoming_maintenance::MaintenanceStatus>,
    {
        self.maintenance_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_status][crate::model::UpcomingMaintenance::maintenance_status].
    pub fn set_or_clear_maintenance_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::upcoming_maintenance::MaintenanceStatus>,
    {
        self.maintenance_status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::UpcomingMaintenance::type].
    pub fn set_type<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::upcoming_maintenance::Type>,
    {
        self.r#type = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [r#type][crate::model::UpcomingMaintenance::type].
    pub fn set_or_clear_type<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::upcoming_maintenance::Type>,
    {
        self.r#type = v.map(|x| x.into());
        self
    }

    /// Sets the value of [window_end_time][crate::model::UpcomingMaintenance::window_end_time].
    pub fn set_window_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.window_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [window_end_time][crate::model::UpcomingMaintenance::window_end_time].
    pub fn set_or_clear_window_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.window_end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [window_start_time][crate::model::UpcomingMaintenance::window_start_time].
    pub fn set_window_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.window_start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [window_start_time][crate::model::UpcomingMaintenance::window_start_time].
    pub fn set_or_clear_window_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.window_start_time = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for UpcomingMaintenance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.UpcomingMaintenance"
    }
}

/// Defines additional types related to [UpcomingMaintenance].
#[cfg(feature = "instances")]
pub mod upcoming_maintenance {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [maintenanceReasons][google.cloud.compute.v1.UpcomingMaintenance.maintenanceReasons] field.
    ///
    /// [google.cloud.compute.v1.UpcomingMaintenance.maintenanceReasons]: crate::model::upcoming_maintenance::MaintenanceReasons
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MaintenanceReasons {
        /// Maintenance due to disk errors.
        FailureDisk,
        /// Maintenance due to GPU errors.
        FailureGpu,
        /// Maintenance due to customer reported multiple faulty hosts via R&R Subblock API.
        FailureGpuMultipleFaultyHostsCustomerReported,
        /// Maintenance due to customer reported NVLink switch failure via R&R Subblock API.
        FailureGpuNvlinkSwitchCustomerReported,
        /// Maintenance due to high GPU temperature.
        FailureGpuTemperature,
        /// Maintenance due to GPU xid failure.
        FailureGpuXid,
        /// Maintenance due to infrastructure errors.
        FailureInfra,
        /// Maintenance due to interface errors.
        FailureInterface,
        /// Maintenance due to memory errors.
        FailureMemory,
        /// Maintenance due to network errors.
        FailureNetwork,
        /// Maintenance due to NVLink failure.
        FailureNvlink,
        /// Maintenance due to redundant hardware fault.
        FailureRedundantHardwareFault,
        /// Maintenance due to infrastructure relocation.
        InfrastructureRelocation,
        /// Unknown maintenance reason. Do not use this value.
        MaintenanceReasonUnknown,
        /// Maintenance due to planned network update.
        PlannedNetworkUpdate,
        /// Maintenance due to planned update to the instance.
        PlannedUpdate,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MaintenanceReasons::value] or
        /// [MaintenanceReasons::name].
        UnknownValue(maintenance_reasons::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod maintenance_reasons {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl MaintenanceReasons {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::FailureDisk => std::option::Option::Some(0),
                Self::FailureGpu => std::option::Option::Some(1),
                Self::FailureGpuMultipleFaultyHostsCustomerReported => std::option::Option::Some(2),
                Self::FailureGpuNvlinkSwitchCustomerReported => std::option::Option::Some(3),
                Self::FailureGpuTemperature => std::option::Option::Some(4),
                Self::FailureGpuXid => std::option::Option::Some(5),
                Self::FailureInfra => std::option::Option::Some(6),
                Self::FailureInterface => std::option::Option::Some(7),
                Self::FailureMemory => std::option::Option::Some(8),
                Self::FailureNetwork => std::option::Option::Some(9),
                Self::FailureNvlink => std::option::Option::Some(10),
                Self::FailureRedundantHardwareFault => std::option::Option::Some(11),
                Self::InfrastructureRelocation => std::option::Option::Some(12),
                Self::MaintenanceReasonUnknown => std::option::Option::Some(13),
                Self::PlannedNetworkUpdate => std::option::Option::Some(14),
                Self::PlannedUpdate => std::option::Option::Some(15),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::FailureDisk => std::option::Option::Some("FAILURE_DISK"),
                Self::FailureGpu => std::option::Option::Some("FAILURE_GPU"),
                Self::FailureGpuMultipleFaultyHostsCustomerReported => {
                    std::option::Option::Some("FAILURE_GPU_MULTIPLE_FAULTY_HOSTS_CUSTOMER_REPORTED")
                }
                Self::FailureGpuNvlinkSwitchCustomerReported => {
                    std::option::Option::Some("FAILURE_GPU_NVLINK_SWITCH_CUSTOMER_REPORTED")
                }
                Self::FailureGpuTemperature => std::option::Option::Some("FAILURE_GPU_TEMPERATURE"),
                Self::FailureGpuXid => std::option::Option::Some("FAILURE_GPU_XID"),
                Self::FailureInfra => std::option::Option::Some("FAILURE_INFRA"),
                Self::FailureInterface => std::option::Option::Some("FAILURE_INTERFACE"),
                Self::FailureMemory => std::option::Option::Some("FAILURE_MEMORY"),
                Self::FailureNetwork => std::option::Option::Some("FAILURE_NETWORK"),
                Self::FailureNvlink => std::option::Option::Some("FAILURE_NVLINK"),
                Self::FailureRedundantHardwareFault => {
                    std::option::Option::Some("FAILURE_REDUNDANT_HARDWARE_FAULT")
                }
                Self::InfrastructureRelocation => {
                    std::option::Option::Some("INFRASTRUCTURE_RELOCATION")
                }
                Self::MaintenanceReasonUnknown => {
                    std::option::Option::Some("MAINTENANCE_REASON_UNKNOWN")
                }
                Self::PlannedNetworkUpdate => std::option::Option::Some("PLANNED_NETWORK_UPDATE"),
                Self::PlannedUpdate => std::option::Option::Some("PLANNED_UPDATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for MaintenanceReasons {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for MaintenanceReasons {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for MaintenanceReasons {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::FailureDisk,
                1 => Self::FailureGpu,
                2 => Self::FailureGpuMultipleFaultyHostsCustomerReported,
                3 => Self::FailureGpuNvlinkSwitchCustomerReported,
                4 => Self::FailureGpuTemperature,
                5 => Self::FailureGpuXid,
                6 => Self::FailureInfra,
                7 => Self::FailureInterface,
                8 => Self::FailureMemory,
                9 => Self::FailureNetwork,
                10 => Self::FailureNvlink,
                11 => Self::FailureRedundantHardwareFault,
                12 => Self::InfrastructureRelocation,
                13 => Self::MaintenanceReasonUnknown,
                14 => Self::PlannedNetworkUpdate,
                15 => Self::PlannedUpdate,
                _ => Self::UnknownValue(maintenance_reasons::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for MaintenanceReasons {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FAILURE_DISK" => Self::FailureDisk,
                "FAILURE_GPU" => Self::FailureGpu,
                "FAILURE_GPU_MULTIPLE_FAULTY_HOSTS_CUSTOMER_REPORTED" => {
                    Self::FailureGpuMultipleFaultyHostsCustomerReported
                }
                "FAILURE_GPU_NVLINK_SWITCH_CUSTOMER_REPORTED" => {
                    Self::FailureGpuNvlinkSwitchCustomerReported
                }
                "FAILURE_GPU_TEMPERATURE" => Self::FailureGpuTemperature,
                "FAILURE_GPU_XID" => Self::FailureGpuXid,
                "FAILURE_INFRA" => Self::FailureInfra,
                "FAILURE_INTERFACE" => Self::FailureInterface,
                "FAILURE_MEMORY" => Self::FailureMemory,
                "FAILURE_NETWORK" => Self::FailureNetwork,
                "FAILURE_NVLINK" => Self::FailureNvlink,
                "FAILURE_REDUNDANT_HARDWARE_FAULT" => Self::FailureRedundantHardwareFault,
                "INFRASTRUCTURE_RELOCATION" => Self::InfrastructureRelocation,
                "MAINTENANCE_REASON_UNKNOWN" => Self::MaintenanceReasonUnknown,
                "PLANNED_NETWORK_UPDATE" => Self::PlannedNetworkUpdate,
                "PLANNED_UPDATE" => Self::PlannedUpdate,
                _ => Self::UnknownValue(maintenance_reasons::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for MaintenanceReasons {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::FailureDisk => serializer.serialize_str("FAILURE_DISK"),
                Self::FailureGpu => serializer.serialize_str("FAILURE_GPU"),
                Self::FailureGpuMultipleFaultyHostsCustomerReported => {
                    serializer.serialize_str("FAILURE_GPU_MULTIPLE_FAULTY_HOSTS_CUSTOMER_REPORTED")
                }
                Self::FailureGpuNvlinkSwitchCustomerReported => {
                    serializer.serialize_str("FAILURE_GPU_NVLINK_SWITCH_CUSTOMER_REPORTED")
                }
                Self::FailureGpuTemperature => serializer.serialize_str("FAILURE_GPU_TEMPERATURE"),
                Self::FailureGpuXid => serializer.serialize_str("FAILURE_GPU_XID"),
                Self::FailureInfra => serializer.serialize_str("FAILURE_INFRA"),
                Self::FailureInterface => serializer.serialize_str("FAILURE_INTERFACE"),
                Self::FailureMemory => serializer.serialize_str("FAILURE_MEMORY"),
                Self::FailureNetwork => serializer.serialize_str("FAILURE_NETWORK"),
                Self::FailureNvlink => serializer.serialize_str("FAILURE_NVLINK"),
                Self::FailureRedundantHardwareFault => {
                    serializer.serialize_str("FAILURE_REDUNDANT_HARDWARE_FAULT")
                }
                Self::InfrastructureRelocation => {
                    serializer.serialize_str("INFRASTRUCTURE_RELOCATION")
                }
                Self::MaintenanceReasonUnknown => {
                    serializer.serialize_str("MAINTENANCE_REASON_UNKNOWN")
                }
                Self::PlannedNetworkUpdate => serializer.serialize_str("PLANNED_NETWORK_UPDATE"),
                Self::PlannedUpdate => serializer.serialize_str("PLANNED_UPDATE"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for MaintenanceReasons {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MaintenanceReasons>::new(
                ".google.cloud.compute.v1.UpcomingMaintenance.maintenanceReasons",
            ))
        }
    }

    /// The enumerated type for the [maintenanceStatus][google.cloud.compute.v1.UpcomingMaintenance.maintenanceStatus] field.
    ///
    /// [google.cloud.compute.v1.UpcomingMaintenance.maintenanceStatus]: crate::model::upcoming_maintenance::MaintenanceStatus
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MaintenanceStatus {
        /// There is ongoing maintenance on this VM.
        Ongoing,
        /// There is pending maintenance.
        Pending,
        /// Unknown maintenance status. Do not use this value.
        Unknown,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MaintenanceStatus::value] or
        /// [MaintenanceStatus::name].
        UnknownValue(maintenance_status::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod maintenance_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl MaintenanceStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Ongoing => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Unknown => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Ongoing => std::option::Option::Some("ONGOING"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for MaintenanceStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for MaintenanceStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for MaintenanceStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Ongoing,
                1 => Self::Pending,
                2 => Self::Unknown,
                _ => Self::UnknownValue(maintenance_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for MaintenanceStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ONGOING" => Self::Ongoing,
                "PENDING" => Self::Pending,
                "UNKNOWN" => Self::Unknown,
                _ => Self::UnknownValue(maintenance_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for MaintenanceStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Ongoing => serializer.serialize_str("ONGOING"),
                Self::Pending => serializer.serialize_str("PENDING"),
                Self::Unknown => serializer.serialize_str("UNKNOWN"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for MaintenanceStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MaintenanceStatus>::new(
                ".google.cloud.compute.v1.UpcomingMaintenance.maintenanceStatus",
            ))
        }
    }

    /// The enumerated type for the [type][google.cloud.compute.v1.UpcomingMaintenance.type] field.
    ///
    /// [google.cloud.compute.v1.UpcomingMaintenance.type]: crate::model::upcoming_maintenance::Type
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "instances")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Multiple maintenance types in one window. This is only intended to be used for groups.
        Multiple,
        /// Scheduled maintenance (e.g. maintenance after uptime guarantee is complete).
        Scheduled,
        /// No type specified. Do not use this value.
        UnknownType,
        /// Unscheduled maintenance (e.g. emergency maintenance during uptime guarantee).
        Unscheduled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "instances")]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "instances")]
    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Multiple => std::option::Option::Some(0),
                Self::Scheduled => std::option::Option::Some(1),
                Self::UnknownType => std::option::Option::Some(2),
                Self::Unscheduled => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Multiple => std::option::Option::Some("MULTIPLE"),
                Self::Scheduled => std::option::Option::Some("SCHEDULED"),
                Self::UnknownType => std::option::Option::Some("UNKNOWN_TYPE"),
                Self::Unscheduled => std::option::Option::Some("UNSCHEDULED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "instances")]
    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Multiple,
                1 => Self::Scheduled,
                2 => Self::UnknownType,
                3 => Self::Unscheduled,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MULTIPLE" => Self::Multiple,
                "SCHEDULED" => Self::Scheduled,
                "UNKNOWN_TYPE" => Self::UnknownType,
                "UNSCHEDULED" => Self::Unscheduled,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Multiple => serializer.serialize_str("MULTIPLE"),
                Self::Scheduled => serializer.serialize_str("SCHEDULED"),
                Self::UnknownType => serializer.serialize_str("UNKNOWN_TYPE"),
                Self::Unscheduled => serializer.serialize_str("UNSCHEDULED"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "instances")]
    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.compute.v1.UpcomingMaintenance.type",
            ))
        }
    }
}

/// Represents a Zone resource. A zone is a deployment area. These deployment areas are subsets of a region. For example the zone us-east1-b is located in the us-east1 region. For more information, read Regions and Zones.
#[cfg(feature = "zones")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Zone {
    /// [Output Only] Available cpu/platform selections for the zone.
    pub available_cpu_platforms: std::vec::Vec<std::string::String>,

    /// [Output Only] Creation timestamp in RFC3339 text format.
    pub creation_timestamp: std::option::Option<std::string::String>,

    /// [Output Only] The deprecation status associated with this zone.
    pub deprecated: std::option::Option<crate::model::DeprecationStatus>,

    /// [Output Only] Textual description of the resource.
    pub description: std::option::Option<std::string::String>,

    /// [Output Only] The unique identifier for the resource. This identifier is defined by the server.
    pub id: std::option::Option<u64>,

    /// [Output Only] Type of the resource. Always compute#zone for zones.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] Name of the resource.
    pub name: std::option::Option<std::string::String>,

    /// [Output Only] Full URL reference to the region which hosts the zone.
    pub region: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for the resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Status of the zone, either UP or DOWN.
    pub status: std::option::Option<crate::model::zone::Status>,

    /// [Output Only] Reserved for future use.
    pub supports_pzs: std::option::Option<bool>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "zones")]
impl Zone {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [available_cpu_platforms][crate::model::Zone::available_cpu_platforms].
    pub fn set_available_cpu_platforms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.available_cpu_platforms = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [creation_timestamp][crate::model::Zone::creation_timestamp].
    pub fn set_creation_timestamp<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [creation_timestamp][crate::model::Zone::creation_timestamp].
    pub fn set_or_clear_creation_timestamp<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.creation_timestamp = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deprecated][crate::model::Zone::deprecated].
    pub fn set_deprecated<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DeprecationStatus>,
    {
        self.deprecated = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deprecated][crate::model::Zone::deprecated].
    pub fn set_or_clear_deprecated<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DeprecationStatus>,
    {
        self.deprecated = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::Zone::description].
    pub fn set_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [description][crate::model::Zone::description].
    pub fn set_or_clear_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::Zone::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::Zone::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<u64>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kind][crate::model::Zone::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::Zone::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::Zone::name].
    pub fn set_name<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [name][crate::model::Zone::name].
    pub fn set_or_clear_name<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.name = v.map(|x| x.into());
        self
    }

    /// Sets the value of [region][crate::model::Zone::region].
    pub fn set_region<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.region = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [region][crate::model::Zone::region].
    pub fn set_or_clear_region<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.region = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::Zone::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::Zone::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::Zone::status].
    pub fn set_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::zone::Status>,
    {
        self.status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [status][crate::model::Zone::status].
    pub fn set_or_clear_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::zone::Status>,
    {
        self.status = v.map(|x| x.into());
        self
    }

    /// Sets the value of [supports_pzs][crate::model::Zone::supports_pzs].
    pub fn set_supports_pzs<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.supports_pzs = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [supports_pzs][crate::model::Zone::supports_pzs].
    pub fn set_or_clear_supports_pzs<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.supports_pzs = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "zones")]
impl wkt::message::Message for Zone {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.Zone"
    }
}

/// Defines additional types related to [Zone].
#[cfg(feature = "zones")]
pub mod zone {
    #[allow(unused_imports)]
    use super::*;

    /// The enumerated type for the [status][google.cloud.compute.v1.Zone.status] field.
    ///
    /// [google.cloud.compute.v1.Zone.status]: crate::model::zone::Status
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[cfg(feature = "zones")]
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        Down,
        Up,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    #[cfg(feature = "zones")]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    #[cfg(feature = "zones")]
    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Down => std::option::Option::Some(0),
                Self::Up => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Down => std::option::Option::Some("DOWN"),
                Self::Up => std::option::Option::Some("UP"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    #[cfg(feature = "zones")]
    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    #[cfg(feature = "zones")]
    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    #[cfg(feature = "zones")]
    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Down,
                1 => Self::Up,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    #[cfg(feature = "zones")]
    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "DOWN" => Self::Down,
                "UP" => Self::Up,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    #[cfg(feature = "zones")]
    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Down => serializer.serialize_str("DOWN"),
                Self::Up => serializer.serialize_str("UP"),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    #[cfg(feature = "zones")]
    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.cloud.compute.v1.Zone.status",
            ))
        }
    }
}

/// Contains a list of zone resources.
#[cfg(feature = "zones")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ZoneList {
    /// [Output Only] Unique identifier for the resource; defined by the server.
    pub id: std::option::Option<std::string::String>,

    /// A list of Zone resources.
    pub items: std::vec::Vec<crate::model::Zone>,

    /// Type of resource.
    pub kind: std::option::Option<std::string::String>,

    /// [Output Only] This token allows you to get the next page of results for list requests. If the number of results is larger than maxResults, use the nextPageToken as a value for the query parameter pageToken in the next list request. Subsequent list requests will have their own nextPageToken to continue paging through the results.
    pub next_page_token: std::option::Option<std::string::String>,

    /// [Output Only] Server-defined URL for this resource.
    pub self_link: std::option::Option<std::string::String>,

    /// [Output Only] Informational warning message.
    pub warning: std::option::Option<crate::model::zone_list::Warning>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "zones")]
impl ZoneList {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::ZoneList::id].
    pub fn set_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [id][crate::model::ZoneList::id].
    pub fn set_or_clear_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.id = v.map(|x| x.into());
        self
    }

    /// Sets the value of [items][crate::model::ZoneList::items].
    pub fn set_items<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Zone>,
    {
        use std::iter::Iterator;
        self.items = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kind][crate::model::ZoneList::kind].
    pub fn set_kind<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kind][crate::model::ZoneList::kind].
    pub fn set_or_clear_kind<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kind = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::ZoneList::next_page_token].
    pub fn set_next_page_token<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [next_page_token][crate::model::ZoneList::next_page_token].
    pub fn set_or_clear_next_page_token<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.next_page_token = v.map(|x| x.into());
        self
    }

    /// Sets the value of [self_link][crate::model::ZoneList::self_link].
    pub fn set_self_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [self_link][crate::model::ZoneList::self_link].
    pub fn set_or_clear_self_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.self_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warning][crate::model::ZoneList::warning].
    pub fn set_warning<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::zone_list::Warning>,
    {
        self.warning = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning][crate::model::ZoneList::warning].
    pub fn set_or_clear_warning<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::zone_list::Warning>,
    {
        self.warning = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "zones")]
impl wkt::message::Message for ZoneList {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ZoneList"
    }
}

#[cfg(feature = "zones")]
#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ZoneList {
    type PageItem = crate::model::Zone;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.items
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone().unwrap_or_default()
    }
}

/// Defines additional types related to [ZoneList].
#[cfg(feature = "zones")]
pub mod zone_list {
    #[allow(unused_imports)]
    use super::*;

    /// The message type for the [warning][google.cloud.compute.v1.ZoneList.warning] field.
    ///
    /// [google.cloud.compute.v1.ZoneList.warning]: crate::model::zone_list::Warning
    #[cfg(feature = "zones")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Warning {
        /// [Output Only] A warning code, if applicable. For example, Compute Engine returns NO_RESULTS_ON_PAGE if there are no results in the response.
        pub code: std::option::Option<crate::model::zone_list::warning::Code>,

        /// [Output Only] Metadata about this warning in key: value format. For example: "data": [ { "key": "scope", "value": "zones/us-east1-d" }
        pub data: std::vec::Vec<crate::model::zone_list::warning::Data>,

        /// [Output Only] A human-readable description of the warning code.
        pub message: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "zones")]
    impl Warning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [code][crate::model::zone_list::Warning::code].
        pub fn set_code<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::zone_list::warning::Code>,
        {
            self.code = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [code][crate::model::zone_list::Warning::code].
        pub fn set_or_clear_code<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::zone_list::warning::Code>,
        {
            self.code = v.map(|x| x.into());
            self
        }

        /// Sets the value of [data][crate::model::zone_list::Warning::data].
        pub fn set_data<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::zone_list::warning::Data>,
        {
            use std::iter::Iterator;
            self.data = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [message][crate::model::zone_list::Warning::message].
        pub fn set_message<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [message][crate::model::zone_list::Warning::message].
        pub fn set_or_clear_message<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.message = v.map(|x| x.into());
            self
        }
    }

    #[cfg(feature = "zones")]
    impl wkt::message::Message for Warning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.compute.v1.ZoneList.warning"
        }
    }

    /// Defines additional types related to [Warning].
    #[cfg(feature = "zones")]
    pub mod warning {
        #[allow(unused_imports)]
        use super::*;

        /// The message type for the [data][google.cloud.compute.v1.ZoneList.warning.data] field.
        ///
        /// [google.cloud.compute.v1.ZoneList.warning.data]: crate::model::zone_list::warning::Data
        #[cfg(feature = "zones")]
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Data {
            /// [Output Only] A key that provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement, or a warning about invalid network settings (for example, if an instance attempts to perform IP forwarding but is not enabled for IP forwarding).
            pub key: std::option::Option<std::string::String>,

            /// [Output Only] A warning data value corresponding to the key.
            pub value: std::option::Option<std::string::String>,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        #[cfg(feature = "zones")]
        impl Data {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [key][crate::model::zone_list::warning::Data::key].
            pub fn set_key<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [key][crate::model::zone_list::warning::Data::key].
            pub fn set_or_clear_key<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.key = v.map(|x| x.into());
                self
            }

            /// Sets the value of [value][crate::model::zone_list::warning::Data::value].
            pub fn set_value<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [value][crate::model::zone_list::warning::Data::value].
            pub fn set_or_clear_value<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<std::string::String>,
            {
                self.value = v.map(|x| x.into());
                self
            }
        }

        #[cfg(feature = "zones")]
        impl wkt::message::Message for Data {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.compute.v1.ZoneList.warning.data"
            }
        }

        /// The enumerated type for the [code][google.cloud.compute.v1.ZoneList.warning.code] field.
        ///
        /// [google.cloud.compute.v1.ZoneList.warning.code]: crate::model::zone_list::warning::Code
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "zones")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Code {
            /// Warning about failed cleanup of transient changes made by a failed operation.
            CleanupFailed,
            /// A link to a deprecated resource was created.
            DeprecatedResourceUsed,
            /// When deploying and at least one of the resources has a type marked as deprecated
            DeprecatedTypeUsed,
            /// The user created a boot disk that is larger than image size.
            DiskSizeLargerThanImageSize,
            /// When deploying and at least one of the resources has a type marked as experimental
            ExperimentalTypeUsed,
            /// Warning that is present in an external api call
            ExternalApiWarning,
            /// Warning that value of a field has been overridden. Deprecated unused field.
            #[deprecated]
            FieldValueOverriden,
            /// The operation involved use of an injected kernel, which is deprecated.
            InjectedKernelsDeprecated,
            /// A WEIGHTED_MAGLEV backend service is associated with a health check that is not of type HTTP/HTTPS/HTTP2.
            InvalidHealthCheckForDynamicWieghtedLb,
            /// When deploying a deployment with a exceedingly large number of resources
            LargeDeploymentWarning,
            /// Resource can't be retrieved due to list overhead quota exceed which captures the amount of resources filtered out by user-defined list filter.
            ListOverheadQuotaExceed,
            /// A resource depends on a missing type
            MissingTypeDependency,
            /// The route's nextHopIp address is not assigned to an instance on the network.
            NextHopAddressNotAssigned,
            /// The route's next hop instance cannot ip forward.
            NextHopCannotIpForward,
            /// The route's nextHopInstance URL refers to an instance that does not have an ipv6 interface on the same network as the route.
            NextHopInstanceHasNoIpv6Interface,
            /// The route's nextHopInstance URL refers to an instance that does not exist.
            NextHopInstanceNotFound,
            /// The route's nextHopInstance URL refers to an instance that is not on the same network as the route.
            NextHopInstanceNotOnNetwork,
            /// The route's next hop instance does not have a status of RUNNING.
            NextHopNotRunning,
            /// Error which is not critical. We decided to continue the process despite the mentioned error.
            NotCriticalError,
            /// No results are present on a particular list page.
            NoResultsOnPage,
            /// Success is reported, but some results may be missing due to errors
            PartialSuccess,
            /// Quota information is not available to client requests (e.g: regions.list).
            QuotaInfoUnavailable,
            /// The user attempted to use a resource that requires a TOS they have not accepted.
            RequiredTosAgreement,
            /// Warning that a resource is in use.
            ResourceInUseByOtherResourceWarning,
            /// One or more of the resources set to auto-delete could not be deleted because they were in use.
            ResourceNotDeleted,
            /// When a resource schema validation is ignored.
            SchemaValidationIgnored,
            /// Instance template used in instance group manager is valid as such, but its application does not make a lot of sense, because it allows only single instance in instance group.
            SingleInstancePropertyTemplate,
            /// When undeclared properties in the schema are present
            UndeclaredProperties,
            /// A given scope cannot be reached.
            Unreachable,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Code::value] or
            /// [Code::name].
            UnknownValue(code::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "zones")]
        pub mod code {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "zones")]
        impl Code {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some(0),
                    Self::DeprecatedResourceUsed => std::option::Option::Some(1),
                    Self::DeprecatedTypeUsed => std::option::Option::Some(2),
                    Self::DiskSizeLargerThanImageSize => std::option::Option::Some(3),
                    Self::ExperimentalTypeUsed => std::option::Option::Some(4),
                    Self::ExternalApiWarning => std::option::Option::Some(5),
                    Self::FieldValueOverriden => std::option::Option::Some(6),
                    Self::InjectedKernelsDeprecated => std::option::Option::Some(7),
                    Self::InvalidHealthCheckForDynamicWieghtedLb => std::option::Option::Some(8),
                    Self::LargeDeploymentWarning => std::option::Option::Some(9),
                    Self::ListOverheadQuotaExceed => std::option::Option::Some(10),
                    Self::MissingTypeDependency => std::option::Option::Some(11),
                    Self::NextHopAddressNotAssigned => std::option::Option::Some(12),
                    Self::NextHopCannotIpForward => std::option::Option::Some(13),
                    Self::NextHopInstanceHasNoIpv6Interface => std::option::Option::Some(14),
                    Self::NextHopInstanceNotFound => std::option::Option::Some(15),
                    Self::NextHopInstanceNotOnNetwork => std::option::Option::Some(16),
                    Self::NextHopNotRunning => std::option::Option::Some(17),
                    Self::NotCriticalError => std::option::Option::Some(18),
                    Self::NoResultsOnPage => std::option::Option::Some(19),
                    Self::PartialSuccess => std::option::Option::Some(20),
                    Self::QuotaInfoUnavailable => std::option::Option::Some(21),
                    Self::RequiredTosAgreement => std::option::Option::Some(22),
                    Self::ResourceInUseByOtherResourceWarning => std::option::Option::Some(23),
                    Self::ResourceNotDeleted => std::option::Option::Some(24),
                    Self::SchemaValidationIgnored => std::option::Option::Some(25),
                    Self::SingleInstancePropertyTemplate => std::option::Option::Some(26),
                    Self::UndeclaredProperties => std::option::Option::Some(27),
                    Self::Unreachable => std::option::Option::Some(28),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::CleanupFailed => std::option::Option::Some("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        std::option::Option::Some("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => std::option::Option::Some("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        std::option::Option::Some("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        std::option::Option::Some("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => std::option::Option::Some("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => std::option::Option::Some("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        std::option::Option::Some("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        std::option::Option::Some("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        std::option::Option::Some("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        std::option::Option::Some("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        std::option::Option::Some("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        std::option::Option::Some("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        std::option::Option::Some("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        std::option::Option::Some("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => std::option::Option::Some("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => std::option::Option::Some("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => std::option::Option::Some("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => std::option::Option::Some("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        std::option::Option::Some("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        std::option::Option::Some("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        std::option::Option::Some("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => std::option::Option::Some("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        std::option::Option::Some("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        std::option::Option::Some("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => {
                        std::option::Option::Some("UNDECLARED_PROPERTIES")
                    }
                    Self::Unreachable => std::option::Option::Some("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "zones")]
        impl std::default::Default for Code {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "zones")]
        impl std::fmt::Display for Code {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "zones")]
        impl std::convert::From<i32> for Code {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::CleanupFailed,
                    1 => Self::DeprecatedResourceUsed,
                    2 => Self::DeprecatedTypeUsed,
                    3 => Self::DiskSizeLargerThanImageSize,
                    4 => Self::ExperimentalTypeUsed,
                    5 => Self::ExternalApiWarning,
                    6 => Self::FieldValueOverriden,
                    7 => Self::InjectedKernelsDeprecated,
                    8 => Self::InvalidHealthCheckForDynamicWieghtedLb,
                    9 => Self::LargeDeploymentWarning,
                    10 => Self::ListOverheadQuotaExceed,
                    11 => Self::MissingTypeDependency,
                    12 => Self::NextHopAddressNotAssigned,
                    13 => Self::NextHopCannotIpForward,
                    14 => Self::NextHopInstanceHasNoIpv6Interface,
                    15 => Self::NextHopInstanceNotFound,
                    16 => Self::NextHopInstanceNotOnNetwork,
                    17 => Self::NextHopNotRunning,
                    18 => Self::NotCriticalError,
                    19 => Self::NoResultsOnPage,
                    20 => Self::PartialSuccess,
                    21 => Self::QuotaInfoUnavailable,
                    22 => Self::RequiredTosAgreement,
                    23 => Self::ResourceInUseByOtherResourceWarning,
                    24 => Self::ResourceNotDeleted,
                    25 => Self::SchemaValidationIgnored,
                    26 => Self::SingleInstancePropertyTemplate,
                    27 => Self::UndeclaredProperties,
                    28 => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "zones")]
        impl std::convert::From<&str> for Code {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "CLEANUP_FAILED" => Self::CleanupFailed,
                    "DEPRECATED_RESOURCE_USED" => Self::DeprecatedResourceUsed,
                    "DEPRECATED_TYPE_USED" => Self::DeprecatedTypeUsed,
                    "DISK_SIZE_LARGER_THAN_IMAGE_SIZE" => Self::DiskSizeLargerThanImageSize,
                    "EXPERIMENTAL_TYPE_USED" => Self::ExperimentalTypeUsed,
                    "EXTERNAL_API_WARNING" => Self::ExternalApiWarning,
                    "FIELD_VALUE_OVERRIDEN" => Self::FieldValueOverriden,
                    "INJECTED_KERNELS_DEPRECATED" => Self::InjectedKernelsDeprecated,
                    "INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB" => {
                        Self::InvalidHealthCheckForDynamicWieghtedLb
                    }
                    "LARGE_DEPLOYMENT_WARNING" => Self::LargeDeploymentWarning,
                    "LIST_OVERHEAD_QUOTA_EXCEED" => Self::ListOverheadQuotaExceed,
                    "MISSING_TYPE_DEPENDENCY" => Self::MissingTypeDependency,
                    "NEXT_HOP_ADDRESS_NOT_ASSIGNED" => Self::NextHopAddressNotAssigned,
                    "NEXT_HOP_CANNOT_IP_FORWARD" => Self::NextHopCannotIpForward,
                    "NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE" => {
                        Self::NextHopInstanceHasNoIpv6Interface
                    }
                    "NEXT_HOP_INSTANCE_NOT_FOUND" => Self::NextHopInstanceNotFound,
                    "NEXT_HOP_INSTANCE_NOT_ON_NETWORK" => Self::NextHopInstanceNotOnNetwork,
                    "NEXT_HOP_NOT_RUNNING" => Self::NextHopNotRunning,
                    "NOT_CRITICAL_ERROR" => Self::NotCriticalError,
                    "NO_RESULTS_ON_PAGE" => Self::NoResultsOnPage,
                    "PARTIAL_SUCCESS" => Self::PartialSuccess,
                    "QUOTA_INFO_UNAVAILABLE" => Self::QuotaInfoUnavailable,
                    "REQUIRED_TOS_AGREEMENT" => Self::RequiredTosAgreement,
                    "RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING" => {
                        Self::ResourceInUseByOtherResourceWarning
                    }
                    "RESOURCE_NOT_DELETED" => Self::ResourceNotDeleted,
                    "SCHEMA_VALIDATION_IGNORED" => Self::SchemaValidationIgnored,
                    "SINGLE_INSTANCE_PROPERTY_TEMPLATE" => Self::SingleInstancePropertyTemplate,
                    "UNDECLARED_PROPERTIES" => Self::UndeclaredProperties,
                    "UNREACHABLE" => Self::Unreachable,
                    _ => Self::UnknownValue(code::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "zones")]
        impl serde::ser::Serialize for Code {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::CleanupFailed => serializer.serialize_str("CLEANUP_FAILED"),
                    Self::DeprecatedResourceUsed => {
                        serializer.serialize_str("DEPRECATED_RESOURCE_USED")
                    }
                    Self::DeprecatedTypeUsed => serializer.serialize_str("DEPRECATED_TYPE_USED"),
                    Self::DiskSizeLargerThanImageSize => {
                        serializer.serialize_str("DISK_SIZE_LARGER_THAN_IMAGE_SIZE")
                    }
                    Self::ExperimentalTypeUsed => {
                        serializer.serialize_str("EXPERIMENTAL_TYPE_USED")
                    }
                    Self::ExternalApiWarning => serializer.serialize_str("EXTERNAL_API_WARNING"),
                    Self::FieldValueOverriden => serializer.serialize_str("FIELD_VALUE_OVERRIDEN"),
                    Self::InjectedKernelsDeprecated => {
                        serializer.serialize_str("INJECTED_KERNELS_DEPRECATED")
                    }
                    Self::InvalidHealthCheckForDynamicWieghtedLb => {
                        serializer.serialize_str("INVALID_HEALTH_CHECK_FOR_DYNAMIC_WIEGHTED_LB")
                    }
                    Self::LargeDeploymentWarning => {
                        serializer.serialize_str("LARGE_DEPLOYMENT_WARNING")
                    }
                    Self::ListOverheadQuotaExceed => {
                        serializer.serialize_str("LIST_OVERHEAD_QUOTA_EXCEED")
                    }
                    Self::MissingTypeDependency => {
                        serializer.serialize_str("MISSING_TYPE_DEPENDENCY")
                    }
                    Self::NextHopAddressNotAssigned => {
                        serializer.serialize_str("NEXT_HOP_ADDRESS_NOT_ASSIGNED")
                    }
                    Self::NextHopCannotIpForward => {
                        serializer.serialize_str("NEXT_HOP_CANNOT_IP_FORWARD")
                    }
                    Self::NextHopInstanceHasNoIpv6Interface => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_HAS_NO_IPV6_INTERFACE")
                    }
                    Self::NextHopInstanceNotFound => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_FOUND")
                    }
                    Self::NextHopInstanceNotOnNetwork => {
                        serializer.serialize_str("NEXT_HOP_INSTANCE_NOT_ON_NETWORK")
                    }
                    Self::NextHopNotRunning => serializer.serialize_str("NEXT_HOP_NOT_RUNNING"),
                    Self::NotCriticalError => serializer.serialize_str("NOT_CRITICAL_ERROR"),
                    Self::NoResultsOnPage => serializer.serialize_str("NO_RESULTS_ON_PAGE"),
                    Self::PartialSuccess => serializer.serialize_str("PARTIAL_SUCCESS"),
                    Self::QuotaInfoUnavailable => {
                        serializer.serialize_str("QUOTA_INFO_UNAVAILABLE")
                    }
                    Self::RequiredTosAgreement => {
                        serializer.serialize_str("REQUIRED_TOS_AGREEMENT")
                    }
                    Self::ResourceInUseByOtherResourceWarning => {
                        serializer.serialize_str("RESOURCE_IN_USE_BY_OTHER_RESOURCE_WARNING")
                    }
                    Self::ResourceNotDeleted => serializer.serialize_str("RESOURCE_NOT_DELETED"),
                    Self::SchemaValidationIgnored => {
                        serializer.serialize_str("SCHEMA_VALIDATION_IGNORED")
                    }
                    Self::SingleInstancePropertyTemplate => {
                        serializer.serialize_str("SINGLE_INSTANCE_PROPERTY_TEMPLATE")
                    }
                    Self::UndeclaredProperties => serializer.serialize_str("UNDECLARED_PROPERTIES"),
                    Self::Unreachable => serializer.serialize_str("UNREACHABLE"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "zones")]
        impl<'de> serde::de::Deserialize<'de> for Code {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Code>::new(
                    ".google.cloud.compute.v1.ZoneList.warning.code",
                ))
            }
        }
    }
}

#[cfg(feature = "instances")]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ZoneSetPolicyRequest {
    /// Flatten Policy to create a backwacd compatible wire-format. Deprecated. Use 'policy' to specify bindings.
    pub bindings: std::vec::Vec<crate::model::Binding>,

    /// Flatten Policy to create a backward compatible wire-format. Deprecated. Use 'policy' to specify the etag.
    pub etag: std::option::Option<::bytes::Bytes>,

    /// REQUIRED: The complete policy to be applied to the 'resource'. The size of the policy is limited to a few 10s of KB. An empty policy is in general a valid policy but certain services (like Projects) might reject them.
    pub policy: std::option::Option<crate::model::Policy>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

#[cfg(feature = "instances")]
impl ZoneSetPolicyRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [bindings][crate::model::ZoneSetPolicyRequest::bindings].
    pub fn set_bindings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Binding>,
    {
        use std::iter::Iterator;
        self.bindings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [etag][crate::model::ZoneSetPolicyRequest::etag].
    pub fn set_etag<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.etag = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [etag][crate::model::ZoneSetPolicyRequest::etag].
    pub fn set_or_clear_etag<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<::bytes::Bytes>,
    {
        self.etag = v.map(|x| x.into());
        self
    }

    /// Sets the value of [policy][crate::model::ZoneSetPolicyRequest::policy].
    pub fn set_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Policy>,
    {
        self.policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy][crate::model::ZoneSetPolicyRequest::policy].
    pub fn set_or_clear_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Policy>,
    {
        self.policy = v.map(|x| x.into());
        self
    }
}

#[cfg(feature = "instances")]
impl wkt::message::Message for ZoneSetPolicyRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.compute.v1.ZoneSetPolicyRequest"
    }
}

/// Synthetic messages for the [images][google.cloud.compute.v1.images] service
///
/// [google.cloud.compute.v1.images]: crate::model::Images
#[cfg(feature = "images")]
pub mod images {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [delete()][google.cloud.compute.v1.images.delete] method.
    ///
    /// [google.cloud.compute.v1.images.delete]: crate::client::Images::delete
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteRequest {
        /// Name of the image resource to delete.
        pub image: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl DeleteRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [image][crate::model::images::DeleteRequest::image].
        pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.image = v.into();
            self
        }

        /// Sets the value of [project][crate::model::images::DeleteRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::images::DeleteRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::images::DeleteRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [deprecate()][google.cloud.compute.v1.images.deprecate] method.
    ///
    /// [google.cloud.compute.v1.images.deprecate]: crate::client::Images::deprecate
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeprecateRequest {
        /// Image name.
        pub image: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [deprecate()][google.cloud.compute.v1.images.deprecate] method.
        ///
        /// [google.cloud.compute.v1.images.deprecate]: crate::client::Images::deprecate
        pub body: std::option::Option<crate::model::DeprecationStatus>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl DeprecateRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [image][crate::model::images::DeprecateRequest::image].
        pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.image = v.into();
            self
        }

        /// Sets the value of [project][crate::model::images::DeprecateRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::images::DeprecateRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::images::DeprecateRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::images::DeprecateRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::DeprecationStatus>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::images::DeprecateRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::DeprecationStatus>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [get()][google.cloud.compute.v1.images.get] method.
    ///
    /// [google.cloud.compute.v1.images.get]: crate::client::Images::get
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// Name of the image resource to return.
        pub image: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [image][crate::model::images::GetRequest::image].
        pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.image = v.into();
            self
        }

        /// Sets the value of [project][crate::model::images::GetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }
    }

    /// Synthetic request message for the [getFromFamily()][google.cloud.compute.v1.images.getFromFamily] method.
    ///
    /// [google.cloud.compute.v1.images.getFromFamily]: crate::client::Images::get_from_family
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetFromFamilyRequest {
        /// Name of the image family to search for.
        pub family: std::string::String,

        /// The image project that the image belongs to. For example, to get a CentOS image, specify centos-cloud as the image project.
        pub project: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl GetFromFamilyRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [family][crate::model::images::GetFromFamilyRequest::family].
        pub fn set_family<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.family = v.into();
            self
        }

        /// Sets the value of [project][crate::model::images::GetFromFamilyRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }
    }

    /// Synthetic request message for the [getIamPolicy()][google.cloud.compute.v1.images.getIamPolicy] method.
    ///
    /// [google.cloud.compute.v1.images.getIamPolicy]: crate::client::Images::get_iam_policy
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetIamPolicyRequest {
        /// Requested IAM Policy version.
        pub options_requested_policy_version: std::option::Option<i32>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name or id of the resource for this request.
        pub resource: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl GetIamPolicyRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [options_requested_policy_version][crate::model::images::GetIamPolicyRequest::options_requested_policy_version].
        pub fn set_options_requested_policy_version<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.options_requested_policy_version = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [options_requested_policy_version][crate::model::images::GetIamPolicyRequest::options_requested_policy_version].
        pub fn set_or_clear_options_requested_policy_version<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.options_requested_policy_version = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::images::GetIamPolicyRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::images::GetIamPolicyRequest::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }
    }

    /// Synthetic request message for the [insert()][google.cloud.compute.v1.images.insert] method.
    ///
    /// [google.cloud.compute.v1.images.insert]: crate::client::Images::insert
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InsertRequest {
        /// Force image creation if true.
        pub force_create: std::option::Option<bool>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [insert()][google.cloud.compute.v1.images.insert] method.
        ///
        /// [google.cloud.compute.v1.images.insert]: crate::client::Images::insert
        pub body: std::option::Option<crate::model::Image>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl InsertRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [force_create][crate::model::images::InsertRequest::force_create].
        pub fn set_force_create<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.force_create = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [force_create][crate::model::images::InsertRequest::force_create].
        pub fn set_or_clear_force_create<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.force_create = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::images::InsertRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::images::InsertRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::images::InsertRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::images::InsertRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Image>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::images::InsertRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Image>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.images.list] method.
    ///
    /// [google.cloud.compute.v1.images.list]: crate::client::Images::list
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case of failure. The default value is false. For example, when partial success behavior is enabled, aggregatedList for a single zone scope either returns all resources in the zone or no resources, with an error code.
        pub return_partial_success: std::option::Option<bool>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::images::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::images::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::images::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::images::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::images::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::images::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::images::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::images::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::images::ListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::images::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::images::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [patch()][google.cloud.compute.v1.images.patch] method.
    ///
    /// [google.cloud.compute.v1.images.patch]: crate::client::Images::patch
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PatchRequest {
        /// Name of the image resource to patch.
        pub image: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Synthetic request body field for the [patch()][google.cloud.compute.v1.images.patch] method.
        ///
        /// [google.cloud.compute.v1.images.patch]: crate::client::Images::patch
        pub body: std::option::Option<crate::model::Image>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl PatchRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [image][crate::model::images::PatchRequest::image].
        pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.image = v.into();
            self
        }

        /// Sets the value of [project][crate::model::images::PatchRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::images::PatchRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::images::PatchRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [body][crate::model::images::PatchRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Image>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::images::PatchRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Image>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setIamPolicy()][google.cloud.compute.v1.images.setIamPolicy] method.
    ///
    /// [google.cloud.compute.v1.images.setIamPolicy]: crate::client::Images::set_iam_policy
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetIamPolicyRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// Name or id of the resource for this request.
        pub resource: std::string::String,

        /// Synthetic request body field for the [setIamPolicy()][google.cloud.compute.v1.images.setIamPolicy] method.
        ///
        /// [google.cloud.compute.v1.images.setIamPolicy]: crate::client::Images::set_iam_policy
        pub body: std::option::Option<crate::model::GlobalSetPolicyRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl SetIamPolicyRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::images::SetIamPolicyRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::images::SetIamPolicyRequest::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [body][crate::model::images::SetIamPolicyRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::GlobalSetPolicyRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::images::SetIamPolicyRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::GlobalSetPolicyRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setLabels()][google.cloud.compute.v1.images.setLabels] method.
    ///
    /// [google.cloud.compute.v1.images.setLabels]: crate::client::Images::set_labels
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetLabelsRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// Name or id of the resource for this request.
        pub resource: std::string::String,

        /// Synthetic request body field for the [setLabels()][google.cloud.compute.v1.images.setLabels] method.
        ///
        /// [google.cloud.compute.v1.images.setLabels]: crate::client::Images::set_labels
        pub body: std::option::Option<crate::model::GlobalSetLabelsRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl SetLabelsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::images::SetLabelsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::images::SetLabelsRequest::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [body][crate::model::images::SetLabelsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::GlobalSetLabelsRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::images::SetLabelsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::GlobalSetLabelsRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [testIamPermissions()][google.cloud.compute.v1.images.testIamPermissions] method.
    ///
    /// [google.cloud.compute.v1.images.testIamPermissions]: crate::client::Images::test_iam_permissions
    #[cfg(feature = "images")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TestIamPermissionsRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// Name or id of the resource for this request.
        pub resource: std::string::String,

        /// Synthetic request body field for the [testIamPermissions()][google.cloud.compute.v1.images.testIamPermissions] method.
        ///
        /// [google.cloud.compute.v1.images.testIamPermissions]: crate::client::Images::test_iam_permissions
        pub body: std::option::Option<crate::model::TestPermissionsRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "images")]
    impl TestIamPermissionsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::images::TestIamPermissionsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::images::TestIamPermissionsRequest::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [body][crate::model::images::TestIamPermissionsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TestPermissionsRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::images::TestIamPermissionsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TestPermissionsRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }
}

/// Synthetic messages for the [instances][google.cloud.compute.v1.instances] service
///
/// [google.cloud.compute.v1.instances]: crate::model::Instances
#[cfg(feature = "instances")]
pub mod instances {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [addAccessConfig()][google.cloud.compute.v1.instances.addAccessConfig] method.
    ///
    /// [google.cloud.compute.v1.instances.addAccessConfig]: crate::client::Instances::add_access_config
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AddAccessConfigRequest {
        /// The instance name for this request.
        pub instance: std::string::String,

        /// The name of the network interface to add to this instance.
        pub network_interface: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [addAccessConfig()][google.cloud.compute.v1.instances.addAccessConfig] method.
        ///
        /// [google.cloud.compute.v1.instances.addAccessConfig]: crate::client::Instances::add_access_config
        pub body: std::option::Option<crate::model::AccessConfig>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl AddAccessConfigRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::AddAccessConfigRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [network_interface][crate::model::instances::AddAccessConfigRequest::network_interface].
        pub fn set_network_interface<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_interface = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::AddAccessConfigRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::AddAccessConfigRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::AddAccessConfigRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::AddAccessConfigRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::AddAccessConfigRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::AccessConfig>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::AddAccessConfigRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::AccessConfig>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [addNetworkInterface()][google.cloud.compute.v1.instances.addNetworkInterface] method.
    ///
    /// [google.cloud.compute.v1.instances.addNetworkInterface]: crate::client::Instances::add_network_interface
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AddNetworkInterfaceRequest {
        /// The instance name for this request stored as resource_id. Name should conform to RFC1035 or be an unsigned long integer.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [addNetworkInterface()][google.cloud.compute.v1.instances.addNetworkInterface] method.
        ///
        /// [google.cloud.compute.v1.instances.addNetworkInterface]: crate::client::Instances::add_network_interface
        pub body: std::option::Option<crate::model::NetworkInterface>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl AddNetworkInterfaceRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::AddNetworkInterfaceRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::AddNetworkInterfaceRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::AddNetworkInterfaceRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::AddNetworkInterfaceRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::AddNetworkInterfaceRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::AddNetworkInterfaceRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::NetworkInterface>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::AddNetworkInterfaceRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::NetworkInterface>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [addResourcePolicies()][google.cloud.compute.v1.instances.addResourcePolicies] method.
    ///
    /// [google.cloud.compute.v1.instances.addResourcePolicies]: crate::client::Instances::add_resource_policies
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AddResourcePoliciesRequest {
        /// The instance name for this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [addResourcePolicies()][google.cloud.compute.v1.instances.addResourcePolicies] method.
        ///
        /// [google.cloud.compute.v1.instances.addResourcePolicies]: crate::client::Instances::add_resource_policies
        pub body: std::option::Option<crate::model::InstancesAddResourcePoliciesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl AddResourcePoliciesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::AddResourcePoliciesRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::AddResourcePoliciesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::AddResourcePoliciesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::AddResourcePoliciesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::AddResourcePoliciesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::AddResourcePoliciesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesAddResourcePoliciesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::AddResourcePoliciesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesAddResourcePoliciesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [aggregatedList()][google.cloud.compute.v1.instances.aggregatedList] method.
    ///
    /// [google.cloud.compute.v1.instances.aggregatedList]: crate::client::Instances::aggregated_list
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AggregatedListRequest {
        /// A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.
        pub filter: std::option::Option<std::string::String>,

        /// Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.
        pub include_all_scopes: std::option::Option<bool>,

        /// The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case of failure. The default value is false. For example, when partial success behavior is enabled, aggregatedList for a single zone scope either returns all resources in the zone or no resources, with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The Shared VPC service project id or service project number for which aggregated list request is invoked for subnetworks list-usable api.
        pub service_project_number: std::option::Option<i64>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl AggregatedListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::instances::AggregatedListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::instances::AggregatedListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [include_all_scopes][crate::model::instances::AggregatedListRequest::include_all_scopes].
        pub fn set_include_all_scopes<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.include_all_scopes = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [include_all_scopes][crate::model::instances::AggregatedListRequest::include_all_scopes].
        pub fn set_or_clear_include_all_scopes<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.include_all_scopes = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::instances::AggregatedListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::instances::AggregatedListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::instances::AggregatedListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::instances::AggregatedListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::instances::AggregatedListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::instances::AggregatedListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instances::AggregatedListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::instances::AggregatedListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::instances::AggregatedListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [service_project_number][crate::model::instances::AggregatedListRequest::service_project_number].
        pub fn set_service_project_number<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.service_project_number = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [service_project_number][crate::model::instances::AggregatedListRequest::service_project_number].
        pub fn set_or_clear_service_project_number<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.service_project_number = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [attachDisk()][google.cloud.compute.v1.instances.attachDisk] method.
    ///
    /// [google.cloud.compute.v1.instances.attachDisk]: crate::client::Instances::attach_disk
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AttachDiskRequest {
        /// Whether to force attach the regional disk even if it's currently attached to another instance. If you try to force attach a zonal disk to an instance, you will receive an error.
        pub force_attach: std::option::Option<bool>,

        /// The instance name for this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [attachDisk()][google.cloud.compute.v1.instances.attachDisk] method.
        ///
        /// [google.cloud.compute.v1.instances.attachDisk]: crate::client::Instances::attach_disk
        pub body: std::option::Option<crate::model::AttachedDisk>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl AttachDiskRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [force_attach][crate::model::instances::AttachDiskRequest::force_attach].
        pub fn set_force_attach<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.force_attach = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [force_attach][crate::model::instances::AttachDiskRequest::force_attach].
        pub fn set_or_clear_force_attach<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.force_attach = v.map(|x| x.into());
            self
        }

        /// Sets the value of [instance][crate::model::instances::AttachDiskRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::AttachDiskRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::AttachDiskRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::AttachDiskRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::AttachDiskRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::AttachDiskRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::AttachedDisk>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::AttachDiskRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::AttachedDisk>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [bulkInsert()][google.cloud.compute.v1.instances.bulkInsert] method.
    ///
    /// [google.cloud.compute.v1.instances.bulkInsert]: crate::client::Instances::bulk_insert
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BulkInsertRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [bulkInsert()][google.cloud.compute.v1.instances.bulkInsert] method.
        ///
        /// [google.cloud.compute.v1.instances.bulkInsert]: crate::client::Instances::bulk_insert
        pub body: std::option::Option<crate::model::BulkInsertInstanceResource>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl BulkInsertRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::instances::BulkInsertRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::BulkInsertRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::BulkInsertRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::BulkInsertRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::BulkInsertRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::BulkInsertInstanceResource>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::BulkInsertRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::BulkInsertInstanceResource>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [delete()][google.cloud.compute.v1.instances.delete] method.
    ///
    /// [google.cloud.compute.v1.instances.delete]: crate::client::Instances::delete
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteRequest {
        /// Name of the instance resource to delete.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl DeleteRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::DeleteRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::DeleteRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::DeleteRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::DeleteRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::DeleteRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [deleteAccessConfig()][google.cloud.compute.v1.instances.deleteAccessConfig] method.
    ///
    /// [google.cloud.compute.v1.instances.deleteAccessConfig]: crate::client::Instances::delete_access_config
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteAccessConfigRequest {
        /// The name of the access config to delete.
        pub access_config: std::string::String,

        /// The instance name for this request.
        pub instance: std::string::String,

        /// The name of the network interface.
        pub network_interface: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl DeleteAccessConfigRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [access_config][crate::model::instances::DeleteAccessConfigRequest::access_config].
        pub fn set_access_config<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.access_config = v.into();
            self
        }

        /// Sets the value of [instance][crate::model::instances::DeleteAccessConfigRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [network_interface][crate::model::instances::DeleteAccessConfigRequest::network_interface].
        pub fn set_network_interface<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_interface = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::DeleteAccessConfigRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::DeleteAccessConfigRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::DeleteAccessConfigRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::DeleteAccessConfigRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [deleteNetworkInterface()][google.cloud.compute.v1.instances.deleteNetworkInterface] method.
    ///
    /// [google.cloud.compute.v1.instances.deleteNetworkInterface]: crate::client::Instances::delete_network_interface
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteNetworkInterfaceRequest {
        /// The instance name for this request stored as resource_id. Name should conform to RFC1035 or be an unsigned long integer.
        pub instance: std::string::String,

        /// The name of the dynamic network interface to be deleted from the instance.
        pub network_interface_name: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl DeleteNetworkInterfaceRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::DeleteNetworkInterfaceRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [network_interface_name][crate::model::instances::DeleteNetworkInterfaceRequest::network_interface_name].
        pub fn set_network_interface_name<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_interface_name = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::DeleteNetworkInterfaceRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::DeleteNetworkInterfaceRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::DeleteNetworkInterfaceRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::DeleteNetworkInterfaceRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [detachDisk()][google.cloud.compute.v1.instances.detachDisk] method.
    ///
    /// [google.cloud.compute.v1.instances.detachDisk]: crate::client::Instances::detach_disk
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DetachDiskRequest {
        /// The device name of the disk to detach. Make a get() request on the instance to view currently attached disks and device names.
        pub device_name: std::string::String,

        /// Instance name for this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl DetachDiskRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [device_name][crate::model::instances::DetachDiskRequest::device_name].
        pub fn set_device_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.device_name = v.into();
            self
        }

        /// Sets the value of [instance][crate::model::instances::DetachDiskRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::DetachDiskRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::DetachDiskRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::DetachDiskRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::DetachDiskRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [get()][google.cloud.compute.v1.instances.get] method.
    ///
    /// [google.cloud.compute.v1.instances.get]: crate::client::Instances::get
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// Name of the instance resource to return.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::GetRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::GetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instances::GetRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [getEffectiveFirewalls()][google.cloud.compute.v1.instances.getEffectiveFirewalls] method.
    ///
    /// [google.cloud.compute.v1.instances.getEffectiveFirewalls]: crate::client::Instances::get_effective_firewalls
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetEffectiveFirewallsRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// The name of the network interface to get the effective firewalls.
        pub network_interface: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl GetEffectiveFirewallsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::GetEffectiveFirewallsRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [network_interface][crate::model::instances::GetEffectiveFirewallsRequest::network_interface].
        pub fn set_network_interface<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_interface = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::GetEffectiveFirewallsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instances::GetEffectiveFirewallsRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [getGuestAttributes()][google.cloud.compute.v1.instances.getGuestAttributes] method.
    ///
    /// [google.cloud.compute.v1.instances.getGuestAttributes]: crate::client::Instances::get_guest_attributes
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetGuestAttributesRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Specifies the guest attributes path to be queried.
        pub query_path: std::option::Option<std::string::String>,

        /// Specifies the key for the guest attributes entry.
        pub variable_key: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl GetGuestAttributesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::GetGuestAttributesRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::GetGuestAttributesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [query_path][crate::model::instances::GetGuestAttributesRequest::query_path].
        pub fn set_query_path<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.query_path = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [query_path][crate::model::instances::GetGuestAttributesRequest::query_path].
        pub fn set_or_clear_query_path<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.query_path = v.map(|x| x.into());
            self
        }

        /// Sets the value of [variable_key][crate::model::instances::GetGuestAttributesRequest::variable_key].
        pub fn set_variable_key<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.variable_key = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [variable_key][crate::model::instances::GetGuestAttributesRequest::variable_key].
        pub fn set_or_clear_variable_key<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.variable_key = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::GetGuestAttributesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [getIamPolicy()][google.cloud.compute.v1.instances.getIamPolicy] method.
    ///
    /// [google.cloud.compute.v1.instances.getIamPolicy]: crate::client::Instances::get_iam_policy
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetIamPolicyRequest {
        /// Requested IAM Policy version.
        pub options_requested_policy_version: std::option::Option<i32>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name or id of the resource for this request.
        pub resource: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl GetIamPolicyRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [options_requested_policy_version][crate::model::instances::GetIamPolicyRequest::options_requested_policy_version].
        pub fn set_options_requested_policy_version<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.options_requested_policy_version = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [options_requested_policy_version][crate::model::instances::GetIamPolicyRequest::options_requested_policy_version].
        pub fn set_or_clear_options_requested_policy_version<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.options_requested_policy_version = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instances::GetIamPolicyRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::instances::GetIamPolicyRequest::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instances::GetIamPolicyRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [getScreenshot()][google.cloud.compute.v1.instances.getScreenshot] method.
    ///
    /// [google.cloud.compute.v1.instances.getScreenshot]: crate::client::Instances::get_screenshot
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetScreenshotRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl GetScreenshotRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::GetScreenshotRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::GetScreenshotRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instances::GetScreenshotRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [getSerialPortOutput()][google.cloud.compute.v1.instances.getSerialPortOutput] method.
    ///
    /// [google.cloud.compute.v1.instances.getSerialPortOutput]: crate::client::Instances::get_serial_port_output
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetSerialPortOutputRequest {
        /// Name of the instance for this request.
        pub instance: std::string::String,

        /// Specifies which COM or serial port to retrieve data from.
        pub port: std::option::Option<i32>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Specifies the starting byte position of the output to return. To start with the first byte of output to the specified port, omit this field or set it to `0`. If the output for that byte position is available, this field matches the `start` parameter sent with the request. If the amount of serial console output exceeds the size of the buffer (1 MB), the oldest output is discarded and is no longer available. If the requested start position refers to discarded output, the start position is adjusted to the oldest output still available, and the adjusted start position is returned as the `start` property value. You can also provide a negative start position, which translates to the most recent number of bytes written to the serial port. For example, -3 is interpreted as the most recent 3 bytes written to the serial console. Note that the negative start is bounded by the retained buffer size, and the returned serial console output will not exceed the max buffer size.
        pub start: std::option::Option<i64>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl GetSerialPortOutputRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::GetSerialPortOutputRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [port][crate::model::instances::GetSerialPortOutputRequest::port].
        pub fn set_port<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.port = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [port][crate::model::instances::GetSerialPortOutputRequest::port].
        pub fn set_or_clear_port<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i32>,
        {
            self.port = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instances::GetSerialPortOutputRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [start][crate::model::instances::GetSerialPortOutputRequest::start].
        pub fn set_start<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.start = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start][crate::model::instances::GetSerialPortOutputRequest::start].
        pub fn set_or_clear_start<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.start = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::GetSerialPortOutputRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [getShieldedInstanceIdentity()][google.cloud.compute.v1.instances.getShieldedInstanceIdentity] method.
    ///
    /// [google.cloud.compute.v1.instances.getShieldedInstanceIdentity]: crate::client::Instances::get_shielded_instance_identity
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetShieldedInstanceIdentityRequest {
        /// Name or id of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl GetShieldedInstanceIdentityRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::GetShieldedInstanceIdentityRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::GetShieldedInstanceIdentityRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instances::GetShieldedInstanceIdentityRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [insert()][google.cloud.compute.v1.instances.insert] method.
    ///
    /// [google.cloud.compute.v1.instances.insert]: crate::client::Instances::insert
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct InsertRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Specifies instance template to create the instance. This field is optional. It can be a full or partial URL. For example, the following are all valid URLs to an instance template: - <https://www.googleapis.com/compute/v1/projects/project> /global/instanceTemplates/instanceTemplate - projects/project/global/instanceTemplates/instanceTemplate - global/instanceTemplates/instanceTemplate
        pub source_instance_template: std::option::Option<std::string::String>,

        /// Specifies the machine image to use to create the instance. This field is optional. It can be a full or partial URL. For example, the following are all valid URLs to a machine image: - <https://www.googleapis.com/compute/v1/projects/project/global/global> /machineImages/machineImage - projects/project/global/global/machineImages/machineImage - global/machineImages/machineImage
        pub source_machine_image: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [insert()][google.cloud.compute.v1.instances.insert] method.
        ///
        /// [google.cloud.compute.v1.instances.insert]: crate::client::Instances::insert
        pub body: std::option::Option<crate::model::Instance>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl InsertRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::instances::InsertRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::InsertRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::InsertRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [source_instance_template][crate::model::instances::InsertRequest::source_instance_template].
        pub fn set_source_instance_template<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.source_instance_template = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [source_instance_template][crate::model::instances::InsertRequest::source_instance_template].
        pub fn set_or_clear_source_instance_template<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.source_instance_template = v.map(|x| x.into());
            self
        }

        /// Sets the value of [source_machine_image][crate::model::instances::InsertRequest::source_machine_image].
        pub fn set_source_machine_image<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.source_machine_image = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [source_machine_image][crate::model::instances::InsertRequest::source_machine_image].
        pub fn set_or_clear_source_machine_image<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.source_machine_image = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::InsertRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::InsertRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Instance>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::InsertRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Instance>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.instances.list] method.
    ///
    /// [google.cloud.compute.v1.instances.list]: crate::client::Instances::list
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case of failure. The default value is false. For example, when partial success behavior is enabled, aggregatedList for a single zone scope either returns all resources in the zone or no resources, with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::instances::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::instances::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::instances::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::instances::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::instances::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::instances::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::instances::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::instances::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instances::ListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::instances::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::instances::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::ListRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [listReferrers()][google.cloud.compute.v1.instances.listReferrers] method.
    ///
    /// [google.cloud.compute.v1.instances.listReferrers]: crate::client::Instances::list_referrers
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListReferrersRequest {
        /// A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.
        pub filter: std::option::Option<std::string::String>,

        /// Name of the target instance scoping this request, or '-' if the request should span over all instances in the container.
        pub instance: std::string::String,

        /// The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case of failure. The default value is false. For example, when partial success behavior is enabled, aggregatedList for a single zone scope either returns all resources in the zone or no resources, with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl ListReferrersRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::instances::ListReferrersRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::instances::ListReferrersRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [instance][crate::model::instances::ListReferrersRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [max_results][crate::model::instances::ListReferrersRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::instances::ListReferrersRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::instances::ListReferrersRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::instances::ListReferrersRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::instances::ListReferrersRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::instances::ListReferrersRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instances::ListReferrersRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::instances::ListReferrersRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::instances::ListReferrersRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::ListReferrersRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [performMaintenance()][google.cloud.compute.v1.instances.performMaintenance] method.
    ///
    /// [google.cloud.compute.v1.instances.performMaintenance]: crate::client::Instances::perform_maintenance
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PerformMaintenanceRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl PerformMaintenanceRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::PerformMaintenanceRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::PerformMaintenanceRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::PerformMaintenanceRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::PerformMaintenanceRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::PerformMaintenanceRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [removeResourcePolicies()][google.cloud.compute.v1.instances.removeResourcePolicies] method.
    ///
    /// [google.cloud.compute.v1.instances.removeResourcePolicies]: crate::client::Instances::remove_resource_policies
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RemoveResourcePoliciesRequest {
        /// The instance name for this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [removeResourcePolicies()][google.cloud.compute.v1.instances.removeResourcePolicies] method.
        ///
        /// [google.cloud.compute.v1.instances.removeResourcePolicies]: crate::client::Instances::remove_resource_policies
        pub body: std::option::Option<crate::model::InstancesRemoveResourcePoliciesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl RemoveResourcePoliciesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::RemoveResourcePoliciesRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::RemoveResourcePoliciesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::RemoveResourcePoliciesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::RemoveResourcePoliciesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::RemoveResourcePoliciesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::RemoveResourcePoliciesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesRemoveResourcePoliciesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::RemoveResourcePoliciesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesRemoveResourcePoliciesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [reportHostAsFaulty()][google.cloud.compute.v1.instances.reportHostAsFaulty] method.
    ///
    /// [google.cloud.compute.v1.instances.reportHostAsFaulty]: crate::client::Instances::report_host_as_faulty
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ReportHostAsFaultyRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [reportHostAsFaulty()][google.cloud.compute.v1.instances.reportHostAsFaulty] method.
        ///
        /// [google.cloud.compute.v1.instances.reportHostAsFaulty]: crate::client::Instances::report_host_as_faulty
        pub body: std::option::Option<crate::model::InstancesReportHostAsFaultyRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl ReportHostAsFaultyRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::ReportHostAsFaultyRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::ReportHostAsFaultyRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::ReportHostAsFaultyRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::ReportHostAsFaultyRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::ReportHostAsFaultyRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::ReportHostAsFaultyRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesReportHostAsFaultyRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::ReportHostAsFaultyRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesReportHostAsFaultyRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [reset()][google.cloud.compute.v1.instances.reset] method.
    ///
    /// [google.cloud.compute.v1.instances.reset]: crate::client::Instances::reset
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResetRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl ResetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::ResetRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::ResetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::ResetRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::ResetRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::ResetRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [resume()][google.cloud.compute.v1.instances.resume] method.
    ///
    /// [google.cloud.compute.v1.instances.resume]: crate::client::Instances::resume
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ResumeRequest {
        /// Name of the instance resource to resume.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl ResumeRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::ResumeRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::ResumeRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::ResumeRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::ResumeRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::ResumeRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [sendDiagnosticInterrupt()][google.cloud.compute.v1.instances.sendDiagnosticInterrupt] method.
    ///
    /// [google.cloud.compute.v1.instances.sendDiagnosticInterrupt]: crate::client::Instances::send_diagnostic_interrupt
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SendDiagnosticInterruptRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SendDiagnosticInterruptRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SendDiagnosticInterruptRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SendDiagnosticInterruptRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instances::SendDiagnosticInterruptRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [setDeletionProtection()][google.cloud.compute.v1.instances.setDeletionProtection] method.
    ///
    /// [google.cloud.compute.v1.instances.setDeletionProtection]: crate::client::Instances::set_deletion_protection
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetDeletionProtectionRequest {
        /// Whether the resource should be protected against deletion.
        pub deletion_protection: std::option::Option<bool>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Name or id of the resource for this request.
        pub resource: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetDeletionProtectionRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [deletion_protection][crate::model::instances::SetDeletionProtectionRequest::deletion_protection].
        pub fn set_deletion_protection<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.deletion_protection = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [deletion_protection][crate::model::instances::SetDeletionProtectionRequest::deletion_protection].
        pub fn set_or_clear_deletion_protection<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.deletion_protection = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instances::SetDeletionProtectionRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetDeletionProtectionRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetDeletionProtectionRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [resource][crate::model::instances::SetDeletionProtectionRequest::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetDeletionProtectionRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [setDiskAutoDelete()][google.cloud.compute.v1.instances.setDiskAutoDelete] method.
    ///
    /// [google.cloud.compute.v1.instances.setDiskAutoDelete]: crate::client::Instances::set_disk_auto_delete
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetDiskAutoDeleteRequest {
        /// Whether to auto-delete the disk when the instance is deleted.
        pub auto_delete: bool,

        /// The device name of the disk to modify. Make a get() request on the instance to view currently attached disks and device names.
        pub device_name: std::string::String,

        /// The instance name for this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetDiskAutoDeleteRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [auto_delete][crate::model::instances::SetDiskAutoDeleteRequest::auto_delete].
        pub fn set_auto_delete<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.auto_delete = v.into();
            self
        }

        /// Sets the value of [device_name][crate::model::instances::SetDiskAutoDeleteRequest::device_name].
        pub fn set_device_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.device_name = v.into();
            self
        }

        /// Sets the value of [instance][crate::model::instances::SetDiskAutoDeleteRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetDiskAutoDeleteRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetDiskAutoDeleteRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetDiskAutoDeleteRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetDiskAutoDeleteRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [setIamPolicy()][google.cloud.compute.v1.instances.setIamPolicy] method.
    ///
    /// [google.cloud.compute.v1.instances.setIamPolicy]: crate::client::Instances::set_iam_policy
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetIamPolicyRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// Name or id of the resource for this request.
        pub resource: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setIamPolicy()][google.cloud.compute.v1.instances.setIamPolicy] method.
        ///
        /// [google.cloud.compute.v1.instances.setIamPolicy]: crate::client::Instances::set_iam_policy
        pub body: std::option::Option<crate::model::ZoneSetPolicyRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetIamPolicyRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::instances::SetIamPolicyRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::instances::SetIamPolicyRequest::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetIamPolicyRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetIamPolicyRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::ZoneSetPolicyRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetIamPolicyRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::ZoneSetPolicyRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setLabels()][google.cloud.compute.v1.instances.setLabels] method.
    ///
    /// [google.cloud.compute.v1.instances.setLabels]: crate::client::Instances::set_labels
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetLabelsRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setLabels()][google.cloud.compute.v1.instances.setLabels] method.
        ///
        /// [google.cloud.compute.v1.instances.setLabels]: crate::client::Instances::set_labels
        pub body: std::option::Option<crate::model::InstancesSetLabelsRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetLabelsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetLabelsRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetLabelsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetLabelsRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetLabelsRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetLabelsRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetLabelsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetLabelsRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetLabelsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetLabelsRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setMachineResources()][google.cloud.compute.v1.instances.setMachineResources] method.
    ///
    /// [google.cloud.compute.v1.instances.setMachineResources]: crate::client::Instances::set_machine_resources
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetMachineResourcesRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setMachineResources()][google.cloud.compute.v1.instances.setMachineResources] method.
        ///
        /// [google.cloud.compute.v1.instances.setMachineResources]: crate::client::Instances::set_machine_resources
        pub body: std::option::Option<crate::model::InstancesSetMachineResourcesRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetMachineResourcesRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetMachineResourcesRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetMachineResourcesRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetMachineResourcesRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetMachineResourcesRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetMachineResourcesRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetMachineResourcesRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetMachineResourcesRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetMachineResourcesRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetMachineResourcesRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setMachineType()][google.cloud.compute.v1.instances.setMachineType] method.
    ///
    /// [google.cloud.compute.v1.instances.setMachineType]: crate::client::Instances::set_machine_type
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetMachineTypeRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setMachineType()][google.cloud.compute.v1.instances.setMachineType] method.
        ///
        /// [google.cloud.compute.v1.instances.setMachineType]: crate::client::Instances::set_machine_type
        pub body: std::option::Option<crate::model::InstancesSetMachineTypeRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetMachineTypeRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetMachineTypeRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetMachineTypeRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetMachineTypeRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetMachineTypeRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetMachineTypeRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetMachineTypeRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetMachineTypeRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetMachineTypeRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetMachineTypeRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setMetadata()][google.cloud.compute.v1.instances.setMetadata] method.
    ///
    /// [google.cloud.compute.v1.instances.setMetadata]: crate::client::Instances::set_metadata
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetMetadataRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setMetadata()][google.cloud.compute.v1.instances.setMetadata] method.
        ///
        /// [google.cloud.compute.v1.instances.setMetadata]: crate::client::Instances::set_metadata
        pub body: std::option::Option<crate::model::Metadata>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetMetadataRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetMetadataRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetMetadataRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetMetadataRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetMetadataRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetMetadataRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetMetadataRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Metadata>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetMetadataRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Metadata>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setMinCpuPlatform()][google.cloud.compute.v1.instances.setMinCpuPlatform] method.
    ///
    /// [google.cloud.compute.v1.instances.setMinCpuPlatform]: crate::client::Instances::set_min_cpu_platform
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetMinCpuPlatformRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setMinCpuPlatform()][google.cloud.compute.v1.instances.setMinCpuPlatform] method.
        ///
        /// [google.cloud.compute.v1.instances.setMinCpuPlatform]: crate::client::Instances::set_min_cpu_platform
        pub body: std::option::Option<crate::model::InstancesSetMinCpuPlatformRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetMinCpuPlatformRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetMinCpuPlatformRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetMinCpuPlatformRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetMinCpuPlatformRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetMinCpuPlatformRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetMinCpuPlatformRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetMinCpuPlatformRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetMinCpuPlatformRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetMinCpuPlatformRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetMinCpuPlatformRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setName()][google.cloud.compute.v1.instances.setName] method.
    ///
    /// [google.cloud.compute.v1.instances.setName]: crate::client::Instances::set_name
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetNameRequest {
        /// The instance name for this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setName()][google.cloud.compute.v1.instances.setName] method.
        ///
        /// [google.cloud.compute.v1.instances.setName]: crate::client::Instances::set_name
        pub body: std::option::Option<crate::model::InstancesSetNameRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetNameRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetNameRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetNameRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetNameRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetNameRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetNameRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetNameRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetNameRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetNameRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetNameRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setScheduling()][google.cloud.compute.v1.instances.setScheduling] method.
    ///
    /// [google.cloud.compute.v1.instances.setScheduling]: crate::client::Instances::set_scheduling
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetSchedulingRequest {
        /// Instance name for this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setScheduling()][google.cloud.compute.v1.instances.setScheduling] method.
        ///
        /// [google.cloud.compute.v1.instances.setScheduling]: crate::client::Instances::set_scheduling
        pub body: std::option::Option<crate::model::Scheduling>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetSchedulingRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetSchedulingRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetSchedulingRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetSchedulingRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetSchedulingRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetSchedulingRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetSchedulingRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Scheduling>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetSchedulingRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Scheduling>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setSecurityPolicy()][google.cloud.compute.v1.instances.setSecurityPolicy] method.
    ///
    /// [google.cloud.compute.v1.instances.setSecurityPolicy]: crate::client::Instances::set_security_policy
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetSecurityPolicyRequest {
        /// Name of the Instance resource to which the security policy should be set. The name should conform to RFC1035.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Name of the zone scoping this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setSecurityPolicy()][google.cloud.compute.v1.instances.setSecurityPolicy] method.
        ///
        /// [google.cloud.compute.v1.instances.setSecurityPolicy]: crate::client::Instances::set_security_policy
        pub body: std::option::Option<crate::model::InstancesSetSecurityPolicyRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetSecurityPolicyRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetSecurityPolicyRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetSecurityPolicyRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetSecurityPolicyRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetSecurityPolicyRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetSecurityPolicyRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetSecurityPolicyRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetSecurityPolicyRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetSecurityPolicyRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetSecurityPolicyRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setServiceAccount()][google.cloud.compute.v1.instances.setServiceAccount] method.
    ///
    /// [google.cloud.compute.v1.instances.setServiceAccount]: crate::client::Instances::set_service_account
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetServiceAccountRequest {
        /// Name of the instance resource to start.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setServiceAccount()][google.cloud.compute.v1.instances.setServiceAccount] method.
        ///
        /// [google.cloud.compute.v1.instances.setServiceAccount]: crate::client::Instances::set_service_account
        pub body: std::option::Option<crate::model::InstancesSetServiceAccountRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetServiceAccountRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetServiceAccountRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetServiceAccountRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetServiceAccountRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetServiceAccountRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetServiceAccountRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetServiceAccountRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetServiceAccountRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetServiceAccountRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesSetServiceAccountRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setShieldedInstanceIntegrityPolicy()][google.cloud.compute.v1.instances.setShieldedInstanceIntegrityPolicy] method.
    ///
    /// [google.cloud.compute.v1.instances.setShieldedInstanceIntegrityPolicy]: crate::client::Instances::set_shielded_instance_integrity_policy
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetShieldedInstanceIntegrityPolicyRequest {
        /// Name or id of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setShieldedInstanceIntegrityPolicy()][google.cloud.compute.v1.instances.setShieldedInstanceIntegrityPolicy] method.
        ///
        /// [google.cloud.compute.v1.instances.setShieldedInstanceIntegrityPolicy]: crate::client::Instances::set_shielded_instance_integrity_policy
        pub body: std::option::Option<crate::model::ShieldedInstanceIntegrityPolicy>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetShieldedInstanceIntegrityPolicyRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::ShieldedInstanceIntegrityPolicy>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::ShieldedInstanceIntegrityPolicy>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [setTags()][google.cloud.compute.v1.instances.setTags] method.
    ///
    /// [google.cloud.compute.v1.instances.setTags]: crate::client::Instances::set_tags
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SetTagsRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [setTags()][google.cloud.compute.v1.instances.setTags] method.
        ///
        /// [google.cloud.compute.v1.instances.setTags]: crate::client::Instances::set_tags
        pub body: std::option::Option<crate::model::Tags>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SetTagsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SetTagsRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SetTagsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SetTagsRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SetTagsRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SetTagsRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::SetTagsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Tags>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::SetTagsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Tags>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [simulateMaintenanceEvent()][google.cloud.compute.v1.instances.simulateMaintenanceEvent] method.
    ///
    /// [google.cloud.compute.v1.instances.simulateMaintenanceEvent]: crate::client::Instances::simulate_maintenance_event
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SimulateMaintenanceEventRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// Determines whether the customers receive notifications before migration. Only applicable to SF vms.
        pub with_extended_notifications: std::option::Option<bool>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SimulateMaintenanceEventRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::SimulateMaintenanceEventRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SimulateMaintenanceEventRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SimulateMaintenanceEventRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SimulateMaintenanceEventRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [with_extended_notifications][crate::model::instances::SimulateMaintenanceEventRequest::with_extended_notifications].
        pub fn set_with_extended_notifications<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.with_extended_notifications = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [with_extended_notifications][crate::model::instances::SimulateMaintenanceEventRequest::with_extended_notifications].
        pub fn set_or_clear_with_extended_notifications<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.with_extended_notifications = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SimulateMaintenanceEventRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [start()][google.cloud.compute.v1.instances.start] method.
    ///
    /// [google.cloud.compute.v1.instances.start]: crate::client::Instances::start
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StartRequest {
        /// Name of the instance resource to start.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl StartRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::StartRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::StartRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::StartRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::StartRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::StartRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [startWithEncryptionKey()][google.cloud.compute.v1.instances.startWithEncryptionKey] method.
    ///
    /// [google.cloud.compute.v1.instances.startWithEncryptionKey]: crate::client::Instances::start_with_encryption_key
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StartWithEncryptionKeyRequest {
        /// Name of the instance resource to start.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [startWithEncryptionKey()][google.cloud.compute.v1.instances.startWithEncryptionKey] method.
        ///
        /// [google.cloud.compute.v1.instances.startWithEncryptionKey]: crate::client::Instances::start_with_encryption_key
        pub body: std::option::Option<crate::model::InstancesStartWithEncryptionKeyRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl StartWithEncryptionKeyRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::StartWithEncryptionKeyRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::StartWithEncryptionKeyRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::StartWithEncryptionKeyRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::StartWithEncryptionKeyRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::StartWithEncryptionKeyRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::StartWithEncryptionKeyRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::InstancesStartWithEncryptionKeyRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::StartWithEncryptionKeyRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::InstancesStartWithEncryptionKeyRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [stop()][google.cloud.compute.v1.instances.stop] method.
    ///
    /// [google.cloud.compute.v1.instances.stop]: crate::client::Instances::stop
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StopRequest {
        /// This property is required if the instance has any attached Local SSD disks. If false, Local SSD data will be preserved when the instance is suspended. If true, the contents of any attached Local SSD disks will be discarded.
        pub discard_local_ssd: std::option::Option<bool>,

        /// Name of the instance resource to stop.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl StopRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [discard_local_ssd][crate::model::instances::StopRequest::discard_local_ssd].
        pub fn set_discard_local_ssd<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.discard_local_ssd = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [discard_local_ssd][crate::model::instances::StopRequest::discard_local_ssd].
        pub fn set_or_clear_discard_local_ssd<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.discard_local_ssd = v.map(|x| x.into());
            self
        }

        /// Sets the value of [instance][crate::model::instances::StopRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::StopRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::StopRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::StopRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::StopRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [suspend()][google.cloud.compute.v1.instances.suspend] method.
    ///
    /// [google.cloud.compute.v1.instances.suspend]: crate::client::Instances::suspend
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SuspendRequest {
        /// This property is required if the instance has any attached Local SSD disks. If false, Local SSD data will be preserved when the instance is suspended. If true, the contents of any attached Local SSD disks will be discarded.
        pub discard_local_ssd: std::option::Option<bool>,

        /// Name of the instance resource to suspend.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl SuspendRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [discard_local_ssd][crate::model::instances::SuspendRequest::discard_local_ssd].
        pub fn set_discard_local_ssd<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.discard_local_ssd = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [discard_local_ssd][crate::model::instances::SuspendRequest::discard_local_ssd].
        pub fn set_or_clear_discard_local_ssd<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.discard_local_ssd = v.map(|x| x.into());
            self
        }

        /// Sets the value of [instance][crate::model::instances::SuspendRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::SuspendRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::SuspendRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::SuspendRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::SuspendRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [testIamPermissions()][google.cloud.compute.v1.instances.testIamPermissions] method.
    ///
    /// [google.cloud.compute.v1.instances.testIamPermissions]: crate::client::Instances::test_iam_permissions
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct TestIamPermissionsRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// Name or id of the resource for this request.
        pub resource: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [testIamPermissions()][google.cloud.compute.v1.instances.testIamPermissions] method.
        ///
        /// [google.cloud.compute.v1.instances.testIamPermissions]: crate::client::Instances::test_iam_permissions
        pub body: std::option::Option<crate::model::TestPermissionsRequest>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl TestIamPermissionsRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::instances::TestIamPermissionsRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::instances::TestIamPermissionsRequest::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::instances::TestIamPermissionsRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::TestIamPermissionsRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::TestPermissionsRequest>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::TestIamPermissionsRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::TestPermissionsRequest>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [update()][google.cloud.compute.v1.instances.update] method.
    ///
    /// [google.cloud.compute.v1.instances.update]: crate::client::Instances::update
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UpdateRequest {
        /// Name of the instance resource to update.
        pub instance: std::string::String,

        /// Specifies the action to take when updating an instance even if the updated properties do not require it. If not specified, then Compute Engine acts based on the minimum action that the updated properties require.
        pub minimal_action:
            std::option::Option<crate::model::instances::update_request::MinimalAction>,

        /// Specifies the most disruptive action that can be taken on the instance as part of the update. Compute Engine returns an error if the instance properties require a more disruptive action as part of the instance update. Valid options from lowest to highest are NO_EFFECT, REFRESH, and RESTART.
        pub most_disruptive_allowed_action: std::option::Option<
            crate::model::instances::update_request::MostDisruptiveAllowedAction,
        >,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [update()][google.cloud.compute.v1.instances.update] method.
        ///
        /// [google.cloud.compute.v1.instances.update]: crate::client::Instances::update
        pub body: std::option::Option<crate::model::Instance>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl UpdateRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::UpdateRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [minimal_action][crate::model::instances::UpdateRequest::minimal_action].
        pub fn set_minimal_action<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::instances::update_request::MinimalAction>,
        {
            self.minimal_action = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [minimal_action][crate::model::instances::UpdateRequest::minimal_action].
        pub fn set_or_clear_minimal_action<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::instances::update_request::MinimalAction>,
        {
            self.minimal_action = v.map(|x| x.into());
            self
        }

        /// Sets the value of [most_disruptive_allowed_action][crate::model::instances::UpdateRequest::most_disruptive_allowed_action].
        pub fn set_most_disruptive_allowed_action<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::instances::update_request::MostDisruptiveAllowedAction,
                >,
        {
            self.most_disruptive_allowed_action = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [most_disruptive_allowed_action][crate::model::instances::UpdateRequest::most_disruptive_allowed_action].
        pub fn set_or_clear_most_disruptive_allowed_action<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<
                    crate::model::instances::update_request::MostDisruptiveAllowedAction,
                >,
        {
            self.most_disruptive_allowed_action = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::instances::UpdateRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::UpdateRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::UpdateRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::UpdateRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::UpdateRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Instance>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::UpdateRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Instance>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Defines additional types related to [UpdateRequest].
    #[cfg(feature = "instances")]
    pub mod update_request {
        #[allow(unused_imports)]
        use super::*;

        /// The enumerated type for the [minimalAction][google.cloud.compute.v1.instances.updateRequest.minimalAction] field.
        ///
        /// [google.cloud.compute.v1.instances.updateRequest.minimalAction]: crate::model::instances::update_request::MinimalAction
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instances")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum MinimalAction {
            Invalid,
            /// No changes can be made to the instance.
            NoEffect,
            /// The instance will not restart.
            Refresh,
            /// The instance will restart.
            Restart,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [MinimalAction::value] or
            /// [MinimalAction::name].
            UnknownValue(minimal_action::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instances")]
        pub mod minimal_action {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instances")]
        impl MinimalAction {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Invalid => std::option::Option::Some(0),
                    Self::NoEffect => std::option::Option::Some(1),
                    Self::Refresh => std::option::Option::Some(2),
                    Self::Restart => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Invalid => std::option::Option::Some("INVALID"),
                    Self::NoEffect => std::option::Option::Some("NO_EFFECT"),
                    Self::Refresh => std::option::Option::Some("REFRESH"),
                    Self::Restart => std::option::Option::Some("RESTART"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::default::Default for MinimalAction {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instances")]
        impl std::fmt::Display for MinimalAction {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<i32> for MinimalAction {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Invalid,
                    1 => Self::NoEffect,
                    2 => Self::Refresh,
                    3 => Self::Restart,
                    _ => Self::UnknownValue(minimal_action::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<&str> for MinimalAction {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "INVALID" => Self::Invalid,
                    "NO_EFFECT" => Self::NoEffect,
                    "REFRESH" => Self::Refresh,
                    "RESTART" => Self::Restart,
                    _ => Self::UnknownValue(minimal_action::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl serde::ser::Serialize for MinimalAction {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Invalid => serializer.serialize_str("INVALID"),
                    Self::NoEffect => serializer.serialize_str("NO_EFFECT"),
                    Self::Refresh => serializer.serialize_str("REFRESH"),
                    Self::Restart => serializer.serialize_str("RESTART"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl<'de> serde::de::Deserialize<'de> for MinimalAction {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<MinimalAction>::new(
                    ".google.cloud.compute.v1.instances.updateRequest.minimalAction",
                ))
            }
        }

        /// The enumerated type for the [mostDisruptiveAllowedAction][google.cloud.compute.v1.instances.updateRequest.mostDisruptiveAllowedAction] field.
        ///
        /// [google.cloud.compute.v1.instances.updateRequest.mostDisruptiveAllowedAction]: crate::model::instances::update_request::MostDisruptiveAllowedAction
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[cfg(feature = "instances")]
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum MostDisruptiveAllowedAction {
            Invalid,
            /// No changes can be made to the instance.
            NoEffect,
            /// The instance will not restart.
            Refresh,
            /// The instance will restart.
            Restart,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [MostDisruptiveAllowedAction::value] or
            /// [MostDisruptiveAllowedAction::name].
            UnknownValue(most_disruptive_allowed_action::UnknownValue),
        }

        #[doc(hidden)]
        #[cfg(feature = "instances")]
        pub mod most_disruptive_allowed_action {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        #[cfg(feature = "instances")]
        impl MostDisruptiveAllowedAction {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Invalid => std::option::Option::Some(0),
                    Self::NoEffect => std::option::Option::Some(1),
                    Self::Refresh => std::option::Option::Some(2),
                    Self::Restart => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Invalid => std::option::Option::Some("INVALID"),
                    Self::NoEffect => std::option::Option::Some("NO_EFFECT"),
                    Self::Refresh => std::option::Option::Some("REFRESH"),
                    Self::Restart => std::option::Option::Some("RESTART"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::default::Default for MostDisruptiveAllowedAction {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        #[cfg(feature = "instances")]
        impl std::fmt::Display for MostDisruptiveAllowedAction {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<i32> for MostDisruptiveAllowedAction {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Invalid,
                    1 => Self::NoEffect,
                    2 => Self::Refresh,
                    3 => Self::Restart,
                    _ => Self::UnknownValue(most_disruptive_allowed_action::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl std::convert::From<&str> for MostDisruptiveAllowedAction {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "INVALID" => Self::Invalid,
                    "NO_EFFECT" => Self::NoEffect,
                    "REFRESH" => Self::Refresh,
                    "RESTART" => Self::Restart,
                    _ => Self::UnknownValue(most_disruptive_allowed_action::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl serde::ser::Serialize for MostDisruptiveAllowedAction {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Invalid => serializer.serialize_str("INVALID"),
                    Self::NoEffect => serializer.serialize_str("NO_EFFECT"),
                    Self::Refresh => serializer.serialize_str("REFRESH"),
                    Self::Restart => serializer.serialize_str("RESTART"),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        #[cfg(feature = "instances")]
        impl<'de> serde::de::Deserialize<'de> for MostDisruptiveAllowedAction {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<
                    MostDisruptiveAllowedAction,
                >::new(
                    ".google.cloud.compute.v1.instances.updateRequest.mostDisruptiveAllowedAction",
                ))
            }
        }
    }

    /// Synthetic request message for the [updateAccessConfig()][google.cloud.compute.v1.instances.updateAccessConfig] method.
    ///
    /// [google.cloud.compute.v1.instances.updateAccessConfig]: crate::client::Instances::update_access_config
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UpdateAccessConfigRequest {
        /// The instance name for this request.
        pub instance: std::string::String,

        /// The name of the network interface where the access config is attached.
        pub network_interface: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [updateAccessConfig()][google.cloud.compute.v1.instances.updateAccessConfig] method.
        ///
        /// [google.cloud.compute.v1.instances.updateAccessConfig]: crate::client::Instances::update_access_config
        pub body: std::option::Option<crate::model::AccessConfig>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl UpdateAccessConfigRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::UpdateAccessConfigRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [network_interface][crate::model::instances::UpdateAccessConfigRequest::network_interface].
        pub fn set_network_interface<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_interface = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::UpdateAccessConfigRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::UpdateAccessConfigRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::UpdateAccessConfigRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::UpdateAccessConfigRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::UpdateAccessConfigRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::AccessConfig>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::UpdateAccessConfigRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::AccessConfig>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [updateDisplayDevice()][google.cloud.compute.v1.instances.updateDisplayDevice] method.
    ///
    /// [google.cloud.compute.v1.instances.updateDisplayDevice]: crate::client::Instances::update_display_device
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UpdateDisplayDeviceRequest {
        /// Name of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [updateDisplayDevice()][google.cloud.compute.v1.instances.updateDisplayDevice] method.
        ///
        /// [google.cloud.compute.v1.instances.updateDisplayDevice]: crate::client::Instances::update_display_device
        pub body: std::option::Option<crate::model::DisplayDevice>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl UpdateDisplayDeviceRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::UpdateDisplayDeviceRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::UpdateDisplayDeviceRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::UpdateDisplayDeviceRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::UpdateDisplayDeviceRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::UpdateDisplayDeviceRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::UpdateDisplayDeviceRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::DisplayDevice>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::UpdateDisplayDeviceRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::DisplayDevice>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [updateNetworkInterface()][google.cloud.compute.v1.instances.updateNetworkInterface] method.
    ///
    /// [google.cloud.compute.v1.instances.updateNetworkInterface]: crate::client::Instances::update_network_interface
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UpdateNetworkInterfaceRequest {
        /// The instance name for this request.
        pub instance: std::string::String,

        /// The name of the network interface to update.
        pub network_interface: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [updateNetworkInterface()][google.cloud.compute.v1.instances.updateNetworkInterface] method.
        ///
        /// [google.cloud.compute.v1.instances.updateNetworkInterface]: crate::client::Instances::update_network_interface
        pub body: std::option::Option<crate::model::NetworkInterface>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl UpdateNetworkInterfaceRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::UpdateNetworkInterfaceRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [network_interface][crate::model::instances::UpdateNetworkInterfaceRequest::network_interface].
        pub fn set_network_interface<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.network_interface = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::UpdateNetworkInterfaceRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::UpdateNetworkInterfaceRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::UpdateNetworkInterfaceRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::UpdateNetworkInterfaceRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::UpdateNetworkInterfaceRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::NetworkInterface>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::UpdateNetworkInterfaceRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::NetworkInterface>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [updateShieldedInstanceConfig()][google.cloud.compute.v1.instances.updateShieldedInstanceConfig] method.
    ///
    /// [google.cloud.compute.v1.instances.updateShieldedInstanceConfig]: crate::client::Instances::update_shielded_instance_config
    #[cfg(feature = "instances")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UpdateShieldedInstanceConfigRequest {
        /// Name or id of the instance scoping this request.
        pub instance: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// An optional request ID to identify requests. Specify a unique request ID so that if you must retry your request, the server will know to ignore the request if it has already been completed. For example, consider a situation where you make an initial request and the request times out. If you make the request again with the same request ID, the server can check if original operation with the same request ID was received, and if so, will ignore the second request. This prevents clients from accidentally creating duplicate commitments. The request ID must be a valid UUID with the exception that zero UUID is not supported ( 00000000-0000-0000-0000-000000000000).
        pub request_id: std::option::Option<std::string::String>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        /// Synthetic request body field for the [updateShieldedInstanceConfig()][google.cloud.compute.v1.instances.updateShieldedInstanceConfig] method.
        ///
        /// [google.cloud.compute.v1.instances.updateShieldedInstanceConfig]: crate::client::Instances::update_shielded_instance_config
        pub body: std::option::Option<crate::model::ShieldedInstanceConfig>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "instances")]
    impl UpdateShieldedInstanceConfigRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [instance][crate::model::instances::UpdateShieldedInstanceConfigRequest::instance].
        pub fn set_instance<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.instance = v.into();
            self
        }

        /// Sets the value of [project][crate::model::instances::UpdateShieldedInstanceConfigRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [request_id][crate::model::instances::UpdateShieldedInstanceConfigRequest::request_id].
        pub fn set_request_id<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [request_id][crate::model::instances::UpdateShieldedInstanceConfigRequest::request_id].
        pub fn set_or_clear_request_id<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.request_id = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::instances::UpdateShieldedInstanceConfigRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }

        /// Sets the value of [body][crate::model::instances::UpdateShieldedInstanceConfigRequest::body].
        pub fn set_body<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
        {
            self.body = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [body][crate::model::instances::UpdateShieldedInstanceConfigRequest::body].
        pub fn set_or_clear_body<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
        {
            self.body = v.map(|x| x.into());
            self
        }
    }
}

/// Synthetic messages for the [machineTypes][google.cloud.compute.v1.machineTypes] service
///
/// [google.cloud.compute.v1.machineTypes]: crate::model::MachineTypes
#[cfg(feature = "machine-types")]
pub mod machine_types {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [aggregatedList()][google.cloud.compute.v1.machineTypes.aggregatedList] method.
    ///
    /// [google.cloud.compute.v1.machineTypes.aggregatedList]: crate::client::MachineTypes::aggregated_list
    #[cfg(feature = "machine-types")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AggregatedListRequest {
        /// A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.
        pub filter: std::option::Option<std::string::String>,

        /// Indicates whether every visible scope for each scope type (zone, region, global) should be included in the response. For new resource types added after this field, the flag has no effect as new resource types will always include every visible scope for each scope type in response. For resource types which predate this field, if this flag is omitted or false, only scopes of the scope types where the resource type is expected to be found will be included.
        pub include_all_scopes: std::option::Option<bool>,

        /// The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case of failure. The default value is false. For example, when partial success behavior is enabled, aggregatedList for a single zone scope either returns all resources in the zone or no resources, with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The Shared VPC service project id or service project number for which aggregated list request is invoked for subnetworks list-usable api.
        pub service_project_number: std::option::Option<i64>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "machine-types")]
    impl AggregatedListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::machine_types::AggregatedListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::machine_types::AggregatedListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [include_all_scopes][crate::model::machine_types::AggregatedListRequest::include_all_scopes].
        pub fn set_include_all_scopes<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.include_all_scopes = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [include_all_scopes][crate::model::machine_types::AggregatedListRequest::include_all_scopes].
        pub fn set_or_clear_include_all_scopes<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.include_all_scopes = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::machine_types::AggregatedListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::machine_types::AggregatedListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::machine_types::AggregatedListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::machine_types::AggregatedListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::machine_types::AggregatedListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::machine_types::AggregatedListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::machine_types::AggregatedListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::machine_types::AggregatedListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::machine_types::AggregatedListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [service_project_number][crate::model::machine_types::AggregatedListRequest::service_project_number].
        pub fn set_service_project_number<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.service_project_number = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [service_project_number][crate::model::machine_types::AggregatedListRequest::service_project_number].
        pub fn set_or_clear_service_project_number<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<i64>,
        {
            self.service_project_number = v.map(|x| x.into());
            self
        }
    }

    /// Synthetic request message for the [get()][google.cloud.compute.v1.machineTypes.get] method.
    ///
    /// [google.cloud.compute.v1.machineTypes.get]: crate::client::MachineTypes::get
    #[cfg(feature = "machine-types")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// Name of the machine type to return.
        pub machine_type: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "machine-types")]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [machine_type][crate::model::machine_types::GetRequest::machine_type].
        pub fn set_machine_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.machine_type = v.into();
            self
        }

        /// Sets the value of [project][crate::model::machine_types::GetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::machine_types::GetRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.machineTypes.list] method.
    ///
    /// [google.cloud.compute.v1.machineTypes.list]: crate::client::MachineTypes::list
    #[cfg(feature = "machine-types")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case of failure. The default value is false. For example, when partial success behavior is enabled, aggregatedList for a single zone scope either returns all resources in the zone or no resources, with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// The name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "machine-types")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::machine_types::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::machine_types::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::machine_types::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::machine_types::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::machine_types::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::machine_types::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::machine_types::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::machine_types::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::machine_types::ListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::machine_types::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::machine_types::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::machine_types::ListRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }
}

/// Synthetic messages for the [zoneOperations][google.cloud.compute.v1.zoneOperations] service
///
/// [google.cloud.compute.v1.zoneOperations]: crate::model::ZoneOperations
#[cfg(feature = "zone-operations")]
pub mod zone_operations {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [delete()][google.cloud.compute.v1.zoneOperations.delete] method.
    ///
    /// [google.cloud.compute.v1.zoneOperations.delete]: crate::client::ZoneOperations::delete
    #[cfg(feature = "zone-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DeleteRequest {
        /// Name of the Operations resource to delete, or its unique numeric identifier.
        pub operation: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "zone-operations")]
    impl DeleteRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation][crate::model::zone_operations::DeleteRequest::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [project][crate::model::zone_operations::DeleteRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::zone_operations::DeleteRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [get()][google.cloud.compute.v1.zoneOperations.get] method.
    ///
    /// [google.cloud.compute.v1.zoneOperations.get]: crate::client::ZoneOperations::get
    #[cfg(feature = "zone-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// Name of the Operations resource to return, or its unique numeric identifier.
        pub operation: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "zone-operations")]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation][crate::model::zone_operations::GetRequest::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [project][crate::model::zone_operations::GetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::zone_operations::GetRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.zoneOperations.list] method.
    ///
    /// [google.cloud.compute.v1.zoneOperations.list]: crate::client::ZoneOperations::list
    #[cfg(feature = "zone-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case of failure. The default value is false. For example, when partial success behavior is enabled, aggregatedList for a single zone scope either returns all resources in the zone or no resources, with an error code.
        pub return_partial_success: std::option::Option<bool>,

        /// Name of the zone for request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "zone-operations")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::zone_operations::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::zone_operations::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::zone_operations::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::zone_operations::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::zone_operations::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::zone_operations::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::zone_operations::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::zone_operations::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::zone_operations::ListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::zone_operations::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::zone_operations::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }

        /// Sets the value of [zone][crate::model::zone_operations::ListRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [wait()][google.cloud.compute.v1.zoneOperations.wait] method.
    ///
    /// [google.cloud.compute.v1.zoneOperations.wait]: crate::client::ZoneOperations::wait
    #[cfg(feature = "zone-operations")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WaitRequest {
        /// Name of the Operations resource to return, or its unique numeric identifier.
        pub operation: std::string::String,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the zone for this request.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "zone-operations")]
    impl WaitRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation][crate::model::zone_operations::WaitRequest::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [project][crate::model::zone_operations::WaitRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::zone_operations::WaitRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }
}

/// Synthetic messages for the [zones][google.cloud.compute.v1.zones] service
///
/// [google.cloud.compute.v1.zones]: crate::model::Zones
#[cfg(feature = "zones")]
pub mod zones {
    #[allow(unused_imports)]
    use super::*;

    /// Synthetic request message for the [get()][google.cloud.compute.v1.zones.get] method.
    ///
    /// [google.cloud.compute.v1.zones.get]: crate::client::Zones::get
    #[cfg(feature = "zones")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GetRequest {
        /// Project ID for this request.
        pub project: std::string::String,

        /// Name of the zone resource to return.
        pub zone: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "zones")]
    impl GetRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project][crate::model::zones::GetRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [zone][crate::model::zones::GetRequest::zone].
        pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.zone = v.into();
            self
        }
    }

    /// Synthetic request message for the [list()][google.cloud.compute.v1.zones.list] method.
    ///
    /// [google.cloud.compute.v1.zones.list]: crate::client::Zones::list
    #[cfg(feature = "zones")]
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ListRequest {
        /// A filter expression that filters resources listed in the response. Most Compute resources support two types of filter expressions: expressions that support regular expressions and expressions that follow API improvement proposal AIP-160. These two types of filter expressions cannot be mixed in one request. If you want to use AIP-160, your expression must specify the field name, an operator, and the value that you want to use for filtering. The value must be a string, a number, or a boolean. The operator must be either `=`, `!=`, `>`, `<`, `<=`, `>=` or `:`. For example, if you are filtering Compute Engine instances, you can exclude instances named `example-instance` by specifying `name != example-instance`. The `:*` comparison can be used to test whether a key has been defined. For example, to find all objects with `owner` label use: ``` labels.owner:* ``` You can also filter nested fields. For example, you could specify `scheduling.automaticRestart = false` to include instances only if they are not scheduled for automatic restarts. You can use filtering on nested fields to filter based on resource labels. To filter on multiple expressions, provide each separate expression within parentheses. For example: ``` (scheduling.automaticRestart = true) (cpuPlatform = "Intel Skylake") ``` By default, each expression is an `AND` expression. However, you can include `AND` and `OR` expressions explicitly. For example: ``` (cpuPlatform = "Intel Skylake") OR (cpuPlatform = "Intel Broadwell") AND (scheduling.automaticRestart = true) ``` If you want to use a regular expression, use the `eq` (equal) or `ne` (not equal) operator against a single un-parenthesized expression with or without quotes or against multiple parenthesized expressions. Examples: `fieldname eq unquoted literal` `fieldname eq 'single quoted literal'` `fieldname eq "double quoted literal"` `(fieldname1 eq literal) (fieldname2 ne "literal")` The literal value is interpreted as a regular expression using Google RE2 library syntax. The literal value must match the entire field. For example, to filter for instances that do not end with name "instance", you would use `name ne .*instance`. You cannot combine constraints on multiple fields using regular expressions.
        pub filter: std::option::Option<std::string::String>,

        /// The maximum number of results per page that should be returned. If the number of available results is larger than `maxResults`, Compute Engine returns a `nextPageToken` that can be used to get the next page of results in subsequent list requests. Acceptable values are `0` to `500`, inclusive. (Default: `500`)
        pub max_results: std::option::Option<u32>,

        /// Sorts list results by a certain order. By default, results are returned in alphanumerical order based on the resource name. You can also sort results in descending order based on the creation timestamp using `orderBy="creationTimestamp desc"`. This sorts results based on the `creationTimestamp` field in reverse chronological order (newest result first). Use this to sort resources like operations so that the newest operation is returned first. Currently, only sorting by `name` or `creationTimestamp desc` is supported.
        pub order_by: std::option::Option<std::string::String>,

        /// Specifies a page token to use. Set `pageToken` to the `nextPageToken` returned by a previous list request to get the next page of results.
        pub page_token: std::option::Option<std::string::String>,

        /// Project ID for this request.
        pub project: std::string::String,

        /// Opt-in for partial success behavior which provides partial results in case of failure. The default value is false. For example, when partial success behavior is enabled, aggregatedList for a single zone scope either returns all resources in the zone or no resources, with an error code.
        pub return_partial_success: std::option::Option<bool>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    #[cfg(feature = "zones")]
    impl ListRequest {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [filter][crate::model::zones::ListRequest::filter].
        pub fn set_filter<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [filter][crate::model::zones::ListRequest::filter].
        pub fn set_or_clear_filter<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.filter = v.map(|x| x.into());
            self
        }

        /// Sets the value of [max_results][crate::model::zones::ListRequest::max_results].
        pub fn set_max_results<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [max_results][crate::model::zones::ListRequest::max_results].
        pub fn set_or_clear_max_results<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<u32>,
        {
            self.max_results = v.map(|x| x.into());
            self
        }

        /// Sets the value of [order_by][crate::model::zones::ListRequest::order_by].
        pub fn set_order_by<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [order_by][crate::model::zones::ListRequest::order_by].
        pub fn set_or_clear_order_by<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.order_by = v.map(|x| x.into());
            self
        }

        /// Sets the value of [page_token][crate::model::zones::ListRequest::page_token].
        pub fn set_page_token<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [page_token][crate::model::zones::ListRequest::page_token].
        pub fn set_or_clear_page_token<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<std::string::String>,
        {
            self.page_token = v.map(|x| x.into());
            self
        }

        /// Sets the value of [project][crate::model::zones::ListRequest::project].
        pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project = v.into();
            self
        }

        /// Sets the value of [return_partial_success][crate::model::zones::ListRequest::return_partial_success].
        pub fn set_return_partial_success<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [return_partial_success][crate::model::zones::ListRequest::return_partial_success].
        pub fn set_or_clear_return_partial_success<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<bool>,
        {
            self.return_partial_success = v.map(|x| x.into());
            self
        }
    }
}
