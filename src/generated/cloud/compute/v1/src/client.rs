// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.
#![allow(rustdoc::bare_urls)]
#![allow(rustdoc::broken_intra_doc_links)]
#![allow(rustdoc::redundant_explicit_links)]

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::AcceleratorTypes;
/// let client = AcceleratorTypes::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `acceleratorTypes` resource.
///
/// # Configuration
///
/// To configure `AcceleratorTypes` use the `with_*` methods in the type returned
/// by [builder()][AcceleratorTypes::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::accelerator_types::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::accelerator_types::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `AcceleratorTypes` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `AcceleratorTypes` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "accelerator-types")]
#[cfg_attr(docsrs, doc(cfg(feature = "accelerator-types")))]
#[derive(Clone, Debug)]
pub struct AcceleratorTypes {
    inner: std::sync::Arc<dyn super::stub::dynamic::AcceleratorTypes>,
}

#[cfg(feature = "accelerator-types")]
impl AcceleratorTypes {
    /// Returns a builder for [AcceleratorTypes].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::AcceleratorTypes;
    /// let client = AcceleratorTypes::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::accelerator_types::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::accelerator_types::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::AcceleratorTypes + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::AcceleratorTypes>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::AcceleratorTypes> {
        super::transport::AcceleratorTypes::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::AcceleratorTypes> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::AcceleratorTypes::new)
    }

    /// Retrieves an aggregated list of accelerator types.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::accelerator_types::AggregatedList {
        super::builder::accelerator_types::AggregatedList::new(self.inner.clone())
    }

    /// Returns the specified accelerator type.
    pub fn get(&self) -> super::builder::accelerator_types::Get {
        super::builder::accelerator_types::Get::new(self.inner.clone())
    }

    /// Retrieves a list of accelerator types that are available to the specified
    /// project.
    pub fn list(&self) -> super::builder::accelerator_types::List {
        super::builder::accelerator_types::List::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::Addresses;
/// let client = Addresses::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `addresses` resource.
///
/// # Configuration
///
/// To configure `Addresses` use the `with_*` methods in the type returned
/// by [builder()][Addresses::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::addresses::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::addresses::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Addresses` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Addresses` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "addresses")]
#[cfg_attr(docsrs, doc(cfg(feature = "addresses")))]
#[derive(Clone, Debug)]
pub struct Addresses {
    inner: std::sync::Arc<dyn super::stub::dynamic::Addresses>,
}

#[cfg(feature = "addresses")]
impl Addresses {
    /// Returns a builder for [Addresses].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::Addresses;
    /// let client = Addresses::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::addresses::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::addresses::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Addresses + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Addresses>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Addresses> {
        super::transport::Addresses::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Addresses> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Addresses::new)
    }

    /// Retrieves an aggregated list of addresses.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::addresses::AggregatedList {
        super::builder::addresses::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified address resource.
    pub fn delete(&self) -> super::builder::addresses::Delete {
        super::builder::addresses::Delete::new(self.inner.clone())
    }

    /// Returns the specified address resource.
    pub fn get(&self) -> super::builder::addresses::Get {
        super::builder::addresses::Get::new(self.inner.clone())
    }

    /// Creates an address resource in the specified project by using the data
    /// included in the request.
    pub fn insert(&self) -> super::builder::addresses::Insert {
        super::builder::addresses::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of addresses contained within
    /// the specified region.
    pub fn list(&self) -> super::builder::addresses::List {
        super::builder::addresses::List::new(self.inner.clone())
    }

    /// Moves the specified address resource.
    pub fn r#move(&self) -> super::builder::addresses::Move {
        super::builder::addresses::Move::new(self.inner.clone())
    }

    /// Sets the labels on an Address. To learn more about labels, read theLabeling
    /// Resources documentation.
    pub fn set_labels(&self) -> super::builder::addresses::SetLabels {
        super::builder::addresses::SetLabels::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::addresses::TestIamPermissions {
        super::builder::addresses::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::addresses::GetOperation {
        super::builder::addresses::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::Autoscalers;
/// let client = Autoscalers::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `autoscalers` resource.
///
/// # Configuration
///
/// To configure `Autoscalers` use the `with_*` methods in the type returned
/// by [builder()][Autoscalers::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::autoscalers::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::autoscalers::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Autoscalers` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Autoscalers` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "autoscalers")]
#[cfg_attr(docsrs, doc(cfg(feature = "autoscalers")))]
#[derive(Clone, Debug)]
pub struct Autoscalers {
    inner: std::sync::Arc<dyn super::stub::dynamic::Autoscalers>,
}

#[cfg(feature = "autoscalers")]
impl Autoscalers {
    /// Returns a builder for [Autoscalers].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::Autoscalers;
    /// let client = Autoscalers::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::autoscalers::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::autoscalers::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Autoscalers + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Autoscalers>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Autoscalers> {
        super::transport::Autoscalers::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Autoscalers> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Autoscalers::new)
    }

    /// Retrieves an aggregated list of autoscalers.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::autoscalers::AggregatedList {
        super::builder::autoscalers::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified autoscaler.
    pub fn delete(&self) -> super::builder::autoscalers::Delete {
        super::builder::autoscalers::Delete::new(self.inner.clone())
    }

    /// Returns the specified autoscaler resource.
    pub fn get(&self) -> super::builder::autoscalers::Get {
        super::builder::autoscalers::Get::new(self.inner.clone())
    }

    /// Creates an autoscaler in the specified project using the data
    /// included in the request.
    pub fn insert(&self) -> super::builder::autoscalers::Insert {
        super::builder::autoscalers::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of autoscalers contained within
    /// the specified zone.
    pub fn list(&self) -> super::builder::autoscalers::List {
        super::builder::autoscalers::List::new(self.inner.clone())
    }

    /// Updates an autoscaler in the specified project using the data
    /// included in the request. This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::autoscalers::Patch {
        super::builder::autoscalers::Patch::new(self.inner.clone())
    }

    /// Updates an autoscaler in the specified project using the data
    /// included in the request.
    pub fn update(&self) -> super::builder::autoscalers::Update {
        super::builder::autoscalers::Update::new(self.inner.clone())
    }

    /// Retrieves the specified zone-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::autoscalers::GetOperation {
        super::builder::autoscalers::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::BackendBuckets;
/// let client = BackendBuckets::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `backendBuckets` resource.
///
/// # Configuration
///
/// To configure `BackendBuckets` use the `with_*` methods in the type returned
/// by [builder()][BackendBuckets::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::backend_buckets::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::backend_buckets::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `BackendBuckets` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `BackendBuckets` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "backend-buckets")]
#[cfg_attr(docsrs, doc(cfg(feature = "backend-buckets")))]
#[derive(Clone, Debug)]
pub struct BackendBuckets {
    inner: std::sync::Arc<dyn super::stub::dynamic::BackendBuckets>,
}

#[cfg(feature = "backend-buckets")]
impl BackendBuckets {
    /// Returns a builder for [BackendBuckets].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::BackendBuckets;
    /// let client = BackendBuckets::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::backend_buckets::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::backend_buckets::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::BackendBuckets + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::BackendBuckets>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::BackendBuckets> {
        super::transport::BackendBuckets::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::BackendBuckets> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::BackendBuckets::new)
    }

    /// Adds a key for validating requests with signed URLs for this backend
    /// bucket.
    pub fn add_signed_url_key(&self) -> super::builder::backend_buckets::AddSignedUrlKey {
        super::builder::backend_buckets::AddSignedUrlKey::new(self.inner.clone())
    }

    /// Deletes the specified BackendBucket resource.
    pub fn delete(&self) -> super::builder::backend_buckets::Delete {
        super::builder::backend_buckets::Delete::new(self.inner.clone())
    }

    /// Deletes a key for validating requests with signed URLs for this backend
    /// bucket.
    pub fn delete_signed_url_key(&self) -> super::builder::backend_buckets::DeleteSignedUrlKey {
        super::builder::backend_buckets::DeleteSignedUrlKey::new(self.inner.clone())
    }

    /// Returns the specified BackendBucket resource.
    pub fn get(&self) -> super::builder::backend_buckets::Get {
        super::builder::backend_buckets::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::backend_buckets::GetIamPolicy {
        super::builder::backend_buckets::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates a BackendBucket resource in the specified project using
    /// the data included in the request.
    pub fn insert(&self) -> super::builder::backend_buckets::Insert {
        super::builder::backend_buckets::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of BackendBucket resources available to the specified
    /// project.
    pub fn list(&self) -> super::builder::backend_buckets::List {
        super::builder::backend_buckets::List::new(self.inner.clone())
    }

    /// Updates the specified BackendBucket resource with the data included in the
    /// request. This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::backend_buckets::Patch {
        super::builder::backend_buckets::Patch::new(self.inner.clone())
    }

    /// Sets the edge security policy for the specified backend bucket.
    pub fn set_edge_security_policy(
        &self,
    ) -> super::builder::backend_buckets::SetEdgeSecurityPolicy {
        super::builder::backend_buckets::SetEdgeSecurityPolicy::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::backend_buckets::SetIamPolicy {
        super::builder::backend_buckets::SetIamPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::backend_buckets::TestIamPermissions {
        super::builder::backend_buckets::TestIamPermissions::new(self.inner.clone())
    }

    /// Updates the specified BackendBucket resource with the data included in the
    /// request.
    pub fn update(&self) -> super::builder::backend_buckets::Update {
        super::builder::backend_buckets::Update::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::backend_buckets::GetOperation {
        super::builder::backend_buckets::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::BackendServices;
/// let client = BackendServices::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `backendServices` resource.
///
/// # Configuration
///
/// To configure `BackendServices` use the `with_*` methods in the type returned
/// by [builder()][BackendServices::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::backend_services::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::backend_services::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `BackendServices` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `BackendServices` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "backend-services")]
#[cfg_attr(docsrs, doc(cfg(feature = "backend-services")))]
#[derive(Clone, Debug)]
pub struct BackendServices {
    inner: std::sync::Arc<dyn super::stub::dynamic::BackendServices>,
}

#[cfg(feature = "backend-services")]
impl BackendServices {
    /// Returns a builder for [BackendServices].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::BackendServices;
    /// let client = BackendServices::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::backend_services::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::backend_services::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::BackendServices + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::BackendServices>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::BackendServices> {
        super::transport::BackendServices::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::BackendServices> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::BackendServices::new)
    }

    /// Adds a key for validating requests with signed URLs for this backend
    /// service.
    pub fn add_signed_url_key(&self) -> super::builder::backend_services::AddSignedUrlKey {
        super::builder::backend_services::AddSignedUrlKey::new(self.inner.clone())
    }

    /// Retrieves the list of all BackendService resources, regional and global,
    /// available to the specified project.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::backend_services::AggregatedList {
        super::builder::backend_services::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified BackendService resource.
    pub fn delete(&self) -> super::builder::backend_services::Delete {
        super::builder::backend_services::Delete::new(self.inner.clone())
    }

    /// Deletes a key for validating requests with signed URLs for this backend
    /// service.
    pub fn delete_signed_url_key(&self) -> super::builder::backend_services::DeleteSignedUrlKey {
        super::builder::backend_services::DeleteSignedUrlKey::new(self.inner.clone())
    }

    /// Returns the specified BackendService resource.
    pub fn get(&self) -> super::builder::backend_services::Get {
        super::builder::backend_services::Get::new(self.inner.clone())
    }

    /// Returns effective security policies applied to this backend service.
    pub fn get_effective_security_policies(
        &self,
    ) -> super::builder::backend_services::GetEffectiveSecurityPolicies {
        super::builder::backend_services::GetEffectiveSecurityPolicies::new(self.inner.clone())
    }

    /// Gets the most recent health check results for this
    /// BackendService.
    ///
    /// Example request body:
    ///
    /// {
    /// "group": "/zones/us-east1-b/instanceGroups/lb-backend-example"
    /// }
    pub fn get_health(&self) -> super::builder::backend_services::GetHealth {
        super::builder::backend_services::GetHealth::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::backend_services::GetIamPolicy {
        super::builder::backend_services::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates a BackendService resource in the specified project using
    /// the data included in the request. For more information, see
    /// Backend services overview.
    pub fn insert(&self) -> super::builder::backend_services::Insert {
        super::builder::backend_services::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of BackendService resources available to the specified
    /// project.
    pub fn list(&self) -> super::builder::backend_services::List {
        super::builder::backend_services::List::new(self.inner.clone())
    }

    /// Retrieves a list of all usable backend services in the specified project.
    pub fn list_usable(&self) -> super::builder::backend_services::ListUsable {
        super::builder::backend_services::ListUsable::new(self.inner.clone())
    }

    /// Patches the specified BackendService resource with the data included in the
    /// request. For more information, see
    /// Backend services overview. This method
    /// supports PATCH semantics and uses the JSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::backend_services::Patch {
        super::builder::backend_services::Patch::new(self.inner.clone())
    }

    /// Sets the edge security policy for the specified backend service.
    pub fn set_edge_security_policy(
        &self,
    ) -> super::builder::backend_services::SetEdgeSecurityPolicy {
        super::builder::backend_services::SetEdgeSecurityPolicy::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::backend_services::SetIamPolicy {
        super::builder::backend_services::SetIamPolicy::new(self.inner.clone())
    }

    /// Sets the Google Cloud Armor security policy for the specified backend
    /// service. For more information, seeGoogle
    /// Cloud Armor Overview
    pub fn set_security_policy(&self) -> super::builder::backend_services::SetSecurityPolicy {
        super::builder::backend_services::SetSecurityPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::backend_services::TestIamPermissions {
        super::builder::backend_services::TestIamPermissions::new(self.inner.clone())
    }

    /// Updates the specified BackendService resource with the data included in the
    /// request. For more information, seeBackend
    /// services overview.
    pub fn update(&self) -> super::builder::backend_services::Update {
        super::builder::backend_services::Update::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::backend_services::GetOperation {
        super::builder::backend_services::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::CrossSiteNetworks;
/// let client = CrossSiteNetworks::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `crossSiteNetworks` resource.
///
/// # Configuration
///
/// To configure `CrossSiteNetworks` use the `with_*` methods in the type returned
/// by [builder()][CrossSiteNetworks::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::cross_site_networks::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::cross_site_networks::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `CrossSiteNetworks` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `CrossSiteNetworks` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "cross-site-networks")]
#[cfg_attr(docsrs, doc(cfg(feature = "cross-site-networks")))]
#[derive(Clone, Debug)]
pub struct CrossSiteNetworks {
    inner: std::sync::Arc<dyn super::stub::dynamic::CrossSiteNetworks>,
}

#[cfg(feature = "cross-site-networks")]
impl CrossSiteNetworks {
    /// Returns a builder for [CrossSiteNetworks].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::CrossSiteNetworks;
    /// let client = CrossSiteNetworks::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::cross_site_networks::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::cross_site_networks::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::CrossSiteNetworks + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::CrossSiteNetworks>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::CrossSiteNetworks> {
        super::transport::CrossSiteNetworks::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::CrossSiteNetworks> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::CrossSiteNetworks::new)
    }

    /// Deletes the specified cross-site network in the given scope.
    pub fn delete(&self) -> super::builder::cross_site_networks::Delete {
        super::builder::cross_site_networks::Delete::new(self.inner.clone())
    }

    /// Returns the specified cross-site network in the given scope.
    pub fn get(&self) -> super::builder::cross_site_networks::Get {
        super::builder::cross_site_networks::Get::new(self.inner.clone())
    }

    /// Creates a cross-site network in the specified project in the given scope
    /// using the parameters that are included in the request.
    pub fn insert(&self) -> super::builder::cross_site_networks::Insert {
        super::builder::cross_site_networks::Insert::new(self.inner.clone())
    }

    /// Lists the cross-site networks for a project in the given scope.
    pub fn list(&self) -> super::builder::cross_site_networks::List {
        super::builder::cross_site_networks::List::new(self.inner.clone())
    }

    /// Updates the specified cross-site network with the data included in
    /// the request. This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::cross_site_networks::Patch {
        super::builder::cross_site_networks::Patch::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::cross_site_networks::GetOperation {
        super::builder::cross_site_networks::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::DiskTypes;
/// let client = DiskTypes::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `diskTypes` resource.
///
/// # Configuration
///
/// To configure `DiskTypes` use the `with_*` methods in the type returned
/// by [builder()][DiskTypes::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::disk_types::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::disk_types::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `DiskTypes` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `DiskTypes` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "disk-types")]
#[cfg_attr(docsrs, doc(cfg(feature = "disk-types")))]
#[derive(Clone, Debug)]
pub struct DiskTypes {
    inner: std::sync::Arc<dyn super::stub::dynamic::DiskTypes>,
}

#[cfg(feature = "disk-types")]
impl DiskTypes {
    /// Returns a builder for [DiskTypes].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::DiskTypes;
    /// let client = DiskTypes::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::disk_types::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::disk_types::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::DiskTypes + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::DiskTypes>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::DiskTypes> {
        super::transport::DiskTypes::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::DiskTypes> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::DiskTypes::new)
    }

    /// Retrieves an aggregated list of disk types.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::disk_types::AggregatedList {
        super::builder::disk_types::AggregatedList::new(self.inner.clone())
    }

    /// Returns the specified disk type.
    pub fn get(&self) -> super::builder::disk_types::Get {
        super::builder::disk_types::Get::new(self.inner.clone())
    }

    /// Retrieves a list of disk types available to the specified
    /// project.
    pub fn list(&self) -> super::builder::disk_types::List {
        super::builder::disk_types::List::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::Disks;
/// let client = Disks::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `disks` resource.
///
/// # Configuration
///
/// To configure `Disks` use the `with_*` methods in the type returned
/// by [builder()][Disks::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::disks::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::disks::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Disks` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Disks` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "disks")]
#[cfg_attr(docsrs, doc(cfg(feature = "disks")))]
#[derive(Clone, Debug)]
pub struct Disks {
    inner: std::sync::Arc<dyn super::stub::dynamic::Disks>,
}

#[cfg(feature = "disks")]
impl Disks {
    /// Returns a builder for [Disks].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::Disks;
    /// let client = Disks::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::disks::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::disks::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Disks + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Disks>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Disks> {
        super::transport::Disks::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Disks> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Disks::new)
    }

    /// Adds existing resource policies to a disk. You can only add one
    /// policy which will be applied to this disk for scheduling snapshot
    /// creation.
    pub fn add_resource_policies(&self) -> super::builder::disks::AddResourcePolicies {
        super::builder::disks::AddResourcePolicies::new(self.inner.clone())
    }

    /// Retrieves an aggregated list of persistent disks.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::disks::AggregatedList {
        super::builder::disks::AggregatedList::new(self.inner.clone())
    }

    /// Bulk create a set of disks.
    pub fn bulk_insert(&self) -> super::builder::disks::BulkInsert {
        super::builder::disks::BulkInsert::new(self.inner.clone())
    }

    /// Sets the labels on many disks at once. To learn more about labels, read theLabeling
    /// Resources documentation.
    pub fn bulk_set_labels(&self) -> super::builder::disks::BulkSetLabels {
        super::builder::disks::BulkSetLabels::new(self.inner.clone())
    }

    /// Creates a snapshot of a specified persistent disk. For regular snapshot
    /// creation, consider using snapshots.insert
    /// instead, as that method supports more features, such as creating snapshots
    /// in a project different from the source disk project.
    pub fn create_snapshot(&self) -> super::builder::disks::CreateSnapshot {
        super::builder::disks::CreateSnapshot::new(self.inner.clone())
    }

    /// Deletes the specified persistent disk. Deleting a disk removes its data
    /// permanently and is irreversible. However, deleting a disk does not
    /// delete any snapshots
    /// previously made from the disk. You must separatelydelete
    /// snapshots.
    pub fn delete(&self) -> super::builder::disks::Delete {
        super::builder::disks::Delete::new(self.inner.clone())
    }

    /// Returns the specified persistent disk.
    pub fn get(&self) -> super::builder::disks::Get {
        super::builder::disks::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::disks::GetIamPolicy {
        super::builder::disks::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates a persistent disk in the specified project using the data
    /// in the request. You can create a disk from a source
    /// (sourceImage, sourceSnapshot, orsourceDisk) or create an empty 500 GB data disk by
    /// omitting all properties. You can also create a disk that is larger than
    /// the default size by specifying the sizeGb property.
    pub fn insert(&self) -> super::builder::disks::Insert {
        super::builder::disks::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of persistent disks contained within
    /// the specified zone.
    pub fn list(&self) -> super::builder::disks::List {
        super::builder::disks::List::new(self.inner.clone())
    }

    /// Removes resource policies from a disk.
    pub fn remove_resource_policies(&self) -> super::builder::disks::RemoveResourcePolicies {
        super::builder::disks::RemoveResourcePolicies::new(self.inner.clone())
    }

    /// Resizes the specified persistent disk.
    /// You can only increase the size of the disk.
    pub fn resize(&self) -> super::builder::disks::Resize {
        super::builder::disks::Resize::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::disks::SetIamPolicy {
        super::builder::disks::SetIamPolicy::new(self.inner.clone())
    }

    /// Sets the labels on a disk. To learn more about labels, read theLabeling
    /// Resources documentation.
    pub fn set_labels(&self) -> super::builder::disks::SetLabels {
        super::builder::disks::SetLabels::new(self.inner.clone())
    }

    /// Starts asynchronous replication.
    /// Must be invoked on the primary disk.
    pub fn start_async_replication(&self) -> super::builder::disks::StartAsyncReplication {
        super::builder::disks::StartAsyncReplication::new(self.inner.clone())
    }

    /// Stops asynchronous replication.
    /// Can be invoked either on the primary or on the secondary disk.
    pub fn stop_async_replication(&self) -> super::builder::disks::StopAsyncReplication {
        super::builder::disks::StopAsyncReplication::new(self.inner.clone())
    }

    /// Stops asynchronous replication for a consistency group of disks.
    /// Can be invoked either in the primary or secondary scope.
    pub fn stop_group_async_replication(&self) -> super::builder::disks::StopGroupAsyncReplication {
        super::builder::disks::StopGroupAsyncReplication::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::disks::TestIamPermissions {
        super::builder::disks::TestIamPermissions::new(self.inner.clone())
    }

    /// Updates the specified disk with the data included in the request.
    /// The update is performed only on selected fields included as part
    /// of update-mask. Only the following fields can be modified: user_license.
    pub fn update(&self) -> super::builder::disks::Update {
        super::builder::disks::Update::new(self.inner.clone())
    }

    /// Retrieves the specified zone-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::disks::GetOperation {
        super::builder::disks::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::ExternalVpnGateways;
/// let client = ExternalVpnGateways::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `externalVpnGateways` resource.
///
/// # Configuration
///
/// To configure `ExternalVpnGateways` use the `with_*` methods in the type returned
/// by [builder()][ExternalVpnGateways::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::external_vpn_gateways::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::external_vpn_gateways::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ExternalVpnGateways` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ExternalVpnGateways` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "external-vpn-gateways")]
#[cfg_attr(docsrs, doc(cfg(feature = "external-vpn-gateways")))]
#[derive(Clone, Debug)]
pub struct ExternalVpnGateways {
    inner: std::sync::Arc<dyn super::stub::dynamic::ExternalVpnGateways>,
}

#[cfg(feature = "external-vpn-gateways")]
impl ExternalVpnGateways {
    /// Returns a builder for [ExternalVpnGateways].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::ExternalVpnGateways;
    /// let client = ExternalVpnGateways::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::external_vpn_gateways::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::external_vpn_gateways::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ExternalVpnGateways + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::ExternalVpnGateways>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ExternalVpnGateways> {
        super::transport::ExternalVpnGateways::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ExternalVpnGateways> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ExternalVpnGateways::new)
    }

    /// Deletes the specified externalVpnGateway.
    pub fn delete(&self) -> super::builder::external_vpn_gateways::Delete {
        super::builder::external_vpn_gateways::Delete::new(self.inner.clone())
    }

    /// Returns the specified externalVpnGateway. Get a list of available
    /// externalVpnGateways by making a list() request.
    pub fn get(&self) -> super::builder::external_vpn_gateways::Get {
        super::builder::external_vpn_gateways::Get::new(self.inner.clone())
    }

    /// Creates a ExternalVpnGateway in the specified project using
    /// the data included in the request.
    pub fn insert(&self) -> super::builder::external_vpn_gateways::Insert {
        super::builder::external_vpn_gateways::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of ExternalVpnGateway available to the specified
    /// project.
    pub fn list(&self) -> super::builder::external_vpn_gateways::List {
        super::builder::external_vpn_gateways::List::new(self.inner.clone())
    }

    /// Sets the labels on an ExternalVpnGateway. To learn more about labels,
    /// read the Labeling
    /// Resources documentation.
    pub fn set_labels(&self) -> super::builder::external_vpn_gateways::SetLabels {
        super::builder::external_vpn_gateways::SetLabels::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(
        &self,
    ) -> super::builder::external_vpn_gateways::TestIamPermissions {
        super::builder::external_vpn_gateways::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::external_vpn_gateways::GetOperation {
        super::builder::external_vpn_gateways::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::FirewallPolicies;
/// let client = FirewallPolicies::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `firewallPolicies` resource.
///
/// # Configuration
///
/// To configure `FirewallPolicies` use the `with_*` methods in the type returned
/// by [builder()][FirewallPolicies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::firewall_policies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::firewall_policies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `FirewallPolicies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `FirewallPolicies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "firewall-policies")]
#[cfg_attr(docsrs, doc(cfg(feature = "firewall-policies")))]
#[derive(Clone, Debug)]
pub struct FirewallPolicies {
    inner: std::sync::Arc<dyn super::stub::dynamic::FirewallPolicies>,
}

#[cfg(feature = "firewall-policies")]
impl FirewallPolicies {
    /// Returns a builder for [FirewallPolicies].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::FirewallPolicies;
    /// let client = FirewallPolicies::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::firewall_policies::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::firewall_policies::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::FirewallPolicies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::FirewallPolicies>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::FirewallPolicies> {
        super::transport::FirewallPolicies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::FirewallPolicies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::FirewallPolicies::new)
    }

    /// Inserts an association for the specified firewall policy.
    pub fn add_association(&self) -> super::builder::firewall_policies::AddAssociation {
        super::builder::firewall_policies::AddAssociation::new(self.inner.clone())
    }

    /// Inserts a rule into a firewall policy.
    pub fn add_rule(&self) -> super::builder::firewall_policies::AddRule {
        super::builder::firewall_policies::AddRule::new(self.inner.clone())
    }

    /// Copies rules to the specified firewall policy.
    pub fn clone_rules(&self) -> super::builder::firewall_policies::CloneRules {
        super::builder::firewall_policies::CloneRules::new(self.inner.clone())
    }

    /// Deletes the specified policy.
    pub fn delete(&self) -> super::builder::firewall_policies::Delete {
        super::builder::firewall_policies::Delete::new(self.inner.clone())
    }

    /// Returns the specified firewall policy.
    pub fn get(&self) -> super::builder::firewall_policies::Get {
        super::builder::firewall_policies::Get::new(self.inner.clone())
    }

    /// Gets an association with the specified name.
    pub fn get_association(&self) -> super::builder::firewall_policies::GetAssociation {
        super::builder::firewall_policies::GetAssociation::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::firewall_policies::GetIamPolicy {
        super::builder::firewall_policies::GetIamPolicy::new(self.inner.clone())
    }

    /// Gets a rule of the specified priority.
    pub fn get_rule(&self) -> super::builder::firewall_policies::GetRule {
        super::builder::firewall_policies::GetRule::new(self.inner.clone())
    }

    /// Creates a new policy in the specified project using the data included in
    /// the request.
    pub fn insert(&self) -> super::builder::firewall_policies::Insert {
        super::builder::firewall_policies::Insert::new(self.inner.clone())
    }

    /// Lists all the policies that have been configured for the specified
    /// folder or organization.
    pub fn list(&self) -> super::builder::firewall_policies::List {
        super::builder::firewall_policies::List::new(self.inner.clone())
    }

    /// Lists associations of a specified target, i.e., organization or folder.
    pub fn list_associations(&self) -> super::builder::firewall_policies::ListAssociations {
        super::builder::firewall_policies::ListAssociations::new(self.inner.clone())
    }

    /// Moves the specified firewall policy.
    pub fn r#move(&self) -> super::builder::firewall_policies::Move {
        super::builder::firewall_policies::Move::new(self.inner.clone())
    }

    /// Patches the specified policy with the data included in the request.
    pub fn patch(&self) -> super::builder::firewall_policies::Patch {
        super::builder::firewall_policies::Patch::new(self.inner.clone())
    }

    /// Patches a rule of the specified priority.
    pub fn patch_rule(&self) -> super::builder::firewall_policies::PatchRule {
        super::builder::firewall_policies::PatchRule::new(self.inner.clone())
    }

    /// Removes an association for the specified firewall policy.
    pub fn remove_association(&self) -> super::builder::firewall_policies::RemoveAssociation {
        super::builder::firewall_policies::RemoveAssociation::new(self.inner.clone())
    }

    /// Deletes a rule of the specified priority.
    pub fn remove_rule(&self) -> super::builder::firewall_policies::RemoveRule {
        super::builder::firewall_policies::RemoveRule::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::firewall_policies::SetIamPolicy {
        super::builder::firewall_policies::SetIamPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::firewall_policies::TestIamPermissions {
        super::builder::firewall_policies::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource. Gets a list of operations
    /// by making a `list()` request.
    pub fn get_operation(&self) -> super::builder::firewall_policies::GetOperation {
        super::builder::firewall_policies::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::Firewalls;
/// let client = Firewalls::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `firewalls` resource.
///
/// # Configuration
///
/// To configure `Firewalls` use the `with_*` methods in the type returned
/// by [builder()][Firewalls::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::firewalls::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::firewalls::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Firewalls` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Firewalls` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "firewalls")]
#[cfg_attr(docsrs, doc(cfg(feature = "firewalls")))]
#[derive(Clone, Debug)]
pub struct Firewalls {
    inner: std::sync::Arc<dyn super::stub::dynamic::Firewalls>,
}

#[cfg(feature = "firewalls")]
impl Firewalls {
    /// Returns a builder for [Firewalls].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::Firewalls;
    /// let client = Firewalls::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::firewalls::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::firewalls::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Firewalls + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Firewalls>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Firewalls> {
        super::transport::Firewalls::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Firewalls> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Firewalls::new)
    }

    /// Deletes the specified firewall.
    pub fn delete(&self) -> super::builder::firewalls::Delete {
        super::builder::firewalls::Delete::new(self.inner.clone())
    }

    /// Returns the specified firewall.
    pub fn get(&self) -> super::builder::firewalls::Get {
        super::builder::firewalls::Get::new(self.inner.clone())
    }

    /// Creates a firewall rule in the specified project using the data
    /// included in the request.
    pub fn insert(&self) -> super::builder::firewalls::Insert {
        super::builder::firewalls::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of firewall rules available to the specified
    /// project.
    pub fn list(&self) -> super::builder::firewalls::List {
        super::builder::firewalls::List::new(self.inner.clone())
    }

    /// Updates the specified firewall rule with the data included in the
    /// request. This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::firewalls::Patch {
        super::builder::firewalls::Patch::new(self.inner.clone())
    }

    /// Updates the specified firewall rule with the data included in the
    /// request.
    /// Note that all fields will be updated if using PUT, even fields that are not
    /// specified. To update individual fields, please use PATCH instead.
    pub fn update(&self) -> super::builder::firewalls::Update {
        super::builder::firewalls::Update::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::firewalls::GetOperation {
        super::builder::firewalls::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::ForwardingRules;
/// let client = ForwardingRules::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `forwardingRules` resource.
///
/// # Configuration
///
/// To configure `ForwardingRules` use the `with_*` methods in the type returned
/// by [builder()][ForwardingRules::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::forwarding_rules::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::forwarding_rules::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ForwardingRules` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ForwardingRules` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "forwarding-rules")]
#[cfg_attr(docsrs, doc(cfg(feature = "forwarding-rules")))]
#[derive(Clone, Debug)]
pub struct ForwardingRules {
    inner: std::sync::Arc<dyn super::stub::dynamic::ForwardingRules>,
}

#[cfg(feature = "forwarding-rules")]
impl ForwardingRules {
    /// Returns a builder for [ForwardingRules].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::ForwardingRules;
    /// let client = ForwardingRules::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::forwarding_rules::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::forwarding_rules::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ForwardingRules + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::ForwardingRules>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ForwardingRules> {
        super::transport::ForwardingRules::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ForwardingRules> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ForwardingRules::new)
    }

    /// Retrieves an aggregated list of forwarding rules.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::forwarding_rules::AggregatedList {
        super::builder::forwarding_rules::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified ForwardingRule resource.
    pub fn delete(&self) -> super::builder::forwarding_rules::Delete {
        super::builder::forwarding_rules::Delete::new(self.inner.clone())
    }

    /// Returns the specified ForwardingRule resource.
    pub fn get(&self) -> super::builder::forwarding_rules::Get {
        super::builder::forwarding_rules::Get::new(self.inner.clone())
    }

    /// Creates a ForwardingRule resource in the specified project and region using
    /// the data included in the request.
    pub fn insert(&self) -> super::builder::forwarding_rules::Insert {
        super::builder::forwarding_rules::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of ForwardingRule resources available to the specified
    /// project and region.
    pub fn list(&self) -> super::builder::forwarding_rules::List {
        super::builder::forwarding_rules::List::new(self.inner.clone())
    }

    /// Updates the specified forwarding rule with the data included in the
    /// request. This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules. Currently, you can only
    /// patch the network_tier field.
    pub fn patch(&self) -> super::builder::forwarding_rules::Patch {
        super::builder::forwarding_rules::Patch::new(self.inner.clone())
    }

    /// Sets the labels on the specified resource. To learn more about labels,
    /// read the
    /// Labeling Resources documentation.
    pub fn set_labels(&self) -> super::builder::forwarding_rules::SetLabels {
        super::builder::forwarding_rules::SetLabels::new(self.inner.clone())
    }

    /// Changes target URL for forwarding rule. The new target should be of the
    /// same type as the old target.
    pub fn set_target(&self) -> super::builder::forwarding_rules::SetTarget {
        super::builder::forwarding_rules::SetTarget::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::forwarding_rules::GetOperation {
        super::builder::forwarding_rules::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::FutureReservations;
/// let client = FutureReservations::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `futureReservations` resource.
///
/// # Configuration
///
/// To configure `FutureReservations` use the `with_*` methods in the type returned
/// by [builder()][FutureReservations::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::future_reservations::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::future_reservations::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `FutureReservations` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `FutureReservations` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "future-reservations")]
#[cfg_attr(docsrs, doc(cfg(feature = "future-reservations")))]
#[derive(Clone, Debug)]
pub struct FutureReservations {
    inner: std::sync::Arc<dyn super::stub::dynamic::FutureReservations>,
}

#[cfg(feature = "future-reservations")]
impl FutureReservations {
    /// Returns a builder for [FutureReservations].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::FutureReservations;
    /// let client = FutureReservations::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::future_reservations::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::future_reservations::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::FutureReservations + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::FutureReservations>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::FutureReservations> {
        super::transport::FutureReservations::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::FutureReservations> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::FutureReservations::new)
    }

    /// Retrieves an aggregated list of future reservations.
    ///
    /// To prevent failure, recommendation is that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::future_reservations::AggregatedList {
        super::builder::future_reservations::AggregatedList::new(self.inner.clone())
    }

    /// Cancel the specified future reservation.
    pub fn cancel(&self) -> super::builder::future_reservations::Cancel {
        super::builder::future_reservations::Cancel::new(self.inner.clone())
    }

    /// Deletes the specified future reservation.
    pub fn delete(&self) -> super::builder::future_reservations::Delete {
        super::builder::future_reservations::Delete::new(self.inner.clone())
    }

    /// Retrieves information about the specified future reservation.
    pub fn get(&self) -> super::builder::future_reservations::Get {
        super::builder::future_reservations::Get::new(self.inner.clone())
    }

    /// Creates a new Future Reservation.
    pub fn insert(&self) -> super::builder::future_reservations::Insert {
        super::builder::future_reservations::Insert::new(self.inner.clone())
    }

    /// A list of all the future reservations that have been configured for the
    /// specified project in specified zone.
    pub fn list(&self) -> super::builder::future_reservations::List {
        super::builder::future_reservations::List::new(self.inner.clone())
    }

    /// Updates the specified future reservation.
    pub fn update(&self) -> super::builder::future_reservations::Update {
        super::builder::future_reservations::Update::new(self.inner.clone())
    }

    /// Retrieves the specified zone-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::future_reservations::GetOperation {
        super::builder::future_reservations::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::GlobalAddresses;
/// let client = GlobalAddresses::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `globalAddresses` resource.
///
/// # Configuration
///
/// To configure `GlobalAddresses` use the `with_*` methods in the type returned
/// by [builder()][GlobalAddresses::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::global_addresses::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::global_addresses::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `GlobalAddresses` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `GlobalAddresses` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "global-addresses")]
#[cfg_attr(docsrs, doc(cfg(feature = "global-addresses")))]
#[derive(Clone, Debug)]
pub struct GlobalAddresses {
    inner: std::sync::Arc<dyn super::stub::dynamic::GlobalAddresses>,
}

#[cfg(feature = "global-addresses")]
impl GlobalAddresses {
    /// Returns a builder for [GlobalAddresses].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::GlobalAddresses;
    /// let client = GlobalAddresses::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::global_addresses::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::global_addresses::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::GlobalAddresses + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::GlobalAddresses>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::GlobalAddresses> {
        super::transport::GlobalAddresses::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::GlobalAddresses> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::GlobalAddresses::new)
    }

    /// Deletes the specified address resource.
    pub fn delete(&self) -> super::builder::global_addresses::Delete {
        super::builder::global_addresses::Delete::new(self.inner.clone())
    }

    /// Returns the specified address resource.
    pub fn get(&self) -> super::builder::global_addresses::Get {
        super::builder::global_addresses::Get::new(self.inner.clone())
    }

    /// Creates an address resource in the specified project by using the data
    /// included in the request.
    pub fn insert(&self) -> super::builder::global_addresses::Insert {
        super::builder::global_addresses::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of global addresses.
    pub fn list(&self) -> super::builder::global_addresses::List {
        super::builder::global_addresses::List::new(self.inner.clone())
    }

    /// Moves the specified address resource from one project to another project.
    pub fn r#move(&self) -> super::builder::global_addresses::Move {
        super::builder::global_addresses::Move::new(self.inner.clone())
    }

    /// Sets the labels on a GlobalAddress. To learn more about labels, read theLabeling
    /// Resources documentation.
    pub fn set_labels(&self) -> super::builder::global_addresses::SetLabels {
        super::builder::global_addresses::SetLabels::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::global_addresses::TestIamPermissions {
        super::builder::global_addresses::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::global_addresses::GetOperation {
        super::builder::global_addresses::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::GlobalForwardingRules;
/// let client = GlobalForwardingRules::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `globalForwardingRules` resource.
///
/// # Configuration
///
/// To configure `GlobalForwardingRules` use the `with_*` methods in the type returned
/// by [builder()][GlobalForwardingRules::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::global_forwarding_rules::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::global_forwarding_rules::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `GlobalForwardingRules` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `GlobalForwardingRules` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "global-forwarding-rules")]
#[cfg_attr(docsrs, doc(cfg(feature = "global-forwarding-rules")))]
#[derive(Clone, Debug)]
pub struct GlobalForwardingRules {
    inner: std::sync::Arc<dyn super::stub::dynamic::GlobalForwardingRules>,
}

#[cfg(feature = "global-forwarding-rules")]
impl GlobalForwardingRules {
    /// Returns a builder for [GlobalForwardingRules].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::GlobalForwardingRules;
    /// let client = GlobalForwardingRules::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::global_forwarding_rules::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::global_forwarding_rules::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::GlobalForwardingRules + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::GlobalForwardingRules>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::GlobalForwardingRules> {
        super::transport::GlobalForwardingRules::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::GlobalForwardingRules> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::GlobalForwardingRules::new)
    }

    /// Deletes the specified GlobalForwardingRule resource.
    pub fn delete(&self) -> super::builder::global_forwarding_rules::Delete {
        super::builder::global_forwarding_rules::Delete::new(self.inner.clone())
    }

    /// Returns the specified GlobalForwardingRule resource. Gets a list of
    /// available forwarding rules by making a list() request.
    pub fn get(&self) -> super::builder::global_forwarding_rules::Get {
        super::builder::global_forwarding_rules::Get::new(self.inner.clone())
    }

    /// Creates a GlobalForwardingRule resource in the specified project using
    /// the data included in the request.
    pub fn insert(&self) -> super::builder::global_forwarding_rules::Insert {
        super::builder::global_forwarding_rules::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of GlobalForwardingRule resources available to the
    /// specified project.
    pub fn list(&self) -> super::builder::global_forwarding_rules::List {
        super::builder::global_forwarding_rules::List::new(self.inner.clone())
    }

    /// Updates the specified forwarding rule with the data included in the
    /// request. This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules. Currently, you can only
    /// patch the network_tier field.
    pub fn patch(&self) -> super::builder::global_forwarding_rules::Patch {
        super::builder::global_forwarding_rules::Patch::new(self.inner.clone())
    }

    /// Sets the labels on the specified resource. To learn more about labels,
    /// read the
    /// Labeling resources documentation.
    pub fn set_labels(&self) -> super::builder::global_forwarding_rules::SetLabels {
        super::builder::global_forwarding_rules::SetLabels::new(self.inner.clone())
    }

    /// Changes target URL for the GlobalForwardingRule resource. The new target
    /// should be of the same type as the old target.
    pub fn set_target(&self) -> super::builder::global_forwarding_rules::SetTarget {
        super::builder::global_forwarding_rules::SetTarget::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::global_forwarding_rules::GetOperation {
        super::builder::global_forwarding_rules::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::GlobalNetworkEndpointGroups;
/// let client = GlobalNetworkEndpointGroups::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `globalNetworkEndpointGroups` resource.
///
/// # Configuration
///
/// To configure `GlobalNetworkEndpointGroups` use the `with_*` methods in the type returned
/// by [builder()][GlobalNetworkEndpointGroups::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::global_network_endpoint_groups::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::global_network_endpoint_groups::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `GlobalNetworkEndpointGroups` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `GlobalNetworkEndpointGroups` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "global-network-endpoint-groups")]
#[cfg_attr(docsrs, doc(cfg(feature = "global-network-endpoint-groups")))]
#[derive(Clone, Debug)]
pub struct GlobalNetworkEndpointGroups {
    inner: std::sync::Arc<dyn super::stub::dynamic::GlobalNetworkEndpointGroups>,
}

#[cfg(feature = "global-network-endpoint-groups")]
impl GlobalNetworkEndpointGroups {
    /// Returns a builder for [GlobalNetworkEndpointGroups].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::GlobalNetworkEndpointGroups;
    /// let client = GlobalNetworkEndpointGroups::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::global_network_endpoint_groups::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::global_network_endpoint_groups::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::GlobalNetworkEndpointGroups + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::GlobalNetworkEndpointGroups>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::GlobalNetworkEndpointGroups> {
        super::transport::GlobalNetworkEndpointGroups::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::GlobalNetworkEndpointGroups> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::GlobalNetworkEndpointGroups::new)
    }

    /// Attach a network endpoint to the specified network endpoint group.
    pub fn attach_network_endpoints(
        &self,
    ) -> super::builder::global_network_endpoint_groups::AttachNetworkEndpoints {
        super::builder::global_network_endpoint_groups::AttachNetworkEndpoints::new(
            self.inner.clone(),
        )
    }

    /// Deletes the specified network endpoint group.Note that the NEG cannot be
    /// deleted if there are backend services referencing it.
    pub fn delete(&self) -> super::builder::global_network_endpoint_groups::Delete {
        super::builder::global_network_endpoint_groups::Delete::new(self.inner.clone())
    }

    /// Detach the network endpoint from the specified network endpoint group.
    pub fn detach_network_endpoints(
        &self,
    ) -> super::builder::global_network_endpoint_groups::DetachNetworkEndpoints {
        super::builder::global_network_endpoint_groups::DetachNetworkEndpoints::new(
            self.inner.clone(),
        )
    }

    /// Returns the specified network endpoint group.
    pub fn get(&self) -> super::builder::global_network_endpoint_groups::Get {
        super::builder::global_network_endpoint_groups::Get::new(self.inner.clone())
    }

    /// Creates a network endpoint group in the specified project using the
    /// parameters that are included in the request.
    pub fn insert(&self) -> super::builder::global_network_endpoint_groups::Insert {
        super::builder::global_network_endpoint_groups::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of network endpoint groups that are located in the
    /// specified project.
    pub fn list(&self) -> super::builder::global_network_endpoint_groups::List {
        super::builder::global_network_endpoint_groups::List::new(self.inner.clone())
    }

    /// Lists the network endpoints in the specified network endpoint group.
    pub fn list_network_endpoints(
        &self,
    ) -> super::builder::global_network_endpoint_groups::ListNetworkEndpoints {
        super::builder::global_network_endpoint_groups::ListNetworkEndpoints::new(
            self.inner.clone(),
        )
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::global_network_endpoint_groups::GetOperation {
        super::builder::global_network_endpoint_groups::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::GlobalOperations;
/// let client = GlobalOperations::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `globalOperations` resource.
///
/// # Configuration
///
/// To configure `GlobalOperations` use the `with_*` methods in the type returned
/// by [builder()][GlobalOperations::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::global_operations::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::global_operations::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `GlobalOperations` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `GlobalOperations` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "global-operations")]
#[cfg_attr(docsrs, doc(cfg(feature = "global-operations")))]
#[derive(Clone, Debug)]
pub struct GlobalOperations {
    inner: std::sync::Arc<dyn super::stub::dynamic::GlobalOperations>,
}

#[cfg(feature = "global-operations")]
impl GlobalOperations {
    /// Returns a builder for [GlobalOperations].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::GlobalOperations;
    /// let client = GlobalOperations::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::global_operations::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::global_operations::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::GlobalOperations + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::GlobalOperations>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::GlobalOperations> {
        super::transport::GlobalOperations::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::GlobalOperations> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::GlobalOperations::new)
    }

    /// Retrieves an aggregated list of all operations.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::global_operations::AggregatedList {
        super::builder::global_operations::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified Operations resource.
    pub fn delete(&self) -> super::builder::global_operations::Delete {
        super::builder::global_operations::Delete::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get(&self) -> super::builder::global_operations::Get {
        super::builder::global_operations::Get::new(self.inner.clone())
    }

    /// Retrieves a list of Operation resources contained within the specified
    /// project.
    pub fn list(&self) -> super::builder::global_operations::List {
        super::builder::global_operations::List::new(self.inner.clone())
    }

    /// Waits for the specified Operation resource to return as `DONE`
    /// or for the request to approach the 2 minute deadline, and retrieves the
    /// specified Operation resource. This method differs from the
    /// `GET` method in that it waits for no more than the default
    /// deadline (2 minutes) and then returns the current state of the operation,
    /// which might be `DONE` or still in progress.
    ///
    /// This method is called on a best-effort basis. Specifically:
    ///
    /// ```norust
    /// - In uncommon cases, when the server is overloaded, the request might
    /// return before the default deadline is reached, or might return after zero
    /// seconds.
    /// ```
    ///
    /// - If the default deadline is reached, there is no guarantee that the
    ///   operation is actually done when the method returns. Be prepared to retry
    ///   if the operation is not `DONE`.
    pub fn wait(&self) -> super::builder::global_operations::Wait {
        super::builder::global_operations::Wait::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::GlobalOrganizationOperations;
/// let client = GlobalOrganizationOperations::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `globalOrganizationOperations` resource.
///
/// # Configuration
///
/// To configure `GlobalOrganizationOperations` use the `with_*` methods in the type returned
/// by [builder()][GlobalOrganizationOperations::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::global_organization_operations::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::global_organization_operations::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `GlobalOrganizationOperations` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `GlobalOrganizationOperations` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "global-organization-operations")]
#[cfg_attr(docsrs, doc(cfg(feature = "global-organization-operations")))]
#[derive(Clone, Debug)]
pub struct GlobalOrganizationOperations {
    inner: std::sync::Arc<dyn super::stub::dynamic::GlobalOrganizationOperations>,
}

#[cfg(feature = "global-organization-operations")]
impl GlobalOrganizationOperations {
    /// Returns a builder for [GlobalOrganizationOperations].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::GlobalOrganizationOperations;
    /// let client = GlobalOrganizationOperations::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::global_organization_operations::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::global_organization_operations::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::GlobalOrganizationOperations + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::GlobalOrganizationOperations>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::GlobalOrganizationOperations> {
        super::transport::GlobalOrganizationOperations::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::GlobalOrganizationOperations> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::GlobalOrganizationOperations::new)
    }

    /// Deletes the specified Operations resource.
    pub fn delete(&self) -> super::builder::global_organization_operations::Delete {
        super::builder::global_organization_operations::Delete::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource. Gets a list of operations
    /// by making a `list()` request.
    pub fn get(&self) -> super::builder::global_organization_operations::Get {
        super::builder::global_organization_operations::Get::new(self.inner.clone())
    }

    /// Retrieves a list of Operation resources contained within the specified
    /// organization.
    pub fn list(&self) -> super::builder::global_organization_operations::List {
        super::builder::global_organization_operations::List::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::GlobalPublicDelegatedPrefixes;
/// let client = GlobalPublicDelegatedPrefixes::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `globalPublicDelegatedPrefixes` resource.
///
/// # Configuration
///
/// To configure `GlobalPublicDelegatedPrefixes` use the `with_*` methods in the type returned
/// by [builder()][GlobalPublicDelegatedPrefixes::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::global_public_delegated_prefixes::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::global_public_delegated_prefixes::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `GlobalPublicDelegatedPrefixes` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `GlobalPublicDelegatedPrefixes` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "global-public-delegated-prefixes")]
#[cfg_attr(docsrs, doc(cfg(feature = "global-public-delegated-prefixes")))]
#[derive(Clone, Debug)]
pub struct GlobalPublicDelegatedPrefixes {
    inner: std::sync::Arc<dyn super::stub::dynamic::GlobalPublicDelegatedPrefixes>,
}

#[cfg(feature = "global-public-delegated-prefixes")]
impl GlobalPublicDelegatedPrefixes {
    /// Returns a builder for [GlobalPublicDelegatedPrefixes].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::GlobalPublicDelegatedPrefixes;
    /// let client = GlobalPublicDelegatedPrefixes::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::global_public_delegated_prefixes::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::global_public_delegated_prefixes::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::GlobalPublicDelegatedPrefixes + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::GlobalPublicDelegatedPrefixes>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::GlobalPublicDelegatedPrefixes> {
        super::transport::GlobalPublicDelegatedPrefixes::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::GlobalPublicDelegatedPrefixes> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::GlobalPublicDelegatedPrefixes::new)
    }

    /// Deletes the specified global PublicDelegatedPrefix.
    pub fn delete(&self) -> super::builder::global_public_delegated_prefixes::Delete {
        super::builder::global_public_delegated_prefixes::Delete::new(self.inner.clone())
    }

    /// Returns the specified global PublicDelegatedPrefix resource.
    pub fn get(&self) -> super::builder::global_public_delegated_prefixes::Get {
        super::builder::global_public_delegated_prefixes::Get::new(self.inner.clone())
    }

    /// Creates a global PublicDelegatedPrefix in the specified project using the
    /// parameters that are included in the request.
    pub fn insert(&self) -> super::builder::global_public_delegated_prefixes::Insert {
        super::builder::global_public_delegated_prefixes::Insert::new(self.inner.clone())
    }

    /// Lists the global PublicDelegatedPrefixes for a project.
    pub fn list(&self) -> super::builder::global_public_delegated_prefixes::List {
        super::builder::global_public_delegated_prefixes::List::new(self.inner.clone())
    }

    /// Patches the specified global PublicDelegatedPrefix resource with the data
    /// included in the request. This method supportsPATCH
    /// semantics and usesJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::global_public_delegated_prefixes::Patch {
        super::builder::global_public_delegated_prefixes::Patch::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::global_public_delegated_prefixes::GetOperation {
        super::builder::global_public_delegated_prefixes::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::HealthChecks;
/// let client = HealthChecks::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `healthChecks` resource.
///
/// # Configuration
///
/// To configure `HealthChecks` use the `with_*` methods in the type returned
/// by [builder()][HealthChecks::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::health_checks::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::health_checks::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `HealthChecks` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `HealthChecks` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "health-checks")]
#[cfg_attr(docsrs, doc(cfg(feature = "health-checks")))]
#[derive(Clone, Debug)]
pub struct HealthChecks {
    inner: std::sync::Arc<dyn super::stub::dynamic::HealthChecks>,
}

#[cfg(feature = "health-checks")]
impl HealthChecks {
    /// Returns a builder for [HealthChecks].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::HealthChecks;
    /// let client = HealthChecks::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::health_checks::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::health_checks::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::HealthChecks + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::HealthChecks>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::HealthChecks> {
        super::transport::HealthChecks::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::HealthChecks> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::HealthChecks::new)
    }

    /// Retrieves the list of all HealthCheck resources, regional and global,
    /// available to the specified project.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::health_checks::AggregatedList {
        super::builder::health_checks::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified HealthCheck resource.
    pub fn delete(&self) -> super::builder::health_checks::Delete {
        super::builder::health_checks::Delete::new(self.inner.clone())
    }

    /// Returns the specified HealthCheck resource.
    pub fn get(&self) -> super::builder::health_checks::Get {
        super::builder::health_checks::Get::new(self.inner.clone())
    }

    /// Creates a HealthCheck resource in the specified project using the data
    /// included in the request.
    pub fn insert(&self) -> super::builder::health_checks::Insert {
        super::builder::health_checks::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of HealthCheck resources available to the specified
    /// project.
    pub fn list(&self) -> super::builder::health_checks::List {
        super::builder::health_checks::List::new(self.inner.clone())
    }

    /// Updates a HealthCheck resource in the specified project using the data
    /// included in the request. This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::health_checks::Patch {
        super::builder::health_checks::Patch::new(self.inner.clone())
    }

    /// Updates a HealthCheck resource in the specified project using the data
    /// included in the request.
    pub fn update(&self) -> super::builder::health_checks::Update {
        super::builder::health_checks::Update::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::health_checks::GetOperation {
        super::builder::health_checks::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::HttpHealthChecks;
/// let client = HttpHealthChecks::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `httpHealthChecks` resource.
///
/// # Configuration
///
/// To configure `HttpHealthChecks` use the `with_*` methods in the type returned
/// by [builder()][HttpHealthChecks::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::http_health_checks::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::http_health_checks::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `HttpHealthChecks` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `HttpHealthChecks` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "http-health-checks")]
#[cfg_attr(docsrs, doc(cfg(feature = "http-health-checks")))]
#[derive(Clone, Debug)]
pub struct HttpHealthChecks {
    inner: std::sync::Arc<dyn super::stub::dynamic::HttpHealthChecks>,
}

#[cfg(feature = "http-health-checks")]
impl HttpHealthChecks {
    /// Returns a builder for [HttpHealthChecks].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::HttpHealthChecks;
    /// let client = HttpHealthChecks::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::http_health_checks::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::http_health_checks::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::HttpHealthChecks + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::HttpHealthChecks>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::HttpHealthChecks> {
        super::transport::HttpHealthChecks::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::HttpHealthChecks> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::HttpHealthChecks::new)
    }

    /// Deletes the specified HttpHealthCheck resource.
    pub fn delete(&self) -> super::builder::http_health_checks::Delete {
        super::builder::http_health_checks::Delete::new(self.inner.clone())
    }

    /// Returns the specified HttpHealthCheck resource.
    pub fn get(&self) -> super::builder::http_health_checks::Get {
        super::builder::http_health_checks::Get::new(self.inner.clone())
    }

    /// Creates a HttpHealthCheck resource in the specified project using the data
    /// included in the request.
    pub fn insert(&self) -> super::builder::http_health_checks::Insert {
        super::builder::http_health_checks::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of HttpHealthCheck resources available to the specified
    /// project.
    pub fn list(&self) -> super::builder::http_health_checks::List {
        super::builder::http_health_checks::List::new(self.inner.clone())
    }

    /// Updates a HttpHealthCheck resource in the specified project using the data
    /// included in the request. This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::http_health_checks::Patch {
        super::builder::http_health_checks::Patch::new(self.inner.clone())
    }

    /// Updates a HttpHealthCheck resource in the specified project using the data
    /// included in the request.
    pub fn update(&self) -> super::builder::http_health_checks::Update {
        super::builder::http_health_checks::Update::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::http_health_checks::GetOperation {
        super::builder::http_health_checks::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::HttpsHealthChecks;
/// let client = HttpsHealthChecks::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `httpsHealthChecks` resource.
///
/// # Configuration
///
/// To configure `HttpsHealthChecks` use the `with_*` methods in the type returned
/// by [builder()][HttpsHealthChecks::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::https_health_checks::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::https_health_checks::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `HttpsHealthChecks` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `HttpsHealthChecks` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "https-health-checks")]
#[cfg_attr(docsrs, doc(cfg(feature = "https-health-checks")))]
#[derive(Clone, Debug)]
pub struct HttpsHealthChecks {
    inner: std::sync::Arc<dyn super::stub::dynamic::HttpsHealthChecks>,
}

#[cfg(feature = "https-health-checks")]
impl HttpsHealthChecks {
    /// Returns a builder for [HttpsHealthChecks].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::HttpsHealthChecks;
    /// let client = HttpsHealthChecks::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::https_health_checks::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::https_health_checks::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::HttpsHealthChecks + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::HttpsHealthChecks>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::HttpsHealthChecks> {
        super::transport::HttpsHealthChecks::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::HttpsHealthChecks> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::HttpsHealthChecks::new)
    }

    /// Deletes the specified HttpsHealthCheck resource.
    pub fn delete(&self) -> super::builder::https_health_checks::Delete {
        super::builder::https_health_checks::Delete::new(self.inner.clone())
    }

    /// Returns the specified HttpsHealthCheck resource.
    pub fn get(&self) -> super::builder::https_health_checks::Get {
        super::builder::https_health_checks::Get::new(self.inner.clone())
    }

    /// Creates a HttpsHealthCheck resource in the specified project using the data
    /// included in the request.
    pub fn insert(&self) -> super::builder::https_health_checks::Insert {
        super::builder::https_health_checks::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of HttpsHealthCheck resources available to the specified
    /// project.
    pub fn list(&self) -> super::builder::https_health_checks::List {
        super::builder::https_health_checks::List::new(self.inner.clone())
    }

    /// Updates a HttpsHealthCheck resource in the specified project using the data
    /// included in the request. This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::https_health_checks::Patch {
        super::builder::https_health_checks::Patch::new(self.inner.clone())
    }

    /// Updates a HttpsHealthCheck resource in the specified project using the data
    /// included in the request.
    pub fn update(&self) -> super::builder::https_health_checks::Update {
        super::builder::https_health_checks::Update::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::https_health_checks::GetOperation {
        super::builder::https_health_checks::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::ImageFamilyViews;
/// let client = ImageFamilyViews::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `imageFamilyViews` resource.
///
/// # Configuration
///
/// To configure `ImageFamilyViews` use the `with_*` methods in the type returned
/// by [builder()][ImageFamilyViews::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::image_family_views::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::image_family_views::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ImageFamilyViews` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ImageFamilyViews` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "image-family-views")]
#[cfg_attr(docsrs, doc(cfg(feature = "image-family-views")))]
#[derive(Clone, Debug)]
pub struct ImageFamilyViews {
    inner: std::sync::Arc<dyn super::stub::dynamic::ImageFamilyViews>,
}

#[cfg(feature = "image-family-views")]
impl ImageFamilyViews {
    /// Returns a builder for [ImageFamilyViews].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::ImageFamilyViews;
    /// let client = ImageFamilyViews::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::image_family_views::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::image_family_views::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ImageFamilyViews + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::ImageFamilyViews>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ImageFamilyViews> {
        super::transport::ImageFamilyViews::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ImageFamilyViews> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ImageFamilyViews::new)
    }

    /// Returns the latest image that is part of an image family, is not
    /// deprecated and is rolled out in the specified zone.
    pub fn get(&self) -> super::builder::image_family_views::Get {
        super::builder::image_family_views::Get::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::Images;
/// let client = Images::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `images` resource.
///
/// # Configuration
///
/// To configure `Images` use the `with_*` methods in the type returned
/// by [builder()][Images::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::images::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::images::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Images` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Images` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "images")]
#[cfg_attr(docsrs, doc(cfg(feature = "images")))]
#[derive(Clone, Debug)]
pub struct Images {
    inner: std::sync::Arc<dyn super::stub::dynamic::Images>,
}

#[cfg(feature = "images")]
impl Images {
    /// Returns a builder for [Images].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::Images;
    /// let client = Images::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::images::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::images::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Images + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Images>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Images> {
        super::transport::Images::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Images> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Images::new)
    }

    /// Deletes the specified image.
    pub fn delete(&self) -> super::builder::images::Delete {
        super::builder::images::Delete::new(self.inner.clone())
    }

    /// Sets the deprecation status of an image.
    ///
    /// If an empty request body is given, clears the deprecation status instead.
    pub fn deprecate(&self) -> super::builder::images::Deprecate {
        super::builder::images::Deprecate::new(self.inner.clone())
    }

    /// Returns the specified image.
    pub fn get(&self) -> super::builder::images::Get {
        super::builder::images::Get::new(self.inner.clone())
    }

    /// Returns the latest image that is part of an image family and is not
    /// deprecated. For more information on image families, seePublic
    /// image families documentation.
    pub fn get_from_family(&self) -> super::builder::images::GetFromFamily {
        super::builder::images::GetFromFamily::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::images::GetIamPolicy {
        super::builder::images::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates an image in the specified project using the data included
    /// in the request.
    pub fn insert(&self) -> super::builder::images::Insert {
        super::builder::images::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of custom images
    /// available to the specified project. Custom images are images you
    /// create that belong to your project. This method does not
    /// get any images that belong to other projects, including publicly-available
    /// images, like Debian 8. If you want to get a list of publicly-available
    /// images, use this method to make a request to the respective image project,
    /// such as debian-cloud or windows-cloud.
    pub fn list(&self) -> super::builder::images::List {
        super::builder::images::List::new(self.inner.clone())
    }

    /// Patches the specified image with the data included in the request.
    /// Only the following fields can be modified: family, description,
    /// deprecation status.
    pub fn patch(&self) -> super::builder::images::Patch {
        super::builder::images::Patch::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::images::SetIamPolicy {
        super::builder::images::SetIamPolicy::new(self.inner.clone())
    }

    /// Sets the labels on an image. To learn more about labels, read theLabeling
    /// Resources documentation.
    pub fn set_labels(&self) -> super::builder::images::SetLabels {
        super::builder::images::SetLabels::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::images::TestIamPermissions {
        super::builder::images::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::images::GetOperation {
        super::builder::images::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::InstanceGroupManagerResizeRequests;
/// let client = InstanceGroupManagerResizeRequests::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `instanceGroupManagerResizeRequests` resource.
///
/// # Configuration
///
/// To configure `InstanceGroupManagerResizeRequests` use the `with_*` methods in the type returned
/// by [builder()][InstanceGroupManagerResizeRequests::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::instance_group_manager_resize_requests::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::instance_group_manager_resize_requests::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `InstanceGroupManagerResizeRequests` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `InstanceGroupManagerResizeRequests` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "instance-group-manager-resize-requests")]
#[cfg_attr(docsrs, doc(cfg(feature = "instance-group-manager-resize-requests")))]
#[derive(Clone, Debug)]
pub struct InstanceGroupManagerResizeRequests {
    inner: std::sync::Arc<dyn super::stub::dynamic::InstanceGroupManagerResizeRequests>,
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl InstanceGroupManagerResizeRequests {
    /// Returns a builder for [InstanceGroupManagerResizeRequests].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::InstanceGroupManagerResizeRequests;
    /// let client = InstanceGroupManagerResizeRequests::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::instance_group_manager_resize_requests::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::instance_group_manager_resize_requests::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::InstanceGroupManagerResizeRequests + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::InstanceGroupManagerResizeRequests>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InstanceGroupManagerResizeRequests> {
        super::transport::InstanceGroupManagerResizeRequests::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InstanceGroupManagerResizeRequests> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::InstanceGroupManagerResizeRequests::new)
    }

    /// Cancels the specified resize request and removes it from the queue.
    /// Cancelled resize request does no longer wait for the resources to be
    /// provisioned. Cancel is only possible for requests that are accepted in the
    /// queue.
    pub fn cancel(&self) -> super::builder::instance_group_manager_resize_requests::Cancel {
        super::builder::instance_group_manager_resize_requests::Cancel::new(self.inner.clone())
    }

    /// Deletes the specified, inactive resize request. Requests that are still
    /// active cannot be deleted. Deleting request does not delete instances that
    /// were provisioned previously.
    pub fn delete(&self) -> super::builder::instance_group_manager_resize_requests::Delete {
        super::builder::instance_group_manager_resize_requests::Delete::new(self.inner.clone())
    }

    /// Returns all of the details about the specified resize request.
    pub fn get(&self) -> super::builder::instance_group_manager_resize_requests::Get {
        super::builder::instance_group_manager_resize_requests::Get::new(self.inner.clone())
    }

    /// Creates a new resize request that starts provisioning VMs immediately
    /// or queues VM creation.
    pub fn insert(&self) -> super::builder::instance_group_manager_resize_requests::Insert {
        super::builder::instance_group_manager_resize_requests::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of resize requests that are contained in the
    /// managed instance group.
    pub fn list(&self) -> super::builder::instance_group_manager_resize_requests::List {
        super::builder::instance_group_manager_resize_requests::List::new(self.inner.clone())
    }

    /// Retrieves the specified zone-specific Operations resource.
    pub fn get_operation(
        &self,
    ) -> super::builder::instance_group_manager_resize_requests::GetOperation {
        super::builder::instance_group_manager_resize_requests::GetOperation::new(
            self.inner.clone(),
        )
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::InstanceGroupManagers;
/// let client = InstanceGroupManagers::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `instanceGroupManagers` resource.
///
/// # Configuration
///
/// To configure `InstanceGroupManagers` use the `with_*` methods in the type returned
/// by [builder()][InstanceGroupManagers::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::instance_group_managers::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::instance_group_managers::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `InstanceGroupManagers` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `InstanceGroupManagers` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "instance-group-managers")]
#[cfg_attr(docsrs, doc(cfg(feature = "instance-group-managers")))]
#[derive(Clone, Debug)]
pub struct InstanceGroupManagers {
    inner: std::sync::Arc<dyn super::stub::dynamic::InstanceGroupManagers>,
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagers {
    /// Returns a builder for [InstanceGroupManagers].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::InstanceGroupManagers;
    /// let client = InstanceGroupManagers::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::instance_group_managers::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::instance_group_managers::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::InstanceGroupManagers + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::InstanceGroupManagers>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InstanceGroupManagers> {
        super::transport::InstanceGroupManagers::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InstanceGroupManagers> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::InstanceGroupManagers::new)
    }

    /// Flags the specified instances to be removed from the
    /// managed instance group. Abandoning an instance does not delete the
    /// instance, but it does remove the instance from any target pools that are
    /// applied by the managed instance group. This method reduces thetargetSize of the managed instance group by the
    /// number of instances that you abandon. This operation is marked asDONE when the action is scheduled even if the instances have
    /// not yet been removed from the group. You must separately verify the
    /// status of the abandoning action with thelistmanagedinstances
    /// method.
    ///
    /// If the group is part of a backend
    /// service that has enabled
    /// connection draining, it can take up to 60 seconds after the connection
    /// draining duration has elapsed before the VM instance is removed or deleted.
    ///
    /// You can specify a maximum of 1000 instances with this method per request.
    pub fn abandon_instances(&self) -> super::builder::instance_group_managers::AbandonInstances {
        super::builder::instance_group_managers::AbandonInstances::new(self.inner.clone())
    }

    /// Retrieves the list of managed instance groups and groups them by zone.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::instance_group_managers::AggregatedList {
        super::builder::instance_group_managers::AggregatedList::new(self.inner.clone())
    }

    /// Applies changes to selected instances on the managed instance group.
    /// This method can be used to apply new overrides and/or new versions.
    pub fn apply_updates_to_instances(
        &self,
    ) -> super::builder::instance_group_managers::ApplyUpdatesToInstances {
        super::builder::instance_group_managers::ApplyUpdatesToInstances::new(self.inner.clone())
    }

    /// Creates instances with per-instance configurations in this managed instance
    /// group. Instances are created using the current instance template. Thecreate instances operation is marked DONE if thecreateInstances request is successful. The underlying actions
    /// take additional time. You must separately verify the status of thecreating or actions with the listmanagedinstances
    /// method.
    pub fn create_instances(&self) -> super::builder::instance_group_managers::CreateInstances {
        super::builder::instance_group_managers::CreateInstances::new(self.inner.clone())
    }

    /// Deletes the specified managed instance group and all of the instances
    /// in that group. Note that the instance group must not belong to a
    /// backend service. Read
    /// Deleting an instance group for more information.
    pub fn delete(&self) -> super::builder::instance_group_managers::Delete {
        super::builder::instance_group_managers::Delete::new(self.inner.clone())
    }

    /// Flags the specified instances in the managed instance group for immediate
    /// deletion. The instances are also removed from any target
    /// pools of which they were a member. This method reduces thetargetSize of the managed instance group by the number of
    /// instances that you delete. This operation is marked as DONE
    /// when the action is scheduled even if the instances are still being deleted.
    /// You must separately verify the status of the deleting action
    /// with thelistmanagedinstances
    /// method.
    ///
    /// If the group is part of a backend
    /// service that has enabled
    /// connection draining, it can take up to 60 seconds after the connection
    /// draining duration has elapsed before the VM instance is removed or deleted.
    ///
    /// You can specify a maximum of 1000 instances with this method per request.
    pub fn delete_instances(&self) -> super::builder::instance_group_managers::DeleteInstances {
        super::builder::instance_group_managers::DeleteInstances::new(self.inner.clone())
    }

    /// Deletes selected per-instance configurations for the managed instance
    /// group.
    pub fn delete_per_instance_configs(
        &self,
    ) -> super::builder::instance_group_managers::DeletePerInstanceConfigs {
        super::builder::instance_group_managers::DeletePerInstanceConfigs::new(self.inner.clone())
    }

    /// Returns all of the details about the specified managed instance group.
    pub fn get(&self) -> super::builder::instance_group_managers::Get {
        super::builder::instance_group_managers::Get::new(self.inner.clone())
    }

    /// Creates a managed instance group using the information that you specify
    /// in the request. After the group is created, instances in the group are
    /// created using the specified instance template.
    /// This operation is marked as DONE when the group is created
    /// even if the instances in the group have not yet been created. You
    /// must separately verify the status of the individual instances with thelistmanagedinstances
    /// method.
    ///
    /// A managed instance group can have up to 1000 VM instances per group. Please
    /// contact Cloud Support if you need an increase in
    /// this limit.
    pub fn insert(&self) -> super::builder::instance_group_managers::Insert {
        super::builder::instance_group_managers::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of managed instance groups that are contained within the
    /// specified project and zone.
    pub fn list(&self) -> super::builder::instance_group_managers::List {
        super::builder::instance_group_managers::List::new(self.inner.clone())
    }

    /// Lists all errors thrown by actions on instances for a given managed
    /// instance group. The filter and orderBy query
    /// parameters are not supported.
    pub fn list_errors(&self) -> super::builder::instance_group_managers::ListErrors {
        super::builder::instance_group_managers::ListErrors::new(self.inner.clone())
    }

    /// Lists all of the instances in the managed instance group. Each instance
    /// in the list has a currentAction, which indicates the action
    /// that the managed instance group is performing on the instance. For example,
    /// if the group is still creating an instance, the currentAction
    /// is CREATING. If a previous action failed, the
    /// list displays the errors for that failed action. The orderBy
    /// query parameter is not supported. The `pageToken` query parameter is
    /// supported only if the group's `listManagedInstancesResults` field is set
    /// to `PAGINATED`.
    pub fn list_managed_instances(
        &self,
    ) -> super::builder::instance_group_managers::ListManagedInstances {
        super::builder::instance_group_managers::ListManagedInstances::new(self.inner.clone())
    }

    /// Lists all of the per-instance configurations defined for the managed
    /// instance group. The orderBy query parameter is not supported.
    pub fn list_per_instance_configs(
        &self,
    ) -> super::builder::instance_group_managers::ListPerInstanceConfigs {
        super::builder::instance_group_managers::ListPerInstanceConfigs::new(self.inner.clone())
    }

    /// Updates a managed instance group using the information that you specify
    /// in the request.
    /// This operation is marked as DONE when the group is patched
    /// even if the instances in the group are still in the process of being
    /// patched. You must separately verify the status of the individual instances
    /// with thelistManagedInstances
    /// method. This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules.
    ///
    /// If you update your group to specify a new template or instance
    /// configuration, it's possible that your intended specification for each VM
    /// in the group is different from the current state of that VM. To learn how
    /// to apply an updated configuration to the VMs in a MIG, seeUpdating instances in
    /// a MIG.
    pub fn patch(&self) -> super::builder::instance_group_managers::Patch {
        super::builder::instance_group_managers::Patch::new(self.inner.clone())
    }

    /// Inserts or patches per-instance configurations for the managed instance
    /// group. perInstanceConfig.name serves as a key used to
    /// distinguish whether to perform insert or patch.
    pub fn patch_per_instance_configs(
        &self,
    ) -> super::builder::instance_group_managers::PatchPerInstanceConfigs {
        super::builder::instance_group_managers::PatchPerInstanceConfigs::new(self.inner.clone())
    }

    /// Flags the specified VM instances in the managed instance group to be
    /// immediately recreated. Each instance is recreated using the group's current
    /// configuration. This operation is marked as DONE when the flag
    /// is set even if the instances have not yet been recreated. You must
    /// separately verify the status of each instance by checking itscurrentAction field; for more information, see Checking
    /// the status of managed instances.
    ///
    /// If the group is part of a backend
    /// service that has enabled
    /// connection draining, it can take up to 60 seconds after the connection
    /// draining duration has elapsed before the VM instance is removed or deleted.
    ///
    /// You can specify a maximum of 1000 instances with this method per request.
    pub fn recreate_instances(&self) -> super::builder::instance_group_managers::RecreateInstances {
        super::builder::instance_group_managers::RecreateInstances::new(self.inner.clone())
    }

    /// Resizes the managed instance group. If you increase the size, the group
    /// creates new instances using the current instance template. If you decrease
    /// the size, the group deletes instances. The resize operation is markedDONE when the resize actions are scheduled even if the group
    /// has not yet added or deleted any instances. You must separately
    /// verify the status of the creating or deleting
    /// actions with thelistmanagedinstances
    /// method.
    ///
    /// When resizing down, the instance group arbitrarily chooses the order in
    /// which VMs are deleted. The group takes into account some VM attributes when
    /// making the selection including:
    ///
    /// + The status of the VM instance.
    /// + The health of the VM instance.
    /// + The instance template version the VM is based on.
    /// + For regional managed instance groups, the location of the VM instance.
    ///
    /// This list is subject to change.
    ///
    /// If the group is part of a backend
    /// service that has enabled
    /// connection draining, it can take up to 60 seconds after the connection
    /// draining duration has elapsed before the VM instance is removed or deleted.
    pub fn resize(&self) -> super::builder::instance_group_managers::Resize {
        super::builder::instance_group_managers::Resize::new(self.inner.clone())
    }

    /// Flags the specified instances in the managed instance group to be
    /// resumed. This method increases thetargetSize and decreases the targetSuspendedSize
    /// of the managed instance group by the number of instances that you resume.
    /// The resumeInstances operation is marked DONE if
    /// the resumeInstances request is successful. The underlying
    /// actions take additional time. You must separately verify the status of theRESUMING action with thelistmanagedinstances
    /// method.
    ///
    /// In this request, you can only specify instances that are suspended. For
    /// example, if an instance was previously suspended using the suspendInstances
    /// method, it can be resumed using the resumeInstances method.
    ///
    /// If a health check is attached to the managed instance group, the specified
    /// instances will be verified as healthy after they are resumed.
    ///
    /// You can specify a maximum of 1000 instances with this method per request.
    pub fn resume_instances(&self) -> super::builder::instance_group_managers::ResumeInstances {
        super::builder::instance_group_managers::ResumeInstances::new(self.inner.clone())
    }

    /// Specifies the instance template to use when creating new instances in this
    /// group. The templates for existing instances in the group do not change
    /// unless you run recreateInstances, runapplyUpdatesToInstances, or set the group'supdatePolicy.type to PROACTIVE.
    pub fn set_instance_template(
        &self,
    ) -> super::builder::instance_group_managers::SetInstanceTemplate {
        super::builder::instance_group_managers::SetInstanceTemplate::new(self.inner.clone())
    }

    /// Modifies the target pools to which all instances in this managed instance
    /// group are assigned. The target pools automatically apply to all of the
    /// instances in the managed instance group. This operation is markedDONE when you make the request even if the instances have not
    /// yet been added to their target pools. The change might take some time to
    /// apply to all of the instances in the group depending on the size of the
    /// group.
    pub fn set_target_pools(&self) -> super::builder::instance_group_managers::SetTargetPools {
        super::builder::instance_group_managers::SetTargetPools::new(self.inner.clone())
    }

    /// Flags the specified instances in the managed instance group to be
    /// started. This method increases thetargetSize and decreases the targetStoppedSize
    /// of the managed instance group by the number of instances that you start.
    /// The startInstances operation is marked DONE if
    /// the startInstances request is successful. The underlying
    /// actions take additional time. You must separately verify the status of theSTARTING action with thelistmanagedinstances
    /// method.
    ///
    /// In this request, you can only specify instances that are stopped. For
    /// example, if an instance was previously stopped using the stopInstances
    /// method, it can be started using the startInstances method.
    ///
    /// If a health check is attached to the managed instance group, the specified
    /// instances will be verified as healthy after they are started.
    ///
    /// You can specify a maximum of 1000 instances with this method per request.
    pub fn start_instances(&self) -> super::builder::instance_group_managers::StartInstances {
        super::builder::instance_group_managers::StartInstances::new(self.inner.clone())
    }

    /// Flags the specified instances in the managed instance group to be
    /// immediately stopped. You can only specify instances that are running in
    /// this request. This method reduces thetargetSize and increases the targetStoppedSize
    /// of the managed instance group by the number of instances that you stop.
    /// The stopInstances operation is marked DONE if
    /// the stopInstances request is successful. The underlying
    /// actions take additional time. You must separately verify the status of theSTOPPING action with thelistmanagedinstances
    /// method.
    ///
    /// If the standbyPolicy.initialDelaySec field is set, the group
    /// delays stopping the instances until initialDelaySec have
    /// passed from instance.creationTimestamp (that is, when the
    /// instance was created). This delay gives your application time to
    /// set itself up and initialize on the instance. If more thaninitialDelaySec seconds have passed sinceinstance.creationTimestamp when this method is called, there
    /// will be zero delay.
    ///
    /// If the group is part of a backend
    /// service that has enabled
    /// connection draining, it can take up to 60 seconds after the connection
    /// draining duration has elapsed before the VM instance is stopped.
    ///
    /// Stopped instances can be started using the startInstances
    /// method.
    ///
    /// You can specify a maximum of 1000 instances with this method per request.
    pub fn stop_instances(&self) -> super::builder::instance_group_managers::StopInstances {
        super::builder::instance_group_managers::StopInstances::new(self.inner.clone())
    }

    /// Flags the specified instances in the managed instance group to be
    /// immediately suspended. You can only specify instances that are running in
    /// this request. This method reduces thetargetSize and increases the targetSuspendedSize
    /// of the managed instance group by the number of instances that you suspend.
    /// The suspendInstances operation is marked DONE if
    /// the suspendInstances request is successful. The underlying
    /// actions take additional time. You must separately verify the status of theSUSPENDING action with thelistmanagedinstances
    /// method.
    ///
    /// If the standbyPolicy.initialDelaySec field is set, the group
    /// delays suspension of the instances until initialDelaySec have
    /// passed from instance.creationTimestamp (that is, when the
    /// instance was created). This delay gives your application time to
    /// set itself up and initialize on the instance. If more thaninitialDelaySec seconds have passed sinceinstance.creationTimestamp when this method is called, there
    /// will be zero delay.
    ///
    /// If the group is part of a backend
    /// service that has enabled
    /// connection draining, it can take up to 60 seconds after the connection
    /// draining duration has elapsed before the VM instance is suspended.
    ///
    /// Suspended instances can be resumed using the resumeInstances
    /// method.
    ///
    /// You can specify a maximum of 1000 instances with this method per request.
    pub fn suspend_instances(&self) -> super::builder::instance_group_managers::SuspendInstances {
        super::builder::instance_group_managers::SuspendInstances::new(self.inner.clone())
    }

    /// Inserts or updates per-instance configurations for the managed instance
    /// group. perInstanceConfig.name serves as a key used to
    /// distinguish whether to perform insert or patch.
    pub fn update_per_instance_configs(
        &self,
    ) -> super::builder::instance_group_managers::UpdatePerInstanceConfigs {
        super::builder::instance_group_managers::UpdatePerInstanceConfigs::new(self.inner.clone())
    }

    /// Retrieves the specified zone-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::instance_group_managers::GetOperation {
        super::builder::instance_group_managers::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::InstanceGroups;
/// let client = InstanceGroups::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `instanceGroups` resource.
///
/// # Configuration
///
/// To configure `InstanceGroups` use the `with_*` methods in the type returned
/// by [builder()][InstanceGroups::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::instance_groups::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::instance_groups::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `InstanceGroups` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `InstanceGroups` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "instance-groups")]
#[cfg_attr(docsrs, doc(cfg(feature = "instance-groups")))]
#[derive(Clone, Debug)]
pub struct InstanceGroups {
    inner: std::sync::Arc<dyn super::stub::dynamic::InstanceGroups>,
}

#[cfg(feature = "instance-groups")]
impl InstanceGroups {
    /// Returns a builder for [InstanceGroups].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::InstanceGroups;
    /// let client = InstanceGroups::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::instance_groups::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::instance_groups::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::InstanceGroups + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::InstanceGroups>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InstanceGroups> {
        super::transport::InstanceGroups::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InstanceGroups> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::InstanceGroups::new)
    }

    /// Adds a list of instances to the specified instance group.  All of the
    /// instances in the instance group must be in the same network/subnetwork.
    /// Read
    /// Adding instances for more information.
    pub fn add_instances(&self) -> super::builder::instance_groups::AddInstances {
        super::builder::instance_groups::AddInstances::new(self.inner.clone())
    }

    /// Retrieves the list of instance groups and sorts them by zone.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::instance_groups::AggregatedList {
        super::builder::instance_groups::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified instance group. The instances in the group are not
    /// deleted. Note that instance group must not belong to a backend service.
    /// Read
    /// Deleting an instance group for more information.
    pub fn delete(&self) -> super::builder::instance_groups::Delete {
        super::builder::instance_groups::Delete::new(self.inner.clone())
    }

    /// Returns the specified zonal instance group. Get a list of available zonal
    /// instance groups by making a list() request.
    ///
    /// For managed instance groups, use theinstanceGroupManagers
    /// or regionInstanceGroupManagers
    /// methods instead.
    pub fn get(&self) -> super::builder::instance_groups::Get {
        super::builder::instance_groups::Get::new(self.inner.clone())
    }

    /// Creates an instance group in the specified project using the
    /// parameters that are included in the request.
    pub fn insert(&self) -> super::builder::instance_groups::Insert {
        super::builder::instance_groups::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of zonal instance group resources contained within the
    /// specified zone.
    ///
    /// For managed instance groups, use theinstanceGroupManagers
    /// or regionInstanceGroupManagers
    /// methods instead.
    pub fn list(&self) -> super::builder::instance_groups::List {
        super::builder::instance_groups::List::new(self.inner.clone())
    }

    /// Lists the instances in the specified instance group.
    /// The orderBy query parameter is not supported.
    /// The filter query parameter is supported, but only for
    /// expressions that use `eq` (equal) or `ne` (not equal) operators.
    pub fn list_instances(&self) -> super::builder::instance_groups::ListInstances {
        super::builder::instance_groups::ListInstances::new(self.inner.clone())
    }

    /// Removes one or more instances from the specified instance group, but does
    /// not delete those instances.
    ///
    /// If the group is part of a backend
    /// service that has enabled
    /// connection draining, it can take up to 60 seconds after the connection
    /// draining duration before the VM instance is removed or deleted.
    pub fn remove_instances(&self) -> super::builder::instance_groups::RemoveInstances {
        super::builder::instance_groups::RemoveInstances::new(self.inner.clone())
    }

    /// Sets the named ports for the specified instance group.
    pub fn set_named_ports(&self) -> super::builder::instance_groups::SetNamedPorts {
        super::builder::instance_groups::SetNamedPorts::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::instance_groups::TestIamPermissions {
        super::builder::instance_groups::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified zone-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::instance_groups::GetOperation {
        super::builder::instance_groups::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::InstanceSettings;
/// let client = InstanceSettings::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `instanceSettings` resource.
///
/// # Configuration
///
/// To configure `InstanceSettings` use the `with_*` methods in the type returned
/// by [builder()][InstanceSettings::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::instance_settings::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::instance_settings::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `InstanceSettings` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `InstanceSettings` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "instance-settings")]
#[cfg_attr(docsrs, doc(cfg(feature = "instance-settings")))]
#[derive(Clone, Debug)]
pub struct InstanceSettings {
    inner: std::sync::Arc<dyn super::stub::dynamic::InstanceSettings>,
}

#[cfg(feature = "instance-settings")]
impl InstanceSettings {
    /// Returns a builder for [InstanceSettings].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::InstanceSettings;
    /// let client = InstanceSettings::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::instance_settings::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::instance_settings::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::InstanceSettings + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::InstanceSettings>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InstanceSettings> {
        super::transport::InstanceSettings::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InstanceSettings> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::InstanceSettings::new)
    }

    /// Get Instance settings.
    pub fn get(&self) -> super::builder::instance_settings::Get {
        super::builder::instance_settings::Get::new(self.inner.clone())
    }

    /// Patch Instance settings
    pub fn patch(&self) -> super::builder::instance_settings::Patch {
        super::builder::instance_settings::Patch::new(self.inner.clone())
    }

    /// Retrieves the specified zone-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::instance_settings::GetOperation {
        super::builder::instance_settings::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::InstanceTemplates;
/// let client = InstanceTemplates::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `instanceTemplates` resource.
///
/// # Configuration
///
/// To configure `InstanceTemplates` use the `with_*` methods in the type returned
/// by [builder()][InstanceTemplates::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::instance_templates::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::instance_templates::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `InstanceTemplates` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `InstanceTemplates` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "instance-templates")]
#[cfg_attr(docsrs, doc(cfg(feature = "instance-templates")))]
#[derive(Clone, Debug)]
pub struct InstanceTemplates {
    inner: std::sync::Arc<dyn super::stub::dynamic::InstanceTemplates>,
}

#[cfg(feature = "instance-templates")]
impl InstanceTemplates {
    /// Returns a builder for [InstanceTemplates].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::InstanceTemplates;
    /// let client = InstanceTemplates::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::instance_templates::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::instance_templates::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::InstanceTemplates + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::InstanceTemplates>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InstanceTemplates> {
        super::transport::InstanceTemplates::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InstanceTemplates> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::InstanceTemplates::new)
    }

    /// Retrieves the list of all InstanceTemplates resources, regional and global,
    /// available to the specified project.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::instance_templates::AggregatedList {
        super::builder::instance_templates::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified instance template. Deleting an instance template is
    /// permanent and cannot be undone. It is not possible to delete templates
    /// that are already in use by a managed instance group.
    pub fn delete(&self) -> super::builder::instance_templates::Delete {
        super::builder::instance_templates::Delete::new(self.inner.clone())
    }

    /// Returns the specified instance template.
    pub fn get(&self) -> super::builder::instance_templates::Get {
        super::builder::instance_templates::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::instance_templates::GetIamPolicy {
        super::builder::instance_templates::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates an instance template in the specified project using the
    /// data that is included in the request. If you are creating a new template to
    /// update an existing instance group, your new instance template must use the
    /// same network or, if applicable, the same subnetwork as the original
    /// template.
    pub fn insert(&self) -> super::builder::instance_templates::Insert {
        super::builder::instance_templates::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of instance templates that are contained within
    /// the specified project.
    pub fn list(&self) -> super::builder::instance_templates::List {
        super::builder::instance_templates::List::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::instance_templates::SetIamPolicy {
        super::builder::instance_templates::SetIamPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::instance_templates::TestIamPermissions {
        super::builder::instance_templates::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::instance_templates::GetOperation {
        super::builder::instance_templates::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::Instances;
/// let client = Instances::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `instances` resource.
///
/// # Configuration
///
/// To configure `Instances` use the `with_*` methods in the type returned
/// by [builder()][Instances::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::instances::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::instances::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Instances` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Instances` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "instances")]
#[cfg_attr(docsrs, doc(cfg(feature = "instances")))]
#[derive(Clone, Debug)]
pub struct Instances {
    inner: std::sync::Arc<dyn super::stub::dynamic::Instances>,
}

#[cfg(feature = "instances")]
impl Instances {
    /// Returns a builder for [Instances].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::Instances;
    /// let client = Instances::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::instances::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::instances::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Instances + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Instances>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Instances> {
        super::transport::Instances::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Instances> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Instances::new)
    }

    /// Adds an access config to an instance's network interface.
    pub fn add_access_config(&self) -> super::builder::instances::AddAccessConfig {
        super::builder::instances::AddAccessConfig::new(self.inner.clone())
    }

    /// Adds one dynamic network interface to an active instance.
    pub fn add_network_interface(&self) -> super::builder::instances::AddNetworkInterface {
        super::builder::instances::AddNetworkInterface::new(self.inner.clone())
    }

    /// Adds existing resource policies to an instance. You can only add one
    /// policy right now which will be applied to this instance for scheduling live
    /// migrations.
    pub fn add_resource_policies(&self) -> super::builder::instances::AddResourcePolicies {
        super::builder::instances::AddResourcePolicies::new(self.inner.clone())
    }

    /// Retrieves an aggregated list of all of the instances in your project
    /// across all regions and zones.
    ///
    /// The performance of this method degrades when a filter is specified on a
    /// project that has a very large number of instances.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::instances::AggregatedList {
        super::builder::instances::AggregatedList::new(self.inner.clone())
    }

    /// Attaches an existing Disk resource to an instance. You must first
    /// create the disk before you can attach it. It is not possible to create
    /// and attach a disk at the same time. For more information, readAdding a
    /// persistent disk to your instance.
    pub fn attach_disk(&self) -> super::builder::instances::AttachDisk {
        super::builder::instances::AttachDisk::new(self.inner.clone())
    }

    /// Creates multiple instances. Count specifies the number of instances to
    /// create. For more information, seeAbout bulk
    /// creation of VMs.
    pub fn bulk_insert(&self) -> super::builder::instances::BulkInsert {
        super::builder::instances::BulkInsert::new(self.inner.clone())
    }

    /// Deletes the specified Instance resource. For more information, seeDeleting
    /// an instance.
    pub fn delete(&self) -> super::builder::instances::Delete {
        super::builder::instances::Delete::new(self.inner.clone())
    }

    /// Deletes an access config from an instance's network interface.
    pub fn delete_access_config(&self) -> super::builder::instances::DeleteAccessConfig {
        super::builder::instances::DeleteAccessConfig::new(self.inner.clone())
    }

    /// Deletes one dynamic network interface from an active instance.
    /// InstancesDeleteNetworkInterfaceRequest indicates:
    ///
    /// - instance from which to delete, using project+zone+resource_id fields;
    /// - dynamic network interface to be deleted, using network_interface_name
    ///   field;
    pub fn delete_network_interface(&self) -> super::builder::instances::DeleteNetworkInterface {
        super::builder::instances::DeleteNetworkInterface::new(self.inner.clone())
    }

    /// Detaches a disk from an instance.
    pub fn detach_disk(&self) -> super::builder::instances::DetachDisk {
        super::builder::instances::DetachDisk::new(self.inner.clone())
    }

    /// Returns the specified Instance resource.
    pub fn get(&self) -> super::builder::instances::Get {
        super::builder::instances::Get::new(self.inner.clone())
    }

    /// Returns effective firewalls applied to an interface of the instance.
    pub fn get_effective_firewalls(&self) -> super::builder::instances::GetEffectiveFirewalls {
        super::builder::instances::GetEffectiveFirewalls::new(self.inner.clone())
    }

    /// Returns the specified guest attributes entry.
    pub fn get_guest_attributes(&self) -> super::builder::instances::GetGuestAttributes {
        super::builder::instances::GetGuestAttributes::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::instances::GetIamPolicy {
        super::builder::instances::GetIamPolicy::new(self.inner.clone())
    }

    /// Returns the screenshot from the specified instance.
    pub fn get_screenshot(&self) -> super::builder::instances::GetScreenshot {
        super::builder::instances::GetScreenshot::new(self.inner.clone())
    }

    /// Returns the last 1 MB of serial port output from the specified instance.
    pub fn get_serial_port_output(&self) -> super::builder::instances::GetSerialPortOutput {
        super::builder::instances::GetSerialPortOutput::new(self.inner.clone())
    }

    /// Returns the Shielded Instance Identity of an instance
    pub fn get_shielded_instance_identity(
        &self,
    ) -> super::builder::instances::GetShieldedInstanceIdentity {
        super::builder::instances::GetShieldedInstanceIdentity::new(self.inner.clone())
    }

    /// Creates an instance resource in the specified project using the data
    /// included in the request.
    pub fn insert(&self) -> super::builder::instances::Insert {
        super::builder::instances::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of instances contained within
    /// the specified zone.
    pub fn list(&self) -> super::builder::instances::List {
        super::builder::instances::List::new(self.inner.clone())
    }

    /// Retrieves a list of resources that refer to the VM instance specified in
    /// the request. For example, if the VM instance is part of a managed or
    /// unmanaged instance group, the referrers list includes the instance group.
    /// For more information, readViewing
    /// referrers to VM instances.
    pub fn list_referrers(&self) -> super::builder::instances::ListReferrers {
        super::builder::instances::ListReferrers::new(self.inner.clone())
    }

    /// Perform a manual maintenance on the instance.
    pub fn perform_maintenance(&self) -> super::builder::instances::PerformMaintenance {
        super::builder::instances::PerformMaintenance::new(self.inner.clone())
    }

    /// Removes resource policies from an instance.
    pub fn remove_resource_policies(&self) -> super::builder::instances::RemoveResourcePolicies {
        super::builder::instances::RemoveResourcePolicies::new(self.inner.clone())
    }

    /// Mark the host as faulty and try to restart the instance on a new host.
    pub fn report_host_as_faulty(&self) -> super::builder::instances::ReportHostAsFaulty {
        super::builder::instances::ReportHostAsFaulty::new(self.inner.clone())
    }

    /// Performs a reset on the instance. This is a hard reset. The VM
    /// does not do a graceful shutdown. For more information, seeResetting
    /// an instance.
    pub fn reset(&self) -> super::builder::instances::Reset {
        super::builder::instances::Reset::new(self.inner.clone())
    }

    /// Resumes an instance that was suspended using theinstances().suspend
    /// method.
    pub fn resume(&self) -> super::builder::instances::Resume {
        super::builder::instances::Resume::new(self.inner.clone())
    }

    /// Sends diagnostic interrupt to the instance.
    pub fn send_diagnostic_interrupt(&self) -> super::builder::instances::SendDiagnosticInterrupt {
        super::builder::instances::SendDiagnosticInterrupt::new(self.inner.clone())
    }

    /// Sets deletion protection on the instance.
    pub fn set_deletion_protection(&self) -> super::builder::instances::SetDeletionProtection {
        super::builder::instances::SetDeletionProtection::new(self.inner.clone())
    }

    /// Sets the auto-delete flag for a disk attached to an instance.
    pub fn set_disk_auto_delete(&self) -> super::builder::instances::SetDiskAutoDelete {
        super::builder::instances::SetDiskAutoDelete::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::instances::SetIamPolicy {
        super::builder::instances::SetIamPolicy::new(self.inner.clone())
    }

    /// Sets labels on an instance.  To learn more about labels, read theLabeling
    /// Resources documentation.
    pub fn set_labels(&self) -> super::builder::instances::SetLabels {
        super::builder::instances::SetLabels::new(self.inner.clone())
    }

    /// Changes the number and/or type of accelerator for a stopped instance to the
    /// values specified in the request.
    pub fn set_machine_resources(&self) -> super::builder::instances::SetMachineResources {
        super::builder::instances::SetMachineResources::new(self.inner.clone())
    }

    /// Changes the machine type for a stopped instance to the machine
    /// type specified in the request.
    pub fn set_machine_type(&self) -> super::builder::instances::SetMachineType {
        super::builder::instances::SetMachineType::new(self.inner.clone())
    }

    /// Sets metadata for the specified instance to the data included
    /// in the request.
    pub fn set_metadata(&self) -> super::builder::instances::SetMetadata {
        super::builder::instances::SetMetadata::new(self.inner.clone())
    }

    /// Changes the minimum CPU platform that this instance should use.
    /// This method can only
    /// be called on a stopped instance. For more information, readSpecifying a
    /// Minimum CPU Platform.
    pub fn set_min_cpu_platform(&self) -> super::builder::instances::SetMinCpuPlatform {
        super::builder::instances::SetMinCpuPlatform::new(self.inner.clone())
    }

    /// Sets name of an instance.
    pub fn set_name(&self) -> super::builder::instances::SetName {
        super::builder::instances::SetName::new(self.inner.clone())
    }

    /// Sets an instance's scheduling options. You can only call this method on astopped instance,
    /// that is, a VM instance that is in a `TERMINATED` state. SeeInstance Life
    /// Cycle for more information on the possible instance states.
    /// For more information about setting scheduling options for a VM, seeSet
    /// VM host maintenance policy.
    pub fn set_scheduling(&self) -> super::builder::instances::SetScheduling {
        super::builder::instances::SetScheduling::new(self.inner.clone())
    }

    /// Sets the Google Cloud Armor security policy for the specified instance.
    /// For more information, seeGoogle
    /// Cloud Armor Overview
    pub fn set_security_policy(&self) -> super::builder::instances::SetSecurityPolicy {
        super::builder::instances::SetSecurityPolicy::new(self.inner.clone())
    }

    /// Sets the service account on the instance. For more information,
    /// readChanging
    /// the service account and access scopes for an instance.
    pub fn set_service_account(&self) -> super::builder::instances::SetServiceAccount {
        super::builder::instances::SetServiceAccount::new(self.inner.clone())
    }

    /// Sets the Shielded Instance integrity policy for an instance. You can
    /// only use this method on a running instance. This method
    /// supports PATCH semantics and uses the JSON merge
    /// patch format and processing rules.
    pub fn set_shielded_instance_integrity_policy(
        &self,
    ) -> super::builder::instances::SetShieldedInstanceIntegrityPolicy {
        super::builder::instances::SetShieldedInstanceIntegrityPolicy::new(self.inner.clone())
    }

    /// Sets network tags
    /// for the specified instance to the data included in the request.
    pub fn set_tags(&self) -> super::builder::instances::SetTags {
        super::builder::instances::SetTags::new(self.inner.clone())
    }

    /// Simulates a host maintenance event on a VM. For more information, see
    /// Simulate a host maintenance event.
    pub fn simulate_maintenance_event(
        &self,
    ) -> super::builder::instances::SimulateMaintenanceEvent {
        super::builder::instances::SimulateMaintenanceEvent::new(self.inner.clone())
    }

    /// Starts an instance that was stopped using theinstances().stop
    /// method. For more information, seeRestart an
    /// instance.
    pub fn start(&self) -> super::builder::instances::Start {
        super::builder::instances::Start::new(self.inner.clone())
    }

    /// Starts an instance that was stopped using theinstances().stop
    /// method. For more information, seeRestart an
    /// instance.
    pub fn start_with_encryption_key(&self) -> super::builder::instances::StartWithEncryptionKey {
        super::builder::instances::StartWithEncryptionKey::new(self.inner.clone())
    }

    /// Stops a running instance, shutting it down cleanly, and allows
    /// you to restart the instance at a later time. Stopped instances do not incur
    /// VM usage charges while they are stopped. However, resources that the VM is
    /// using, such as persistent disks and static IP addresses, will continue to
    /// be charged until they are deleted. For more information, seeStopping
    /// an instance.
    pub fn stop(&self) -> super::builder::instances::Stop {
        super::builder::instances::Stop::new(self.inner.clone())
    }

    /// This method suspends a running instance, saving its state to persistent
    /// storage, and allows you to resume the instance at a later time. Suspended
    /// instances have no compute costs (cores or RAM), and incur only storage
    /// charges for the saved VM memory and localSSD data. Any charged resources
    /// the virtual machine was using, such as persistent disks and static IP
    /// addresses, will continue to be charged while the instance is suspended.
    /// For more information, see
    /// Suspending and resuming an instance.
    pub fn suspend(&self) -> super::builder::instances::Suspend {
        super::builder::instances::Suspend::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::instances::TestIamPermissions {
        super::builder::instances::TestIamPermissions::new(self.inner.clone())
    }

    /// Updates an instance only if the necessary resources are available. This
    /// method can update only a specific set of instance properties. See
    /// Updating a running instance for a list of updatable instance
    /// properties.
    pub fn update(&self) -> super::builder::instances::Update {
        super::builder::instances::Update::new(self.inner.clone())
    }

    /// Updates the specified access config from an instance's network interface
    /// with the data included in the request. This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules.
    pub fn update_access_config(&self) -> super::builder::instances::UpdateAccessConfig {
        super::builder::instances::UpdateAccessConfig::new(self.inner.clone())
    }

    /// Updates the Display config for a VM instance. You can
    /// only use this method on a stopped VM instance. This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules.
    pub fn update_display_device(&self) -> super::builder::instances::UpdateDisplayDevice {
        super::builder::instances::UpdateDisplayDevice::new(self.inner.clone())
    }

    /// Updates an instance's network interface. This method can only update an
    /// interface's alias IP range and attached network. See Modifying
    /// alias IP ranges for an existing instance for instructions on
    /// changing alias IP ranges. See Migrating
    /// a VM between networks for instructions on migrating an interface.
    /// This method follows PATCH semantics.
    pub fn update_network_interface(&self) -> super::builder::instances::UpdateNetworkInterface {
        super::builder::instances::UpdateNetworkInterface::new(self.inner.clone())
    }

    /// Updates the Shielded Instance config for an instance. You can
    /// only use this method on a stopped instance. This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules.
    pub fn update_shielded_instance_config(
        &self,
    ) -> super::builder::instances::UpdateShieldedInstanceConfig {
        super::builder::instances::UpdateShieldedInstanceConfig::new(self.inner.clone())
    }

    /// Retrieves the specified zone-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::instances::GetOperation {
        super::builder::instances::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::InstantSnapshots;
/// let client = InstantSnapshots::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `instantSnapshots` resource.
///
/// # Configuration
///
/// To configure `InstantSnapshots` use the `with_*` methods in the type returned
/// by [builder()][InstantSnapshots::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::instant_snapshots::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::instant_snapshots::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `InstantSnapshots` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `InstantSnapshots` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "instant-snapshots")]
#[cfg_attr(docsrs, doc(cfg(feature = "instant-snapshots")))]
#[derive(Clone, Debug)]
pub struct InstantSnapshots {
    inner: std::sync::Arc<dyn super::stub::dynamic::InstantSnapshots>,
}

#[cfg(feature = "instant-snapshots")]
impl InstantSnapshots {
    /// Returns a builder for [InstantSnapshots].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::InstantSnapshots;
    /// let client = InstantSnapshots::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::instant_snapshots::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::instant_snapshots::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::InstantSnapshots + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::InstantSnapshots>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InstantSnapshots> {
        super::transport::InstantSnapshots::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InstantSnapshots> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::InstantSnapshots::new)
    }

    /// Retrieves an aggregated list of instantSnapshots.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::instant_snapshots::AggregatedList {
        super::builder::instant_snapshots::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified InstantSnapshot resource. Keep in mind that deleting
    /// a single instantSnapshot might not necessarily delete all the data on that
    /// instantSnapshot. If any data on the instantSnapshot that is marked for
    /// deletion is needed for subsequent instantSnapshots, the data will be moved
    /// to the next corresponding instantSnapshot.
    ///
    /// For more information, seeDeleting
    /// instantSnapshots.
    pub fn delete(&self) -> super::builder::instant_snapshots::Delete {
        super::builder::instant_snapshots::Delete::new(self.inner.clone())
    }

    /// Returns the specified InstantSnapshot resource in the specified zone.
    pub fn get(&self) -> super::builder::instant_snapshots::Get {
        super::builder::instant_snapshots::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::instant_snapshots::GetIamPolicy {
        super::builder::instant_snapshots::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates an instant snapshot in the specified zone.
    pub fn insert(&self) -> super::builder::instant_snapshots::Insert {
        super::builder::instant_snapshots::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of InstantSnapshot resources contained within
    /// the specified zone.
    pub fn list(&self) -> super::builder::instant_snapshots::List {
        super::builder::instant_snapshots::List::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::instant_snapshots::SetIamPolicy {
        super::builder::instant_snapshots::SetIamPolicy::new(self.inner.clone())
    }

    /// Sets the labels on a instantSnapshot in the given zone. To learn more about
    /// labels, read the Labeling
    /// Resources documentation.
    pub fn set_labels(&self) -> super::builder::instant_snapshots::SetLabels {
        super::builder::instant_snapshots::SetLabels::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::instant_snapshots::TestIamPermissions {
        super::builder::instant_snapshots::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified zone-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::instant_snapshots::GetOperation {
        super::builder::instant_snapshots::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::InterconnectAttachmentGroups;
/// let client = InterconnectAttachmentGroups::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `interconnectAttachmentGroups` resource.
///
/// # Configuration
///
/// To configure `InterconnectAttachmentGroups` use the `with_*` methods in the type returned
/// by [builder()][InterconnectAttachmentGroups::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::interconnect_attachment_groups::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::interconnect_attachment_groups::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `InterconnectAttachmentGroups` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `InterconnectAttachmentGroups` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "interconnect-attachment-groups")]
#[cfg_attr(docsrs, doc(cfg(feature = "interconnect-attachment-groups")))]
#[derive(Clone, Debug)]
pub struct InterconnectAttachmentGroups {
    inner: std::sync::Arc<dyn super::stub::dynamic::InterconnectAttachmentGroups>,
}

#[cfg(feature = "interconnect-attachment-groups")]
impl InterconnectAttachmentGroups {
    /// Returns a builder for [InterconnectAttachmentGroups].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::InterconnectAttachmentGroups;
    /// let client = InterconnectAttachmentGroups::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::interconnect_attachment_groups::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::interconnect_attachment_groups::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::InterconnectAttachmentGroups + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::InterconnectAttachmentGroups>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InterconnectAttachmentGroups> {
        super::transport::InterconnectAttachmentGroups::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InterconnectAttachmentGroups> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::InterconnectAttachmentGroups::new)
    }

    /// Deletes the specified InterconnectAttachmentGroup in the given scope
    pub fn delete(&self) -> super::builder::interconnect_attachment_groups::Delete {
        super::builder::interconnect_attachment_groups::Delete::new(self.inner.clone())
    }

    /// Returns the specified InterconnectAttachmentGroup resource in the given
    /// scope.
    pub fn get(&self) -> super::builder::interconnect_attachment_groups::Get {
        super::builder::interconnect_attachment_groups::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::interconnect_attachment_groups::GetIamPolicy {
        super::builder::interconnect_attachment_groups::GetIamPolicy::new(self.inner.clone())
    }

    /// Returns the InterconnectAttachmentStatuses for the specified
    /// InterconnectAttachmentGroup resource.
    pub fn get_operational_status(
        &self,
    ) -> super::builder::interconnect_attachment_groups::GetOperationalStatus {
        super::builder::interconnect_attachment_groups::GetOperationalStatus::new(
            self.inner.clone(),
        )
    }

    /// Creates a InterconnectAttachmentGroup in the specified project in the given
    /// scope using the parameters that are included in the request.
    pub fn insert(&self) -> super::builder::interconnect_attachment_groups::Insert {
        super::builder::interconnect_attachment_groups::Insert::new(self.inner.clone())
    }

    /// Lists the InterconnectAttachmentGroups for a project in the given scope.
    pub fn list(&self) -> super::builder::interconnect_attachment_groups::List {
        super::builder::interconnect_attachment_groups::List::new(self.inner.clone())
    }

    /// Patches the specified InterconnectAttachmentGroup resource with the data
    /// included in the request. This method supports PATCH
    /// semantics and usesJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::interconnect_attachment_groups::Patch {
        super::builder::interconnect_attachment_groups::Patch::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::interconnect_attachment_groups::SetIamPolicy {
        super::builder::interconnect_attachment_groups::SetIamPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(
        &self,
    ) -> super::builder::interconnect_attachment_groups::TestIamPermissions {
        super::builder::interconnect_attachment_groups::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::interconnect_attachment_groups::GetOperation {
        super::builder::interconnect_attachment_groups::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::InterconnectAttachments;
/// let client = InterconnectAttachments::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `interconnectAttachments` resource.
///
/// # Configuration
///
/// To configure `InterconnectAttachments` use the `with_*` methods in the type returned
/// by [builder()][InterconnectAttachments::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::interconnect_attachments::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::interconnect_attachments::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `InterconnectAttachments` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `InterconnectAttachments` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "interconnect-attachments")]
#[cfg_attr(docsrs, doc(cfg(feature = "interconnect-attachments")))]
#[derive(Clone, Debug)]
pub struct InterconnectAttachments {
    inner: std::sync::Arc<dyn super::stub::dynamic::InterconnectAttachments>,
}

#[cfg(feature = "interconnect-attachments")]
impl InterconnectAttachments {
    /// Returns a builder for [InterconnectAttachments].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::InterconnectAttachments;
    /// let client = InterconnectAttachments::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::interconnect_attachments::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::interconnect_attachments::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::InterconnectAttachments + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::InterconnectAttachments>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InterconnectAttachments> {
        super::transport::InterconnectAttachments::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InterconnectAttachments> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::InterconnectAttachments::new)
    }

    /// Retrieves an aggregated list of interconnect attachments.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::interconnect_attachments::AggregatedList {
        super::builder::interconnect_attachments::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified interconnect attachment.
    pub fn delete(&self) -> super::builder::interconnect_attachments::Delete {
        super::builder::interconnect_attachments::Delete::new(self.inner.clone())
    }

    /// Returns the specified interconnect attachment.
    pub fn get(&self) -> super::builder::interconnect_attachments::Get {
        super::builder::interconnect_attachments::Get::new(self.inner.clone())
    }

    /// Creates an InterconnectAttachment in the specified project using the data
    /// included in the request.
    pub fn insert(&self) -> super::builder::interconnect_attachments::Insert {
        super::builder::interconnect_attachments::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of interconnect attachments contained within
    /// the specified region.
    pub fn list(&self) -> super::builder::interconnect_attachments::List {
        super::builder::interconnect_attachments::List::new(self.inner.clone())
    }

    /// Updates the specified interconnect attachment with the data included in the
    /// request. This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::interconnect_attachments::Patch {
        super::builder::interconnect_attachments::Patch::new(self.inner.clone())
    }

    /// Sets the labels on an InterconnectAttachment. To learn more about labels,
    /// read the Labeling
    /// Resources documentation.
    pub fn set_labels(&self) -> super::builder::interconnect_attachments::SetLabels {
        super::builder::interconnect_attachments::SetLabels::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::interconnect_attachments::GetOperation {
        super::builder::interconnect_attachments::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::InterconnectGroups;
/// let client = InterconnectGroups::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `interconnectGroups` resource.
///
/// # Configuration
///
/// To configure `InterconnectGroups` use the `with_*` methods in the type returned
/// by [builder()][InterconnectGroups::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::interconnect_groups::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::interconnect_groups::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `InterconnectGroups` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `InterconnectGroups` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "interconnect-groups")]
#[cfg_attr(docsrs, doc(cfg(feature = "interconnect-groups")))]
#[derive(Clone, Debug)]
pub struct InterconnectGroups {
    inner: std::sync::Arc<dyn super::stub::dynamic::InterconnectGroups>,
}

#[cfg(feature = "interconnect-groups")]
impl InterconnectGroups {
    /// Returns a builder for [InterconnectGroups].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::InterconnectGroups;
    /// let client = InterconnectGroups::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::interconnect_groups::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::interconnect_groups::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::InterconnectGroups + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::InterconnectGroups>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InterconnectGroups> {
        super::transport::InterconnectGroups::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InterconnectGroups> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::InterconnectGroups::new)
    }

    /// Create Interconnects with redundancy by creating them in a specified
    /// interconnect group.
    pub fn create_members(&self) -> super::builder::interconnect_groups::CreateMembers {
        super::builder::interconnect_groups::CreateMembers::new(self.inner.clone())
    }

    /// Deletes the specified InterconnectGroup in the given scope
    pub fn delete(&self) -> super::builder::interconnect_groups::Delete {
        super::builder::interconnect_groups::Delete::new(self.inner.clone())
    }

    /// Returns the specified InterconnectGroup resource in the given scope.
    pub fn get(&self) -> super::builder::interconnect_groups::Get {
        super::builder::interconnect_groups::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::interconnect_groups::GetIamPolicy {
        super::builder::interconnect_groups::GetIamPolicy::new(self.inner.clone())
    }

    /// Returns the interconnectStatuses for the specified
    /// InterconnectGroup.
    pub fn get_operational_status(
        &self,
    ) -> super::builder::interconnect_groups::GetOperationalStatus {
        super::builder::interconnect_groups::GetOperationalStatus::new(self.inner.clone())
    }

    /// Creates a InterconnectGroup in the specified project in the given scope
    /// using the parameters that are included in the request.
    pub fn insert(&self) -> super::builder::interconnect_groups::Insert {
        super::builder::interconnect_groups::Insert::new(self.inner.clone())
    }

    /// Lists the InterconnectGroups for a project in the given scope.
    pub fn list(&self) -> super::builder::interconnect_groups::List {
        super::builder::interconnect_groups::List::new(self.inner.clone())
    }

    /// Patches the specified InterconnectGroup resource with the data included in
    /// the request. This method supports PATCH
    /// semantics and usesJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::interconnect_groups::Patch {
        super::builder::interconnect_groups::Patch::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::interconnect_groups::SetIamPolicy {
        super::builder::interconnect_groups::SetIamPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::interconnect_groups::TestIamPermissions {
        super::builder::interconnect_groups::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::interconnect_groups::GetOperation {
        super::builder::interconnect_groups::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::InterconnectLocations;
/// let client = InterconnectLocations::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `interconnectLocations` resource.
///
/// # Configuration
///
/// To configure `InterconnectLocations` use the `with_*` methods in the type returned
/// by [builder()][InterconnectLocations::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::interconnect_locations::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::interconnect_locations::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `InterconnectLocations` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `InterconnectLocations` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "interconnect-locations")]
#[cfg_attr(docsrs, doc(cfg(feature = "interconnect-locations")))]
#[derive(Clone, Debug)]
pub struct InterconnectLocations {
    inner: std::sync::Arc<dyn super::stub::dynamic::InterconnectLocations>,
}

#[cfg(feature = "interconnect-locations")]
impl InterconnectLocations {
    /// Returns a builder for [InterconnectLocations].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::InterconnectLocations;
    /// let client = InterconnectLocations::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::interconnect_locations::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::interconnect_locations::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::InterconnectLocations + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::InterconnectLocations>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InterconnectLocations> {
        super::transport::InterconnectLocations::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InterconnectLocations> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::InterconnectLocations::new)
    }

    /// Returns the details for the specified interconnect location. Gets a list of
    /// available interconnect locations by making a list() request.
    pub fn get(&self) -> super::builder::interconnect_locations::Get {
        super::builder::interconnect_locations::Get::new(self.inner.clone())
    }

    /// Retrieves the list of interconnect locations available to the specified
    /// project.
    pub fn list(&self) -> super::builder::interconnect_locations::List {
        super::builder::interconnect_locations::List::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::InterconnectRemoteLocations;
/// let client = InterconnectRemoteLocations::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `interconnectRemoteLocations` resource.
///
/// # Configuration
///
/// To configure `InterconnectRemoteLocations` use the `with_*` methods in the type returned
/// by [builder()][InterconnectRemoteLocations::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::interconnect_remote_locations::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::interconnect_remote_locations::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `InterconnectRemoteLocations` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `InterconnectRemoteLocations` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "interconnect-remote-locations")]
#[cfg_attr(docsrs, doc(cfg(feature = "interconnect-remote-locations")))]
#[derive(Clone, Debug)]
pub struct InterconnectRemoteLocations {
    inner: std::sync::Arc<dyn super::stub::dynamic::InterconnectRemoteLocations>,
}

#[cfg(feature = "interconnect-remote-locations")]
impl InterconnectRemoteLocations {
    /// Returns a builder for [InterconnectRemoteLocations].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::InterconnectRemoteLocations;
    /// let client = InterconnectRemoteLocations::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::interconnect_remote_locations::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::interconnect_remote_locations::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::InterconnectRemoteLocations + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::InterconnectRemoteLocations>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InterconnectRemoteLocations> {
        super::transport::InterconnectRemoteLocations::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::InterconnectRemoteLocations> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::InterconnectRemoteLocations::new)
    }

    /// Returns the details for the specified interconnect remote location. Gets a
    /// list of available interconnect remote locations by making alist() request.
    pub fn get(&self) -> super::builder::interconnect_remote_locations::Get {
        super::builder::interconnect_remote_locations::Get::new(self.inner.clone())
    }

    /// Retrieves the list of interconnect remote locations available to the
    /// specified project.
    pub fn list(&self) -> super::builder::interconnect_remote_locations::List {
        super::builder::interconnect_remote_locations::List::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::Interconnects;
/// let client = Interconnects::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `interconnects` resource.
///
/// # Configuration
///
/// To configure `Interconnects` use the `with_*` methods in the type returned
/// by [builder()][Interconnects::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::interconnects::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::interconnects::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Interconnects` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Interconnects` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "interconnects")]
#[cfg_attr(docsrs, doc(cfg(feature = "interconnects")))]
#[derive(Clone, Debug)]
pub struct Interconnects {
    inner: std::sync::Arc<dyn super::stub::dynamic::Interconnects>,
}

#[cfg(feature = "interconnects")]
impl Interconnects {
    /// Returns a builder for [Interconnects].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::Interconnects;
    /// let client = Interconnects::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::interconnects::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::interconnects::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Interconnects + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Interconnects>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Interconnects> {
        super::transport::Interconnects::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Interconnects> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Interconnects::new)
    }

    /// Deletes the specified Interconnect.
    pub fn delete(&self) -> super::builder::interconnects::Delete {
        super::builder::interconnects::Delete::new(self.inner.clone())
    }

    /// Returns the specified Interconnect. Get a list of available Interconnects
    /// by making a list() request.
    pub fn get(&self) -> super::builder::interconnects::Get {
        super::builder::interconnects::Get::new(self.inner.clone())
    }

    /// Returns the interconnectDiagnostics for the specified
    /// Interconnect.
    ///
    /// In the event of a
    /// global outage, do not use this API to make decisions about where to
    /// redirect your network traffic.
    ///
    /// Unlike a VLAN attachment, which is regional, a Cloud Interconnect
    /// connection is a global resource. A global outage can prevent this
    /// API from functioning properly.
    pub fn get_diagnostics(&self) -> super::builder::interconnects::GetDiagnostics {
        super::builder::interconnects::GetDiagnostics::new(self.inner.clone())
    }

    /// Returns the interconnectMacsecConfig for the specified
    /// Interconnect.
    pub fn get_macsec_config(&self) -> super::builder::interconnects::GetMacsecConfig {
        super::builder::interconnects::GetMacsecConfig::new(self.inner.clone())
    }

    /// Creates an Interconnect in the specified project using
    /// the data included in the request.
    pub fn insert(&self) -> super::builder::interconnects::Insert {
        super::builder::interconnects::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of Interconnects available to the specified project.
    pub fn list(&self) -> super::builder::interconnects::List {
        super::builder::interconnects::List::new(self.inner.clone())
    }

    /// Updates the specified Interconnect with the data included in the request.
    /// This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::interconnects::Patch {
        super::builder::interconnects::Patch::new(self.inner.clone())
    }

    /// Sets the labels on an Interconnect. To learn more about labels,
    /// read the Labeling
    /// Resources documentation.
    pub fn set_labels(&self) -> super::builder::interconnects::SetLabels {
        super::builder::interconnects::SetLabels::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::interconnects::GetOperation {
        super::builder::interconnects::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::LicenseCodes;
/// let client = LicenseCodes::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `licenseCodes` resource.
///
/// # Configuration
///
/// To configure `LicenseCodes` use the `with_*` methods in the type returned
/// by [builder()][LicenseCodes::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::license_codes::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::license_codes::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `LicenseCodes` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `LicenseCodes` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "license-codes")]
#[cfg_attr(docsrs, doc(cfg(feature = "license-codes")))]
#[derive(Clone, Debug)]
pub struct LicenseCodes {
    inner: std::sync::Arc<dyn super::stub::dynamic::LicenseCodes>,
}

#[cfg(feature = "license-codes")]
impl LicenseCodes {
    /// Returns a builder for [LicenseCodes].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::LicenseCodes;
    /// let client = LicenseCodes::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::license_codes::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::license_codes::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::LicenseCodes + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::LicenseCodes>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::LicenseCodes> {
        super::transport::LicenseCodes::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::LicenseCodes> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::LicenseCodes::new)
    }

    /// Return a specified license code. License codes are mirrored across
    /// all projects that have permissions to read the License Code.
    /// *Caution* This resource is intended
    /// for use only by third-party partners who are creatingCloud Marketplace
    /// images.
    pub fn get(&self) -> super::builder::license_codes::Get {
        super::builder::license_codes::Get::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    /// *Caution* This resource is intended
    /// for use only by third-party partners who are creatingCloud Marketplace
    /// images.
    pub fn test_iam_permissions(&self) -> super::builder::license_codes::TestIamPermissions {
        super::builder::license_codes::TestIamPermissions::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::Licenses;
/// let client = Licenses::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `licenses` resource.
///
/// # Configuration
///
/// To configure `Licenses` use the `with_*` methods in the type returned
/// by [builder()][Licenses::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::licenses::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::licenses::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Licenses` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Licenses` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "licenses")]
#[cfg_attr(docsrs, doc(cfg(feature = "licenses")))]
#[derive(Clone, Debug)]
pub struct Licenses {
    inner: std::sync::Arc<dyn super::stub::dynamic::Licenses>,
}

#[cfg(feature = "licenses")]
impl Licenses {
    /// Returns a builder for [Licenses].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::Licenses;
    /// let client = Licenses::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::licenses::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::licenses::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Licenses + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Licenses>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Licenses> {
        super::transport::Licenses::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Licenses> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Licenses::new)
    }

    /// Deletes the specified license.
    /// *Caution* This resource is intended
    /// for use only by third-party partners who are creatingCloud Marketplace
    /// images.
    pub fn delete(&self) -> super::builder::licenses::Delete {
        super::builder::licenses::Delete::new(self.inner.clone())
    }

    /// Returns the specified License resource.
    /// *Caution* This resource is intended
    /// for use only by third-party partners who are creatingCloud Marketplace
    /// images.
    pub fn get(&self) -> super::builder::licenses::Get {
        super::builder::licenses::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    /// *Caution* This resource is intended
    /// for use only by third-party partners who are creatingCloud Marketplace
    /// images.
    pub fn get_iam_policy(&self) -> super::builder::licenses::GetIamPolicy {
        super::builder::licenses::GetIamPolicy::new(self.inner.clone())
    }

    /// Create a License resource in the specified project.
    /// *Caution* This resource is intended
    /// for use only by third-party partners who are creatingCloud Marketplace
    /// images.
    pub fn insert(&self) -> super::builder::licenses::Insert {
        super::builder::licenses::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of licenses
    /// available in the specified project. This method does not
    /// get any licenses that belong to other projects, including licenses attached
    /// to publicly-available images, like Debian 9. If you want to get a list of
    /// publicly-available licenses, use this method to make a request to the
    /// respective image project, such as debian-cloud orwindows-cloud.
    /// *Caution* This resource is intended
    /// for use only by third-party partners who are creatingCloud Marketplace
    /// images.
    pub fn list(&self) -> super::builder::licenses::List {
        super::builder::licenses::List::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    /// *Caution* This resource is intended
    /// for use only by third-party partners who are creatingCloud Marketplace
    /// images.
    pub fn set_iam_policy(&self) -> super::builder::licenses::SetIamPolicy {
        super::builder::licenses::SetIamPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    /// *Caution* This resource is intended
    /// for use only by third-party partners who are creatingCloud Marketplace
    /// images.
    pub fn test_iam_permissions(&self) -> super::builder::licenses::TestIamPermissions {
        super::builder::licenses::TestIamPermissions::new(self.inner.clone())
    }

    /// Updates a License resource in the specified project.
    /// *Caution* This resource is intended
    /// for use only by third-party partners who are creatingCloud Marketplace
    /// images.
    pub fn update(&self) -> super::builder::licenses::Update {
        super::builder::licenses::Update::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::licenses::GetOperation {
        super::builder::licenses::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::MachineImages;
/// let client = MachineImages::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `machineImages` resource.
///
/// # Configuration
///
/// To configure `MachineImages` use the `with_*` methods in the type returned
/// by [builder()][MachineImages::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::machine_images::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::machine_images::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `MachineImages` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `MachineImages` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "machine-images")]
#[cfg_attr(docsrs, doc(cfg(feature = "machine-images")))]
#[derive(Clone, Debug)]
pub struct MachineImages {
    inner: std::sync::Arc<dyn super::stub::dynamic::MachineImages>,
}

#[cfg(feature = "machine-images")]
impl MachineImages {
    /// Returns a builder for [MachineImages].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::MachineImages;
    /// let client = MachineImages::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::machine_images::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::machine_images::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::MachineImages + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::MachineImages>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::MachineImages> {
        super::transport::MachineImages::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::MachineImages> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::MachineImages::new)
    }

    /// Deletes the specified machine image. Deleting a machine image is permanent
    /// and cannot be undone.
    pub fn delete(&self) -> super::builder::machine_images::Delete {
        super::builder::machine_images::Delete::new(self.inner.clone())
    }

    /// Returns the specified machine image.
    pub fn get(&self) -> super::builder::machine_images::Get {
        super::builder::machine_images::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::machine_images::GetIamPolicy {
        super::builder::machine_images::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates a machine image in the specified project using the
    /// data that is included in the request. If you are creating a new machine
    /// image to update an existing instance, your new machine image should use the
    /// same network or, if applicable, the same subnetwork as the original
    /// instance.
    pub fn insert(&self) -> super::builder::machine_images::Insert {
        super::builder::machine_images::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of machine images that are contained within
    /// the specified project.
    pub fn list(&self) -> super::builder::machine_images::List {
        super::builder::machine_images::List::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::machine_images::SetIamPolicy {
        super::builder::machine_images::SetIamPolicy::new(self.inner.clone())
    }

    /// Sets the labels on a machine image. To learn more about labels, read theLabeling
    /// Resources documentation.
    pub fn set_labels(&self) -> super::builder::machine_images::SetLabels {
        super::builder::machine_images::SetLabels::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::machine_images::TestIamPermissions {
        super::builder::machine_images::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::machine_images::GetOperation {
        super::builder::machine_images::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::MachineTypes;
/// let client = MachineTypes::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `machineTypes` resource.
///
/// # Configuration
///
/// To configure `MachineTypes` use the `with_*` methods in the type returned
/// by [builder()][MachineTypes::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::machine_types::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::machine_types::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `MachineTypes` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `MachineTypes` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "machine-types")]
#[cfg_attr(docsrs, doc(cfg(feature = "machine-types")))]
#[derive(Clone, Debug)]
pub struct MachineTypes {
    inner: std::sync::Arc<dyn super::stub::dynamic::MachineTypes>,
}

#[cfg(feature = "machine-types")]
impl MachineTypes {
    /// Returns a builder for [MachineTypes].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::MachineTypes;
    /// let client = MachineTypes::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::machine_types::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::machine_types::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::MachineTypes + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::MachineTypes>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::MachineTypes> {
        super::transport::MachineTypes::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::MachineTypes> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::MachineTypes::new)
    }

    /// Retrieves an aggregated list of machine types.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::machine_types::AggregatedList {
        super::builder::machine_types::AggregatedList::new(self.inner.clone())
    }

    /// Returns the specified machine type.
    pub fn get(&self) -> super::builder::machine_types::Get {
        super::builder::machine_types::Get::new(self.inner.clone())
    }

    /// Retrieves a list of machine types available to the specified
    /// project.
    pub fn list(&self) -> super::builder::machine_types::List {
        super::builder::machine_types::List::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::NetworkAttachments;
/// let client = NetworkAttachments::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `networkAttachments` resource.
///
/// # Configuration
///
/// To configure `NetworkAttachments` use the `with_*` methods in the type returned
/// by [builder()][NetworkAttachments::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::network_attachments::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::network_attachments::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `NetworkAttachments` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `NetworkAttachments` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "network-attachments")]
#[cfg_attr(docsrs, doc(cfg(feature = "network-attachments")))]
#[derive(Clone, Debug)]
pub struct NetworkAttachments {
    inner: std::sync::Arc<dyn super::stub::dynamic::NetworkAttachments>,
}

#[cfg(feature = "network-attachments")]
impl NetworkAttachments {
    /// Returns a builder for [NetworkAttachments].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::NetworkAttachments;
    /// let client = NetworkAttachments::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::network_attachments::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::network_attachments::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::NetworkAttachments + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::NetworkAttachments>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::NetworkAttachments> {
        super::transport::NetworkAttachments::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::NetworkAttachments> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::NetworkAttachments::new)
    }

    /// Retrieves the list of all NetworkAttachment resources,
    /// regional and global, available to the specified project.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::network_attachments::AggregatedList {
        super::builder::network_attachments::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified NetworkAttachment in the given scope
    pub fn delete(&self) -> super::builder::network_attachments::Delete {
        super::builder::network_attachments::Delete::new(self.inner.clone())
    }

    /// Returns the specified NetworkAttachment resource in the given scope.
    pub fn get(&self) -> super::builder::network_attachments::Get {
        super::builder::network_attachments::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::network_attachments::GetIamPolicy {
        super::builder::network_attachments::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates a NetworkAttachment in the specified project in the given scope
    /// using the parameters that are included in the request.
    pub fn insert(&self) -> super::builder::network_attachments::Insert {
        super::builder::network_attachments::Insert::new(self.inner.clone())
    }

    /// Lists the NetworkAttachments for a project in the given scope.
    pub fn list(&self) -> super::builder::network_attachments::List {
        super::builder::network_attachments::List::new(self.inner.clone())
    }

    /// Patches the specified NetworkAttachment resource with the data included in
    /// the request. This method supports PATCH
    /// semantics and usesJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::network_attachments::Patch {
        super::builder::network_attachments::Patch::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::network_attachments::SetIamPolicy {
        super::builder::network_attachments::SetIamPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::network_attachments::TestIamPermissions {
        super::builder::network_attachments::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::network_attachments::GetOperation {
        super::builder::network_attachments::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::NetworkEdgeSecurityServices;
/// let client = NetworkEdgeSecurityServices::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `networkEdgeSecurityServices` resource.
///
/// # Configuration
///
/// To configure `NetworkEdgeSecurityServices` use the `with_*` methods in the type returned
/// by [builder()][NetworkEdgeSecurityServices::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::network_edge_security_services::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::network_edge_security_services::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `NetworkEdgeSecurityServices` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `NetworkEdgeSecurityServices` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "network-edge-security-services")]
#[cfg_attr(docsrs, doc(cfg(feature = "network-edge-security-services")))]
#[derive(Clone, Debug)]
pub struct NetworkEdgeSecurityServices {
    inner: std::sync::Arc<dyn super::stub::dynamic::NetworkEdgeSecurityServices>,
}

#[cfg(feature = "network-edge-security-services")]
impl NetworkEdgeSecurityServices {
    /// Returns a builder for [NetworkEdgeSecurityServices].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::NetworkEdgeSecurityServices;
    /// let client = NetworkEdgeSecurityServices::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::network_edge_security_services::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::network_edge_security_services::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::NetworkEdgeSecurityServices + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::NetworkEdgeSecurityServices>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::NetworkEdgeSecurityServices> {
        super::transport::NetworkEdgeSecurityServices::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::NetworkEdgeSecurityServices> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::NetworkEdgeSecurityServices::new)
    }

    /// Retrieves the list of all NetworkEdgeSecurityService resources available to
    /// the specified project.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(
        &self,
    ) -> super::builder::network_edge_security_services::AggregatedList {
        super::builder::network_edge_security_services::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified service.
    pub fn delete(&self) -> super::builder::network_edge_security_services::Delete {
        super::builder::network_edge_security_services::Delete::new(self.inner.clone())
    }

    /// Gets a specified NetworkEdgeSecurityService.
    pub fn get(&self) -> super::builder::network_edge_security_services::Get {
        super::builder::network_edge_security_services::Get::new(self.inner.clone())
    }

    /// Creates a new service in the specified project using the data included in
    /// the request.
    pub fn insert(&self) -> super::builder::network_edge_security_services::Insert {
        super::builder::network_edge_security_services::Insert::new(self.inner.clone())
    }

    /// Patches the specified policy with the data included in the request.
    pub fn patch(&self) -> super::builder::network_edge_security_services::Patch {
        super::builder::network_edge_security_services::Patch::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::network_edge_security_services::GetOperation {
        super::builder::network_edge_security_services::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::NetworkEndpointGroups;
/// let client = NetworkEndpointGroups::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `networkEndpointGroups` resource.
///
/// # Configuration
///
/// To configure `NetworkEndpointGroups` use the `with_*` methods in the type returned
/// by [builder()][NetworkEndpointGroups::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::network_endpoint_groups::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::network_endpoint_groups::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `NetworkEndpointGroups` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `NetworkEndpointGroups` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "network-endpoint-groups")]
#[cfg_attr(docsrs, doc(cfg(feature = "network-endpoint-groups")))]
#[derive(Clone, Debug)]
pub struct NetworkEndpointGroups {
    inner: std::sync::Arc<dyn super::stub::dynamic::NetworkEndpointGroups>,
}

#[cfg(feature = "network-endpoint-groups")]
impl NetworkEndpointGroups {
    /// Returns a builder for [NetworkEndpointGroups].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::NetworkEndpointGroups;
    /// let client = NetworkEndpointGroups::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::network_endpoint_groups::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::network_endpoint_groups::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::NetworkEndpointGroups + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::NetworkEndpointGroups>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::NetworkEndpointGroups> {
        super::transport::NetworkEndpointGroups::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::NetworkEndpointGroups> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::NetworkEndpointGroups::new)
    }

    /// Retrieves the list of network endpoint groups and sorts them by zone.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::network_endpoint_groups::AggregatedList {
        super::builder::network_endpoint_groups::AggregatedList::new(self.inner.clone())
    }

    /// Attach a list of network endpoints to the specified network endpoint group.
    pub fn attach_network_endpoints(
        &self,
    ) -> super::builder::network_endpoint_groups::AttachNetworkEndpoints {
        super::builder::network_endpoint_groups::AttachNetworkEndpoints::new(self.inner.clone())
    }

    /// Deletes the specified network endpoint group. The network endpoints in the
    /// NEG and the VM instances they belong to are not terminated when the NEG is
    /// deleted. Note that the NEG cannot be deleted if there are backend services
    /// referencing it.
    pub fn delete(&self) -> super::builder::network_endpoint_groups::Delete {
        super::builder::network_endpoint_groups::Delete::new(self.inner.clone())
    }

    /// Detach a list of network endpoints from the specified network endpoint
    /// group.
    pub fn detach_network_endpoints(
        &self,
    ) -> super::builder::network_endpoint_groups::DetachNetworkEndpoints {
        super::builder::network_endpoint_groups::DetachNetworkEndpoints::new(self.inner.clone())
    }

    /// Returns the specified network endpoint group.
    pub fn get(&self) -> super::builder::network_endpoint_groups::Get {
        super::builder::network_endpoint_groups::Get::new(self.inner.clone())
    }

    /// Creates a network endpoint group in the specified project using the
    /// parameters that are included in the request.
    pub fn insert(&self) -> super::builder::network_endpoint_groups::Insert {
        super::builder::network_endpoint_groups::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of network endpoint groups that are located in the
    /// specified project and zone.
    pub fn list(&self) -> super::builder::network_endpoint_groups::List {
        super::builder::network_endpoint_groups::List::new(self.inner.clone())
    }

    /// Lists the network endpoints in the specified network endpoint group.
    pub fn list_network_endpoints(
        &self,
    ) -> super::builder::network_endpoint_groups::ListNetworkEndpoints {
        super::builder::network_endpoint_groups::ListNetworkEndpoints::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(
        &self,
    ) -> super::builder::network_endpoint_groups::TestIamPermissions {
        super::builder::network_endpoint_groups::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified zone-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::network_endpoint_groups::GetOperation {
        super::builder::network_endpoint_groups::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::NetworkFirewallPolicies;
/// let client = NetworkFirewallPolicies::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `networkFirewallPolicies` resource.
///
/// # Configuration
///
/// To configure `NetworkFirewallPolicies` use the `with_*` methods in the type returned
/// by [builder()][NetworkFirewallPolicies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::network_firewall_policies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::network_firewall_policies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `NetworkFirewallPolicies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `NetworkFirewallPolicies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "network-firewall-policies")]
#[cfg_attr(docsrs, doc(cfg(feature = "network-firewall-policies")))]
#[derive(Clone, Debug)]
pub struct NetworkFirewallPolicies {
    inner: std::sync::Arc<dyn super::stub::dynamic::NetworkFirewallPolicies>,
}

#[cfg(feature = "network-firewall-policies")]
impl NetworkFirewallPolicies {
    /// Returns a builder for [NetworkFirewallPolicies].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::NetworkFirewallPolicies;
    /// let client = NetworkFirewallPolicies::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::network_firewall_policies::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::network_firewall_policies::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::NetworkFirewallPolicies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::NetworkFirewallPolicies>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::NetworkFirewallPolicies> {
        super::transport::NetworkFirewallPolicies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::NetworkFirewallPolicies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::NetworkFirewallPolicies::new)
    }

    /// Inserts an association for the specified firewall policy.
    pub fn add_association(&self) -> super::builder::network_firewall_policies::AddAssociation {
        super::builder::network_firewall_policies::AddAssociation::new(self.inner.clone())
    }

    /// Inserts a packet mirroring rule into a firewall policy.
    pub fn add_packet_mirroring_rule(
        &self,
    ) -> super::builder::network_firewall_policies::AddPacketMirroringRule {
        super::builder::network_firewall_policies::AddPacketMirroringRule::new(self.inner.clone())
    }

    /// Inserts a rule into a firewall policy.
    pub fn add_rule(&self) -> super::builder::network_firewall_policies::AddRule {
        super::builder::network_firewall_policies::AddRule::new(self.inner.clone())
    }

    /// Retrieves an aggregated list of network firewall policies, listing network
    /// firewall policies from all applicable scopes (global and regional) and
    /// grouping the results per scope.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::network_firewall_policies::AggregatedList {
        super::builder::network_firewall_policies::AggregatedList::new(self.inner.clone())
    }

    /// Copies rules to the specified firewall policy.
    pub fn clone_rules(&self) -> super::builder::network_firewall_policies::CloneRules {
        super::builder::network_firewall_policies::CloneRules::new(self.inner.clone())
    }

    /// Deletes the specified policy.
    pub fn delete(&self) -> super::builder::network_firewall_policies::Delete {
        super::builder::network_firewall_policies::Delete::new(self.inner.clone())
    }

    /// Returns the specified network firewall policy.
    pub fn get(&self) -> super::builder::network_firewall_policies::Get {
        super::builder::network_firewall_policies::Get::new(self.inner.clone())
    }

    /// Gets an association with the specified name.
    pub fn get_association(&self) -> super::builder::network_firewall_policies::GetAssociation {
        super::builder::network_firewall_policies::GetAssociation::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::network_firewall_policies::GetIamPolicy {
        super::builder::network_firewall_policies::GetIamPolicy::new(self.inner.clone())
    }

    /// Gets a packet mirroring rule of the specified priority.
    pub fn get_packet_mirroring_rule(
        &self,
    ) -> super::builder::network_firewall_policies::GetPacketMirroringRule {
        super::builder::network_firewall_policies::GetPacketMirroringRule::new(self.inner.clone())
    }

    /// Gets a rule of the specified priority.
    pub fn get_rule(&self) -> super::builder::network_firewall_policies::GetRule {
        super::builder::network_firewall_policies::GetRule::new(self.inner.clone())
    }

    /// Creates a new policy in the specified project using the data included in
    /// the request.
    pub fn insert(&self) -> super::builder::network_firewall_policies::Insert {
        super::builder::network_firewall_policies::Insert::new(self.inner.clone())
    }

    /// Lists all the policies that have been configured for the specified project.
    pub fn list(&self) -> super::builder::network_firewall_policies::List {
        super::builder::network_firewall_policies::List::new(self.inner.clone())
    }

    /// Patches the specified policy with the data included in the request.
    pub fn patch(&self) -> super::builder::network_firewall_policies::Patch {
        super::builder::network_firewall_policies::Patch::new(self.inner.clone())
    }

    /// Patches a packet mirroring rule of the specified priority.
    pub fn patch_packet_mirroring_rule(
        &self,
    ) -> super::builder::network_firewall_policies::PatchPacketMirroringRule {
        super::builder::network_firewall_policies::PatchPacketMirroringRule::new(self.inner.clone())
    }

    /// Patches a rule of the specified priority.
    pub fn patch_rule(&self) -> super::builder::network_firewall_policies::PatchRule {
        super::builder::network_firewall_policies::PatchRule::new(self.inner.clone())
    }

    /// Removes an association for the specified firewall policy.
    pub fn remove_association(
        &self,
    ) -> super::builder::network_firewall_policies::RemoveAssociation {
        super::builder::network_firewall_policies::RemoveAssociation::new(self.inner.clone())
    }

    /// Deletes a packet mirroring rule of the specified priority.
    pub fn remove_packet_mirroring_rule(
        &self,
    ) -> super::builder::network_firewall_policies::RemovePacketMirroringRule {
        super::builder::network_firewall_policies::RemovePacketMirroringRule::new(
            self.inner.clone(),
        )
    }

    /// Deletes a rule of the specified priority.
    pub fn remove_rule(&self) -> super::builder::network_firewall_policies::RemoveRule {
        super::builder::network_firewall_policies::RemoveRule::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::network_firewall_policies::SetIamPolicy {
        super::builder::network_firewall_policies::SetIamPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(
        &self,
    ) -> super::builder::network_firewall_policies::TestIamPermissions {
        super::builder::network_firewall_policies::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::network_firewall_policies::GetOperation {
        super::builder::network_firewall_policies::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::NetworkProfiles;
/// let client = NetworkProfiles::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `networkProfiles` resource.
///
/// # Configuration
///
/// To configure `NetworkProfiles` use the `with_*` methods in the type returned
/// by [builder()][NetworkProfiles::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::network_profiles::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::network_profiles::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `NetworkProfiles` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `NetworkProfiles` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "network-profiles")]
#[cfg_attr(docsrs, doc(cfg(feature = "network-profiles")))]
#[derive(Clone, Debug)]
pub struct NetworkProfiles {
    inner: std::sync::Arc<dyn super::stub::dynamic::NetworkProfiles>,
}

#[cfg(feature = "network-profiles")]
impl NetworkProfiles {
    /// Returns a builder for [NetworkProfiles].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::NetworkProfiles;
    /// let client = NetworkProfiles::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::network_profiles::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::network_profiles::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::NetworkProfiles + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::NetworkProfiles>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::NetworkProfiles> {
        super::transport::NetworkProfiles::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::NetworkProfiles> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::NetworkProfiles::new)
    }

    /// Returns the specified network profile.
    pub fn get(&self) -> super::builder::network_profiles::Get {
        super::builder::network_profiles::Get::new(self.inner.clone())
    }

    /// Retrieves a list of network profiles available to the specified
    /// project.
    pub fn list(&self) -> super::builder::network_profiles::List {
        super::builder::network_profiles::List::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::Networks;
/// let client = Networks::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `networks` resource.
///
/// # Configuration
///
/// To configure `Networks` use the `with_*` methods in the type returned
/// by [builder()][Networks::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::networks::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::networks::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Networks` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Networks` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "networks")]
#[cfg_attr(docsrs, doc(cfg(feature = "networks")))]
#[derive(Clone, Debug)]
pub struct Networks {
    inner: std::sync::Arc<dyn super::stub::dynamic::Networks>,
}

#[cfg(feature = "networks")]
impl Networks {
    /// Returns a builder for [Networks].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::Networks;
    /// let client = Networks::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::networks::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::networks::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Networks + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Networks>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Networks> {
        super::transport::Networks::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Networks> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Networks::new)
    }

    /// Adds a peering to the specified network.
    pub fn add_peering(&self) -> super::builder::networks::AddPeering {
        super::builder::networks::AddPeering::new(self.inner.clone())
    }

    /// Deletes the specified network.
    pub fn delete(&self) -> super::builder::networks::Delete {
        super::builder::networks::Delete::new(self.inner.clone())
    }

    /// Returns the specified network.
    pub fn get(&self) -> super::builder::networks::Get {
        super::builder::networks::Get::new(self.inner.clone())
    }

    /// Returns the effective firewalls on a given network.
    pub fn get_effective_firewalls(&self) -> super::builder::networks::GetEffectiveFirewalls {
        super::builder::networks::GetEffectiveFirewalls::new(self.inner.clone())
    }

    /// Creates a network in the specified project using the data included
    /// in the request.
    pub fn insert(&self) -> super::builder::networks::Insert {
        super::builder::networks::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of networks available to the specified project.
    pub fn list(&self) -> super::builder::networks::List {
        super::builder::networks::List::new(self.inner.clone())
    }

    /// Lists the peering routes exchanged over peering connection.
    pub fn list_peering_routes(&self) -> super::builder::networks::ListPeeringRoutes {
        super::builder::networks::ListPeeringRoutes::new(self.inner.clone())
    }

    /// Patches the specified network with the data included in the request.
    /// Only routingConfig can be modified.
    pub fn patch(&self) -> super::builder::networks::Patch {
        super::builder::networks::Patch::new(self.inner.clone())
    }

    /// Removes a peering from the specified network.
    pub fn remove_peering(&self) -> super::builder::networks::RemovePeering {
        super::builder::networks::RemovePeering::new(self.inner.clone())
    }

    /// Requests to remove a peering from the specified network. Applicable only
    /// for PeeringConnection with update_strategy=CONSENSUS.
    pub fn request_remove_peering(&self) -> super::builder::networks::RequestRemovePeering {
        super::builder::networks::RequestRemovePeering::new(self.inner.clone())
    }

    /// Switches the network mode from auto subnet mode to custom subnet mode.
    pub fn switch_to_custom_mode(&self) -> super::builder::networks::SwitchToCustomMode {
        super::builder::networks::SwitchToCustomMode::new(self.inner.clone())
    }

    /// Updates the specified network peering with the data included in the
    /// request. You can only modify the NetworkPeering.export_custom_routes field
    /// and the NetworkPeering.import_custom_routes field.
    pub fn update_peering(&self) -> super::builder::networks::UpdatePeering {
        super::builder::networks::UpdatePeering::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::networks::GetOperation {
        super::builder::networks::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::NodeGroups;
/// let client = NodeGroups::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `nodeGroups` resource.
///
/// # Configuration
///
/// To configure `NodeGroups` use the `with_*` methods in the type returned
/// by [builder()][NodeGroups::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::node_groups::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::node_groups::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `NodeGroups` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `NodeGroups` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "node-groups")]
#[cfg_attr(docsrs, doc(cfg(feature = "node-groups")))]
#[derive(Clone, Debug)]
pub struct NodeGroups {
    inner: std::sync::Arc<dyn super::stub::dynamic::NodeGroups>,
}

#[cfg(feature = "node-groups")]
impl NodeGroups {
    /// Returns a builder for [NodeGroups].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::NodeGroups;
    /// let client = NodeGroups::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::node_groups::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::node_groups::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::NodeGroups + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::NodeGroups>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::NodeGroups> {
        super::transport::NodeGroups::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::NodeGroups> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::NodeGroups::new)
    }

    /// Adds specified number of nodes to the node group.
    pub fn add_nodes(&self) -> super::builder::node_groups::AddNodes {
        super::builder::node_groups::AddNodes::new(self.inner.clone())
    }

    /// Retrieves an aggregated list of node groups.
    /// Note: use nodeGroups.listNodes for more details about each group.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::node_groups::AggregatedList {
        super::builder::node_groups::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified NodeGroup resource.
    pub fn delete(&self) -> super::builder::node_groups::Delete {
        super::builder::node_groups::Delete::new(self.inner.clone())
    }

    /// Deletes specified nodes from the node group.
    pub fn delete_nodes(&self) -> super::builder::node_groups::DeleteNodes {
        super::builder::node_groups::DeleteNodes::new(self.inner.clone())
    }

    /// Returns the specified NodeGroup. Get a list of available NodeGroups
    /// by making a list() request.
    /// Note: the "nodes" field should not be used. Use nodeGroups.listNodes
    /// instead.
    pub fn get(&self) -> super::builder::node_groups::Get {
        super::builder::node_groups::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::node_groups::GetIamPolicy {
        super::builder::node_groups::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates a NodeGroup resource in the specified project using the data
    /// included in the request.
    pub fn insert(&self) -> super::builder::node_groups::Insert {
        super::builder::node_groups::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of node groups available to the specified project.
    /// Note: use nodeGroups.listNodes for more details about each group.
    pub fn list(&self) -> super::builder::node_groups::List {
        super::builder::node_groups::List::new(self.inner.clone())
    }

    /// Lists nodes in the node group.
    pub fn list_nodes(&self) -> super::builder::node_groups::ListNodes {
        super::builder::node_groups::ListNodes::new(self.inner.clone())
    }

    /// Updates the specified node group.
    pub fn patch(&self) -> super::builder::node_groups::Patch {
        super::builder::node_groups::Patch::new(self.inner.clone())
    }

    /// Perform maintenance on a subset of nodes in the node group.
    pub fn perform_maintenance(&self) -> super::builder::node_groups::PerformMaintenance {
        super::builder::node_groups::PerformMaintenance::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::node_groups::SetIamPolicy {
        super::builder::node_groups::SetIamPolicy::new(self.inner.clone())
    }

    /// Updates the node template of the node group.
    pub fn set_node_template(&self) -> super::builder::node_groups::SetNodeTemplate {
        super::builder::node_groups::SetNodeTemplate::new(self.inner.clone())
    }

    /// Simulates maintenance event on specified nodes from the node group.
    pub fn simulate_maintenance_event(
        &self,
    ) -> super::builder::node_groups::SimulateMaintenanceEvent {
        super::builder::node_groups::SimulateMaintenanceEvent::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::node_groups::TestIamPermissions {
        super::builder::node_groups::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified zone-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::node_groups::GetOperation {
        super::builder::node_groups::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::NodeTemplates;
/// let client = NodeTemplates::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `nodeTemplates` resource.
///
/// # Configuration
///
/// To configure `NodeTemplates` use the `with_*` methods in the type returned
/// by [builder()][NodeTemplates::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::node_templates::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::node_templates::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `NodeTemplates` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `NodeTemplates` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "node-templates")]
#[cfg_attr(docsrs, doc(cfg(feature = "node-templates")))]
#[derive(Clone, Debug)]
pub struct NodeTemplates {
    inner: std::sync::Arc<dyn super::stub::dynamic::NodeTemplates>,
}

#[cfg(feature = "node-templates")]
impl NodeTemplates {
    /// Returns a builder for [NodeTemplates].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::NodeTemplates;
    /// let client = NodeTemplates::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::node_templates::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::node_templates::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::NodeTemplates + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::NodeTemplates>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::NodeTemplates> {
        super::transport::NodeTemplates::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::NodeTemplates> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::NodeTemplates::new)
    }

    /// Retrieves an aggregated list of node templates.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::node_templates::AggregatedList {
        super::builder::node_templates::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified NodeTemplate resource.
    pub fn delete(&self) -> super::builder::node_templates::Delete {
        super::builder::node_templates::Delete::new(self.inner.clone())
    }

    /// Returns the specified node template.
    pub fn get(&self) -> super::builder::node_templates::Get {
        super::builder::node_templates::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::node_templates::GetIamPolicy {
        super::builder::node_templates::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates a NodeTemplate resource in the specified project using the data
    /// included in the request.
    pub fn insert(&self) -> super::builder::node_templates::Insert {
        super::builder::node_templates::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of node templates available to the specified
    /// project.
    pub fn list(&self) -> super::builder::node_templates::List {
        super::builder::node_templates::List::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::node_templates::SetIamPolicy {
        super::builder::node_templates::SetIamPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::node_templates::TestIamPermissions {
        super::builder::node_templates::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::node_templates::GetOperation {
        super::builder::node_templates::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::NodeTypes;
/// let client = NodeTypes::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `nodeTypes` resource.
///
/// # Configuration
///
/// To configure `NodeTypes` use the `with_*` methods in the type returned
/// by [builder()][NodeTypes::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::node_types::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::node_types::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `NodeTypes` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `NodeTypes` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "node-types")]
#[cfg_attr(docsrs, doc(cfg(feature = "node-types")))]
#[derive(Clone, Debug)]
pub struct NodeTypes {
    inner: std::sync::Arc<dyn super::stub::dynamic::NodeTypes>,
}

#[cfg(feature = "node-types")]
impl NodeTypes {
    /// Returns a builder for [NodeTypes].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::NodeTypes;
    /// let client = NodeTypes::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::node_types::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::node_types::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::NodeTypes + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::NodeTypes>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::NodeTypes> {
        super::transport::NodeTypes::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::NodeTypes> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::NodeTypes::new)
    }

    /// Retrieves an aggregated list of node types.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::node_types::AggregatedList {
        super::builder::node_types::AggregatedList::new(self.inner.clone())
    }

    /// Returns the specified node type.
    pub fn get(&self) -> super::builder::node_types::Get {
        super::builder::node_types::Get::new(self.inner.clone())
    }

    /// Retrieves a list of node types available to the specified
    /// project.
    pub fn list(&self) -> super::builder::node_types::List {
        super::builder::node_types::List::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::OrganizationSecurityPolicies;
/// let client = OrganizationSecurityPolicies::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `organizationSecurityPolicies` resource.
///
/// # Configuration
///
/// To configure `OrganizationSecurityPolicies` use the `with_*` methods in the type returned
/// by [builder()][OrganizationSecurityPolicies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::organization_security_policies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::organization_security_policies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `OrganizationSecurityPolicies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `OrganizationSecurityPolicies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "organization-security-policies")]
#[cfg_attr(docsrs, doc(cfg(feature = "organization-security-policies")))]
#[derive(Clone, Debug)]
pub struct OrganizationSecurityPolicies {
    inner: std::sync::Arc<dyn super::stub::dynamic::OrganizationSecurityPolicies>,
}

#[cfg(feature = "organization-security-policies")]
impl OrganizationSecurityPolicies {
    /// Returns a builder for [OrganizationSecurityPolicies].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::OrganizationSecurityPolicies;
    /// let client = OrganizationSecurityPolicies::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::organization_security_policies::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::organization_security_policies::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::OrganizationSecurityPolicies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::OrganizationSecurityPolicies>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::OrganizationSecurityPolicies> {
        super::transport::OrganizationSecurityPolicies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::OrganizationSecurityPolicies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::OrganizationSecurityPolicies::new)
    }

    /// Inserts an association for the specified security policy.
    ///
    /// This has billing implications.  Projects in the hierarchy with effective
    /// hierarchical security policies will be automatically enrolled into Cloud
    /// Armor Enterprise if not already enrolled.
    ///
    /// Use of this API to modify firewall policies is deprecated. Use
    /// firewallPolicies.addAssociation instead if possible.
    pub fn add_association(
        &self,
    ) -> super::builder::organization_security_policies::AddAssociation {
        super::builder::organization_security_policies::AddAssociation::new(self.inner.clone())
    }

    /// Inserts a rule into a security policy.
    pub fn add_rule(&self) -> super::builder::organization_security_policies::AddRule {
        super::builder::organization_security_policies::AddRule::new(self.inner.clone())
    }

    /// Copies rules to the specified security policy.
    ///
    /// Use of this API to modify firewall policies is deprecated. Use
    /// firewallPolicies.copyRules instead.
    pub fn copy_rules(&self) -> super::builder::organization_security_policies::CopyRules {
        super::builder::organization_security_policies::CopyRules::new(self.inner.clone())
    }

    /// Deletes the specified policy.
    ///
    /// Use of this API to remove firewall policies is deprecated. Use
    /// firewallPolicies.delete instead.
    pub fn delete(&self) -> super::builder::organization_security_policies::Delete {
        super::builder::organization_security_policies::Delete::new(self.inner.clone())
    }

    /// List all of the ordered rules present in a single specified policy.
    ///
    /// Use of this API to read firewall policies is deprecated. Use
    /// firewallPolicies.get instead.
    pub fn get(&self) -> super::builder::organization_security_policies::Get {
        super::builder::organization_security_policies::Get::new(self.inner.clone())
    }

    /// Gets an association with the specified name.
    ///
    /// Use of this API to read firewall policies is deprecated. Use
    /// firewallPolicies.getAssociation instead if possible.
    pub fn get_association(
        &self,
    ) -> super::builder::organization_security_policies::GetAssociation {
        super::builder::organization_security_policies::GetAssociation::new(self.inner.clone())
    }

    /// Gets a rule at the specified priority.
    ///
    /// Use of this API to read firewall policies is deprecated. Use
    /// firewallPolicies.getRule instead.
    pub fn get_rule(&self) -> super::builder::organization_security_policies::GetRule {
        super::builder::organization_security_policies::GetRule::new(self.inner.clone())
    }

    /// Creates a new policy in the specified organization using the data included
    /// in the request.
    ///
    /// Use of this API to insert firewall policies is deprecated. Use
    /// firewallPolicies.insert instead.
    pub fn insert(&self) -> super::builder::organization_security_policies::Insert {
        super::builder::organization_security_policies::Insert::new(self.inner.clone())
    }

    /// List all the policies that have been configured for the specified
    /// organization.
    ///
    /// Use of this API to read firewall policies is deprecated. Use
    /// firewallPolicies.list instead.
    pub fn list(&self) -> super::builder::organization_security_policies::List {
        super::builder::organization_security_policies::List::new(self.inner.clone())
    }

    /// Lists associations of a specified target, i.e., organization or folder.
    ///
    /// Use of this API to read firewall policies is deprecated. Use
    /// firewallPolicies.listAssociations instead if possible.
    pub fn list_associations(
        &self,
    ) -> super::builder::organization_security_policies::ListAssociations {
        super::builder::organization_security_policies::ListAssociations::new(self.inner.clone())
    }

    /// Gets the current list of preconfigured Web Application Firewall (WAF)
    /// expressions.
    pub fn list_preconfigured_expression_sets(
        &self,
    ) -> super::builder::organization_security_policies::ListPreconfiguredExpressionSets {
        super::builder::organization_security_policies::ListPreconfiguredExpressionSets::new(
            self.inner.clone(),
        )
    }

    /// Moves the specified security policy.
    ///
    /// Use of this API to modify firewall policies is deprecated. Use
    /// firewallPolicies.move instead.
    pub fn r#move(&self) -> super::builder::organization_security_policies::Move {
        super::builder::organization_security_policies::Move::new(self.inner.clone())
    }

    /// Patches the specified policy with the data included in the request.
    ///
    /// Use of this API to modify firewall policies is deprecated. Use
    /// firewallPolicies.patch instead.
    pub fn patch(&self) -> super::builder::organization_security_policies::Patch {
        super::builder::organization_security_policies::Patch::new(self.inner.clone())
    }

    /// Patches a rule at the specified priority.
    ///
    /// Use of this API to modify firewall policies is deprecated. Use
    /// firewallPolicies.patchRule instead.
    pub fn patch_rule(&self) -> super::builder::organization_security_policies::PatchRule {
        super::builder::organization_security_policies::PatchRule::new(self.inner.clone())
    }

    /// Removes an association for the specified security policy.
    ///
    /// Use of this API to modify firewall policies is deprecated. Use
    /// firewallPolicies.removeAssociation instead if possible.
    pub fn remove_association(
        &self,
    ) -> super::builder::organization_security_policies::RemoveAssociation {
        super::builder::organization_security_policies::RemoveAssociation::new(self.inner.clone())
    }

    /// Deletes a rule at the specified priority.
    pub fn remove_rule(&self) -> super::builder::organization_security_policies::RemoveRule {
        super::builder::organization_security_policies::RemoveRule::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource. Gets a list of operations
    /// by making a `list()` request.
    pub fn get_operation(&self) -> super::builder::organization_security_policies::GetOperation {
        super::builder::organization_security_policies::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::PacketMirrorings;
/// let client = PacketMirrorings::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `packetMirrorings` resource.
///
/// # Configuration
///
/// To configure `PacketMirrorings` use the `with_*` methods in the type returned
/// by [builder()][PacketMirrorings::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::packet_mirrorings::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::packet_mirrorings::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `PacketMirrorings` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `PacketMirrorings` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "packet-mirrorings")]
#[cfg_attr(docsrs, doc(cfg(feature = "packet-mirrorings")))]
#[derive(Clone, Debug)]
pub struct PacketMirrorings {
    inner: std::sync::Arc<dyn super::stub::dynamic::PacketMirrorings>,
}

#[cfg(feature = "packet-mirrorings")]
impl PacketMirrorings {
    /// Returns a builder for [PacketMirrorings].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::PacketMirrorings;
    /// let client = PacketMirrorings::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::packet_mirrorings::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::packet_mirrorings::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::PacketMirrorings + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::PacketMirrorings>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::PacketMirrorings> {
        super::transport::PacketMirrorings::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::PacketMirrorings> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::PacketMirrorings::new)
    }

    /// Retrieves an aggregated list of packetMirrorings.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::packet_mirrorings::AggregatedList {
        super::builder::packet_mirrorings::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified PacketMirroring resource.
    pub fn delete(&self) -> super::builder::packet_mirrorings::Delete {
        super::builder::packet_mirrorings::Delete::new(self.inner.clone())
    }

    /// Returns the specified PacketMirroring resource.
    pub fn get(&self) -> super::builder::packet_mirrorings::Get {
        super::builder::packet_mirrorings::Get::new(self.inner.clone())
    }

    /// Creates a PacketMirroring resource in the specified project and region
    /// using the data included in the request.
    pub fn insert(&self) -> super::builder::packet_mirrorings::Insert {
        super::builder::packet_mirrorings::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of PacketMirroring resources available to the specified
    /// project and region.
    pub fn list(&self) -> super::builder::packet_mirrorings::List {
        super::builder::packet_mirrorings::List::new(self.inner.clone())
    }

    /// Patches the specified PacketMirroring resource with the data included in
    /// the request. This method supportsPATCH
    /// semantics and usesJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::packet_mirrorings::Patch {
        super::builder::packet_mirrorings::Patch::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::packet_mirrorings::TestIamPermissions {
        super::builder::packet_mirrorings::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::packet_mirrorings::GetOperation {
        super::builder::packet_mirrorings::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::PreviewFeatures;
/// let client = PreviewFeatures::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `previewFeatures` resource.
///
/// # Configuration
///
/// To configure `PreviewFeatures` use the `with_*` methods in the type returned
/// by [builder()][PreviewFeatures::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::preview_features::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::preview_features::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `PreviewFeatures` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `PreviewFeatures` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "preview-features")]
#[cfg_attr(docsrs, doc(cfg(feature = "preview-features")))]
#[derive(Clone, Debug)]
pub struct PreviewFeatures {
    inner: std::sync::Arc<dyn super::stub::dynamic::PreviewFeatures>,
}

#[cfg(feature = "preview-features")]
impl PreviewFeatures {
    /// Returns a builder for [PreviewFeatures].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::PreviewFeatures;
    /// let client = PreviewFeatures::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::preview_features::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::preview_features::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::PreviewFeatures + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::PreviewFeatures>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::PreviewFeatures> {
        super::transport::PreviewFeatures::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::PreviewFeatures> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::PreviewFeatures::new)
    }

    /// Returns the details of the given PreviewFeature.
    pub fn get(&self) -> super::builder::preview_features::Get {
        super::builder::preview_features::Get::new(self.inner.clone())
    }

    /// Returns the details of the given PreviewFeature.
    pub fn list(&self) -> super::builder::preview_features::List {
        super::builder::preview_features::List::new(self.inner.clone())
    }

    /// Patches the given PreviewFeature. This method is used to enable or disable
    /// a PreviewFeature.
    pub fn update(&self) -> super::builder::preview_features::Update {
        super::builder::preview_features::Update::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::preview_features::GetOperation {
        super::builder::preview_features::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::Projects;
/// let client = Projects::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `projects` resource.
///
/// # Configuration
///
/// To configure `Projects` use the `with_*` methods in the type returned
/// by [builder()][Projects::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::projects::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::projects::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Projects` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Projects` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "projects")]
#[cfg_attr(docsrs, doc(cfg(feature = "projects")))]
#[derive(Clone, Debug)]
pub struct Projects {
    inner: std::sync::Arc<dyn super::stub::dynamic::Projects>,
}

#[cfg(feature = "projects")]
impl Projects {
    /// Returns a builder for [Projects].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::Projects;
    /// let client = Projects::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::projects::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::projects::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Projects + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Projects>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Projects> {
        super::transport::Projects::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Projects> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Projects::new)
    }

    /// Disable this project as a shared VPC host project.
    pub fn disable_xpn_host(&self) -> super::builder::projects::DisableXpnHost {
        super::builder::projects::DisableXpnHost::new(self.inner.clone())
    }

    /// Disable a service resource (also known as service project) associated with
    /// this host project.
    pub fn disable_xpn_resource(&self) -> super::builder::projects::DisableXpnResource {
        super::builder::projects::DisableXpnResource::new(self.inner.clone())
    }

    /// Enable this project as a shared VPC host project.
    pub fn enable_xpn_host(&self) -> super::builder::projects::EnableXpnHost {
        super::builder::projects::EnableXpnHost::new(self.inner.clone())
    }

    /// Enable service resource (a.k.a service project) for a host project, so that
    /// subnets in the host project can be used by instances in the service
    /// project.
    pub fn enable_xpn_resource(&self) -> super::builder::projects::EnableXpnResource {
        super::builder::projects::EnableXpnResource::new(self.inner.clone())
    }

    /// Returns the specified Project resource.
    ///
    /// To decrease latency for this method, you can optionally omit any unneeded
    /// information from the response by using a field mask. This practice is
    /// especially recommended for unused quota information (the `quotas` field).
    /// To exclude one or more fields, set your request's `fields` query parameter
    /// to only include the fields you need. For example, to only include the `id`
    /// and `selfLink` fields, add the query parameter `?fields=id,selfLink` to
    /// your request.
    pub fn get(&self) -> super::builder::projects::Get {
        super::builder::projects::Get::new(self.inner.clone())
    }

    /// Gets the shared VPC host project that this project links to. May be empty
    /// if no link exists.
    pub fn get_xpn_host(&self) -> super::builder::projects::GetXpnHost {
        super::builder::projects::GetXpnHost::new(self.inner.clone())
    }

    /// Gets service resources (a.k.a service project) associated with this host
    /// project.
    pub fn get_xpn_resources(&self) -> super::builder::projects::GetXpnResources {
        super::builder::projects::GetXpnResources::new(self.inner.clone())
    }

    /// Lists all shared VPC host projects visible to the user in an organization.
    pub fn list_xpn_hosts(&self) -> super::builder::projects::ListXpnHosts {
        super::builder::projects::ListXpnHosts::new(self.inner.clone())
    }

    /// Starting September 29, 2025, you can't use the moveDisk API on new
    /// projects. To move a disk to a different region or zone, follow the steps in
    /// [Change the location of a
    /// disk](https://{$universe.dns_names.final_documentation_domain}/compute/docs/disks/migrate-to-hyperdisk#migrate-to-hd).
    ///
    /// Projects that already use the moveDisk API can continue usage until
    /// September 29, 2026.
    ///
    /// Starting November 1, 2025, API responses will include a warning message in
    /// the response body about the upcoming deprecation. You can skip the message
    /// to continue using the service without interruption.
    #[deprecated]
    pub fn move_disk(&self) -> super::builder::projects::MoveDisk {
        super::builder::projects::MoveDisk::new(self.inner.clone())
    }

    /// Moves an instance and its attached persistent disks from one zone to
    /// another.
    /// *Note*: Moving VMs or disks by using this method might
    /// cause unexpected behavior. For more information, see the [known
    /// issue](/compute/docs/troubleshooting/known-issues#moving_vms_or_disks_using_the_moveinstance_api_or_the_causes_unexpected_behavior).
    /// [Deprecated] This method is deprecated. See [moving instance across
    /// zones](/compute/docs/instances/moving-instance-across-zones) instead.
    #[deprecated]
    pub fn move_instance(&self) -> super::builder::projects::MoveInstance {
        super::builder::projects::MoveInstance::new(self.inner.clone())
    }

    /// Sets the Cloud Armor tier of the project. To set ENTERPRISE or above the
    /// billing account of the project must be subscribed to Cloud Armor
    /// Enterprise. See Subscribing
    /// to Cloud Armor Enterprise for more information.
    pub fn set_cloud_armor_tier(&self) -> super::builder::projects::SetCloudArmorTier {
        super::builder::projects::SetCloudArmorTier::new(self.inner.clone())
    }

    /// Sets metadata common to all instances within the specified project using
    /// the data included in the request.
    pub fn set_common_instance_metadata(
        &self,
    ) -> super::builder::projects::SetCommonInstanceMetadata {
        super::builder::projects::SetCommonInstanceMetadata::new(self.inner.clone())
    }

    /// Sets the default network tier of the project. The default network tier is
    /// used when an address/forwardingRule/instance is created without specifying
    /// the network tier field.
    pub fn set_default_network_tier(&self) -> super::builder::projects::SetDefaultNetworkTier {
        super::builder::projects::SetDefaultNetworkTier::new(self.inner.clone())
    }

    /// Enables the usage export feature and sets theusage export bucket
    /// where reports are stored. If you provide an empty request body using this
    /// method, the usage export feature will be disabled.
    pub fn set_usage_export_bucket(&self) -> super::builder::projects::SetUsageExportBucket {
        super::builder::projects::SetUsageExportBucket::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::projects::GetOperation {
        super::builder::projects::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::PublicAdvertisedPrefixes;
/// let client = PublicAdvertisedPrefixes::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `publicAdvertisedPrefixes` resource.
///
/// # Configuration
///
/// To configure `PublicAdvertisedPrefixes` use the `with_*` methods in the type returned
/// by [builder()][PublicAdvertisedPrefixes::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::public_advertised_prefixes::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::public_advertised_prefixes::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `PublicAdvertisedPrefixes` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `PublicAdvertisedPrefixes` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "public-advertised-prefixes")]
#[cfg_attr(docsrs, doc(cfg(feature = "public-advertised-prefixes")))]
#[derive(Clone, Debug)]
pub struct PublicAdvertisedPrefixes {
    inner: std::sync::Arc<dyn super::stub::dynamic::PublicAdvertisedPrefixes>,
}

#[cfg(feature = "public-advertised-prefixes")]
impl PublicAdvertisedPrefixes {
    /// Returns a builder for [PublicAdvertisedPrefixes].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::PublicAdvertisedPrefixes;
    /// let client = PublicAdvertisedPrefixes::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::public_advertised_prefixes::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::public_advertised_prefixes::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::PublicAdvertisedPrefixes + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::PublicAdvertisedPrefixes>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::PublicAdvertisedPrefixes> {
        super::transport::PublicAdvertisedPrefixes::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::PublicAdvertisedPrefixes> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::PublicAdvertisedPrefixes::new)
    }

    /// Announces the specified PublicAdvertisedPrefix
    pub fn announce(&self) -> super::builder::public_advertised_prefixes::Announce {
        super::builder::public_advertised_prefixes::Announce::new(self.inner.clone())
    }

    /// Deletes the specified PublicAdvertisedPrefix
    pub fn delete(&self) -> super::builder::public_advertised_prefixes::Delete {
        super::builder::public_advertised_prefixes::Delete::new(self.inner.clone())
    }

    /// Returns the specified PublicAdvertisedPrefix resource.
    pub fn get(&self) -> super::builder::public_advertised_prefixes::Get {
        super::builder::public_advertised_prefixes::Get::new(self.inner.clone())
    }

    /// Creates a PublicAdvertisedPrefix in the specified project
    /// using the parameters that are included in the request.
    pub fn insert(&self) -> super::builder::public_advertised_prefixes::Insert {
        super::builder::public_advertised_prefixes::Insert::new(self.inner.clone())
    }

    /// Lists the PublicAdvertisedPrefixes for a project.
    pub fn list(&self) -> super::builder::public_advertised_prefixes::List {
        super::builder::public_advertised_prefixes::List::new(self.inner.clone())
    }

    /// Patches the specified Router resource with the data included in the
    /// request. This method supportsPATCH
    /// semantics and usesJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::public_advertised_prefixes::Patch {
        super::builder::public_advertised_prefixes::Patch::new(self.inner.clone())
    }

    /// Withdraws the specified PublicAdvertisedPrefix
    pub fn withdraw(&self) -> super::builder::public_advertised_prefixes::Withdraw {
        super::builder::public_advertised_prefixes::Withdraw::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::public_advertised_prefixes::GetOperation {
        super::builder::public_advertised_prefixes::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::PublicDelegatedPrefixes;
/// let client = PublicDelegatedPrefixes::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `publicDelegatedPrefixes` resource.
///
/// # Configuration
///
/// To configure `PublicDelegatedPrefixes` use the `with_*` methods in the type returned
/// by [builder()][PublicDelegatedPrefixes::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::public_delegated_prefixes::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::public_delegated_prefixes::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `PublicDelegatedPrefixes` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `PublicDelegatedPrefixes` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "public-delegated-prefixes")]
#[cfg_attr(docsrs, doc(cfg(feature = "public-delegated-prefixes")))]
#[derive(Clone, Debug)]
pub struct PublicDelegatedPrefixes {
    inner: std::sync::Arc<dyn super::stub::dynamic::PublicDelegatedPrefixes>,
}

#[cfg(feature = "public-delegated-prefixes")]
impl PublicDelegatedPrefixes {
    /// Returns a builder for [PublicDelegatedPrefixes].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::PublicDelegatedPrefixes;
    /// let client = PublicDelegatedPrefixes::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::public_delegated_prefixes::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::public_delegated_prefixes::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::PublicDelegatedPrefixes + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::PublicDelegatedPrefixes>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::PublicDelegatedPrefixes> {
        super::transport::PublicDelegatedPrefixes::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::PublicDelegatedPrefixes> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::PublicDelegatedPrefixes::new)
    }

    /// Lists all PublicDelegatedPrefix resources owned by the specific project
    /// across all scopes.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::public_delegated_prefixes::AggregatedList {
        super::builder::public_delegated_prefixes::AggregatedList::new(self.inner.clone())
    }

    /// Announces the specified PublicDelegatedPrefix in the given region.
    pub fn announce(&self) -> super::builder::public_delegated_prefixes::Announce {
        super::builder::public_delegated_prefixes::Announce::new(self.inner.clone())
    }

    /// Deletes the specified PublicDelegatedPrefix in the given region.
    pub fn delete(&self) -> super::builder::public_delegated_prefixes::Delete {
        super::builder::public_delegated_prefixes::Delete::new(self.inner.clone())
    }

    /// Returns the specified PublicDelegatedPrefix resource in the given region.
    pub fn get(&self) -> super::builder::public_delegated_prefixes::Get {
        super::builder::public_delegated_prefixes::Get::new(self.inner.clone())
    }

    /// Creates a PublicDelegatedPrefix in the specified project in the given
    /// region using the parameters that are included in the request.
    pub fn insert(&self) -> super::builder::public_delegated_prefixes::Insert {
        super::builder::public_delegated_prefixes::Insert::new(self.inner.clone())
    }

    /// Lists the PublicDelegatedPrefixes for a project in the given region.
    pub fn list(&self) -> super::builder::public_delegated_prefixes::List {
        super::builder::public_delegated_prefixes::List::new(self.inner.clone())
    }

    /// Patches the specified PublicDelegatedPrefix resource with the data included
    /// in the request. This method supportsPATCH
    /// semantics and usesJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::public_delegated_prefixes::Patch {
        super::builder::public_delegated_prefixes::Patch::new(self.inner.clone())
    }

    /// Withdraws the specified PublicDelegatedPrefix in the given region.
    pub fn withdraw(&self) -> super::builder::public_delegated_prefixes::Withdraw {
        super::builder::public_delegated_prefixes::Withdraw::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::public_delegated_prefixes::GetOperation {
        super::builder::public_delegated_prefixes::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionAutoscalers;
/// let client = RegionAutoscalers::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionAutoscalers` resource.
///
/// # Configuration
///
/// To configure `RegionAutoscalers` use the `with_*` methods in the type returned
/// by [builder()][RegionAutoscalers::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_autoscalers::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_autoscalers::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionAutoscalers` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionAutoscalers` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-autoscalers")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-autoscalers")))]
#[derive(Clone, Debug)]
pub struct RegionAutoscalers {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionAutoscalers>,
}

#[cfg(feature = "region-autoscalers")]
impl RegionAutoscalers {
    /// Returns a builder for [RegionAutoscalers].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionAutoscalers;
    /// let client = RegionAutoscalers::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_autoscalers::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_autoscalers::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionAutoscalers + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::RegionAutoscalers>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionAutoscalers> {
        super::transport::RegionAutoscalers::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionAutoscalers> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionAutoscalers::new)
    }

    /// Deletes the specified autoscaler.
    pub fn delete(&self) -> super::builder::region_autoscalers::Delete {
        super::builder::region_autoscalers::Delete::new(self.inner.clone())
    }

    /// Returns the specified autoscaler.
    pub fn get(&self) -> super::builder::region_autoscalers::Get {
        super::builder::region_autoscalers::Get::new(self.inner.clone())
    }

    /// Creates an autoscaler in the specified project using
    /// the data included in the request.
    pub fn insert(&self) -> super::builder::region_autoscalers::Insert {
        super::builder::region_autoscalers::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of autoscalers contained within
    /// the specified region.
    pub fn list(&self) -> super::builder::region_autoscalers::List {
        super::builder::region_autoscalers::List::new(self.inner.clone())
    }

    /// Updates an autoscaler in the specified project using
    /// the data included in the request. This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::region_autoscalers::Patch {
        super::builder::region_autoscalers::Patch::new(self.inner.clone())
    }

    /// Updates an autoscaler in the specified project using
    /// the data included in the request.
    pub fn update(&self) -> super::builder::region_autoscalers::Update {
        super::builder::region_autoscalers::Update::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_autoscalers::GetOperation {
        super::builder::region_autoscalers::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionBackendServices;
/// let client = RegionBackendServices::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionBackendServices` resource.
///
/// # Configuration
///
/// To configure `RegionBackendServices` use the `with_*` methods in the type returned
/// by [builder()][RegionBackendServices::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_backend_services::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_backend_services::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionBackendServices` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionBackendServices` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-backend-services")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-backend-services")))]
#[derive(Clone, Debug)]
pub struct RegionBackendServices {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionBackendServices>,
}

#[cfg(feature = "region-backend-services")]
impl RegionBackendServices {
    /// Returns a builder for [RegionBackendServices].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionBackendServices;
    /// let client = RegionBackendServices::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_backend_services::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_backend_services::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionBackendServices + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::RegionBackendServices>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionBackendServices> {
        super::transport::RegionBackendServices::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionBackendServices> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionBackendServices::new)
    }

    /// Deletes the specified regional BackendService resource.
    pub fn delete(&self) -> super::builder::region_backend_services::Delete {
        super::builder::region_backend_services::Delete::new(self.inner.clone())
    }

    /// Returns the specified regional BackendService resource.
    pub fn get(&self) -> super::builder::region_backend_services::Get {
        super::builder::region_backend_services::Get::new(self.inner.clone())
    }

    /// Gets the most recent health check results for this
    /// regional BackendService.
    pub fn get_health(&self) -> super::builder::region_backend_services::GetHealth {
        super::builder::region_backend_services::GetHealth::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::region_backend_services::GetIamPolicy {
        super::builder::region_backend_services::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates a regional BackendService resource in the specified project using
    /// the data included in the request. For more information, see
    /// Backend services overview.
    pub fn insert(&self) -> super::builder::region_backend_services::Insert {
        super::builder::region_backend_services::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of regional BackendService resources available to the
    /// specified project in the given region.
    pub fn list(&self) -> super::builder::region_backend_services::List {
        super::builder::region_backend_services::List::new(self.inner.clone())
    }

    /// Retrieves a list of all usable backend services in the specified project in
    /// the given region.
    pub fn list_usable(&self) -> super::builder::region_backend_services::ListUsable {
        super::builder::region_backend_services::ListUsable::new(self.inner.clone())
    }

    /// Updates the specified regional BackendService resource with the data
    /// included in the request. For more information, see
    /// Understanding backend services This method
    /// supports PATCH semantics and uses the JSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::region_backend_services::Patch {
        super::builder::region_backend_services::Patch::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::region_backend_services::SetIamPolicy {
        super::builder::region_backend_services::SetIamPolicy::new(self.inner.clone())
    }

    /// Sets the Google Cloud Armor security policy for the specified backend
    /// service. For more information, seeGoogle
    /// Cloud Armor Overview
    pub fn set_security_policy(
        &self,
    ) -> super::builder::region_backend_services::SetSecurityPolicy {
        super::builder::region_backend_services::SetSecurityPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(
        &self,
    ) -> super::builder::region_backend_services::TestIamPermissions {
        super::builder::region_backend_services::TestIamPermissions::new(self.inner.clone())
    }

    /// Updates the specified regional BackendService resource with the data
    /// included in the request. For more information,
    /// see
    /// Backend services overview.
    pub fn update(&self) -> super::builder::region_backend_services::Update {
        super::builder::region_backend_services::Update::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_backend_services::GetOperation {
        super::builder::region_backend_services::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionCommitments;
/// let client = RegionCommitments::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionCommitments` resource.
///
/// # Configuration
///
/// To configure `RegionCommitments` use the `with_*` methods in the type returned
/// by [builder()][RegionCommitments::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_commitments::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_commitments::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionCommitments` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionCommitments` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-commitments")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-commitments")))]
#[derive(Clone, Debug)]
pub struct RegionCommitments {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionCommitments>,
}

#[cfg(feature = "region-commitments")]
impl RegionCommitments {
    /// Returns a builder for [RegionCommitments].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionCommitments;
    /// let client = RegionCommitments::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_commitments::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_commitments::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionCommitments + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::RegionCommitments>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionCommitments> {
        super::transport::RegionCommitments::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionCommitments> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionCommitments::new)
    }

    /// Retrieves an aggregated list of commitments by region.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::region_commitments::AggregatedList {
        super::builder::region_commitments::AggregatedList::new(self.inner.clone())
    }

    /// Returns the specified commitment resource.
    pub fn get(&self) -> super::builder::region_commitments::Get {
        super::builder::region_commitments::Get::new(self.inner.clone())
    }

    /// Creates a commitment in the specified project using the data
    /// included in the request.
    pub fn insert(&self) -> super::builder::region_commitments::Insert {
        super::builder::region_commitments::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of commitments contained within
    /// the specified region.
    pub fn list(&self) -> super::builder::region_commitments::List {
        super::builder::region_commitments::List::new(self.inner.clone())
    }

    /// Updates the specified commitment with the data included in the request.
    /// Update is performed only on selected fields included as part of
    /// update-mask. Only the following fields can be updated: auto_renew and plan.
    pub fn update(&self) -> super::builder::region_commitments::Update {
        super::builder::region_commitments::Update::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_commitments::GetOperation {
        super::builder::region_commitments::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionDiskTypes;
/// let client = RegionDiskTypes::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionDiskTypes` resource.
///
/// # Configuration
///
/// To configure `RegionDiskTypes` use the `with_*` methods in the type returned
/// by [builder()][RegionDiskTypes::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_disk_types::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_disk_types::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionDiskTypes` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionDiskTypes` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-disk-types")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-disk-types")))]
#[derive(Clone, Debug)]
pub struct RegionDiskTypes {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionDiskTypes>,
}

#[cfg(feature = "region-disk-types")]
impl RegionDiskTypes {
    /// Returns a builder for [RegionDiskTypes].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionDiskTypes;
    /// let client = RegionDiskTypes::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_disk_types::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_disk_types::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionDiskTypes + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::RegionDiskTypes>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionDiskTypes> {
        super::transport::RegionDiskTypes::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionDiskTypes> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionDiskTypes::new)
    }

    /// Returns the specified regional disk type.
    pub fn get(&self) -> super::builder::region_disk_types::Get {
        super::builder::region_disk_types::Get::new(self.inner.clone())
    }

    /// Retrieves a list of regional disk types available to the specified project.
    pub fn list(&self) -> super::builder::region_disk_types::List {
        super::builder::region_disk_types::List::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionDisks;
/// let client = RegionDisks::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionDisks` resource.
///
/// # Configuration
///
/// To configure `RegionDisks` use the `with_*` methods in the type returned
/// by [builder()][RegionDisks::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_disks::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_disks::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionDisks` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionDisks` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-disks")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-disks")))]
#[derive(Clone, Debug)]
pub struct RegionDisks {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionDisks>,
}

#[cfg(feature = "region-disks")]
impl RegionDisks {
    /// Returns a builder for [RegionDisks].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionDisks;
    /// let client = RegionDisks::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_disks::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::region_disks::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionDisks + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::RegionDisks>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionDisks> {
        super::transport::RegionDisks::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionDisks> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionDisks::new)
    }

    /// Adds existing resource policies to a regional disk. You can only add one
    /// policy which will be applied to this disk for scheduling snapshot
    /// creation.
    pub fn add_resource_policies(&self) -> super::builder::region_disks::AddResourcePolicies {
        super::builder::region_disks::AddResourcePolicies::new(self.inner.clone())
    }

    /// Bulk create a set of disks.
    pub fn bulk_insert(&self) -> super::builder::region_disks::BulkInsert {
        super::builder::region_disks::BulkInsert::new(self.inner.clone())
    }

    /// Creates a snapshot of a specified persistent disk. For regular snapshot
    /// creation, consider using snapshots.insert
    /// instead, as that method supports more features, such as creating snapshots
    /// in a project different from the source disk project.
    pub fn create_snapshot(&self) -> super::builder::region_disks::CreateSnapshot {
        super::builder::region_disks::CreateSnapshot::new(self.inner.clone())
    }

    /// Deletes the specified regional persistent disk. Deleting a regional disk
    /// removes all the replicas of its data permanently and is irreversible.
    /// However, deleting a disk does not delete anysnapshots
    /// previously made from the disk. You must separatelydelete
    /// snapshots.
    pub fn delete(&self) -> super::builder::region_disks::Delete {
        super::builder::region_disks::Delete::new(self.inner.clone())
    }

    /// Returns a specified regional persistent disk.
    pub fn get(&self) -> super::builder::region_disks::Get {
        super::builder::region_disks::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::region_disks::GetIamPolicy {
        super::builder::region_disks::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates a persistent regional disk in the specified project using the data
    /// included in the request.
    pub fn insert(&self) -> super::builder::region_disks::Insert {
        super::builder::region_disks::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of persistent disks contained within
    /// the specified region.
    pub fn list(&self) -> super::builder::region_disks::List {
        super::builder::region_disks::List::new(self.inner.clone())
    }

    /// Removes resource policies from a regional disk.
    pub fn remove_resource_policies(&self) -> super::builder::region_disks::RemoveResourcePolicies {
        super::builder::region_disks::RemoveResourcePolicies::new(self.inner.clone())
    }

    /// Resizes the specified regional persistent disk.
    pub fn resize(&self) -> super::builder::region_disks::Resize {
        super::builder::region_disks::Resize::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::region_disks::SetIamPolicy {
        super::builder::region_disks::SetIamPolicy::new(self.inner.clone())
    }

    /// Sets the labels on the target regional disk.
    pub fn set_labels(&self) -> super::builder::region_disks::SetLabels {
        super::builder::region_disks::SetLabels::new(self.inner.clone())
    }

    /// Starts asynchronous replication.
    /// Must be invoked on the primary disk.
    pub fn start_async_replication(&self) -> super::builder::region_disks::StartAsyncReplication {
        super::builder::region_disks::StartAsyncReplication::new(self.inner.clone())
    }

    /// Stops asynchronous replication.
    /// Can be invoked either on the primary or on the secondary disk.
    pub fn stop_async_replication(&self) -> super::builder::region_disks::StopAsyncReplication {
        super::builder::region_disks::StopAsyncReplication::new(self.inner.clone())
    }

    /// Stops asynchronous replication for a consistency group of disks.
    /// Can be invoked either in the primary or secondary scope.
    pub fn stop_group_async_replication(
        &self,
    ) -> super::builder::region_disks::StopGroupAsyncReplication {
        super::builder::region_disks::StopGroupAsyncReplication::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::region_disks::TestIamPermissions {
        super::builder::region_disks::TestIamPermissions::new(self.inner.clone())
    }

    /// Update the specified disk with the data included in the request. Update is
    /// performed only on selected fields included as part of update-mask. Only the
    /// following fields can be modified: user_license.
    pub fn update(&self) -> super::builder::region_disks::Update {
        super::builder::region_disks::Update::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_disks::GetOperation {
        super::builder::region_disks::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionHealthCheckServices;
/// let client = RegionHealthCheckServices::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionHealthCheckServices` resource.
///
/// # Configuration
///
/// To configure `RegionHealthCheckServices` use the `with_*` methods in the type returned
/// by [builder()][RegionHealthCheckServices::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_health_check_services::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_health_check_services::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionHealthCheckServices` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionHealthCheckServices` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-health-check-services")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-health-check-services")))]
#[derive(Clone, Debug)]
pub struct RegionHealthCheckServices {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionHealthCheckServices>,
}

#[cfg(feature = "region-health-check-services")]
impl RegionHealthCheckServices {
    /// Returns a builder for [RegionHealthCheckServices].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionHealthCheckServices;
    /// let client = RegionHealthCheckServices::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_health_check_services::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_health_check_services::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionHealthCheckServices + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::RegionHealthCheckServices>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionHealthCheckServices> {
        super::transport::RegionHealthCheckServices::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionHealthCheckServices> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionHealthCheckServices::new)
    }

    /// Deletes the specified regional HealthCheckService.
    pub fn delete(&self) -> super::builder::region_health_check_services::Delete {
        super::builder::region_health_check_services::Delete::new(self.inner.clone())
    }

    /// Returns the specified regional HealthCheckService resource.
    pub fn get(&self) -> super::builder::region_health_check_services::Get {
        super::builder::region_health_check_services::Get::new(self.inner.clone())
    }

    /// Creates a regional HealthCheckService resource in the
    /// specified project and region using the data included in the request.
    pub fn insert(&self) -> super::builder::region_health_check_services::Insert {
        super::builder::region_health_check_services::Insert::new(self.inner.clone())
    }

    /// Lists all the HealthCheckService resources that have been
    /// configured for the specified project in the given region.
    pub fn list(&self) -> super::builder::region_health_check_services::List {
        super::builder::region_health_check_services::List::new(self.inner.clone())
    }

    /// Updates the specified regional HealthCheckService resource
    /// with the data included in the request.  This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::region_health_check_services::Patch {
        super::builder::region_health_check_services::Patch::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_health_check_services::GetOperation {
        super::builder::region_health_check_services::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionHealthChecks;
/// let client = RegionHealthChecks::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionHealthChecks` resource.
///
/// # Configuration
///
/// To configure `RegionHealthChecks` use the `with_*` methods in the type returned
/// by [builder()][RegionHealthChecks::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_health_checks::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_health_checks::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionHealthChecks` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionHealthChecks` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-health-checks")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-health-checks")))]
#[derive(Clone, Debug)]
pub struct RegionHealthChecks {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionHealthChecks>,
}

#[cfg(feature = "region-health-checks")]
impl RegionHealthChecks {
    /// Returns a builder for [RegionHealthChecks].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionHealthChecks;
    /// let client = RegionHealthChecks::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_health_checks::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_health_checks::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionHealthChecks + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::RegionHealthChecks>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionHealthChecks> {
        super::transport::RegionHealthChecks::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionHealthChecks> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionHealthChecks::new)
    }

    /// Deletes the specified HealthCheck resource.
    pub fn delete(&self) -> super::builder::region_health_checks::Delete {
        super::builder::region_health_checks::Delete::new(self.inner.clone())
    }

    /// Returns the specified HealthCheck resource.
    pub fn get(&self) -> super::builder::region_health_checks::Get {
        super::builder::region_health_checks::Get::new(self.inner.clone())
    }

    /// Creates a HealthCheck resource in the specified project using the data
    /// included in the request.
    pub fn insert(&self) -> super::builder::region_health_checks::Insert {
        super::builder::region_health_checks::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of HealthCheck resources available to the specified
    /// project.
    pub fn list(&self) -> super::builder::region_health_checks::List {
        super::builder::region_health_checks::List::new(self.inner.clone())
    }

    /// Updates a HealthCheck resource in the specified project using the data
    /// included in the request. This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::region_health_checks::Patch {
        super::builder::region_health_checks::Patch::new(self.inner.clone())
    }

    /// Updates a HealthCheck resource in the specified project using the data
    /// included in the request.
    pub fn update(&self) -> super::builder::region_health_checks::Update {
        super::builder::region_health_checks::Update::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_health_checks::GetOperation {
        super::builder::region_health_checks::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionInstanceGroupManagers;
/// let client = RegionInstanceGroupManagers::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionInstanceGroupManagers` resource.
///
/// # Configuration
///
/// To configure `RegionInstanceGroupManagers` use the `with_*` methods in the type returned
/// by [builder()][RegionInstanceGroupManagers::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_instance_group_managers::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_instance_group_managers::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionInstanceGroupManagers` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionInstanceGroupManagers` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-instance-group-managers")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-instance-group-managers")))]
#[derive(Clone, Debug)]
pub struct RegionInstanceGroupManagers {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionInstanceGroupManagers>,
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagers {
    /// Returns a builder for [RegionInstanceGroupManagers].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionInstanceGroupManagers;
    /// let client = RegionInstanceGroupManagers::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_instance_group_managers::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_instance_group_managers::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionInstanceGroupManagers + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::RegionInstanceGroupManagers>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionInstanceGroupManagers> {
        super::transport::RegionInstanceGroupManagers::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionInstanceGroupManagers> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionInstanceGroupManagers::new)
    }

    /// Flags the specified instances to be immediately removed from the managed
    /// instance group. Abandoning an instance does not delete the
    /// instance, but it does remove the instance from any target pools that are
    /// applied by the managed instance group. This method reduces thetargetSize of the managed instance group by the
    /// number of instances that you abandon. This operation is marked asDONE when the action is scheduled even if the instances have
    /// not yet been removed from the group. You must separately verify the
    /// status of the abandoning action with thelistmanagedinstances
    /// method.
    ///
    /// If the group is part of a backend
    /// service that has enabled
    /// connection draining, it can take up to 60 seconds after the connection
    /// draining duration has elapsed before the VM instance is removed or deleted.
    ///
    /// You can specify a maximum of 1000 instances with this method per request.
    pub fn abandon_instances(
        &self,
    ) -> super::builder::region_instance_group_managers::AbandonInstances {
        super::builder::region_instance_group_managers::AbandonInstances::new(self.inner.clone())
    }

    /// Apply updates to selected instances the managed instance group.
    pub fn apply_updates_to_instances(
        &self,
    ) -> super::builder::region_instance_group_managers::ApplyUpdatesToInstances {
        super::builder::region_instance_group_managers::ApplyUpdatesToInstances::new(
            self.inner.clone(),
        )
    }

    /// Creates instances with per-instance configurations in this regional managed
    /// instance group. Instances are created using the current instance template.
    /// The create instances operation is marked DONE if
    /// the createInstances request is successful. The underlying
    /// actions take additional time. You must separately verify the status of thecreating or actions with the listmanagedinstances
    /// method.
    pub fn create_instances(
        &self,
    ) -> super::builder::region_instance_group_managers::CreateInstances {
        super::builder::region_instance_group_managers::CreateInstances::new(self.inner.clone())
    }

    /// Deletes the specified managed instance group and all of the instances
    /// in that group.
    pub fn delete(&self) -> super::builder::region_instance_group_managers::Delete {
        super::builder::region_instance_group_managers::Delete::new(self.inner.clone())
    }

    /// Flags the specified instances in the managed instance group to be
    /// immediately deleted. The instances are also removed from any target
    /// pools of which they were a member. This method reduces thetargetSize of the managed instance group by the number of
    /// instances that you delete.
    /// The deleteInstances operation is marked DONE if
    /// the deleteInstances request is successful. The underlying
    /// actions take additional time. You must separately verify the status of thedeleting action with thelistmanagedinstances
    /// method.
    ///
    /// If the group is part of a backend
    /// service that has enabled
    /// connection draining, it can take up to 60 seconds after the connection
    /// draining duration has elapsed before the VM instance is removed or deleted.
    ///
    /// You can specify a maximum of 1000 instances with this method per request.
    pub fn delete_instances(
        &self,
    ) -> super::builder::region_instance_group_managers::DeleteInstances {
        super::builder::region_instance_group_managers::DeleteInstances::new(self.inner.clone())
    }

    /// Deletes selected per-instance configurations for the managed instance
    /// group.
    pub fn delete_per_instance_configs(
        &self,
    ) -> super::builder::region_instance_group_managers::DeletePerInstanceConfigs {
        super::builder::region_instance_group_managers::DeletePerInstanceConfigs::new(
            self.inner.clone(),
        )
    }

    /// Returns all of the details about the specified managed instance group.
    pub fn get(&self) -> super::builder::region_instance_group_managers::Get {
        super::builder::region_instance_group_managers::Get::new(self.inner.clone())
    }

    /// Creates a managed instance group using the information that you specify
    /// in the request. After the group is created, instances in the group are
    /// created using the specified instance template.
    /// This operation is marked as DONE when the group is created
    /// even if the instances in the group have not yet been created. You must
    /// separately verify the status of the individual instances with thelistmanagedinstances
    /// method.
    ///
    /// A regional managed instance group can contain up to 2000 instances.
    pub fn insert(&self) -> super::builder::region_instance_group_managers::Insert {
        super::builder::region_instance_group_managers::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of managed instance groups that are contained
    /// within the specified region.
    pub fn list(&self) -> super::builder::region_instance_group_managers::List {
        super::builder::region_instance_group_managers::List::new(self.inner.clone())
    }

    /// Lists all errors thrown by actions on instances for a given regional
    /// managed instance group. The filter andorderBy query parameters are not supported.
    pub fn list_errors(&self) -> super::builder::region_instance_group_managers::ListErrors {
        super::builder::region_instance_group_managers::ListErrors::new(self.inner.clone())
    }

    /// Lists the instances in the managed instance group and instances that are
    /// scheduled to be created. The list includes any current actions
    /// that the group has scheduled for its instances. The orderBy
    /// query parameter is not supported.   The `pageToken` query parameter is
    /// supported only if the group's `listManagedInstancesResults` field is set
    /// to `PAGINATED`.
    pub fn list_managed_instances(
        &self,
    ) -> super::builder::region_instance_group_managers::ListManagedInstances {
        super::builder::region_instance_group_managers::ListManagedInstances::new(
            self.inner.clone(),
        )
    }

    /// Lists all of the per-instance configurations defined for the managed
    /// instance group. The orderBy query parameter is not supported.
    pub fn list_per_instance_configs(
        &self,
    ) -> super::builder::region_instance_group_managers::ListPerInstanceConfigs {
        super::builder::region_instance_group_managers::ListPerInstanceConfigs::new(
            self.inner.clone(),
        )
    }

    /// Updates a managed instance group using the information that you specify
    /// in the request.
    /// This operation is marked as DONE when the group is patched
    /// even if the instances in the group are still in the process of being
    /// patched. You must separately verify the status of the individual instances
    /// with the listmanagedinstances
    /// method. This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules.
    ///
    /// If you update your group to specify a new template or instance
    /// configuration, it's possible that your intended specification for each VM
    /// in the group is different from the current state of that VM. To learn how
    /// to apply an updated configuration to the VMs in a MIG, seeUpdating instances in
    /// a MIG.
    pub fn patch(&self) -> super::builder::region_instance_group_managers::Patch {
        super::builder::region_instance_group_managers::Patch::new(self.inner.clone())
    }

    /// Inserts or patches per-instance configurations for the managed instance
    /// group. perInstanceConfig.name serves as a key used to
    /// distinguish whether to perform insert or patch.
    pub fn patch_per_instance_configs(
        &self,
    ) -> super::builder::region_instance_group_managers::PatchPerInstanceConfigs {
        super::builder::region_instance_group_managers::PatchPerInstanceConfigs::new(
            self.inner.clone(),
        )
    }

    /// Flags the specified VM instances in the managed instance group to be
    /// immediately recreated. Each instance is recreated using the group's current
    /// configuration. This operation is marked as DONE when the flag
    /// is set even if the instances have not yet been recreated. You must
    /// separately verify the status of each instance by checking itscurrentAction field; for more information, see Checking
    /// the status of managed instances.
    ///
    /// If the group is part of a backend
    /// service that has enabled
    /// connection draining, it can take up to 60 seconds after the connection
    /// draining duration has elapsed before the VM instance is removed or deleted.
    ///
    /// You can specify a maximum of 1000 instances with this method per request.
    pub fn recreate_instances(
        &self,
    ) -> super::builder::region_instance_group_managers::RecreateInstances {
        super::builder::region_instance_group_managers::RecreateInstances::new(self.inner.clone())
    }

    /// Changes the intended size of the managed instance group. If you increase
    /// the size, the group creates new instances using the current instance
    /// template. If you decrease the size, the group deletes one or more
    /// instances.
    ///
    /// The resize operation is marked DONE if theresize request is successful. The underlying actions take
    /// additional time. You must separately verify the status of thecreating or deleting actions with thelistmanagedinstances
    /// method.
    ///
    /// If the group is part of a backend
    /// service that has enabled
    /// connection draining, it can take up to 60 seconds after the connection
    /// draining duration has elapsed before the VM instance is removed or deleted.
    pub fn resize(&self) -> super::builder::region_instance_group_managers::Resize {
        super::builder::region_instance_group_managers::Resize::new(self.inner.clone())
    }

    /// Flags the specified instances in the managed instance group to be
    /// resumed. This method increases thetargetSize and decreases the targetSuspendedSize
    /// of the managed instance group by the number of instances that you resume.
    /// The resumeInstances operation is marked DONE if
    /// the resumeInstances request is successful. The underlying
    /// actions take additional time. You must separately verify the status of theRESUMING action with thelistmanagedinstances
    /// method.
    ///
    /// In this request, you can only specify instances that are suspended. For
    /// example, if an instance was previously suspended using the suspendInstances
    /// method, it can be resumed using the resumeInstances method.
    ///
    /// If a health check is attached to the managed instance group, the specified
    /// instances will be verified as healthy after they are resumed.
    ///
    /// You can specify a maximum of 1000 instances with this method per request.
    pub fn resume_instances(
        &self,
    ) -> super::builder::region_instance_group_managers::ResumeInstances {
        super::builder::region_instance_group_managers::ResumeInstances::new(self.inner.clone())
    }

    /// Sets the instance template to use when creating new instances or recreating
    /// instances in this group. Existing instances are not affected.
    pub fn set_instance_template(
        &self,
    ) -> super::builder::region_instance_group_managers::SetInstanceTemplate {
        super::builder::region_instance_group_managers::SetInstanceTemplate::new(self.inner.clone())
    }

    /// Modifies the target pools to which all new instances in this group are
    /// assigned. Existing instances in the group are not affected.
    pub fn set_target_pools(
        &self,
    ) -> super::builder::region_instance_group_managers::SetTargetPools {
        super::builder::region_instance_group_managers::SetTargetPools::new(self.inner.clone())
    }

    /// Flags the specified instances in the managed instance group to be
    /// started. This method increases thetargetSize and decreases the targetStoppedSize
    /// of the managed instance group by the number of instances that you start.
    /// The startInstances operation is marked DONE if
    /// the startInstances request is successful. The underlying
    /// actions take additional time. You must separately verify the status of theSTARTING action with thelistmanagedinstances
    /// method.
    ///
    /// In this request, you can only specify instances that are stopped. For
    /// example, if an instance was previously stopped using the stopInstances
    /// method, it can be started using the startInstances method.
    ///
    /// If a health check is attached to the managed instance group, the specified
    /// instances will be verified as healthy after they are started.
    ///
    /// You can specify a maximum of 1000 instances with this method per request.
    pub fn start_instances(
        &self,
    ) -> super::builder::region_instance_group_managers::StartInstances {
        super::builder::region_instance_group_managers::StartInstances::new(self.inner.clone())
    }

    /// Flags the specified instances in the managed instance group to be
    /// immediately stopped. You can only specify instances that are running in
    /// this request. This method reduces thetargetSize and increases the targetStoppedSize
    /// of the managed instance group by the number of instances that you stop.
    /// The stopInstances operation is marked DONE if
    /// the stopInstances request is successful. The underlying
    /// actions take additional time. You must separately verify the status of theSTOPPING action with thelistmanagedinstances
    /// method.
    ///
    /// If the standbyPolicy.initialDelaySec field is set, the group
    /// delays stopping the instances until initialDelaySec have
    /// passed from instance.creationTimestamp (that is, when the
    /// instance was created). This delay gives your application time to
    /// set itself up and initialize on the instance. If more thaninitialDelaySec seconds have passed sinceinstance.creationTimestamp when this method is called, there
    /// will be zero delay.
    ///
    /// If the group is part of a backend
    /// service that has enabled
    /// connection draining, it can take up to 60 seconds after the connection
    /// draining duration has elapsed before the VM instance is stopped.
    ///
    /// Stopped instances can be started using the startInstances
    /// method.
    ///
    /// You can specify a maximum of 1000 instances with this method per request.
    pub fn stop_instances(&self) -> super::builder::region_instance_group_managers::StopInstances {
        super::builder::region_instance_group_managers::StopInstances::new(self.inner.clone())
    }

    /// Flags the specified instances in the managed instance group to be
    /// immediately suspended. You can only specify instances that are running in
    /// this request. This method reduces thetargetSize and increases the targetSuspendedSize
    /// of the managed instance group by the number of instances that you suspend.
    /// The suspendInstances operation is marked DONE if
    /// the suspendInstances request is successful. The underlying
    /// actions take additional time. You must separately verify the status of theSUSPENDING action with thelistmanagedinstances
    /// method.
    ///
    /// If the standbyPolicy.initialDelaySec field is set, the group
    /// delays suspension of the instances until initialDelaySec have
    /// passed from instance.creationTimestamp (that is, when the
    /// instance was created). This delay gives your application time to
    /// set itself up and initialize on the instance. If more thaninitialDelaySec seconds have passed sinceinstance.creationTimestamp when this method is called, there
    /// will be zero delay.
    ///
    /// If the group is part of a backend
    /// service that has enabled
    /// connection draining, it can take up to 60 seconds after the connection
    /// draining duration has elapsed before the VM instance is suspended.
    ///
    /// Suspended instances can be resumed using the resumeInstances
    /// method.
    ///
    /// You can specify a maximum of 1000 instances with this method per request.
    pub fn suspend_instances(
        &self,
    ) -> super::builder::region_instance_group_managers::SuspendInstances {
        super::builder::region_instance_group_managers::SuspendInstances::new(self.inner.clone())
    }

    /// Inserts or updates per-instance configurations for the managed instance
    /// group. perInstanceConfig.name serves as a key used to
    /// distinguish whether to perform insert or patch.
    pub fn update_per_instance_configs(
        &self,
    ) -> super::builder::region_instance_group_managers::UpdatePerInstanceConfigs {
        super::builder::region_instance_group_managers::UpdatePerInstanceConfigs::new(
            self.inner.clone(),
        )
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_instance_group_managers::GetOperation {
        super::builder::region_instance_group_managers::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionInstanceGroups;
/// let client = RegionInstanceGroups::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionInstanceGroups` resource.
///
/// # Configuration
///
/// To configure `RegionInstanceGroups` use the `with_*` methods in the type returned
/// by [builder()][RegionInstanceGroups::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_instance_groups::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_instance_groups::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionInstanceGroups` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionInstanceGroups` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-instance-groups")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-instance-groups")))]
#[derive(Clone, Debug)]
pub struct RegionInstanceGroups {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionInstanceGroups>,
}

#[cfg(feature = "region-instance-groups")]
impl RegionInstanceGroups {
    /// Returns a builder for [RegionInstanceGroups].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionInstanceGroups;
    /// let client = RegionInstanceGroups::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_instance_groups::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_instance_groups::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionInstanceGroups + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::RegionInstanceGroups>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionInstanceGroups> {
        super::transport::RegionInstanceGroups::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionInstanceGroups> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionInstanceGroups::new)
    }

    /// Returns the specified instance group resource.
    pub fn get(&self) -> super::builder::region_instance_groups::Get {
        super::builder::region_instance_groups::Get::new(self.inner.clone())
    }

    /// Retrieves the list of instance group resources contained within
    /// the specified region.
    pub fn list(&self) -> super::builder::region_instance_groups::List {
        super::builder::region_instance_groups::List::new(self.inner.clone())
    }

    /// Lists the instances in the specified instance group and displays
    /// information about the named ports. Depending on the specified options, this
    /// method can list all instances or only the instances that are running.
    /// The orderBy query parameter is not supported.
    pub fn list_instances(&self) -> super::builder::region_instance_groups::ListInstances {
        super::builder::region_instance_groups::ListInstances::new(self.inner.clone())
    }

    /// Sets the named ports for the specified regional instance group.
    pub fn set_named_ports(&self) -> super::builder::region_instance_groups::SetNamedPorts {
        super::builder::region_instance_groups::SetNamedPorts::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(
        &self,
    ) -> super::builder::region_instance_groups::TestIamPermissions {
        super::builder::region_instance_groups::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_instance_groups::GetOperation {
        super::builder::region_instance_groups::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionInstanceTemplates;
/// let client = RegionInstanceTemplates::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionInstanceTemplates` resource.
///
/// # Configuration
///
/// To configure `RegionInstanceTemplates` use the `with_*` methods in the type returned
/// by [builder()][RegionInstanceTemplates::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_instance_templates::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_instance_templates::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionInstanceTemplates` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionInstanceTemplates` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-instance-templates")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-instance-templates")))]
#[derive(Clone, Debug)]
pub struct RegionInstanceTemplates {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionInstanceTemplates>,
}

#[cfg(feature = "region-instance-templates")]
impl RegionInstanceTemplates {
    /// Returns a builder for [RegionInstanceTemplates].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionInstanceTemplates;
    /// let client = RegionInstanceTemplates::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_instance_templates::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_instance_templates::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionInstanceTemplates + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::RegionInstanceTemplates>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionInstanceTemplates> {
        super::transport::RegionInstanceTemplates::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionInstanceTemplates> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionInstanceTemplates::new)
    }

    /// Deletes the specified instance template. Deleting an instance template is
    /// permanent and cannot be undone.
    pub fn delete(&self) -> super::builder::region_instance_templates::Delete {
        super::builder::region_instance_templates::Delete::new(self.inner.clone())
    }

    /// Returns the specified instance template.
    pub fn get(&self) -> super::builder::region_instance_templates::Get {
        super::builder::region_instance_templates::Get::new(self.inner.clone())
    }

    /// Creates an instance template in the specified project and region using the
    /// global instance template whose URL is included in the request.
    pub fn insert(&self) -> super::builder::region_instance_templates::Insert {
        super::builder::region_instance_templates::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of instance templates that are contained within the
    /// specified project and region.
    pub fn list(&self) -> super::builder::region_instance_templates::List {
        super::builder::region_instance_templates::List::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_instance_templates::GetOperation {
        super::builder::region_instance_templates::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionInstances;
/// let client = RegionInstances::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionInstances` resource.
///
/// # Configuration
///
/// To configure `RegionInstances` use the `with_*` methods in the type returned
/// by [builder()][RegionInstances::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_instances::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_instances::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionInstances` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionInstances` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-instances")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-instances")))]
#[derive(Clone, Debug)]
pub struct RegionInstances {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionInstances>,
}

#[cfg(feature = "region-instances")]
impl RegionInstances {
    /// Returns a builder for [RegionInstances].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionInstances;
    /// let client = RegionInstances::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_instances::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_instances::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionInstances + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::RegionInstances>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionInstances> {
        super::transport::RegionInstances::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionInstances> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionInstances::new)
    }

    /// Creates multiple instances in a given region. Count specifies the number of
    /// instances to create.
    pub fn bulk_insert(&self) -> super::builder::region_instances::BulkInsert {
        super::builder::region_instances::BulkInsert::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_instances::GetOperation {
        super::builder::region_instances::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionInstantSnapshots;
/// let client = RegionInstantSnapshots::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionInstantSnapshots` resource.
///
/// # Configuration
///
/// To configure `RegionInstantSnapshots` use the `with_*` methods in the type returned
/// by [builder()][RegionInstantSnapshots::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_instant_snapshots::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_instant_snapshots::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionInstantSnapshots` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionInstantSnapshots` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-instant-snapshots")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-instant-snapshots")))]
#[derive(Clone, Debug)]
pub struct RegionInstantSnapshots {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionInstantSnapshots>,
}

#[cfg(feature = "region-instant-snapshots")]
impl RegionInstantSnapshots {
    /// Returns a builder for [RegionInstantSnapshots].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionInstantSnapshots;
    /// let client = RegionInstantSnapshots::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_instant_snapshots::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_instant_snapshots::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionInstantSnapshots + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::RegionInstantSnapshots>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionInstantSnapshots> {
        super::transport::RegionInstantSnapshots::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionInstantSnapshots> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionInstantSnapshots::new)
    }

    /// Deletes the specified InstantSnapshot resource. Keep in mind that deleting
    /// a single instantSnapshot might not necessarily delete all the data on that
    /// instantSnapshot. If any data on the instantSnapshot that is marked for
    /// deletion is needed for subsequent instantSnapshots, the data will be moved
    /// to the next corresponding instantSnapshot.
    ///
    /// For more information, seeDeleting
    /// instantSnapshots.
    pub fn delete(&self) -> super::builder::region_instant_snapshots::Delete {
        super::builder::region_instant_snapshots::Delete::new(self.inner.clone())
    }

    /// Returns the specified InstantSnapshot resource in the specified region.
    pub fn get(&self) -> super::builder::region_instant_snapshots::Get {
        super::builder::region_instant_snapshots::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::region_instant_snapshots::GetIamPolicy {
        super::builder::region_instant_snapshots::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates an instant snapshot in the specified region.
    pub fn insert(&self) -> super::builder::region_instant_snapshots::Insert {
        super::builder::region_instant_snapshots::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of InstantSnapshot resources contained within
    /// the specified region.
    pub fn list(&self) -> super::builder::region_instant_snapshots::List {
        super::builder::region_instant_snapshots::List::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::region_instant_snapshots::SetIamPolicy {
        super::builder::region_instant_snapshots::SetIamPolicy::new(self.inner.clone())
    }

    /// Sets the labels on a instantSnapshot in the given region. To learn more
    /// about labels, read the Labeling
    /// Resources documentation.
    pub fn set_labels(&self) -> super::builder::region_instant_snapshots::SetLabels {
        super::builder::region_instant_snapshots::SetLabels::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(
        &self,
    ) -> super::builder::region_instant_snapshots::TestIamPermissions {
        super::builder::region_instant_snapshots::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_instant_snapshots::GetOperation {
        super::builder::region_instant_snapshots::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionNetworkEndpointGroups;
/// let client = RegionNetworkEndpointGroups::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionNetworkEndpointGroups` resource.
///
/// # Configuration
///
/// To configure `RegionNetworkEndpointGroups` use the `with_*` methods in the type returned
/// by [builder()][RegionNetworkEndpointGroups::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_network_endpoint_groups::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_network_endpoint_groups::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionNetworkEndpointGroups` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionNetworkEndpointGroups` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-network-endpoint-groups")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-network-endpoint-groups")))]
#[derive(Clone, Debug)]
pub struct RegionNetworkEndpointGroups {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionNetworkEndpointGroups>,
}

#[cfg(feature = "region-network-endpoint-groups")]
impl RegionNetworkEndpointGroups {
    /// Returns a builder for [RegionNetworkEndpointGroups].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionNetworkEndpointGroups;
    /// let client = RegionNetworkEndpointGroups::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_network_endpoint_groups::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_network_endpoint_groups::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionNetworkEndpointGroups + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::RegionNetworkEndpointGroups>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionNetworkEndpointGroups> {
        super::transport::RegionNetworkEndpointGroups::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionNetworkEndpointGroups> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionNetworkEndpointGroups::new)
    }

    /// Attach a list of network endpoints to the specified network endpoint group.
    pub fn attach_network_endpoints(
        &self,
    ) -> super::builder::region_network_endpoint_groups::AttachNetworkEndpoints {
        super::builder::region_network_endpoint_groups::AttachNetworkEndpoints::new(
            self.inner.clone(),
        )
    }

    /// Deletes the specified network endpoint group. Note that the NEG cannot be
    /// deleted if it is configured as a backend of a backend service.
    pub fn delete(&self) -> super::builder::region_network_endpoint_groups::Delete {
        super::builder::region_network_endpoint_groups::Delete::new(self.inner.clone())
    }

    /// Detach the network endpoint from the specified network endpoint group.
    pub fn detach_network_endpoints(
        &self,
    ) -> super::builder::region_network_endpoint_groups::DetachNetworkEndpoints {
        super::builder::region_network_endpoint_groups::DetachNetworkEndpoints::new(
            self.inner.clone(),
        )
    }

    /// Returns the specified network endpoint group.
    pub fn get(&self) -> super::builder::region_network_endpoint_groups::Get {
        super::builder::region_network_endpoint_groups::Get::new(self.inner.clone())
    }

    /// Creates a network endpoint group in the specified project using the
    /// parameters that are included in the request.
    pub fn insert(&self) -> super::builder::region_network_endpoint_groups::Insert {
        super::builder::region_network_endpoint_groups::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of regional network endpoint groups available to the
    /// specified project in the given region.
    pub fn list(&self) -> super::builder::region_network_endpoint_groups::List {
        super::builder::region_network_endpoint_groups::List::new(self.inner.clone())
    }

    /// Lists the network endpoints in the specified network endpoint group.
    pub fn list_network_endpoints(
        &self,
    ) -> super::builder::region_network_endpoint_groups::ListNetworkEndpoints {
        super::builder::region_network_endpoint_groups::ListNetworkEndpoints::new(
            self.inner.clone(),
        )
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_network_endpoint_groups::GetOperation {
        super::builder::region_network_endpoint_groups::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionNetworkFirewallPolicies;
/// let client = RegionNetworkFirewallPolicies::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionNetworkFirewallPolicies` resource.
///
/// # Configuration
///
/// To configure `RegionNetworkFirewallPolicies` use the `with_*` methods in the type returned
/// by [builder()][RegionNetworkFirewallPolicies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_network_firewall_policies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_network_firewall_policies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionNetworkFirewallPolicies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionNetworkFirewallPolicies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-network-firewall-policies")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-network-firewall-policies")))]
#[derive(Clone, Debug)]
pub struct RegionNetworkFirewallPolicies {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionNetworkFirewallPolicies>,
}

#[cfg(feature = "region-network-firewall-policies")]
impl RegionNetworkFirewallPolicies {
    /// Returns a builder for [RegionNetworkFirewallPolicies].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionNetworkFirewallPolicies;
    /// let client = RegionNetworkFirewallPolicies::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_network_firewall_policies::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_network_firewall_policies::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionNetworkFirewallPolicies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::RegionNetworkFirewallPolicies>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionNetworkFirewallPolicies> {
        super::transport::RegionNetworkFirewallPolicies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionNetworkFirewallPolicies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionNetworkFirewallPolicies::new)
    }

    /// Inserts an association for the specified network firewall policy.
    pub fn add_association(
        &self,
    ) -> super::builder::region_network_firewall_policies::AddAssociation {
        super::builder::region_network_firewall_policies::AddAssociation::new(self.inner.clone())
    }

    /// Inserts a rule into a network firewall policy.
    pub fn add_rule(&self) -> super::builder::region_network_firewall_policies::AddRule {
        super::builder::region_network_firewall_policies::AddRule::new(self.inner.clone())
    }

    /// Copies rules to the specified network firewall policy.
    pub fn clone_rules(&self) -> super::builder::region_network_firewall_policies::CloneRules {
        super::builder::region_network_firewall_policies::CloneRules::new(self.inner.clone())
    }

    /// Deletes the specified network firewall policy.
    pub fn delete(&self) -> super::builder::region_network_firewall_policies::Delete {
        super::builder::region_network_firewall_policies::Delete::new(self.inner.clone())
    }

    /// Returns the specified network firewall policy.
    pub fn get(&self) -> super::builder::region_network_firewall_policies::Get {
        super::builder::region_network_firewall_policies::Get::new(self.inner.clone())
    }

    /// Gets an association with the specified name.
    pub fn get_association(
        &self,
    ) -> super::builder::region_network_firewall_policies::GetAssociation {
        super::builder::region_network_firewall_policies::GetAssociation::new(self.inner.clone())
    }

    /// Returns the effective firewalls on a given network.
    pub fn get_effective_firewalls(
        &self,
    ) -> super::builder::region_network_firewall_policies::GetEffectiveFirewalls {
        super::builder::region_network_firewall_policies::GetEffectiveFirewalls::new(
            self.inner.clone(),
        )
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::region_network_firewall_policies::GetIamPolicy {
        super::builder::region_network_firewall_policies::GetIamPolicy::new(self.inner.clone())
    }

    /// Gets a rule of the specified priority.
    pub fn get_rule(&self) -> super::builder::region_network_firewall_policies::GetRule {
        super::builder::region_network_firewall_policies::GetRule::new(self.inner.clone())
    }

    /// Creates a new network firewall policy in the specified project and region.
    pub fn insert(&self) -> super::builder::region_network_firewall_policies::Insert {
        super::builder::region_network_firewall_policies::Insert::new(self.inner.clone())
    }

    /// Lists all the network firewall policies that have been configured
    /// for the specified project in the given region.
    pub fn list(&self) -> super::builder::region_network_firewall_policies::List {
        super::builder::region_network_firewall_policies::List::new(self.inner.clone())
    }

    /// Patches the specified network firewall policy.
    pub fn patch(&self) -> super::builder::region_network_firewall_policies::Patch {
        super::builder::region_network_firewall_policies::Patch::new(self.inner.clone())
    }

    /// Patches a rule of the specified priority.
    pub fn patch_rule(&self) -> super::builder::region_network_firewall_policies::PatchRule {
        super::builder::region_network_firewall_policies::PatchRule::new(self.inner.clone())
    }

    /// Removes an association for the specified network firewall policy.
    pub fn remove_association(
        &self,
    ) -> super::builder::region_network_firewall_policies::RemoveAssociation {
        super::builder::region_network_firewall_policies::RemoveAssociation::new(self.inner.clone())
    }

    /// Deletes a rule of the specified priority.
    pub fn remove_rule(&self) -> super::builder::region_network_firewall_policies::RemoveRule {
        super::builder::region_network_firewall_policies::RemoveRule::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::region_network_firewall_policies::SetIamPolicy {
        super::builder::region_network_firewall_policies::SetIamPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(
        &self,
    ) -> super::builder::region_network_firewall_policies::TestIamPermissions {
        super::builder::region_network_firewall_policies::TestIamPermissions::new(
            self.inner.clone(),
        )
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_network_firewall_policies::GetOperation {
        super::builder::region_network_firewall_policies::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionNotificationEndpoints;
/// let client = RegionNotificationEndpoints::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionNotificationEndpoints` resource.
///
/// # Configuration
///
/// To configure `RegionNotificationEndpoints` use the `with_*` methods in the type returned
/// by [builder()][RegionNotificationEndpoints::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_notification_endpoints::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_notification_endpoints::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionNotificationEndpoints` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionNotificationEndpoints` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-notification-endpoints")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-notification-endpoints")))]
#[derive(Clone, Debug)]
pub struct RegionNotificationEndpoints {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionNotificationEndpoints>,
}

#[cfg(feature = "region-notification-endpoints")]
impl RegionNotificationEndpoints {
    /// Returns a builder for [RegionNotificationEndpoints].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionNotificationEndpoints;
    /// let client = RegionNotificationEndpoints::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_notification_endpoints::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_notification_endpoints::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionNotificationEndpoints + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::RegionNotificationEndpoints>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionNotificationEndpoints> {
        super::transport::RegionNotificationEndpoints::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionNotificationEndpoints> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionNotificationEndpoints::new)
    }

    /// Deletes the specified NotificationEndpoint in the given region
    pub fn delete(&self) -> super::builder::region_notification_endpoints::Delete {
        super::builder::region_notification_endpoints::Delete::new(self.inner.clone())
    }

    /// Returns the specified NotificationEndpoint resource in the given region.
    pub fn get(&self) -> super::builder::region_notification_endpoints::Get {
        super::builder::region_notification_endpoints::Get::new(self.inner.clone())
    }

    /// Create a NotificationEndpoint in the specified project in the given region
    /// using the parameters that are included in the request.
    pub fn insert(&self) -> super::builder::region_notification_endpoints::Insert {
        super::builder::region_notification_endpoints::Insert::new(self.inner.clone())
    }

    /// Lists the NotificationEndpoints for a project in the given region.
    pub fn list(&self) -> super::builder::region_notification_endpoints::List {
        super::builder::region_notification_endpoints::List::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_notification_endpoints::GetOperation {
        super::builder::region_notification_endpoints::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionOperations;
/// let client = RegionOperations::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionOperations` resource.
///
/// # Configuration
///
/// To configure `RegionOperations` use the `with_*` methods in the type returned
/// by [builder()][RegionOperations::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_operations::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_operations::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionOperations` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionOperations` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-operations")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-operations")))]
#[derive(Clone, Debug)]
pub struct RegionOperations {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionOperations>,
}

#[cfg(feature = "region-operations")]
impl RegionOperations {
    /// Returns a builder for [RegionOperations].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionOperations;
    /// let client = RegionOperations::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_operations::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_operations::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionOperations + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::RegionOperations>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionOperations> {
        super::transport::RegionOperations::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionOperations> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionOperations::new)
    }

    /// Deletes the specified region-specific Operations resource.
    pub fn delete(&self) -> super::builder::region_operations::Delete {
        super::builder::region_operations::Delete::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get(&self) -> super::builder::region_operations::Get {
        super::builder::region_operations::Get::new(self.inner.clone())
    }

    /// Retrieves a list of Operation resources contained within
    /// the specified region.
    pub fn list(&self) -> super::builder::region_operations::List {
        super::builder::region_operations::List::new(self.inner.clone())
    }

    /// Waits for the specified Operation resource to return as `DONE`
    /// or for the request to approach the 2 minute deadline, and retrieves the
    /// specified Operation resource. This method differs from the
    /// `GET` method in that it waits for no more than the default
    /// deadline (2 minutes) and then returns the current state of the operation,
    /// which might be `DONE` or still in progress.
    ///
    /// This method is called on a best-effort basis. Specifically:
    ///
    /// ```norust
    /// - In uncommon cases, when the server is overloaded, the request might
    /// return before the default deadline is reached, or might return after zero
    /// seconds.
    /// ```
    ///
    /// - If the default deadline is reached, there is no guarantee that the
    ///   operation is actually done when the method returns. Be prepared to retry
    ///   if the operation is not `DONE`.
    pub fn wait(&self) -> super::builder::region_operations::Wait {
        super::builder::region_operations::Wait::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionSecurityPolicies;
/// let client = RegionSecurityPolicies::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionSecurityPolicies` resource.
///
/// # Configuration
///
/// To configure `RegionSecurityPolicies` use the `with_*` methods in the type returned
/// by [builder()][RegionSecurityPolicies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_security_policies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_security_policies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionSecurityPolicies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionSecurityPolicies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-security-policies")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-security-policies")))]
#[derive(Clone, Debug)]
pub struct RegionSecurityPolicies {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionSecurityPolicies>,
}

#[cfg(feature = "region-security-policies")]
impl RegionSecurityPolicies {
    /// Returns a builder for [RegionSecurityPolicies].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionSecurityPolicies;
    /// let client = RegionSecurityPolicies::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_security_policies::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_security_policies::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionSecurityPolicies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::RegionSecurityPolicies>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionSecurityPolicies> {
        super::transport::RegionSecurityPolicies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionSecurityPolicies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionSecurityPolicies::new)
    }

    /// Inserts a rule into a security policy.
    pub fn add_rule(&self) -> super::builder::region_security_policies::AddRule {
        super::builder::region_security_policies::AddRule::new(self.inner.clone())
    }

    /// Deletes the specified policy.
    pub fn delete(&self) -> super::builder::region_security_policies::Delete {
        super::builder::region_security_policies::Delete::new(self.inner.clone())
    }

    /// List all of the ordered rules present in a single specified policy.
    pub fn get(&self) -> super::builder::region_security_policies::Get {
        super::builder::region_security_policies::Get::new(self.inner.clone())
    }

    /// Gets a rule at the specified priority.
    pub fn get_rule(&self) -> super::builder::region_security_policies::GetRule {
        super::builder::region_security_policies::GetRule::new(self.inner.clone())
    }

    /// Creates a new policy in the specified project using the data included in
    /// the request.
    pub fn insert(&self) -> super::builder::region_security_policies::Insert {
        super::builder::region_security_policies::Insert::new(self.inner.clone())
    }

    /// List all the policies that have been configured for the specified project
    /// and region.
    pub fn list(&self) -> super::builder::region_security_policies::List {
        super::builder::region_security_policies::List::new(self.inner.clone())
    }

    /// Patches the specified policy with the data included in the request. To
    /// clear fields in the policy, leave the fields empty and specify them in the
    /// updateMask. This cannot be used to be update the rules in the policy.
    /// Please use the per rule methods like addRule, patchRule, and removeRule
    /// instead.
    pub fn patch(&self) -> super::builder::region_security_policies::Patch {
        super::builder::region_security_policies::Patch::new(self.inner.clone())
    }

    /// Patches a rule at the specified priority. To clear fields in the rule,
    /// leave the fields empty and specify them in the updateMask.
    pub fn patch_rule(&self) -> super::builder::region_security_policies::PatchRule {
        super::builder::region_security_policies::PatchRule::new(self.inner.clone())
    }

    /// Deletes a rule at the specified priority.
    pub fn remove_rule(&self) -> super::builder::region_security_policies::RemoveRule {
        super::builder::region_security_policies::RemoveRule::new(self.inner.clone())
    }

    /// Sets the labels on a security policy. To learn more about labels,
    /// read the Labeling Resources
    /// documentation.
    pub fn set_labels(&self) -> super::builder::region_security_policies::SetLabels {
        super::builder::region_security_policies::SetLabels::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_security_policies::GetOperation {
        super::builder::region_security_policies::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionSslCertificates;
/// let client = RegionSslCertificates::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionSslCertificates` resource.
///
/// # Configuration
///
/// To configure `RegionSslCertificates` use the `with_*` methods in the type returned
/// by [builder()][RegionSslCertificates::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_ssl_certificates::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_ssl_certificates::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionSslCertificates` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionSslCertificates` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-ssl-certificates")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-ssl-certificates")))]
#[derive(Clone, Debug)]
pub struct RegionSslCertificates {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionSslCertificates>,
}

#[cfg(feature = "region-ssl-certificates")]
impl RegionSslCertificates {
    /// Returns a builder for [RegionSslCertificates].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionSslCertificates;
    /// let client = RegionSslCertificates::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_ssl_certificates::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_ssl_certificates::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionSslCertificates + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::RegionSslCertificates>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionSslCertificates> {
        super::transport::RegionSslCertificates::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionSslCertificates> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionSslCertificates::new)
    }

    /// Deletes the specified SslCertificate resource in the region.
    pub fn delete(&self) -> super::builder::region_ssl_certificates::Delete {
        super::builder::region_ssl_certificates::Delete::new(self.inner.clone())
    }

    /// Returns the specified SslCertificate resource in the specified region. Get
    /// a list of available SSL certificates by making a list()
    /// request.
    pub fn get(&self) -> super::builder::region_ssl_certificates::Get {
        super::builder::region_ssl_certificates::Get::new(self.inner.clone())
    }

    /// Creates a SslCertificate resource in the specified project and region using
    /// the data included in the request
    pub fn insert(&self) -> super::builder::region_ssl_certificates::Insert {
        super::builder::region_ssl_certificates::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of SslCertificate resources available to the specified
    /// project in the specified region.
    pub fn list(&self) -> super::builder::region_ssl_certificates::List {
        super::builder::region_ssl_certificates::List::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_ssl_certificates::GetOperation {
        super::builder::region_ssl_certificates::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionSslPolicies;
/// let client = RegionSslPolicies::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionSslPolicies` resource.
///
/// # Configuration
///
/// To configure `RegionSslPolicies` use the `with_*` methods in the type returned
/// by [builder()][RegionSslPolicies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_ssl_policies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_ssl_policies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionSslPolicies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionSslPolicies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-ssl-policies")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-ssl-policies")))]
#[derive(Clone, Debug)]
pub struct RegionSslPolicies {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionSslPolicies>,
}

#[cfg(feature = "region-ssl-policies")]
impl RegionSslPolicies {
    /// Returns a builder for [RegionSslPolicies].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionSslPolicies;
    /// let client = RegionSslPolicies::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_ssl_policies::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_ssl_policies::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionSslPolicies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::RegionSslPolicies>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionSslPolicies> {
        super::transport::RegionSslPolicies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionSslPolicies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionSslPolicies::new)
    }

    /// Deletes the specified SSL policy. The SSL policy resource can be deleted
    /// only if it is not in use by any TargetHttpsProxy or TargetSslProxy
    /// resources.
    pub fn delete(&self) -> super::builder::region_ssl_policies::Delete {
        super::builder::region_ssl_policies::Delete::new(self.inner.clone())
    }

    /// Lists all of the ordered rules present in a single specified policy.
    pub fn get(&self) -> super::builder::region_ssl_policies::Get {
        super::builder::region_ssl_policies::Get::new(self.inner.clone())
    }

    /// Creates a new policy in the specified project and region using the data
    /// included in the request.
    pub fn insert(&self) -> super::builder::region_ssl_policies::Insert {
        super::builder::region_ssl_policies::Insert::new(self.inner.clone())
    }

    /// Lists all the SSL policies that have been configured for the specified
    /// project and region.
    pub fn list(&self) -> super::builder::region_ssl_policies::List {
        super::builder::region_ssl_policies::List::new(self.inner.clone())
    }

    /// Lists all features that can be specified in the SSL policy when using
    /// custom profile.
    pub fn list_available_features(
        &self,
    ) -> super::builder::region_ssl_policies::ListAvailableFeatures {
        super::builder::region_ssl_policies::ListAvailableFeatures::new(self.inner.clone())
    }

    /// Patches the specified SSL policy with the data included in the request.
    pub fn patch(&self) -> super::builder::region_ssl_policies::Patch {
        super::builder::region_ssl_policies::Patch::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_ssl_policies::GetOperation {
        super::builder::region_ssl_policies::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionTargetHttpProxies;
/// let client = RegionTargetHttpProxies::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionTargetHttpProxies` resource.
///
/// # Configuration
///
/// To configure `RegionTargetHttpProxies` use the `with_*` methods in the type returned
/// by [builder()][RegionTargetHttpProxies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_target_http_proxies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_target_http_proxies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionTargetHttpProxies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionTargetHttpProxies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-target-http-proxies")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-target-http-proxies")))]
#[derive(Clone, Debug)]
pub struct RegionTargetHttpProxies {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionTargetHttpProxies>,
}

#[cfg(feature = "region-target-http-proxies")]
impl RegionTargetHttpProxies {
    /// Returns a builder for [RegionTargetHttpProxies].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionTargetHttpProxies;
    /// let client = RegionTargetHttpProxies::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_target_http_proxies::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_target_http_proxies::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionTargetHttpProxies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::RegionTargetHttpProxies>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionTargetHttpProxies> {
        super::transport::RegionTargetHttpProxies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionTargetHttpProxies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionTargetHttpProxies::new)
    }

    /// Deletes the specified TargetHttpProxy resource.
    pub fn delete(&self) -> super::builder::region_target_http_proxies::Delete {
        super::builder::region_target_http_proxies::Delete::new(self.inner.clone())
    }

    /// Returns the specified TargetHttpProxy resource in the specified region.
    pub fn get(&self) -> super::builder::region_target_http_proxies::Get {
        super::builder::region_target_http_proxies::Get::new(self.inner.clone())
    }

    /// Creates a TargetHttpProxy resource in the specified project and region
    /// using the data included in the request.
    pub fn insert(&self) -> super::builder::region_target_http_proxies::Insert {
        super::builder::region_target_http_proxies::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of TargetHttpProxy resources available
    /// to the specified project in the specified region.
    pub fn list(&self) -> super::builder::region_target_http_proxies::List {
        super::builder::region_target_http_proxies::List::new(self.inner.clone())
    }

    /// Changes the URL map for TargetHttpProxy.
    pub fn set_url_map(&self) -> super::builder::region_target_http_proxies::SetUrlMap {
        super::builder::region_target_http_proxies::SetUrlMap::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_target_http_proxies::GetOperation {
        super::builder::region_target_http_proxies::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionTargetHttpsProxies;
/// let client = RegionTargetHttpsProxies::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionTargetHttpsProxies` resource.
///
/// # Configuration
///
/// To configure `RegionTargetHttpsProxies` use the `with_*` methods in the type returned
/// by [builder()][RegionTargetHttpsProxies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_target_https_proxies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_target_https_proxies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionTargetHttpsProxies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionTargetHttpsProxies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-target-https-proxies")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-target-https-proxies")))]
#[derive(Clone, Debug)]
pub struct RegionTargetHttpsProxies {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionTargetHttpsProxies>,
}

#[cfg(feature = "region-target-https-proxies")]
impl RegionTargetHttpsProxies {
    /// Returns a builder for [RegionTargetHttpsProxies].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionTargetHttpsProxies;
    /// let client = RegionTargetHttpsProxies::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_target_https_proxies::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_target_https_proxies::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionTargetHttpsProxies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<
        std::sync::Arc<dyn super::stub::dynamic::RegionTargetHttpsProxies>,
    > {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionTargetHttpsProxies> {
        super::transport::RegionTargetHttpsProxies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionTargetHttpsProxies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionTargetHttpsProxies::new)
    }

    /// Deletes the specified TargetHttpsProxy resource.
    pub fn delete(&self) -> super::builder::region_target_https_proxies::Delete {
        super::builder::region_target_https_proxies::Delete::new(self.inner.clone())
    }

    /// Returns the specified TargetHttpsProxy resource in the specified region.
    pub fn get(&self) -> super::builder::region_target_https_proxies::Get {
        super::builder::region_target_https_proxies::Get::new(self.inner.clone())
    }

    /// Creates a TargetHttpsProxy resource in the specified project and region
    /// using the data included in the request.
    pub fn insert(&self) -> super::builder::region_target_https_proxies::Insert {
        super::builder::region_target_https_proxies::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of TargetHttpsProxy resources available
    /// to the specified project in the specified region.
    pub fn list(&self) -> super::builder::region_target_https_proxies::List {
        super::builder::region_target_https_proxies::List::new(self.inner.clone())
    }

    /// Patches the specified regional TargetHttpsProxy resource with the data
    /// included in the request. This method supports PATCH
    /// semantics and usesJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::region_target_https_proxies::Patch {
        super::builder::region_target_https_proxies::Patch::new(self.inner.clone())
    }

    /// Replaces SslCertificates for TargetHttpsProxy.
    pub fn set_ssl_certificates(
        &self,
    ) -> super::builder::region_target_https_proxies::SetSslCertificates {
        super::builder::region_target_https_proxies::SetSslCertificates::new(self.inner.clone())
    }

    /// Changes the URL map for TargetHttpsProxy.
    pub fn set_url_map(&self) -> super::builder::region_target_https_proxies::SetUrlMap {
        super::builder::region_target_https_proxies::SetUrlMap::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_target_https_proxies::GetOperation {
        super::builder::region_target_https_proxies::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionTargetTcpProxies;
/// let client = RegionTargetTcpProxies::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionTargetTcpProxies` resource.
///
/// # Configuration
///
/// To configure `RegionTargetTcpProxies` use the `with_*` methods in the type returned
/// by [builder()][RegionTargetTcpProxies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_target_tcp_proxies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_target_tcp_proxies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionTargetTcpProxies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionTargetTcpProxies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-target-tcp-proxies")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-target-tcp-proxies")))]
#[derive(Clone, Debug)]
pub struct RegionTargetTcpProxies {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionTargetTcpProxies>,
}

#[cfg(feature = "region-target-tcp-proxies")]
impl RegionTargetTcpProxies {
    /// Returns a builder for [RegionTargetTcpProxies].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionTargetTcpProxies;
    /// let client = RegionTargetTcpProxies::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_target_tcp_proxies::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::region_target_tcp_proxies::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionTargetTcpProxies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::RegionTargetTcpProxies>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionTargetTcpProxies> {
        super::transport::RegionTargetTcpProxies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionTargetTcpProxies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionTargetTcpProxies::new)
    }

    /// Deletes the specified TargetTcpProxy resource.
    pub fn delete(&self) -> super::builder::region_target_tcp_proxies::Delete {
        super::builder::region_target_tcp_proxies::Delete::new(self.inner.clone())
    }

    /// Returns the specified TargetTcpProxy resource.
    pub fn get(&self) -> super::builder::region_target_tcp_proxies::Get {
        super::builder::region_target_tcp_proxies::Get::new(self.inner.clone())
    }

    /// Creates a TargetTcpProxy resource in the specified project and region using
    /// the data included in the request.
    pub fn insert(&self) -> super::builder::region_target_tcp_proxies::Insert {
        super::builder::region_target_tcp_proxies::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of TargetTcpProxy resources
    /// available to the specified project in a given region.
    pub fn list(&self) -> super::builder::region_target_tcp_proxies::List {
        super::builder::region_target_tcp_proxies::List::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_target_tcp_proxies::GetOperation {
        super::builder::region_target_tcp_proxies::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionUrlMaps;
/// let client = RegionUrlMaps::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionUrlMaps` resource.
///
/// # Configuration
///
/// To configure `RegionUrlMaps` use the `with_*` methods in the type returned
/// by [builder()][RegionUrlMaps::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_url_maps::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_url_maps::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionUrlMaps` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionUrlMaps` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-url-maps")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-url-maps")))]
#[derive(Clone, Debug)]
pub struct RegionUrlMaps {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionUrlMaps>,
}

#[cfg(feature = "region-url-maps")]
impl RegionUrlMaps {
    /// Returns a builder for [RegionUrlMaps].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionUrlMaps;
    /// let client = RegionUrlMaps::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_url_maps::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::region_url_maps::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionUrlMaps + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::RegionUrlMaps>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionUrlMaps> {
        super::transport::RegionUrlMaps::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionUrlMaps> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionUrlMaps::new)
    }

    /// Deletes the specified UrlMap resource.
    pub fn delete(&self) -> super::builder::region_url_maps::Delete {
        super::builder::region_url_maps::Delete::new(self.inner.clone())
    }

    /// Returns the specified UrlMap resource.
    pub fn get(&self) -> super::builder::region_url_maps::Get {
        super::builder::region_url_maps::Get::new(self.inner.clone())
    }

    /// Creates a UrlMap resource in the specified project using
    /// the data included in the request.
    pub fn insert(&self) -> super::builder::region_url_maps::Insert {
        super::builder::region_url_maps::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of UrlMap resources available to the specified
    /// project in the specified region.
    pub fn list(&self) -> super::builder::region_url_maps::List {
        super::builder::region_url_maps::List::new(self.inner.clone())
    }

    /// Patches the specified UrlMap resource with the data included in the
    /// request. This method supportsPATCH
    /// semantics and usesJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::region_url_maps::Patch {
        super::builder::region_url_maps::Patch::new(self.inner.clone())
    }

    /// Updates the specified UrlMap resource with the data included in the
    /// request.
    pub fn update(&self) -> super::builder::region_url_maps::Update {
        super::builder::region_url_maps::Update::new(self.inner.clone())
    }

    /// Runs static validation for the UrlMap. In particular, the tests of the
    /// provided UrlMap will be run. Calling this method does NOT create the
    /// UrlMap.
    pub fn validate(&self) -> super::builder::region_url_maps::Validate {
        super::builder::region_url_maps::Validate::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::region_url_maps::GetOperation {
        super::builder::region_url_maps::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::RegionZones;
/// let client = RegionZones::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regionZones` resource.
///
/// # Configuration
///
/// To configure `RegionZones` use the `with_*` methods in the type returned
/// by [builder()][RegionZones::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::region_zones::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::region_zones::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `RegionZones` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `RegionZones` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "region-zones")]
#[cfg_attr(docsrs, doc(cfg(feature = "region-zones")))]
#[derive(Clone, Debug)]
pub struct RegionZones {
    inner: std::sync::Arc<dyn super::stub::dynamic::RegionZones>,
}

#[cfg(feature = "region-zones")]
impl RegionZones {
    /// Returns a builder for [RegionZones].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::RegionZones;
    /// let client = RegionZones::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::region_zones::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::region_zones::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::RegionZones + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::RegionZones>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionZones> {
        super::transport::RegionZones::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::RegionZones> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::RegionZones::new)
    }

    /// Retrieves the list of Zone resources under the specific region available to
    /// the specified project.
    pub fn list(&self) -> super::builder::region_zones::List {
        super::builder::region_zones::List::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::Regions;
/// let client = Regions::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `regions` resource.
///
/// # Configuration
///
/// To configure `Regions` use the `with_*` methods in the type returned
/// by [builder()][Regions::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::regions::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::regions::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Regions` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Regions` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "regions")]
#[cfg_attr(docsrs, doc(cfg(feature = "regions")))]
#[derive(Clone, Debug)]
pub struct Regions {
    inner: std::sync::Arc<dyn super::stub::dynamic::Regions>,
}

#[cfg(feature = "regions")]
impl Regions {
    /// Returns a builder for [Regions].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::Regions;
    /// let client = Regions::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::regions::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::regions::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Regions + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Regions>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Regions> {
        super::transport::Regions::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Regions> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Regions::new)
    }

    /// Returns the specified Region resource.
    ///
    /// To decrease latency for this method, you can optionally omit any unneeded
    /// information from the response by using a field mask. This practice is
    /// especially recommended for unused quota information (the `quotas` field).
    /// To exclude one or more fields, set your request's `fields` query parameter
    /// to only include the fields you need. For example, to only include the `id`
    /// and `selfLink` fields, add the query parameter `?fields=id,selfLink` to
    /// your request.
    ///
    /// This method fails if the quota information is unavailable for the region
    /// and if the organization policy constraint
    /// compute.requireBasicQuotaInResponse is enforced. This
    /// constraint, when enforced, disables the fail-open behaviour when quota
    /// information (the `items.quotas` field) is unavailable for the region.
    /// It is recommended to use the default setting
    /// for the constraint unless your application requires the fail-closed
    /// behaviour for this method.
    pub fn get(&self) -> super::builder::regions::Get {
        super::builder::regions::Get::new(self.inner.clone())
    }

    /// Retrieves the list of region resources available to the specified project.
    ///
    /// To decrease latency for this method, you can optionally omit any unneeded
    /// information from the response by using a field mask. This practice is
    /// especially recommended for unused quota information
    /// (the `items.quotas` field).
    /// To exclude one or more fields, set your request's `fields` query parameter
    /// to only include the fields you need. For example, to only include the `id`
    /// and `selfLink` fields, add the query parameter `?fields=id,selfLink` to
    /// your request.
    ///
    /// This method fails if the quota information is unavailable for the region
    /// and if the organization policy constraint
    /// compute.requireBasicQuotaInResponse is enforced. This
    /// constraint, when enforced, disables the fail-open behaviour when quota
    /// information (the `items.quotas` field) is unavailable for the region.
    /// It is recommended to use the default setting
    /// for the constraint unless your application requires the fail-closed
    /// behaviour for this method.
    pub fn list(&self) -> super::builder::regions::List {
        super::builder::regions::List::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::ReservationBlocks;
/// let client = ReservationBlocks::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `reservationBlocks` resource.
///
/// # Configuration
///
/// To configure `ReservationBlocks` use the `with_*` methods in the type returned
/// by [builder()][ReservationBlocks::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::reservation_blocks::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::reservation_blocks::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ReservationBlocks` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ReservationBlocks` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "reservation-blocks")]
#[cfg_attr(docsrs, doc(cfg(feature = "reservation-blocks")))]
#[derive(Clone, Debug)]
pub struct ReservationBlocks {
    inner: std::sync::Arc<dyn super::stub::dynamic::ReservationBlocks>,
}

#[cfg(feature = "reservation-blocks")]
impl ReservationBlocks {
    /// Returns a builder for [ReservationBlocks].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::ReservationBlocks;
    /// let client = ReservationBlocks::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::reservation_blocks::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::reservation_blocks::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ReservationBlocks + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::ReservationBlocks>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ReservationBlocks> {
        super::transport::ReservationBlocks::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ReservationBlocks> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ReservationBlocks::new)
    }

    /// Retrieves information about the specified reservation block.
    pub fn get(&self) -> super::builder::reservation_blocks::Get {
        super::builder::reservation_blocks::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::reservation_blocks::GetIamPolicy {
        super::builder::reservation_blocks::GetIamPolicy::new(self.inner.clone())
    }

    /// Retrieves a list of reservation blocks under a single reservation.
    pub fn list(&self) -> super::builder::reservation_blocks::List {
        super::builder::reservation_blocks::List::new(self.inner.clone())
    }

    /// Allows customers to perform maintenance on a reservation block
    pub fn perform_maintenance(&self) -> super::builder::reservation_blocks::PerformMaintenance {
        super::builder::reservation_blocks::PerformMaintenance::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::reservation_blocks::SetIamPolicy {
        super::builder::reservation_blocks::SetIamPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::reservation_blocks::TestIamPermissions {
        super::builder::reservation_blocks::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified zone-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::reservation_blocks::GetOperation {
        super::builder::reservation_blocks::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::ReservationSubBlocks;
/// let client = ReservationSubBlocks::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `reservationSubBlocks` resource.
///
/// # Configuration
///
/// To configure `ReservationSubBlocks` use the `with_*` methods in the type returned
/// by [builder()][ReservationSubBlocks::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::reservation_sub_blocks::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::reservation_sub_blocks::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ReservationSubBlocks` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ReservationSubBlocks` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "reservation-sub-blocks")]
#[cfg_attr(docsrs, doc(cfg(feature = "reservation-sub-blocks")))]
#[derive(Clone, Debug)]
pub struct ReservationSubBlocks {
    inner: std::sync::Arc<dyn super::stub::dynamic::ReservationSubBlocks>,
}

#[cfg(feature = "reservation-sub-blocks")]
impl ReservationSubBlocks {
    /// Returns a builder for [ReservationSubBlocks].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::ReservationSubBlocks;
    /// let client = ReservationSubBlocks::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::reservation_sub_blocks::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::reservation_sub_blocks::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ReservationSubBlocks + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::ReservationSubBlocks>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ReservationSubBlocks> {
        super::transport::ReservationSubBlocks::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ReservationSubBlocks> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ReservationSubBlocks::new)
    }

    /// Retrieves information about the specified reservation subBlock.
    pub fn get(&self) -> super::builder::reservation_sub_blocks::Get {
        super::builder::reservation_sub_blocks::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::reservation_sub_blocks::GetIamPolicy {
        super::builder::reservation_sub_blocks::GetIamPolicy::new(self.inner.clone())
    }

    /// Retrieves a list of reservation subBlocks under a single reservation.
    pub fn list(&self) -> super::builder::reservation_sub_blocks::List {
        super::builder::reservation_sub_blocks::List::new(self.inner.clone())
    }

    /// Allows customers to perform maintenance on a reservation subBlock
    pub fn perform_maintenance(
        &self,
    ) -> super::builder::reservation_sub_blocks::PerformMaintenance {
        super::builder::reservation_sub_blocks::PerformMaintenance::new(self.inner.clone())
    }

    /// Allows customers to report a faulty subBlock.
    pub fn report_faulty(&self) -> super::builder::reservation_sub_blocks::ReportFaulty {
        super::builder::reservation_sub_blocks::ReportFaulty::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::reservation_sub_blocks::SetIamPolicy {
        super::builder::reservation_sub_blocks::SetIamPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(
        &self,
    ) -> super::builder::reservation_sub_blocks::TestIamPermissions {
        super::builder::reservation_sub_blocks::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified zone-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::reservation_sub_blocks::GetOperation {
        super::builder::reservation_sub_blocks::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::Reservations;
/// let client = Reservations::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `reservations` resource.
///
/// # Configuration
///
/// To configure `Reservations` use the `with_*` methods in the type returned
/// by [builder()][Reservations::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::reservations::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::reservations::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Reservations` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Reservations` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "reservations")]
#[cfg_attr(docsrs, doc(cfg(feature = "reservations")))]
#[derive(Clone, Debug)]
pub struct Reservations {
    inner: std::sync::Arc<dyn super::stub::dynamic::Reservations>,
}

#[cfg(feature = "reservations")]
impl Reservations {
    /// Returns a builder for [Reservations].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::Reservations;
    /// let client = Reservations::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::reservations::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::reservations::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Reservations + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Reservations>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Reservations> {
        super::transport::Reservations::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Reservations> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Reservations::new)
    }

    /// Retrieves an aggregated list of reservations.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::reservations::AggregatedList {
        super::builder::reservations::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified reservation.
    pub fn delete(&self) -> super::builder::reservations::Delete {
        super::builder::reservations::Delete::new(self.inner.clone())
    }

    /// Retrieves information about the specified reservation.
    pub fn get(&self) -> super::builder::reservations::Get {
        super::builder::reservations::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::reservations::GetIamPolicy {
        super::builder::reservations::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates a new reservation. For more information, readReserving zonal
    /// resources.
    pub fn insert(&self) -> super::builder::reservations::Insert {
        super::builder::reservations::Insert::new(self.inner.clone())
    }

    /// A list of all the reservations that have been configured for the
    /// specified project in specified zone.
    pub fn list(&self) -> super::builder::reservations::List {
        super::builder::reservations::List::new(self.inner.clone())
    }

    /// Perform maintenance on an extended reservation
    pub fn perform_maintenance(&self) -> super::builder::reservations::PerformMaintenance {
        super::builder::reservations::PerformMaintenance::new(self.inner.clone())
    }

    /// Resizes the reservation (applicable to standalone reservations only). For
    /// more information, readModifying
    /// reservations.
    pub fn resize(&self) -> super::builder::reservations::Resize {
        super::builder::reservations::Resize::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::reservations::SetIamPolicy {
        super::builder::reservations::SetIamPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::reservations::TestIamPermissions {
        super::builder::reservations::TestIamPermissions::new(self.inner.clone())
    }

    /// Update share settings of the reservation.
    pub fn update(&self) -> super::builder::reservations::Update {
        super::builder::reservations::Update::new(self.inner.clone())
    }

    /// Retrieves the specified zone-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::reservations::GetOperation {
        super::builder::reservations::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::ResourcePolicies;
/// let client = ResourcePolicies::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `resourcePolicies` resource.
///
/// # Configuration
///
/// To configure `ResourcePolicies` use the `with_*` methods in the type returned
/// by [builder()][ResourcePolicies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::resource_policies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::resource_policies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ResourcePolicies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ResourcePolicies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "resource-policies")]
#[cfg_attr(docsrs, doc(cfg(feature = "resource-policies")))]
#[derive(Clone, Debug)]
pub struct ResourcePolicies {
    inner: std::sync::Arc<dyn super::stub::dynamic::ResourcePolicies>,
}

#[cfg(feature = "resource-policies")]
impl ResourcePolicies {
    /// Returns a builder for [ResourcePolicies].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::ResourcePolicies;
    /// let client = ResourcePolicies::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::resource_policies::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::resource_policies::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ResourcePolicies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::ResourcePolicies>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ResourcePolicies> {
        super::transport::ResourcePolicies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ResourcePolicies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ResourcePolicies::new)
    }

    /// Retrieves an aggregated list of resource policies.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::resource_policies::AggregatedList {
        super::builder::resource_policies::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified resource policy.
    pub fn delete(&self) -> super::builder::resource_policies::Delete {
        super::builder::resource_policies::Delete::new(self.inner.clone())
    }

    /// Retrieves all information of the specified resource policy.
    pub fn get(&self) -> super::builder::resource_policies::Get {
        super::builder::resource_policies::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::resource_policies::GetIamPolicy {
        super::builder::resource_policies::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates a new resource policy.
    pub fn insert(&self) -> super::builder::resource_policies::Insert {
        super::builder::resource_policies::Insert::new(self.inner.clone())
    }

    /// A list all the resource policies that have been configured for the
    /// specified project in specified region.
    pub fn list(&self) -> super::builder::resource_policies::List {
        super::builder::resource_policies::List::new(self.inner.clone())
    }

    /// Modify the specified resource policy.
    pub fn patch(&self) -> super::builder::resource_policies::Patch {
        super::builder::resource_policies::Patch::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::resource_policies::SetIamPolicy {
        super::builder::resource_policies::SetIamPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::resource_policies::TestIamPermissions {
        super::builder::resource_policies::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::resource_policies::GetOperation {
        super::builder::resource_policies::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::Routers;
/// let client = Routers::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `routers` resource.
///
/// # Configuration
///
/// To configure `Routers` use the `with_*` methods in the type returned
/// by [builder()][Routers::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::routers::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::routers::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Routers` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Routers` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "routers")]
#[cfg_attr(docsrs, doc(cfg(feature = "routers")))]
#[derive(Clone, Debug)]
pub struct Routers {
    inner: std::sync::Arc<dyn super::stub::dynamic::Routers>,
}

#[cfg(feature = "routers")]
impl Routers {
    /// Returns a builder for [Routers].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::Routers;
    /// let client = Routers::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::routers::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::routers::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Routers + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Routers>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Routers> {
        super::transport::Routers::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Routers> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Routers::new)
    }

    /// Retrieves an aggregated list of routers.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::routers::AggregatedList {
        super::builder::routers::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified Router resource.
    pub fn delete(&self) -> super::builder::routers::Delete {
        super::builder::routers::Delete::new(self.inner.clone())
    }

    /// Deletes Route Policy
    pub fn delete_route_policy(&self) -> super::builder::routers::DeleteRoutePolicy {
        super::builder::routers::DeleteRoutePolicy::new(self.inner.clone())
    }

    /// Returns the specified Router resource.
    pub fn get(&self) -> super::builder::routers::Get {
        super::builder::routers::Get::new(self.inner.clone())
    }

    /// Retrieves runtime NAT IP information.
    pub fn get_nat_ip_info(&self) -> super::builder::routers::GetNatIpInfo {
        super::builder::routers::GetNatIpInfo::new(self.inner.clone())
    }

    /// Retrieves runtime Nat mapping information of VM endpoints.
    pub fn get_nat_mapping_info(&self) -> super::builder::routers::GetNatMappingInfo {
        super::builder::routers::GetNatMappingInfo::new(self.inner.clone())
    }

    /// Returns specified Route Policy
    pub fn get_route_policy(&self) -> super::builder::routers::GetRoutePolicy {
        super::builder::routers::GetRoutePolicy::new(self.inner.clone())
    }

    /// Retrieves runtime information of the specified router.
    pub fn get_router_status(&self) -> super::builder::routers::GetRouterStatus {
        super::builder::routers::GetRouterStatus::new(self.inner.clone())
    }

    /// Creates a Router resource in the specified project and region using
    /// the data included in the request.
    pub fn insert(&self) -> super::builder::routers::Insert {
        super::builder::routers::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of Router resources available to the specified project.
    pub fn list(&self) -> super::builder::routers::List {
        super::builder::routers::List::new(self.inner.clone())
    }

    /// Retrieves a list of router bgp routes available to the specified project.
    pub fn list_bgp_routes(&self) -> super::builder::routers::ListBgpRoutes {
        super::builder::routers::ListBgpRoutes::new(self.inner.clone())
    }

    /// Retrieves a list of router route policy subresources available to the
    /// specified project.
    pub fn list_route_policies(&self) -> super::builder::routers::ListRoutePolicies {
        super::builder::routers::ListRoutePolicies::new(self.inner.clone())
    }

    /// Patches the specified Router resource with the data included in the
    /// request. This method supportsPATCH
    /// semantics and usesJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::routers::Patch {
        super::builder::routers::Patch::new(self.inner.clone())
    }

    /// Patches Route Policy
    pub fn patch_route_policy(&self) -> super::builder::routers::PatchRoutePolicy {
        super::builder::routers::PatchRoutePolicy::new(self.inner.clone())
    }

    /// Preview fields auto-generated during router create andupdate operations.
    /// Calling this method does NOT create or update the router.
    pub fn preview(&self) -> super::builder::routers::Preview {
        super::builder::routers::Preview::new(self.inner.clone())
    }

    /// Updates the specified Router resource with the data included in the
    /// request.  This method conforms toPUT semantics, which requests that the state of the
    /// target resource be created or replaced with the state defined by the
    /// representation enclosed in the request message payload.
    pub fn update(&self) -> super::builder::routers::Update {
        super::builder::routers::Update::new(self.inner.clone())
    }

    /// Updates or creates new Route Policy
    pub fn update_route_policy(&self) -> super::builder::routers::UpdateRoutePolicy {
        super::builder::routers::UpdateRoutePolicy::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::routers::GetOperation {
        super::builder::routers::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::Routes;
/// let client = Routes::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `routes` resource.
///
/// # Configuration
///
/// To configure `Routes` use the `with_*` methods in the type returned
/// by [builder()][Routes::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::routes::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::routes::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Routes` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Routes` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "routes")]
#[cfg_attr(docsrs, doc(cfg(feature = "routes")))]
#[derive(Clone, Debug)]
pub struct Routes {
    inner: std::sync::Arc<dyn super::stub::dynamic::Routes>,
}

#[cfg(feature = "routes")]
impl Routes {
    /// Returns a builder for [Routes].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::Routes;
    /// let client = Routes::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::routes::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::routes::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Routes + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Routes>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Routes> {
        super::transport::Routes::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Routes> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Routes::new)
    }

    /// Deletes the specified Route resource.
    pub fn delete(&self) -> super::builder::routes::Delete {
        super::builder::routes::Delete::new(self.inner.clone())
    }

    /// Returns the specified Route resource.
    pub fn get(&self) -> super::builder::routes::Get {
        super::builder::routes::Get::new(self.inner.clone())
    }

    /// Creates a Route resource in the specified project using the data included
    /// in the request.
    pub fn insert(&self) -> super::builder::routes::Insert {
        super::builder::routes::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of Route resources available to the specified project.
    pub fn list(&self) -> super::builder::routes::List {
        super::builder::routes::List::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::routes::GetOperation {
        super::builder::routes::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::SecurityPolicies;
/// let client = SecurityPolicies::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `securityPolicies` resource.
///
/// # Configuration
///
/// To configure `SecurityPolicies` use the `with_*` methods in the type returned
/// by [builder()][SecurityPolicies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::security_policies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::security_policies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `SecurityPolicies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `SecurityPolicies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "security-policies")]
#[cfg_attr(docsrs, doc(cfg(feature = "security-policies")))]
#[derive(Clone, Debug)]
pub struct SecurityPolicies {
    inner: std::sync::Arc<dyn super::stub::dynamic::SecurityPolicies>,
}

#[cfg(feature = "security-policies")]
impl SecurityPolicies {
    /// Returns a builder for [SecurityPolicies].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::SecurityPolicies;
    /// let client = SecurityPolicies::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::security_policies::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::security_policies::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::SecurityPolicies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::SecurityPolicies>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::SecurityPolicies> {
        super::transport::SecurityPolicies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::SecurityPolicies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::SecurityPolicies::new)
    }

    /// Inserts a rule into a security policy.
    pub fn add_rule(&self) -> super::builder::security_policies::AddRule {
        super::builder::security_policies::AddRule::new(self.inner.clone())
    }

    /// Retrieves the list of all SecurityPolicy resources, regional and global,
    /// available to the specified project.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::security_policies::AggregatedList {
        super::builder::security_policies::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified policy.
    pub fn delete(&self) -> super::builder::security_policies::Delete {
        super::builder::security_policies::Delete::new(self.inner.clone())
    }

    /// List all of the ordered rules present in a single specified policy.
    pub fn get(&self) -> super::builder::security_policies::Get {
        super::builder::security_policies::Get::new(self.inner.clone())
    }

    /// Gets a rule at the specified priority.
    pub fn get_rule(&self) -> super::builder::security_policies::GetRule {
        super::builder::security_policies::GetRule::new(self.inner.clone())
    }

    /// Creates a new policy in the specified project using the data included in
    /// the request.
    pub fn insert(&self) -> super::builder::security_policies::Insert {
        super::builder::security_policies::Insert::new(self.inner.clone())
    }

    /// List all the policies that have been configured for the specified project.
    pub fn list(&self) -> super::builder::security_policies::List {
        super::builder::security_policies::List::new(self.inner.clone())
    }

    /// Gets the current list of preconfigured Web Application Firewall (WAF)
    /// expressions.
    pub fn list_preconfigured_expression_sets(
        &self,
    ) -> super::builder::security_policies::ListPreconfiguredExpressionSets {
        super::builder::security_policies::ListPreconfiguredExpressionSets::new(self.inner.clone())
    }

    /// Patches the specified policy with the data included in the request. To
    /// clear fields in the policy, leave the fields empty and specify them in the
    /// updateMask. This cannot be used to be update the rules in the policy.
    /// Please use the per rule methods like addRule, patchRule, and removeRule
    /// instead.
    pub fn patch(&self) -> super::builder::security_policies::Patch {
        super::builder::security_policies::Patch::new(self.inner.clone())
    }

    /// Patches a rule at the specified priority. To clear fields in the rule,
    /// leave the fields empty and specify them in the updateMask.
    pub fn patch_rule(&self) -> super::builder::security_policies::PatchRule {
        super::builder::security_policies::PatchRule::new(self.inner.clone())
    }

    /// Deletes a rule at the specified priority.
    pub fn remove_rule(&self) -> super::builder::security_policies::RemoveRule {
        super::builder::security_policies::RemoveRule::new(self.inner.clone())
    }

    /// Sets the labels on a security policy. To learn more about labels,
    /// read the Labeling Resources
    /// documentation.
    pub fn set_labels(&self) -> super::builder::security_policies::SetLabels {
        super::builder::security_policies::SetLabels::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::security_policies::GetOperation {
        super::builder::security_policies::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::ServiceAttachments;
/// let client = ServiceAttachments::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `serviceAttachments` resource.
///
/// # Configuration
///
/// To configure `ServiceAttachments` use the `with_*` methods in the type returned
/// by [builder()][ServiceAttachments::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::service_attachments::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::service_attachments::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ServiceAttachments` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ServiceAttachments` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "service-attachments")]
#[cfg_attr(docsrs, doc(cfg(feature = "service-attachments")))]
#[derive(Clone, Debug)]
pub struct ServiceAttachments {
    inner: std::sync::Arc<dyn super::stub::dynamic::ServiceAttachments>,
}

#[cfg(feature = "service-attachments")]
impl ServiceAttachments {
    /// Returns a builder for [ServiceAttachments].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::ServiceAttachments;
    /// let client = ServiceAttachments::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::service_attachments::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::service_attachments::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ServiceAttachments + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::ServiceAttachments>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ServiceAttachments> {
        super::transport::ServiceAttachments::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ServiceAttachments> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ServiceAttachments::new)
    }

    /// Retrieves the list of all ServiceAttachment resources,
    /// regional and global, available to the specified project.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::service_attachments::AggregatedList {
        super::builder::service_attachments::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified ServiceAttachment in the given scope
    pub fn delete(&self) -> super::builder::service_attachments::Delete {
        super::builder::service_attachments::Delete::new(self.inner.clone())
    }

    /// Returns the specified ServiceAttachment resource in the given scope.
    pub fn get(&self) -> super::builder::service_attachments::Get {
        super::builder::service_attachments::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::service_attachments::GetIamPolicy {
        super::builder::service_attachments::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates a ServiceAttachment in the specified project in the given scope
    /// using the parameters that are included in the request.
    pub fn insert(&self) -> super::builder::service_attachments::Insert {
        super::builder::service_attachments::Insert::new(self.inner.clone())
    }

    /// Lists the ServiceAttachments for a project in the given scope.
    pub fn list(&self) -> super::builder::service_attachments::List {
        super::builder::service_attachments::List::new(self.inner.clone())
    }

    /// Patches the specified ServiceAttachment resource with the data included in
    /// the request. This method supports PATCH
    /// semantics and usesJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::service_attachments::Patch {
        super::builder::service_attachments::Patch::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::service_attachments::SetIamPolicy {
        super::builder::service_attachments::SetIamPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::service_attachments::TestIamPermissions {
        super::builder::service_attachments::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::service_attachments::GetOperation {
        super::builder::service_attachments::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::SnapshotSettings;
/// let client = SnapshotSettings::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `snapshotSettings` resource.
///
/// # Configuration
///
/// To configure `SnapshotSettings` use the `with_*` methods in the type returned
/// by [builder()][SnapshotSettings::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::snapshot_settings::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::snapshot_settings::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `SnapshotSettings` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `SnapshotSettings` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "snapshot-settings")]
#[cfg_attr(docsrs, doc(cfg(feature = "snapshot-settings")))]
#[derive(Clone, Debug)]
pub struct SnapshotSettings {
    inner: std::sync::Arc<dyn super::stub::dynamic::SnapshotSettings>,
}

#[cfg(feature = "snapshot-settings")]
impl SnapshotSettings {
    /// Returns a builder for [SnapshotSettings].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::SnapshotSettings;
    /// let client = SnapshotSettings::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::snapshot_settings::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::snapshot_settings::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::SnapshotSettings + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::SnapshotSettings>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::SnapshotSettings> {
        super::transport::SnapshotSettings::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::SnapshotSettings> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::SnapshotSettings::new)
    }

    /// Get snapshot settings.
    pub fn get(&self) -> super::builder::snapshot_settings::Get {
        super::builder::snapshot_settings::Get::new(self.inner.clone())
    }

    /// Patch snapshot settings.
    pub fn patch(&self) -> super::builder::snapshot_settings::Patch {
        super::builder::snapshot_settings::Patch::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::snapshot_settings::GetOperation {
        super::builder::snapshot_settings::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::Snapshots;
/// let client = Snapshots::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `snapshots` resource.
///
/// # Configuration
///
/// To configure `Snapshots` use the `with_*` methods in the type returned
/// by [builder()][Snapshots::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::snapshots::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::snapshots::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Snapshots` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Snapshots` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "snapshots")]
#[cfg_attr(docsrs, doc(cfg(feature = "snapshots")))]
#[derive(Clone, Debug)]
pub struct Snapshots {
    inner: std::sync::Arc<dyn super::stub::dynamic::Snapshots>,
}

#[cfg(feature = "snapshots")]
impl Snapshots {
    /// Returns a builder for [Snapshots].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::Snapshots;
    /// let client = Snapshots::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::snapshots::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::snapshots::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Snapshots + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Snapshots>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Snapshots> {
        super::transport::Snapshots::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Snapshots> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Snapshots::new)
    }

    /// Deletes the specified Snapshot resource. Keep in mind that deleting
    /// a single snapshot might not necessarily delete all the data on that
    /// snapshot. If any data on the snapshot that is marked for deletion is
    /// needed for subsequent snapshots, the data will be moved to the next
    /// corresponding snapshot.
    ///
    /// For more information, seeDeleting
    /// snapshots.
    pub fn delete(&self) -> super::builder::snapshots::Delete {
        super::builder::snapshots::Delete::new(self.inner.clone())
    }

    /// Returns the specified Snapshot resource.
    pub fn get(&self) -> super::builder::snapshots::Get {
        super::builder::snapshots::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::snapshots::GetIamPolicy {
        super::builder::snapshots::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates a snapshot in the specified project using the data included
    /// in the request. For regular snapshot creation, consider using this method
    /// instead of disks.createSnapshot,
    /// as this method supports more features, such as creating snapshots in a
    /// project different from the source disk project.
    pub fn insert(&self) -> super::builder::snapshots::Insert {
        super::builder::snapshots::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of Snapshot resources contained within
    /// the specified project.
    pub fn list(&self) -> super::builder::snapshots::List {
        super::builder::snapshots::List::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::snapshots::SetIamPolicy {
        super::builder::snapshots::SetIamPolicy::new(self.inner.clone())
    }

    /// Sets the labels on a snapshot. To learn more about labels, read theLabeling
    /// Resources documentation.
    pub fn set_labels(&self) -> super::builder::snapshots::SetLabels {
        super::builder::snapshots::SetLabels::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::snapshots::TestIamPermissions {
        super::builder::snapshots::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::snapshots::GetOperation {
        super::builder::snapshots::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::SslCertificates;
/// let client = SslCertificates::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `sslCertificates` resource.
///
/// # Configuration
///
/// To configure `SslCertificates` use the `with_*` methods in the type returned
/// by [builder()][SslCertificates::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::ssl_certificates::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::ssl_certificates::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `SslCertificates` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `SslCertificates` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "ssl-certificates")]
#[cfg_attr(docsrs, doc(cfg(feature = "ssl-certificates")))]
#[derive(Clone, Debug)]
pub struct SslCertificates {
    inner: std::sync::Arc<dyn super::stub::dynamic::SslCertificates>,
}

#[cfg(feature = "ssl-certificates")]
impl SslCertificates {
    /// Returns a builder for [SslCertificates].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::SslCertificates;
    /// let client = SslCertificates::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::ssl_certificates::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::ssl_certificates::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::SslCertificates + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::SslCertificates>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::SslCertificates> {
        super::transport::SslCertificates::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::SslCertificates> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::SslCertificates::new)
    }

    /// Retrieves the list of all SslCertificate resources, regional and global,
    /// available to the specified project.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::ssl_certificates::AggregatedList {
        super::builder::ssl_certificates::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified SslCertificate resource.
    pub fn delete(&self) -> super::builder::ssl_certificates::Delete {
        super::builder::ssl_certificates::Delete::new(self.inner.clone())
    }

    /// Returns the specified SslCertificate resource.
    pub fn get(&self) -> super::builder::ssl_certificates::Get {
        super::builder::ssl_certificates::Get::new(self.inner.clone())
    }

    /// Creates a SslCertificate resource in the specified project using the data
    /// included in the request.
    pub fn insert(&self) -> super::builder::ssl_certificates::Insert {
        super::builder::ssl_certificates::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of SslCertificate resources available to the specified
    /// project.
    pub fn list(&self) -> super::builder::ssl_certificates::List {
        super::builder::ssl_certificates::List::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::ssl_certificates::GetOperation {
        super::builder::ssl_certificates::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::SslPolicies;
/// let client = SslPolicies::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `sslPolicies` resource.
///
/// # Configuration
///
/// To configure `SslPolicies` use the `with_*` methods in the type returned
/// by [builder()][SslPolicies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::ssl_policies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::ssl_policies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `SslPolicies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `SslPolicies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "ssl-policies")]
#[cfg_attr(docsrs, doc(cfg(feature = "ssl-policies")))]
#[derive(Clone, Debug)]
pub struct SslPolicies {
    inner: std::sync::Arc<dyn super::stub::dynamic::SslPolicies>,
}

#[cfg(feature = "ssl-policies")]
impl SslPolicies {
    /// Returns a builder for [SslPolicies].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::SslPolicies;
    /// let client = SslPolicies::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::ssl_policies::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::ssl_policies::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::SslPolicies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::SslPolicies>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::SslPolicies> {
        super::transport::SslPolicies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::SslPolicies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::SslPolicies::new)
    }

    /// Retrieves the list of all SslPolicy resources, regional and global,
    /// available to the specified project.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::ssl_policies::AggregatedList {
        super::builder::ssl_policies::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified SSL policy. The SSL policy resource can be deleted
    /// only if it is not in use by any TargetHttpsProxy or TargetSslProxy
    /// resources.
    pub fn delete(&self) -> super::builder::ssl_policies::Delete {
        super::builder::ssl_policies::Delete::new(self.inner.clone())
    }

    /// Lists all of the ordered rules present in a single specified policy.
    pub fn get(&self) -> super::builder::ssl_policies::Get {
        super::builder::ssl_policies::Get::new(self.inner.clone())
    }

    /// Returns the specified SSL policy resource.
    pub fn insert(&self) -> super::builder::ssl_policies::Insert {
        super::builder::ssl_policies::Insert::new(self.inner.clone())
    }

    /// Lists all the SSL policies that have been configured for the specified
    /// project.
    pub fn list(&self) -> super::builder::ssl_policies::List {
        super::builder::ssl_policies::List::new(self.inner.clone())
    }

    /// Lists all features that can be specified in the SSL policy when using
    /// custom profile.
    pub fn list_available_features(&self) -> super::builder::ssl_policies::ListAvailableFeatures {
        super::builder::ssl_policies::ListAvailableFeatures::new(self.inner.clone())
    }

    /// Patches the specified SSL policy with the data included in the request.
    pub fn patch(&self) -> super::builder::ssl_policies::Patch {
        super::builder::ssl_policies::Patch::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::ssl_policies::GetOperation {
        super::builder::ssl_policies::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::StoragePoolTypes;
/// let client = StoragePoolTypes::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `storagePoolTypes` resource.
///
/// # Configuration
///
/// To configure `StoragePoolTypes` use the `with_*` methods in the type returned
/// by [builder()][StoragePoolTypes::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::storage_pool_types::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::storage_pool_types::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `StoragePoolTypes` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `StoragePoolTypes` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "storage-pool-types")]
#[cfg_attr(docsrs, doc(cfg(feature = "storage-pool-types")))]
#[derive(Clone, Debug)]
pub struct StoragePoolTypes {
    inner: std::sync::Arc<dyn super::stub::dynamic::StoragePoolTypes>,
}

#[cfg(feature = "storage-pool-types")]
impl StoragePoolTypes {
    /// Returns a builder for [StoragePoolTypes].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::StoragePoolTypes;
    /// let client = StoragePoolTypes::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::storage_pool_types::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::storage_pool_types::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::StoragePoolTypes + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::StoragePoolTypes>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::StoragePoolTypes> {
        super::transport::StoragePoolTypes::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::StoragePoolTypes> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::StoragePoolTypes::new)
    }

    /// Retrieves an aggregated list of storage pool types.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::storage_pool_types::AggregatedList {
        super::builder::storage_pool_types::AggregatedList::new(self.inner.clone())
    }

    /// Returns the specified storage pool type.
    pub fn get(&self) -> super::builder::storage_pool_types::Get {
        super::builder::storage_pool_types::Get::new(self.inner.clone())
    }

    /// Retrieves a list of storage pool types available to the specified
    /// project.
    pub fn list(&self) -> super::builder::storage_pool_types::List {
        super::builder::storage_pool_types::List::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::StoragePools;
/// let client = StoragePools::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `storagePools` resource.
///
/// # Configuration
///
/// To configure `StoragePools` use the `with_*` methods in the type returned
/// by [builder()][StoragePools::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::storage_pools::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::storage_pools::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `StoragePools` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `StoragePools` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "storage-pools")]
#[cfg_attr(docsrs, doc(cfg(feature = "storage-pools")))]
#[derive(Clone, Debug)]
pub struct StoragePools {
    inner: std::sync::Arc<dyn super::stub::dynamic::StoragePools>,
}

#[cfg(feature = "storage-pools")]
impl StoragePools {
    /// Returns a builder for [StoragePools].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::StoragePools;
    /// let client = StoragePools::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::storage_pools::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::storage_pools::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::StoragePools + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::StoragePools>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::StoragePools> {
        super::transport::StoragePools::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::StoragePools> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::StoragePools::new)
    }

    /// Retrieves an aggregated list of storage pools.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::storage_pools::AggregatedList {
        super::builder::storage_pools::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified storage pool. Deleting a storagePool
    /// removes its data permanently and is irreversible. However, deleting a
    /// storagePool does not delete any snapshots previously
    /// made from the storagePool. You must separately delete
    /// snapshots.
    pub fn delete(&self) -> super::builder::storage_pools::Delete {
        super::builder::storage_pools::Delete::new(self.inner.clone())
    }

    /// Returns a specified storage pool. Gets a list of available
    /// storage pools by making a list() request.
    pub fn get(&self) -> super::builder::storage_pools::Get {
        super::builder::storage_pools::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::storage_pools::GetIamPolicy {
        super::builder::storage_pools::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates a storage pool in the specified project using the data
    /// in the request.
    pub fn insert(&self) -> super::builder::storage_pools::Insert {
        super::builder::storage_pools::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of storage pools contained within
    /// the specified zone.
    pub fn list(&self) -> super::builder::storage_pools::List {
        super::builder::storage_pools::List::new(self.inner.clone())
    }

    /// Lists the disks in a specified storage pool.
    pub fn list_disks(&self) -> super::builder::storage_pools::ListDisks {
        super::builder::storage_pools::ListDisks::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::storage_pools::SetIamPolicy {
        super::builder::storage_pools::SetIamPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::storage_pools::TestIamPermissions {
        super::builder::storage_pools::TestIamPermissions::new(self.inner.clone())
    }

    /// Updates the specified storagePool with the data included in the request.
    /// The update is performed only on selected fields included as part
    /// of update-mask. Only the following fields can be modified:
    /// pool_provisioned_capacity_gb, pool_provisioned_iops and
    /// pool_provisioned_throughput.
    pub fn update(&self) -> super::builder::storage_pools::Update {
        super::builder::storage_pools::Update::new(self.inner.clone())
    }

    /// Retrieves the specified zone-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::storage_pools::GetOperation {
        super::builder::storage_pools::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::Subnetworks;
/// let client = Subnetworks::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `subnetworks` resource.
///
/// # Configuration
///
/// To configure `Subnetworks` use the `with_*` methods in the type returned
/// by [builder()][Subnetworks::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::subnetworks::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::subnetworks::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Subnetworks` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Subnetworks` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "subnetworks")]
#[cfg_attr(docsrs, doc(cfg(feature = "subnetworks")))]
#[derive(Clone, Debug)]
pub struct Subnetworks {
    inner: std::sync::Arc<dyn super::stub::dynamic::Subnetworks>,
}

#[cfg(feature = "subnetworks")]
impl Subnetworks {
    /// Returns a builder for [Subnetworks].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::Subnetworks;
    /// let client = Subnetworks::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::subnetworks::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::subnetworks::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Subnetworks + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Subnetworks>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Subnetworks> {
        super::transport::Subnetworks::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Subnetworks> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Subnetworks::new)
    }

    /// Retrieves an aggregated list of subnetworks.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::subnetworks::AggregatedList {
        super::builder::subnetworks::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified subnetwork.
    pub fn delete(&self) -> super::builder::subnetworks::Delete {
        super::builder::subnetworks::Delete::new(self.inner.clone())
    }

    /// Expands the IP CIDR range of the subnetwork to a specified value.
    pub fn expand_ip_cidr_range(&self) -> super::builder::subnetworks::ExpandIpCidrRange {
        super::builder::subnetworks::ExpandIpCidrRange::new(self.inner.clone())
    }

    /// Returns the specified subnetwork.
    pub fn get(&self) -> super::builder::subnetworks::Get {
        super::builder::subnetworks::Get::new(self.inner.clone())
    }

    /// Gets the access control policy for a resource. May be empty if no such
    /// policy or resource exists.
    pub fn get_iam_policy(&self) -> super::builder::subnetworks::GetIamPolicy {
        super::builder::subnetworks::GetIamPolicy::new(self.inner.clone())
    }

    /// Creates a subnetwork in the specified project using the data
    /// included in the request.
    pub fn insert(&self) -> super::builder::subnetworks::Insert {
        super::builder::subnetworks::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of subnetworks available to the specified
    /// project.
    pub fn list(&self) -> super::builder::subnetworks::List {
        super::builder::subnetworks::List::new(self.inner.clone())
    }

    /// Retrieves an aggregated list of all usable subnetworks in the project.
    pub fn list_usable(&self) -> super::builder::subnetworks::ListUsable {
        super::builder::subnetworks::ListUsable::new(self.inner.clone())
    }

    /// Patches the specified subnetwork with the data included in the request.
    /// Only certain fields can be updated with a patch request
    /// as indicated in the field descriptions.
    /// You must specify the current fingerprint of the
    /// subnetwork resource being patched.
    pub fn patch(&self) -> super::builder::subnetworks::Patch {
        super::builder::subnetworks::Patch::new(self.inner.clone())
    }

    /// Sets the access control policy on the specified resource.
    /// Replaces any existing policy.
    pub fn set_iam_policy(&self) -> super::builder::subnetworks::SetIamPolicy {
        super::builder::subnetworks::SetIamPolicy::new(self.inner.clone())
    }

    /// Set whether VMs in this subnet can access Google services without assigning
    /// external IP addresses through Private Google Access.
    pub fn set_private_ip_google_access(
        &self,
    ) -> super::builder::subnetworks::SetPrivateIpGoogleAccess {
        super::builder::subnetworks::SetPrivateIpGoogleAccess::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::subnetworks::TestIamPermissions {
        super::builder::subnetworks::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::subnetworks::GetOperation {
        super::builder::subnetworks::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::TargetGrpcProxies;
/// let client = TargetGrpcProxies::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `targetGrpcProxies` resource.
///
/// # Configuration
///
/// To configure `TargetGrpcProxies` use the `with_*` methods in the type returned
/// by [builder()][TargetGrpcProxies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::target_grpc_proxies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::target_grpc_proxies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `TargetGrpcProxies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `TargetGrpcProxies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "target-grpc-proxies")]
#[cfg_attr(docsrs, doc(cfg(feature = "target-grpc-proxies")))]
#[derive(Clone, Debug)]
pub struct TargetGrpcProxies {
    inner: std::sync::Arc<dyn super::stub::dynamic::TargetGrpcProxies>,
}

#[cfg(feature = "target-grpc-proxies")]
impl TargetGrpcProxies {
    /// Returns a builder for [TargetGrpcProxies].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::TargetGrpcProxies;
    /// let client = TargetGrpcProxies::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::target_grpc_proxies::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::target_grpc_proxies::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::TargetGrpcProxies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::TargetGrpcProxies>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::TargetGrpcProxies> {
        super::transport::TargetGrpcProxies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::TargetGrpcProxies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::TargetGrpcProxies::new)
    }

    /// Deletes the specified TargetGrpcProxy in the given scope
    pub fn delete(&self) -> super::builder::target_grpc_proxies::Delete {
        super::builder::target_grpc_proxies::Delete::new(self.inner.clone())
    }

    /// Returns the specified TargetGrpcProxy resource in the given scope.
    pub fn get(&self) -> super::builder::target_grpc_proxies::Get {
        super::builder::target_grpc_proxies::Get::new(self.inner.clone())
    }

    /// Creates a TargetGrpcProxy in the specified project in the given scope
    /// using the parameters that are included in the request.
    pub fn insert(&self) -> super::builder::target_grpc_proxies::Insert {
        super::builder::target_grpc_proxies::Insert::new(self.inner.clone())
    }

    /// Lists the TargetGrpcProxies for a project in the given scope.
    pub fn list(&self) -> super::builder::target_grpc_proxies::List {
        super::builder::target_grpc_proxies::List::new(self.inner.clone())
    }

    /// Patches the specified TargetGrpcProxy resource with the data included in
    /// the request. This method supports PATCH
    /// semantics and usesJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::target_grpc_proxies::Patch {
        super::builder::target_grpc_proxies::Patch::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::target_grpc_proxies::GetOperation {
        super::builder::target_grpc_proxies::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::TargetHttpProxies;
/// let client = TargetHttpProxies::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `targetHttpProxies` resource.
///
/// # Configuration
///
/// To configure `TargetHttpProxies` use the `with_*` methods in the type returned
/// by [builder()][TargetHttpProxies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::target_http_proxies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::target_http_proxies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `TargetHttpProxies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `TargetHttpProxies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "target-http-proxies")]
#[cfg_attr(docsrs, doc(cfg(feature = "target-http-proxies")))]
#[derive(Clone, Debug)]
pub struct TargetHttpProxies {
    inner: std::sync::Arc<dyn super::stub::dynamic::TargetHttpProxies>,
}

#[cfg(feature = "target-http-proxies")]
impl TargetHttpProxies {
    /// Returns a builder for [TargetHttpProxies].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::TargetHttpProxies;
    /// let client = TargetHttpProxies::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::target_http_proxies::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::target_http_proxies::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::TargetHttpProxies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::TargetHttpProxies>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::TargetHttpProxies> {
        super::transport::TargetHttpProxies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::TargetHttpProxies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::TargetHttpProxies::new)
    }

    /// Retrieves the list of all TargetHttpProxy resources, regional and global,
    /// available to the specified project.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::target_http_proxies::AggregatedList {
        super::builder::target_http_proxies::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified TargetHttpProxy resource.
    pub fn delete(&self) -> super::builder::target_http_proxies::Delete {
        super::builder::target_http_proxies::Delete::new(self.inner.clone())
    }

    /// Returns the specified TargetHttpProxy resource.
    pub fn get(&self) -> super::builder::target_http_proxies::Get {
        super::builder::target_http_proxies::Get::new(self.inner.clone())
    }

    /// Creates a TargetHttpProxy resource in the specified
    /// project using the data included in the request.
    pub fn insert(&self) -> super::builder::target_http_proxies::Insert {
        super::builder::target_http_proxies::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of TargetHttpProxy resources available
    /// to the specified project.
    pub fn list(&self) -> super::builder::target_http_proxies::List {
        super::builder::target_http_proxies::List::new(self.inner.clone())
    }

    /// Patches the specified TargetHttpProxy resource with the data included in
    /// the request. This method supports PATCH
    /// semantics and usesJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::target_http_proxies::Patch {
        super::builder::target_http_proxies::Patch::new(self.inner.clone())
    }

    /// Changes the URL map for TargetHttpProxy.
    pub fn set_url_map(&self) -> super::builder::target_http_proxies::SetUrlMap {
        super::builder::target_http_proxies::SetUrlMap::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::target_http_proxies::GetOperation {
        super::builder::target_http_proxies::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::TargetHttpsProxies;
/// let client = TargetHttpsProxies::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `targetHttpsProxies` resource.
///
/// # Configuration
///
/// To configure `TargetHttpsProxies` use the `with_*` methods in the type returned
/// by [builder()][TargetHttpsProxies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::target_https_proxies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::target_https_proxies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `TargetHttpsProxies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `TargetHttpsProxies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "target-https-proxies")]
#[cfg_attr(docsrs, doc(cfg(feature = "target-https-proxies")))]
#[derive(Clone, Debug)]
pub struct TargetHttpsProxies {
    inner: std::sync::Arc<dyn super::stub::dynamic::TargetHttpsProxies>,
}

#[cfg(feature = "target-https-proxies")]
impl TargetHttpsProxies {
    /// Returns a builder for [TargetHttpsProxies].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::TargetHttpsProxies;
    /// let client = TargetHttpsProxies::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::target_https_proxies::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::target_https_proxies::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::TargetHttpsProxies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::TargetHttpsProxies>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::TargetHttpsProxies> {
        super::transport::TargetHttpsProxies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::TargetHttpsProxies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::TargetHttpsProxies::new)
    }

    /// Retrieves the list of all TargetHttpsProxy resources, regional and global,
    /// available to the specified project.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::target_https_proxies::AggregatedList {
        super::builder::target_https_proxies::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified TargetHttpsProxy resource.
    pub fn delete(&self) -> super::builder::target_https_proxies::Delete {
        super::builder::target_https_proxies::Delete::new(self.inner.clone())
    }

    /// Returns the specified TargetHttpsProxy resource.
    pub fn get(&self) -> super::builder::target_https_proxies::Get {
        super::builder::target_https_proxies::Get::new(self.inner.clone())
    }

    /// Creates a TargetHttpsProxy resource in the specified
    /// project using the data included in the request.
    pub fn insert(&self) -> super::builder::target_https_proxies::Insert {
        super::builder::target_https_proxies::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of TargetHttpsProxy resources
    /// available to the specified project.
    pub fn list(&self) -> super::builder::target_https_proxies::List {
        super::builder::target_https_proxies::List::new(self.inner.clone())
    }

    /// Patches the specified TargetHttpsProxy resource with the data included in
    /// the request. This method supports PATCH
    /// semantics and usesJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::target_https_proxies::Patch {
        super::builder::target_https_proxies::Patch::new(self.inner.clone())
    }

    /// Changes the Certificate Map for TargetHttpsProxy.
    pub fn set_certificate_map(&self) -> super::builder::target_https_proxies::SetCertificateMap {
        super::builder::target_https_proxies::SetCertificateMap::new(self.inner.clone())
    }

    /// Sets the QUIC override policy for TargetHttpsProxy.
    pub fn set_quic_override(&self) -> super::builder::target_https_proxies::SetQuicOverride {
        super::builder::target_https_proxies::SetQuicOverride::new(self.inner.clone())
    }

    /// Replaces SslCertificates for TargetHttpsProxy.
    pub fn set_ssl_certificates(&self) -> super::builder::target_https_proxies::SetSslCertificates {
        super::builder::target_https_proxies::SetSslCertificates::new(self.inner.clone())
    }

    /// Sets the SSL policy for TargetHttpsProxy. The SSL policy specifies the
    /// server-side support for SSL features. This affects connections between
    /// clients and the HTTPS proxy load balancer. They do not affect the
    /// connection between the load balancer and the backends.
    pub fn set_ssl_policy(&self) -> super::builder::target_https_proxies::SetSslPolicy {
        super::builder::target_https_proxies::SetSslPolicy::new(self.inner.clone())
    }

    /// Changes the URL map for TargetHttpsProxy.
    pub fn set_url_map(&self) -> super::builder::target_https_proxies::SetUrlMap {
        super::builder::target_https_proxies::SetUrlMap::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::target_https_proxies::GetOperation {
        super::builder::target_https_proxies::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::TargetInstances;
/// let client = TargetInstances::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `targetInstances` resource.
///
/// # Configuration
///
/// To configure `TargetInstances` use the `with_*` methods in the type returned
/// by [builder()][TargetInstances::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::target_instances::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::target_instances::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `TargetInstances` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `TargetInstances` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "target-instances")]
#[cfg_attr(docsrs, doc(cfg(feature = "target-instances")))]
#[derive(Clone, Debug)]
pub struct TargetInstances {
    inner: std::sync::Arc<dyn super::stub::dynamic::TargetInstances>,
}

#[cfg(feature = "target-instances")]
impl TargetInstances {
    /// Returns a builder for [TargetInstances].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::TargetInstances;
    /// let client = TargetInstances::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::target_instances::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::target_instances::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::TargetInstances + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::TargetInstances>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::TargetInstances> {
        super::transport::TargetInstances::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::TargetInstances> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::TargetInstances::new)
    }

    /// Retrieves an aggregated list of target instances.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::target_instances::AggregatedList {
        super::builder::target_instances::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified TargetInstance resource.
    pub fn delete(&self) -> super::builder::target_instances::Delete {
        super::builder::target_instances::Delete::new(self.inner.clone())
    }

    /// Returns the specified TargetInstance resource.
    pub fn get(&self) -> super::builder::target_instances::Get {
        super::builder::target_instances::Get::new(self.inner.clone())
    }

    /// Creates a TargetInstance resource in the specified project and zone using
    /// the data included in the request.
    pub fn insert(&self) -> super::builder::target_instances::Insert {
        super::builder::target_instances::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of TargetInstance resources available to the specified
    /// project and zone.
    pub fn list(&self) -> super::builder::target_instances::List {
        super::builder::target_instances::List::new(self.inner.clone())
    }

    /// Sets the Google Cloud Armor security policy for the specified target
    /// instance. For more information, seeGoogle
    /// Cloud Armor Overview
    pub fn set_security_policy(&self) -> super::builder::target_instances::SetSecurityPolicy {
        super::builder::target_instances::SetSecurityPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::target_instances::TestIamPermissions {
        super::builder::target_instances::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified zone-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::target_instances::GetOperation {
        super::builder::target_instances::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::TargetPools;
/// let client = TargetPools::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `targetPools` resource.
///
/// # Configuration
///
/// To configure `TargetPools` use the `with_*` methods in the type returned
/// by [builder()][TargetPools::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::target_pools::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::target_pools::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `TargetPools` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `TargetPools` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "target-pools")]
#[cfg_attr(docsrs, doc(cfg(feature = "target-pools")))]
#[derive(Clone, Debug)]
pub struct TargetPools {
    inner: std::sync::Arc<dyn super::stub::dynamic::TargetPools>,
}

#[cfg(feature = "target-pools")]
impl TargetPools {
    /// Returns a builder for [TargetPools].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::TargetPools;
    /// let client = TargetPools::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::target_pools::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::target_pools::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::TargetPools + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::TargetPools>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::TargetPools> {
        super::transport::TargetPools::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::TargetPools> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::TargetPools::new)
    }

    /// Adds health check URLs to a target pool.
    pub fn add_health_check(&self) -> super::builder::target_pools::AddHealthCheck {
        super::builder::target_pools::AddHealthCheck::new(self.inner.clone())
    }

    /// Adds an instance to a target pool.
    pub fn add_instance(&self) -> super::builder::target_pools::AddInstance {
        super::builder::target_pools::AddInstance::new(self.inner.clone())
    }

    /// Retrieves an aggregated list of target pools.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::target_pools::AggregatedList {
        super::builder::target_pools::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified target pool.
    pub fn delete(&self) -> super::builder::target_pools::Delete {
        super::builder::target_pools::Delete::new(self.inner.clone())
    }

    /// Returns the specified target pool.
    pub fn get(&self) -> super::builder::target_pools::Get {
        super::builder::target_pools::Get::new(self.inner.clone())
    }

    /// Gets the most recent health check results for each IP for the
    /// instance that is referenced by the given target pool.
    pub fn get_health(&self) -> super::builder::target_pools::GetHealth {
        super::builder::target_pools::GetHealth::new(self.inner.clone())
    }

    /// Creates a target pool in the specified project and region using
    /// the data included in the request.
    pub fn insert(&self) -> super::builder::target_pools::Insert {
        super::builder::target_pools::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of target pools available to the specified
    /// project and region.
    pub fn list(&self) -> super::builder::target_pools::List {
        super::builder::target_pools::List::new(self.inner.clone())
    }

    /// Removes health check URL from a target pool.
    pub fn remove_health_check(&self) -> super::builder::target_pools::RemoveHealthCheck {
        super::builder::target_pools::RemoveHealthCheck::new(self.inner.clone())
    }

    /// Removes instance URL from a target pool.
    pub fn remove_instance(&self) -> super::builder::target_pools::RemoveInstance {
        super::builder::target_pools::RemoveInstance::new(self.inner.clone())
    }

    /// Changes a backup target pool's configurations.
    pub fn set_backup(&self) -> super::builder::target_pools::SetBackup {
        super::builder::target_pools::SetBackup::new(self.inner.clone())
    }

    /// Sets the Google Cloud Armor security policy for the specified target pool.
    /// For more information, seeGoogle
    /// Cloud Armor Overview
    pub fn set_security_policy(&self) -> super::builder::target_pools::SetSecurityPolicy {
        super::builder::target_pools::SetSecurityPolicy::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::target_pools::TestIamPermissions {
        super::builder::target_pools::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::target_pools::GetOperation {
        super::builder::target_pools::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::TargetSslProxies;
/// let client = TargetSslProxies::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `targetSslProxies` resource.
///
/// # Configuration
///
/// To configure `TargetSslProxies` use the `with_*` methods in the type returned
/// by [builder()][TargetSslProxies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::target_ssl_proxies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::target_ssl_proxies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `TargetSslProxies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `TargetSslProxies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "target-ssl-proxies")]
#[cfg_attr(docsrs, doc(cfg(feature = "target-ssl-proxies")))]
#[derive(Clone, Debug)]
pub struct TargetSslProxies {
    inner: std::sync::Arc<dyn super::stub::dynamic::TargetSslProxies>,
}

#[cfg(feature = "target-ssl-proxies")]
impl TargetSslProxies {
    /// Returns a builder for [TargetSslProxies].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::TargetSslProxies;
    /// let client = TargetSslProxies::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::target_ssl_proxies::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::target_ssl_proxies::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::TargetSslProxies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::TargetSslProxies>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::TargetSslProxies> {
        super::transport::TargetSslProxies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::TargetSslProxies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::TargetSslProxies::new)
    }

    /// Deletes the specified TargetSslProxy resource.
    pub fn delete(&self) -> super::builder::target_ssl_proxies::Delete {
        super::builder::target_ssl_proxies::Delete::new(self.inner.clone())
    }

    /// Returns the specified TargetSslProxy resource.
    pub fn get(&self) -> super::builder::target_ssl_proxies::Get {
        super::builder::target_ssl_proxies::Get::new(self.inner.clone())
    }

    /// Creates a TargetSslProxy resource in the specified project using
    /// the data included in the request.
    pub fn insert(&self) -> super::builder::target_ssl_proxies::Insert {
        super::builder::target_ssl_proxies::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of TargetSslProxy resources
    /// available to the specified project.
    pub fn list(&self) -> super::builder::target_ssl_proxies::List {
        super::builder::target_ssl_proxies::List::new(self.inner.clone())
    }

    /// Changes the BackendService for TargetSslProxy.
    pub fn set_backend_service(&self) -> super::builder::target_ssl_proxies::SetBackendService {
        super::builder::target_ssl_proxies::SetBackendService::new(self.inner.clone())
    }

    /// Changes the Certificate Map for TargetSslProxy.
    pub fn set_certificate_map(&self) -> super::builder::target_ssl_proxies::SetCertificateMap {
        super::builder::target_ssl_proxies::SetCertificateMap::new(self.inner.clone())
    }

    /// Changes the ProxyHeaderType for TargetSslProxy.
    pub fn set_proxy_header(&self) -> super::builder::target_ssl_proxies::SetProxyHeader {
        super::builder::target_ssl_proxies::SetProxyHeader::new(self.inner.clone())
    }

    /// Changes SslCertificates for TargetSslProxy.
    pub fn set_ssl_certificates(&self) -> super::builder::target_ssl_proxies::SetSslCertificates {
        super::builder::target_ssl_proxies::SetSslCertificates::new(self.inner.clone())
    }

    /// Sets the SSL policy for TargetSslProxy. The SSL policy specifies the
    /// server-side support for SSL features. This affects connections between
    /// clients and the load balancer. They do not affect the
    /// connection between the load balancer and the backends.
    pub fn set_ssl_policy(&self) -> super::builder::target_ssl_proxies::SetSslPolicy {
        super::builder::target_ssl_proxies::SetSslPolicy::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::target_ssl_proxies::GetOperation {
        super::builder::target_ssl_proxies::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::TargetTcpProxies;
/// let client = TargetTcpProxies::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `targetTcpProxies` resource.
///
/// # Configuration
///
/// To configure `TargetTcpProxies` use the `with_*` methods in the type returned
/// by [builder()][TargetTcpProxies::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::target_tcp_proxies::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::target_tcp_proxies::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `TargetTcpProxies` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `TargetTcpProxies` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "target-tcp-proxies")]
#[cfg_attr(docsrs, doc(cfg(feature = "target-tcp-proxies")))]
#[derive(Clone, Debug)]
pub struct TargetTcpProxies {
    inner: std::sync::Arc<dyn super::stub::dynamic::TargetTcpProxies>,
}

#[cfg(feature = "target-tcp-proxies")]
impl TargetTcpProxies {
    /// Returns a builder for [TargetTcpProxies].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::TargetTcpProxies;
    /// let client = TargetTcpProxies::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::target_tcp_proxies::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::target_tcp_proxies::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::TargetTcpProxies + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::TargetTcpProxies>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::TargetTcpProxies> {
        super::transport::TargetTcpProxies::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::TargetTcpProxies> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::TargetTcpProxies::new)
    }

    /// Retrieves the list of all TargetTcpProxy resources, regional and global,
    /// available to the specified project.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::target_tcp_proxies::AggregatedList {
        super::builder::target_tcp_proxies::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified TargetTcpProxy resource.
    pub fn delete(&self) -> super::builder::target_tcp_proxies::Delete {
        super::builder::target_tcp_proxies::Delete::new(self.inner.clone())
    }

    /// Returns the specified TargetTcpProxy resource.
    pub fn get(&self) -> super::builder::target_tcp_proxies::Get {
        super::builder::target_tcp_proxies::Get::new(self.inner.clone())
    }

    /// Creates a TargetTcpProxy resource in the specified project using
    /// the data included in the request.
    pub fn insert(&self) -> super::builder::target_tcp_proxies::Insert {
        super::builder::target_tcp_proxies::Insert::new(self.inner.clone())
    }

    /// Retrieves the list of TargetTcpProxy resources
    /// available to the specified project.
    pub fn list(&self) -> super::builder::target_tcp_proxies::List {
        super::builder::target_tcp_proxies::List::new(self.inner.clone())
    }

    /// Changes the BackendService for TargetTcpProxy.
    pub fn set_backend_service(&self) -> super::builder::target_tcp_proxies::SetBackendService {
        super::builder::target_tcp_proxies::SetBackendService::new(self.inner.clone())
    }

    /// Changes the ProxyHeaderType for TargetTcpProxy.
    pub fn set_proxy_header(&self) -> super::builder::target_tcp_proxies::SetProxyHeader {
        super::builder::target_tcp_proxies::SetProxyHeader::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::target_tcp_proxies::GetOperation {
        super::builder::target_tcp_proxies::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::TargetVpnGateways;
/// let client = TargetVpnGateways::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `targetVpnGateways` resource.
///
/// # Configuration
///
/// To configure `TargetVpnGateways` use the `with_*` methods in the type returned
/// by [builder()][TargetVpnGateways::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::target_vpn_gateways::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::target_vpn_gateways::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `TargetVpnGateways` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `TargetVpnGateways` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "target-vpn-gateways")]
#[cfg_attr(docsrs, doc(cfg(feature = "target-vpn-gateways")))]
#[derive(Clone, Debug)]
pub struct TargetVpnGateways {
    inner: std::sync::Arc<dyn super::stub::dynamic::TargetVpnGateways>,
}

#[cfg(feature = "target-vpn-gateways")]
impl TargetVpnGateways {
    /// Returns a builder for [TargetVpnGateways].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::TargetVpnGateways;
    /// let client = TargetVpnGateways::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::target_vpn_gateways::ClientBuilder {
        gax::client_builder::internal::new_builder(
            super::builder::target_vpn_gateways::client::Factory,
        )
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::TargetVpnGateways + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::TargetVpnGateways>>
    {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::TargetVpnGateways> {
        super::transport::TargetVpnGateways::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::TargetVpnGateways> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::TargetVpnGateways::new)
    }

    /// Retrieves an aggregated list of target VPN gateways.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::target_vpn_gateways::AggregatedList {
        super::builder::target_vpn_gateways::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified target VPN gateway.
    pub fn delete(&self) -> super::builder::target_vpn_gateways::Delete {
        super::builder::target_vpn_gateways::Delete::new(self.inner.clone())
    }

    /// Returns the specified target VPN gateway.
    pub fn get(&self) -> super::builder::target_vpn_gateways::Get {
        super::builder::target_vpn_gateways::Get::new(self.inner.clone())
    }

    /// Creates a target VPN gateway in the specified project and region using
    /// the data included in the request.
    pub fn insert(&self) -> super::builder::target_vpn_gateways::Insert {
        super::builder::target_vpn_gateways::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of target VPN gateways available to the specified
    /// project and region.
    pub fn list(&self) -> super::builder::target_vpn_gateways::List {
        super::builder::target_vpn_gateways::List::new(self.inner.clone())
    }

    /// Sets the labels on a TargetVpnGateway. To learn more about labels, read theLabeling
    /// Resources documentation.
    pub fn set_labels(&self) -> super::builder::target_vpn_gateways::SetLabels {
        super::builder::target_vpn_gateways::SetLabels::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::target_vpn_gateways::GetOperation {
        super::builder::target_vpn_gateways::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::UrlMaps;
/// let client = UrlMaps::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `urlMaps` resource.
///
/// # Configuration
///
/// To configure `UrlMaps` use the `with_*` methods in the type returned
/// by [builder()][UrlMaps::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::url_maps::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::url_maps::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `UrlMaps` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `UrlMaps` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "url-maps")]
#[cfg_attr(docsrs, doc(cfg(feature = "url-maps")))]
#[derive(Clone, Debug)]
pub struct UrlMaps {
    inner: std::sync::Arc<dyn super::stub::dynamic::UrlMaps>,
}

#[cfg(feature = "url-maps")]
impl UrlMaps {
    /// Returns a builder for [UrlMaps].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::UrlMaps;
    /// let client = UrlMaps::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::url_maps::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::url_maps::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::UrlMaps + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::UrlMaps>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::UrlMaps> {
        super::transport::UrlMaps::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::UrlMaps> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::UrlMaps::new)
    }

    /// Retrieves the list of all UrlMap resources, regional and global,
    /// available to the specified project.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::url_maps::AggregatedList {
        super::builder::url_maps::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified UrlMap resource.
    pub fn delete(&self) -> super::builder::url_maps::Delete {
        super::builder::url_maps::Delete::new(self.inner.clone())
    }

    /// Returns the specified UrlMap resource.
    pub fn get(&self) -> super::builder::url_maps::Get {
        super::builder::url_maps::Get::new(self.inner.clone())
    }

    /// Creates a UrlMap resource in the specified project using
    /// the data included in the request.
    pub fn insert(&self) -> super::builder::url_maps::Insert {
        super::builder::url_maps::Insert::new(self.inner.clone())
    }

    /// Initiates a cache invalidation operation, invalidating the specified path,
    /// scoped to the specified UrlMap.
    ///
    /// For more information, see [Invalidating cached
    /// content](/cdn/docs/invalidating-cached-content).
    pub fn invalidate_cache(&self) -> super::builder::url_maps::InvalidateCache {
        super::builder::url_maps::InvalidateCache::new(self.inner.clone())
    }

    /// Retrieves the list of UrlMap resources available to the specified
    /// project.
    pub fn list(&self) -> super::builder::url_maps::List {
        super::builder::url_maps::List::new(self.inner.clone())
    }

    /// Patches the specified UrlMap resource with the data included in the
    /// request. This method supportsPATCH
    /// semantics and uses theJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::url_maps::Patch {
        super::builder::url_maps::Patch::new(self.inner.clone())
    }

    /// Updates the specified UrlMap resource with the data included in the
    /// request.
    pub fn update(&self) -> super::builder::url_maps::Update {
        super::builder::url_maps::Update::new(self.inner.clone())
    }

    /// Runs static validation for the UrlMap. In particular, the tests of the
    /// provided UrlMap will be run. Calling this method does NOT create the
    /// UrlMap.
    pub fn validate(&self) -> super::builder::url_maps::Validate {
        super::builder::url_maps::Validate::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::url_maps::GetOperation {
        super::builder::url_maps::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::VpnGateways;
/// let client = VpnGateways::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `vpnGateways` resource.
///
/// # Configuration
///
/// To configure `VpnGateways` use the `with_*` methods in the type returned
/// by [builder()][VpnGateways::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::vpn_gateways::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::vpn_gateways::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `VpnGateways` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `VpnGateways` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "vpn-gateways")]
#[cfg_attr(docsrs, doc(cfg(feature = "vpn-gateways")))]
#[derive(Clone, Debug)]
pub struct VpnGateways {
    inner: std::sync::Arc<dyn super::stub::dynamic::VpnGateways>,
}

#[cfg(feature = "vpn-gateways")]
impl VpnGateways {
    /// Returns a builder for [VpnGateways].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::VpnGateways;
    /// let client = VpnGateways::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::vpn_gateways::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::vpn_gateways::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::VpnGateways + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::VpnGateways>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::VpnGateways> {
        super::transport::VpnGateways::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::VpnGateways> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::VpnGateways::new)
    }

    /// Retrieves an aggregated list of VPN gateways.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::vpn_gateways::AggregatedList {
        super::builder::vpn_gateways::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified VPN gateway.
    pub fn delete(&self) -> super::builder::vpn_gateways::Delete {
        super::builder::vpn_gateways::Delete::new(self.inner.clone())
    }

    /// Returns the specified VPN gateway.
    pub fn get(&self) -> super::builder::vpn_gateways::Get {
        super::builder::vpn_gateways::Get::new(self.inner.clone())
    }

    /// Returns the status for the specified VPN gateway.
    pub fn get_status(&self) -> super::builder::vpn_gateways::GetStatus {
        super::builder::vpn_gateways::GetStatus::new(self.inner.clone())
    }

    /// Creates a VPN gateway in the specified project and region using
    /// the data included in the request.
    pub fn insert(&self) -> super::builder::vpn_gateways::Insert {
        super::builder::vpn_gateways::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of VPN gateways available to the specified
    /// project and region.
    pub fn list(&self) -> super::builder::vpn_gateways::List {
        super::builder::vpn_gateways::List::new(self.inner.clone())
    }

    /// Sets the labels on a VpnGateway. To learn more about labels, read theLabeling
    /// Resources documentation.
    pub fn set_labels(&self) -> super::builder::vpn_gateways::SetLabels {
        super::builder::vpn_gateways::SetLabels::new(self.inner.clone())
    }

    /// Returns permissions that a caller has on the specified resource.
    pub fn test_iam_permissions(&self) -> super::builder::vpn_gateways::TestIamPermissions {
        super::builder::vpn_gateways::TestIamPermissions::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::vpn_gateways::GetOperation {
        super::builder::vpn_gateways::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::VpnTunnels;
/// let client = VpnTunnels::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `vpnTunnels` resource.
///
/// # Configuration
///
/// To configure `VpnTunnels` use the `with_*` methods in the type returned
/// by [builder()][VpnTunnels::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::vpn_tunnels::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::vpn_tunnels::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `VpnTunnels` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `VpnTunnels` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "vpn-tunnels")]
#[cfg_attr(docsrs, doc(cfg(feature = "vpn-tunnels")))]
#[derive(Clone, Debug)]
pub struct VpnTunnels {
    inner: std::sync::Arc<dyn super::stub::dynamic::VpnTunnels>,
}

#[cfg(feature = "vpn-tunnels")]
impl VpnTunnels {
    /// Returns a builder for [VpnTunnels].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::VpnTunnels;
    /// let client = VpnTunnels::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::vpn_tunnels::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::vpn_tunnels::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::VpnTunnels + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::VpnTunnels>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::VpnTunnels> {
        super::transport::VpnTunnels::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::VpnTunnels> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::VpnTunnels::new)
    }

    /// Retrieves an aggregated list of VPN tunnels.
    ///
    /// To prevent failure, Google recommends that you set the
    /// `returnPartialSuccess` parameter to `true`.
    pub fn aggregated_list(&self) -> super::builder::vpn_tunnels::AggregatedList {
        super::builder::vpn_tunnels::AggregatedList::new(self.inner.clone())
    }

    /// Deletes the specified VpnTunnel resource.
    pub fn delete(&self) -> super::builder::vpn_tunnels::Delete {
        super::builder::vpn_tunnels::Delete::new(self.inner.clone())
    }

    /// Returns the specified VpnTunnel resource.
    pub fn get(&self) -> super::builder::vpn_tunnels::Get {
        super::builder::vpn_tunnels::Get::new(self.inner.clone())
    }

    /// Creates a VpnTunnel resource in the specified project and region using
    /// the data included in the request.
    pub fn insert(&self) -> super::builder::vpn_tunnels::Insert {
        super::builder::vpn_tunnels::Insert::new(self.inner.clone())
    }

    /// Retrieves a list of VpnTunnel resources contained in the specified
    /// project and region.
    pub fn list(&self) -> super::builder::vpn_tunnels::List {
        super::builder::vpn_tunnels::List::new(self.inner.clone())
    }

    /// Sets the labels on a VpnTunnel. To learn more about labels, read theLabeling
    /// Resources documentation.
    pub fn set_labels(&self) -> super::builder::vpn_tunnels::SetLabels {
        super::builder::vpn_tunnels::SetLabels::new(self.inner.clone())
    }

    /// Retrieves the specified region-specific Operations resource.
    pub fn get_operation(&self) -> super::builder::vpn_tunnels::GetOperation {
        super::builder::vpn_tunnels::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::WireGroups;
/// let client = WireGroups::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `wireGroups` resource.
///
/// # Configuration
///
/// To configure `WireGroups` use the `with_*` methods in the type returned
/// by [builder()][WireGroups::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::wire_groups::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::wire_groups::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `WireGroups` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `WireGroups` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "wire-groups")]
#[cfg_attr(docsrs, doc(cfg(feature = "wire-groups")))]
#[derive(Clone, Debug)]
pub struct WireGroups {
    inner: std::sync::Arc<dyn super::stub::dynamic::WireGroups>,
}

#[cfg(feature = "wire-groups")]
impl WireGroups {
    /// Returns a builder for [WireGroups].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::WireGroups;
    /// let client = WireGroups::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::wire_groups::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::wire_groups::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::WireGroups + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::WireGroups>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::WireGroups> {
        super::transport::WireGroups::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::WireGroups> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::WireGroups::new)
    }

    /// Deletes the specified wire group in the given scope.
    pub fn delete(&self) -> super::builder::wire_groups::Delete {
        super::builder::wire_groups::Delete::new(self.inner.clone())
    }

    /// Gets the specified wire group resource in the given scope.
    pub fn get(&self) -> super::builder::wire_groups::Get {
        super::builder::wire_groups::Get::new(self.inner.clone())
    }

    /// Creates a wire group in the specified project in the given scope
    /// using the parameters that are included in the request.
    pub fn insert(&self) -> super::builder::wire_groups::Insert {
        super::builder::wire_groups::Insert::new(self.inner.clone())
    }

    /// Lists the wire groups for a project in the given scope.
    pub fn list(&self) -> super::builder::wire_groups::List {
        super::builder::wire_groups::List::new(self.inner.clone())
    }

    /// Updates the specified wire group resource with the data included in the
    /// request. This method supportsPATCH
    /// semantics and usesJSON merge
    /// patch format and processing rules.
    pub fn patch(&self) -> super::builder::wire_groups::Patch {
        super::builder::wire_groups::Patch::new(self.inner.clone())
    }

    /// Retrieves the specified Operations resource.
    pub fn get_operation(&self) -> super::builder::wire_groups::GetOperation {
        super::builder::wire_groups::GetOperation::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::ZoneOperations;
/// let client = ZoneOperations::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `zoneOperations` resource.
///
/// # Configuration
///
/// To configure `ZoneOperations` use the `with_*` methods in the type returned
/// by [builder()][ZoneOperations::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::zone_operations::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::zone_operations::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `ZoneOperations` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `ZoneOperations` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "zone-operations")]
#[cfg_attr(docsrs, doc(cfg(feature = "zone-operations")))]
#[derive(Clone, Debug)]
pub struct ZoneOperations {
    inner: std::sync::Arc<dyn super::stub::dynamic::ZoneOperations>,
}

#[cfg(feature = "zone-operations")]
impl ZoneOperations {
    /// Returns a builder for [ZoneOperations].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::ZoneOperations;
    /// let client = ZoneOperations::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::zone_operations::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::zone_operations::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::ZoneOperations + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::ZoneOperations>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ZoneOperations> {
        super::transport::ZoneOperations::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::ZoneOperations> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::ZoneOperations::new)
    }

    /// Deletes the specified zone-specific Operations resource.
    pub fn delete(&self) -> super::builder::zone_operations::Delete {
        super::builder::zone_operations::Delete::new(self.inner.clone())
    }

    /// Retrieves the specified zone-specific Operations resource.
    pub fn get(&self) -> super::builder::zone_operations::Get {
        super::builder::zone_operations::Get::new(self.inner.clone())
    }

    /// Retrieves a list of Operation resources contained within
    /// the specified zone.
    pub fn list(&self) -> super::builder::zone_operations::List {
        super::builder::zone_operations::List::new(self.inner.clone())
    }

    /// Waits for the specified Operation resource to return as `DONE`
    /// or for the request to approach the 2 minute deadline, and retrieves the
    /// specified Operation resource. This method waits for no more than the
    /// 2 minutes and then returns the current state of the
    /// operation, which might be `DONE` or still in progress.
    ///
    /// This method is called on a best-effort basis. Specifically:
    ///
    /// ```norust
    /// - In uncommon cases, when the server is overloaded, the request might
    /// return before the default deadline is reached, or might return after zero
    /// seconds.
    /// ```
    ///
    /// - If the default deadline is reached, there is no guarantee that the
    ///   operation is actually done when the method returns. Be prepared to retry
    ///   if the operation is not `DONE`.
    pub fn wait(&self) -> super::builder::zone_operations::Wait {
        super::builder::zone_operations::Wait::new(self.inner.clone())
    }
}

/// Implements a client for the Google Compute Engine API.
///
/// # Example
/// ```
/// # tokio_test::block_on(async {
/// # use google_cloud_compute_v1::client::Zones;
/// let client = Zones::builder().build().await?;
/// // use `client` to make requests to the Google Compute Engine API.
/// # gax::client_builder::Result::<()>::Ok(()) });
/// ```
///
/// # Service Description
///
/// Service for the `zones` resource.
///
/// # Configuration
///
/// To configure `Zones` use the `with_*` methods in the type returned
/// by [builder()][Zones::builder]. The default configuration should
/// work for most applications. Common configuration changes include
///
/// * [with_endpoint()]: by default this client uses the global default endpoint
///   (`https://compute.googleapis.com`). Applications using regional
///   endpoints or running in restricted networks (e.g. a network configured
//    with [Private Google Access with VPC Service Controls]) may want to
///   override this default.
/// * [with_credentials()]: by default this client uses
///   [Application Default Credentials]. Applications using custom
///   authentication may need to override this default.
///
/// [with_endpoint()]: super::builder::zones::ClientBuilder::with_endpoint
/// [with_credentials()]: super::builder::zones::ClientBuilder::credentials
/// [Private Google Access with VPC Service Controls]: https://cloud.google.com/vpc-service-controls/docs/private-connectivity
/// [Application Default Credentials]: https://cloud.google.com/docs/authentication#adc
///
/// # Pooling and Cloning
///
/// `Zones` holds a connection pool internally, it is advised to
/// create one and the reuse it.  You do not need to wrap `Zones` in
/// an [Rc](std::rc::Rc) or [Arc](std::sync::Arc) to reuse it, because it
/// already uses an `Arc` internally.
#[cfg(feature = "zones")]
#[cfg_attr(docsrs, doc(cfg(feature = "zones")))]
#[derive(Clone, Debug)]
pub struct Zones {
    inner: std::sync::Arc<dyn super::stub::dynamic::Zones>,
}

#[cfg(feature = "zones")]
impl Zones {
    /// Returns a builder for [Zones].
    ///
    /// ```
    /// # tokio_test::block_on(async {
    /// # use google_cloud_compute_v1::client::Zones;
    /// let client = Zones::builder().build().await?;
    /// # gax::client_builder::Result::<()>::Ok(()) });
    /// ```
    pub fn builder() -> super::builder::zones::ClientBuilder {
        gax::client_builder::internal::new_builder(super::builder::zones::client::Factory)
    }

    /// Creates a new client from the provided stub.
    ///
    /// The most common case for calling this function is in tests mocking the
    /// client's behavior.
    pub fn from_stub<T>(stub: T) -> Self
    where
        T: super::stub::Zones + 'static,
    {
        Self {
            inner: std::sync::Arc::new(stub),
        }
    }

    pub(crate) async fn new(
        config: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<Self> {
        let inner = Self::build_inner(config).await?;
        Ok(Self { inner })
    }

    async fn build_inner(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<std::sync::Arc<dyn super::stub::dynamic::Zones>> {
        if gaxi::options::tracing_enabled(&conf) {
            return Ok(std::sync::Arc::new(Self::build_with_tracing(conf).await?));
        }
        Ok(std::sync::Arc::new(Self::build_transport(conf).await?))
    }

    async fn build_transport(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Zones> {
        super::transport::Zones::new(conf).await
    }

    async fn build_with_tracing(
        conf: gaxi::options::ClientConfig,
    ) -> gax::client_builder::Result<impl super::stub::Zones> {
        Self::build_transport(conf)
            .await
            .map(super::tracing::Zones::new)
    }

    /// Returns the specified Zone resource.
    pub fn get(&self) -> super::builder::zones::Get {
        super::builder::zones::Get::new(self.inner.clone())
    }

    /// Retrieves the list of Zone resources available to the specified project.
    pub fn list(&self) -> super::builder::zones::List {
        super::builder::zones::List::new(self.inner.clone())
    }
}
