// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[cfg(any(
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instances",
    feature = "machine-types",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-operations",
    feature = "zone-operations",
    feature = "zones",
))]
use crate::Result;
#[allow(unused_imports)]
use gax::error::Error;

/// Implements [Images](super::stub::Images) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "images")]
#[derive(Clone)]
pub struct Images {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "images")]
impl std::fmt::Debug for Images {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Images")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "images")]
impl Images {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "images")]
impl super::stub::Images for Images {
    async fn delete(
        &self,
        req: crate::model::images::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "image",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn deprecate(
        &self,
        req: crate::model::images::DeprecateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}/deprecate",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "image",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::images::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Image>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "image",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_from_family(
        &self,
        req: crate::model::images::GetFromFamilyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Image>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/family/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.family).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.family).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "family",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::images::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::images::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .force_create
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("forceCreate", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::images::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ImageList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::images::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "image",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::images::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::images::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::images::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [InstanceGroupManagerResizeRequests](super::stub::InstanceGroupManagerResizeRequests) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "instance-group-manager-resize-requests")]
#[derive(Clone)]
pub struct InstanceGroupManagerResizeRequests {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl std::fmt::Debug for InstanceGroupManagerResizeRequests {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("InstanceGroupManagerResizeRequests")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl InstanceGroupManagerResizeRequests {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl super::stub::InstanceGroupManagerResizeRequests for InstanceGroupManagerResizeRequests {
    async fn cancel(
        &self,
        req: crate::model::instance_group_manager_resize_requests::CancelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/resizeRequests/{}/cancel",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.resize_request).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resize_request).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "resize_request",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::instance_group_manager_resize_requests::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/resizeRequests/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resize_request).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resize_request).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resize_request",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::instance_group_manager_resize_requests::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagerResizeRequest>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/resizeRequests/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resize_request).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resize_request).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resize_request",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::instance_group_manager_resize_requests::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/resizeRequests",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::instance_group_manager_resize_requests::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagerResizeRequestsListResponse>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/resizeRequests",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [InstanceGroupManagers](super::stub::InstanceGroupManagers) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "instance-group-managers")]
#[derive(Clone)]
pub struct InstanceGroupManagers {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "instance-group-managers")]
impl std::fmt::Debug for InstanceGroupManagers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("InstanceGroupManagers")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagers {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "instance-group-managers")]
impl super::stub::InstanceGroupManagers for InstanceGroupManagers {
    async fn abandon_instances(
        &self,
        req: crate::model::instance_group_managers::AbandonInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/abandonInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn aggregated_list(
        &self,
        req: crate::model::instance_group_managers::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagerAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/instanceGroupManagers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn apply_updates_to_instances(
        &self,
        req: crate::model::instance_group_managers::ApplyUpdatesToInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/applyUpdatesToInstances",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn create_instances(
        &self,
        req: crate::model::instance_group_managers::CreateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/createInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::instance_group_managers::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_instances(
        &self,
        req: crate::model::instance_group_managers::DeleteInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/deleteInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_per_instance_configs(
        &self,
        req: crate::model::instance_group_managers::DeletePerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/deletePerInstanceConfigs",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::instance_group_managers::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManager>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::instance_group_managers::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::instance_group_managers::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagerList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_errors(
        &self,
        req: crate::model::instance_group_managers::ListErrorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagersListErrorsResponse>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/listErrors",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_managed_instances(
        &self,
        req: crate::model::instance_group_managers::ListManagedInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<crate::model::InstanceGroupManagersListManagedInstancesResponse>,
    > {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/listManagedInstances",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.filter.iter().fold(builder, |builder, p| builder.query(&[("filter", p)]));
            let builder = req.max_results.iter().fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
            let builder = req.order_by.iter().fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
            let builder = req.page_token.iter().fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
            let builder = req.return_partial_success.iter().fold(builder, |builder, p| builder.query(&[("returnPartialSuccess", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_per_instance_configs(
        &self,
        req: crate::model::instance_group_managers::ListPerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<crate::model::InstanceGroupManagersListPerInstanceConfigsResp>,
    > {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/listPerInstanceConfigs",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.filter.iter().fold(builder, |builder, p| builder.query(&[("filter", p)]));
            let builder = req.max_results.iter().fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
            let builder = req.order_by.iter().fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
            let builder = req.page_token.iter().fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
            let builder = req.return_partial_success.iter().fold(builder, |builder, p| builder.query(&[("returnPartialSuccess", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::instance_group_managers::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch_per_instance_configs(
        &self,
        req: crate::model::instance_group_managers::PatchPerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/patchPerInstanceConfigs",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn recreate_instances(
        &self,
        req: crate::model::instance_group_managers::RecreateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/recreateInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn resize(
        &self,
        req: crate::model::instance_group_managers::ResizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/resize",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = builder.query(&[("size", &req.size)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn resume_instances(
        &self,
        req: crate::model::instance_group_managers::ResumeInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/resumeInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_instance_template(
        &self,
        req: crate::model::instance_group_managers::SetInstanceTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/setInstanceTemplate",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_target_pools(
        &self,
        req: crate::model::instance_group_managers::SetTargetPoolsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/setTargetPools",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn start_instances(
        &self,
        req: crate::model::instance_group_managers::StartInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/startInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn stop_instances(
        &self,
        req: crate::model::instance_group_managers::StopInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/stopInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn suspend_instances(
        &self,
        req: crate::model::instance_group_managers::SuspendInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/suspendInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_per_instance_configs(
        &self,
        req: crate::model::instance_group_managers::UpdatePerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/updatePerInstanceConfigs",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [InstanceGroups](super::stub::InstanceGroups) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "instance-groups")]
#[derive(Clone)]
pub struct InstanceGroups {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "instance-groups")]
impl std::fmt::Debug for InstanceGroups {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("InstanceGroups")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "instance-groups")]
impl InstanceGroups {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "instance-groups")]
impl super::stub::InstanceGroups for InstanceGroups {
    async fn add_instances(
        &self,
        req: crate::model::instance_groups::AddInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroups/{}/addInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn aggregated_list(
        &self,
        req: crate::model::instance_groups::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/instanceGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::instance_groups::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::instance_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroup>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::instance_groups::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::instance_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_instances(
        &self,
        req: crate::model::instance_groups::ListInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupsListInstances>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroups/{}/listInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_instances(
        &self,
        req: crate::model::instance_groups::RemoveInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroups/{}/removeInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_named_ports(
        &self,
        req: crate::model::instance_groups::SetNamedPortsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroups/{}/setNamedPorts",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::instance_groups::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroups/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [Instances](super::stub::Instances) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "instances")]
#[derive(Clone)]
pub struct Instances {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "instances")]
impl std::fmt::Debug for Instances {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Instances")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "instances")]
impl Instances {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "instances")]
impl super::stub::Instances for Instances {
    async fn add_access_config(
        &self,
        req: crate::model::instances::AddAccessConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/addAccessConfig",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("networkInterface", &req.network_interface)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn add_network_interface(
        &self,
        req: crate::model::instances::AddNetworkInterfaceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/addNetworkInterface",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn add_resource_policies(
        &self,
        req: crate::model::instances::AddResourcePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/addResourcePolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn aggregated_list(
        &self,
        req: crate::model::instances::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/instances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn attach_disk(
        &self,
        req: crate::model::instances::AttachDiskRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/attachDisk",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .force_attach
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("forceAttach", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn bulk_insert(
        &self,
        req: crate::model::instances::BulkInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/bulkInsert",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::instances::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_access_config(
        &self,
        req: crate::model::instances::DeleteAccessConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/deleteAccessConfig",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("accessConfig", &req.access_config)]);
                let builder = builder.query(&[("networkInterface", &req.network_interface)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_network_interface(
        &self,
        req: crate::model::instances::DeleteNetworkInterfaceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/deleteNetworkInterface",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder =
                    builder.query(&[("networkInterfaceName", &req.network_interface_name)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn detach_disk(
        &self,
        req: crate::model::instances::DetachDiskRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/detachDisk",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("deviceName", &req.device_name)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::instances::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Instance>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_effective_firewalls(
        &self,
        req: crate::model::instances::GetEffectiveFirewallsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstancesGetEffectiveFirewallsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/getEffectiveFirewalls",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("networkInterface", &req.network_interface)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_guest_attributes(
        &self,
        req: crate::model::instances::GetGuestAttributesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GuestAttributes>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/getGuestAttributes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .query_path
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("queryPath", p)]));
                let builder = req
                    .variable_key
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("variableKey", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::instances::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_screenshot(
        &self,
        req: crate::model::instances::GetScreenshotRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Screenshot>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/screenshot",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_serial_port_output(
        &self,
        req: crate::model::instances::GetSerialPortOutputRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SerialPortOutput>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/serialPort",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .port
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("port", p)]));
                let builder = req
                    .start
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("start", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_shielded_instance_identity(
        &self,
        req: crate::model::instances::GetShieldedInstanceIdentityRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ShieldedInstanceIdentity>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/getShieldedInstanceIdentity",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::instances::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .source_instance_template
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("sourceInstanceTemplate", p)])
                    });
                let builder = req.source_machine_image.iter().fold(builder, |builder, p| {
                    builder.query(&[("sourceMachineImage", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::instances::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_referrers(
        &self,
        req: crate::model::instances::ListReferrersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceListReferrers>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/referrers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn perform_maintenance(
        &self,
        req: crate::model::instances::PerformMaintenanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/performMaintenance",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_resource_policies(
        &self,
        req: crate::model::instances::RemoveResourcePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/removeResourcePolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn report_host_as_faulty(
        &self,
        req: crate::model::instances::ReportHostAsFaultyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/reportHostAsFaulty",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn reset(
        &self,
        req: crate::model::instances::ResetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/reset",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn resume(
        &self,
        req: crate::model::instances::ResumeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/resume",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn send_diagnostic_interrupt(
        &self,
        req: crate::model::instances::SendDiagnosticInterruptRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/sendDiagnosticInterrupt",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_deletion_protection(
        &self,
        req: crate::model::instances::SetDeletionProtectionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setDeletionProtection",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req.deletion_protection.iter().fold(builder, |builder, p| {
                    builder.query(&[("deletionProtection", p)])
                });
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_disk_auto_delete(
        &self,
        req: crate::model::instances::SetDiskAutoDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setDiskAutoDelete",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("autoDelete", &req.auto_delete)]);
                let builder = builder.query(&[("deviceName", &req.device_name)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::instances::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::instances::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_machine_resources(
        &self,
        req: crate::model::instances::SetMachineResourcesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setMachineResources",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_machine_type(
        &self,
        req: crate::model::instances::SetMachineTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setMachineType",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_metadata(
        &self,
        req: crate::model::instances::SetMetadataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setMetadata",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_min_cpu_platform(
        &self,
        req: crate::model::instances::SetMinCpuPlatformRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setMinCpuPlatform",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_name(
        &self,
        req: crate::model::instances::SetNameRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setName",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_scheduling(
        &self,
        req: crate::model::instances::SetSchedulingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setScheduling",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_security_policy(
        &self,
        req: crate::model::instances::SetSecurityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setSecurityPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_service_account(
        &self,
        req: crate::model::instances::SetServiceAccountRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setServiceAccount",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_shielded_instance_integrity_policy(
        &self,
        req: crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/instances/{}/setShieldedInstanceIntegrityPolicy",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_tags(
        &self,
        req: crate::model::instances::SetTagsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setTags",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn simulate_maintenance_event(
        &self,
        req: crate::model::instances::SimulateMaintenanceEventRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/simulateMaintenanceEvent",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .with_extended_notifications
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("withExtendedNotifications", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn start(
        &self,
        req: crate::model::instances::StartRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/start",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn start_with_encryption_key(
        &self,
        req: crate::model::instances::StartWithEncryptionKeyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/startWithEncryptionKey",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn stop(
        &self,
        req: crate::model::instances::StopRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/stop",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req.discard_local_ssd.iter().fold(builder, |builder, p| {
                    builder.query(&[("discardLocalSsd", p)])
                });
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn suspend(
        &self,
        req: crate::model::instances::SuspendRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/suspend",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req.discard_local_ssd.iter().fold(builder, |builder, p| {
                    builder.query(&[("discardLocalSsd", p)])
                });
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::instances::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::instances::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = req
                    .minimal_action
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("minimalAction", p)]));
                let builder = req
                    .most_disruptive_allowed_action
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("mostDisruptiveAllowedAction", p)])
                    });
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_access_config(
        &self,
        req: crate::model::instances::UpdateAccessConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/updateAccessConfig",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("networkInterface", &req.network_interface)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_display_device(
        &self,
        req: crate::model::instances::UpdateDisplayDeviceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/updateDisplayDevice",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_network_interface(
        &self,
        req: crate::model::instances::UpdateNetworkInterfaceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/updateNetworkInterface",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = builder.query(&[("networkInterface", &req.network_interface)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_shielded_instance_config(
        &self,
        req: crate::model::instances::UpdateShieldedInstanceConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/updateShieldedInstanceConfig",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [MachineTypes](super::stub::MachineTypes) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "machine-types")]
#[derive(Clone)]
pub struct MachineTypes {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "machine-types")]
impl std::fmt::Debug for MachineTypes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("MachineTypes")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "machine-types")]
impl MachineTypes {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "machine-types")]
impl super::stub::MachineTypes for MachineTypes {
    async fn aggregated_list(
        &self,
        req: crate::model::machine_types::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineTypeAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/machineTypes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::machine_types::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineType>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/machineTypes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.machine_type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.machine_type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "machine_type",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::machine_types::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineTypeList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/machineTypes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [RegionInstanceGroupManagers](super::stub::RegionInstanceGroupManagers) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone)]
pub struct RegionInstanceGroupManagers {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-instance-group-managers")]
impl std::fmt::Debug for RegionInstanceGroupManagers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionInstanceGroupManagers")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagers {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl super::stub::RegionInstanceGroupManagers for RegionInstanceGroupManagers {
    async fn abandon_instances(
        &self,
        req: crate::model::region_instance_group_managers::AbandonInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/abandonInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn apply_updates_to_instances(
        &self,
        req: crate::model::region_instance_group_managers::ApplyUpdatesToInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/applyUpdatesToInstances",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.region).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "region",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn create_instances(
        &self,
        req: crate::model::region_instance_group_managers::CreateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/createInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::region_instance_group_managers::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_instances(
        &self,
        req: crate::model::region_instance_group_managers::DeleteInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/deleteInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_per_instance_configs(
        &self,
        req: crate::model::region_instance_group_managers::DeletePerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/deletePerInstanceConfigs",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.region).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "region",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_instance_group_managers::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManager>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_instance_group_managers::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_instance_group_managers::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionInstanceGroupManagerList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_errors(
        &self,
        req: crate::model::region_instance_group_managers::ListErrorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionInstanceGroupManagersListErrorsResponse>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/listErrors",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_managed_instances(
        &self,
        req: crate::model::region_instance_group_managers::ListManagedInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<crate::model::RegionInstanceGroupManagersListInstancesResponse>,
    > {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/listManagedInstances",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.region).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.filter.iter().fold(builder, |builder, p| builder.query(&[("filter", p)]));
            let builder = req.max_results.iter().fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
            let builder = req.order_by.iter().fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
            let builder = req.page_token.iter().fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
            let builder = req.return_partial_success.iter().fold(builder, |builder, p| builder.query(&[("returnPartialSuccess", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "region",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_per_instance_configs(
        &self,
        req: crate::model::region_instance_group_managers::ListPerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<crate::model::RegionInstanceGroupManagersListInstanceConfigsResp>,
    > {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/listPerInstanceConfigs",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.region).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.filter.iter().fold(builder, |builder, p| builder.query(&[("filter", p)]));
            let builder = req.max_results.iter().fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
            let builder = req.order_by.iter().fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
            let builder = req.page_token.iter().fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
            let builder = req.return_partial_success.iter().fold(builder, |builder, p| builder.query(&[("returnPartialSuccess", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "region",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::region_instance_group_managers::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch_per_instance_configs(
        &self,
        req: crate::model::region_instance_group_managers::PatchPerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/patchPerInstanceConfigs",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.region).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "region",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn recreate_instances(
        &self,
        req: crate::model::region_instance_group_managers::RecreateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/recreateInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn resize(
        &self,
        req: crate::model::region_instance_group_managers::ResizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/resize",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = builder.query(&[("size", &req.size)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn resume_instances(
        &self,
        req: crate::model::region_instance_group_managers::ResumeInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/resumeInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_instance_template(
        &self,
        req: crate::model::region_instance_group_managers::SetInstanceTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/setInstanceTemplate",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.region).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "region",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_target_pools(
        &self,
        req: crate::model::region_instance_group_managers::SetTargetPoolsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/setTargetPools",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn start_instances(
        &self,
        req: crate::model::region_instance_group_managers::StartInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/startInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn stop_instances(
        &self,
        req: crate::model::region_instance_group_managers::StopInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/stopInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn suspend_instances(
        &self,
        req: crate::model::region_instance_group_managers::SuspendInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/suspendInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_per_instance_configs(
        &self,
        req: crate::model::region_instance_group_managers::UpdatePerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/updatePerInstanceConfigs",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.region).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "region",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionInstanceGroups](super::stub::RegionInstanceGroups) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-instance-groups")]
#[derive(Clone)]
pub struct RegionInstanceGroups {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-instance-groups")]
impl std::fmt::Debug for RegionInstanceGroups {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionInstanceGroups")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-instance-groups")]
impl RegionInstanceGroups {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-instance-groups")]
impl super::stub::RegionInstanceGroups for RegionInstanceGroups {
    async fn get(
        &self,
        req: crate::model::region_instance_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroup>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_instance_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionInstanceGroupList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_instances(
        &self,
        req: crate::model::region_instance_groups::ListInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionInstanceGroupsListInstances>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroups/{}/listInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_named_ports(
        &self,
        req: crate::model::region_instance_groups::SetNamedPortsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroups/{}/setNamedPorts",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::region_instance_groups::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroups/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionInstanceTemplates](super::stub::RegionInstanceTemplates) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-instance-templates")]
#[derive(Clone)]
pub struct RegionInstanceTemplates {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-instance-templates")]
impl std::fmt::Debug for RegionInstanceTemplates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionInstanceTemplates")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-instance-templates")]
impl RegionInstanceTemplates {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-instance-templates")]
impl super::stub::RegionInstanceTemplates for RegionInstanceTemplates {
    async fn delete(
        &self,
        req: crate::model::region_instance_templates::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceTemplates/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_template).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_template).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_template",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_instance_templates::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceTemplate>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceTemplates/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_template).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_template).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_template",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_instance_templates::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceTemplates",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_instance_templates::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceTemplateList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceTemplates",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionInstances](super::stub::RegionInstances) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-instances")]
#[derive(Clone)]
pub struct RegionInstances {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-instances")]
impl std::fmt::Debug for RegionInstances {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionInstances")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-instances")]
impl RegionInstances {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-instances")]
impl super::stub::RegionInstances for RegionInstances {
    async fn bulk_insert(
        &self,
        req: crate::model::region_instances::BulkInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instances/bulkInsert",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionOperations](super::stub::RegionOperations) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-operations")]
#[derive(Clone)]
pub struct RegionOperations {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-operations")]
impl std::fmt::Debug for RegionOperations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionOperations")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-operations")]
impl RegionOperations {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-operations")]
impl super::stub::RegionOperations for RegionOperations {
    async fn delete(
        &self,
        req: crate::model::region_operations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_operations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn wait(
        &self,
        req: crate::model::region_operations::WaitRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}/wait",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [ZoneOperations](super::stub::ZoneOperations) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "zone-operations")]
#[derive(Clone)]
pub struct ZoneOperations {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "zone-operations")]
impl std::fmt::Debug for ZoneOperations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ZoneOperations")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "zone-operations")]
impl ZoneOperations {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "zone-operations")]
impl super::stub::ZoneOperations for ZoneOperations {
    async fn delete(
        &self,
        req: crate::model::zone_operations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::zone_operations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn wait(
        &self,
        req: crate::model::zone_operations::WaitRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}/wait",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [Zones](super::stub::Zones) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "zones")]
#[derive(Clone)]
pub struct Zones {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "zones")]
impl std::fmt::Debug for Zones {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Zones").field("inner", &self.inner).finish()
    }
}

#[cfg(feature = "zones")]
impl Zones {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "zones")]
impl super::stub::Zones for Zones {
    async fn get(
        &self,
        req: crate::model::zones::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Zone>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::zones::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ZoneList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}
