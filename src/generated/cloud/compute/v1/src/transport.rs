// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[cfg(any(
    feature = "images",
    feature = "instances",
    feature = "machine-types",
    feature = "zone-operations",
    feature = "zones",
))]
use crate::Result;
#[allow(unused_imports)]
use gax::error::Error;

/// Implements [Images](super::stub::Images) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "images")]
#[derive(Clone)]
pub struct Images {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "images")]
impl std::fmt::Debug for Images {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Images")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "images")]
impl Images {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "images")]
impl super::stub::Images for Images {
    async fn delete(
        &self,
        req: crate::model::images::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "image",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn deprecate(
        &self,
        req: crate::model::images::DeprecateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}/deprecate",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "image",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::images::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Image>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "image",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_from_family(
        &self,
        req: crate::model::images::GetFromFamilyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Image>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/family/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.family).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.family).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "family",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::images::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::images::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .force_create
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("forceCreate", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::images::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ImageList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::images::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "image",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::images::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::images::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::images::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [Instances](super::stub::Instances) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "instances")]
#[derive(Clone)]
pub struct Instances {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "instances")]
impl std::fmt::Debug for Instances {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Instances")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "instances")]
impl Instances {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "instances")]
impl super::stub::Instances for Instances {
    async fn add_access_config(
        &self,
        req: crate::model::instances::AddAccessConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/addAccessConfig",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("networkInterface", &req.network_interface)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn add_network_interface(
        &self,
        req: crate::model::instances::AddNetworkInterfaceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/addNetworkInterface",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn add_resource_policies(
        &self,
        req: crate::model::instances::AddResourcePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/addResourcePolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn aggregated_list(
        &self,
        req: crate::model::instances::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/instances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn attach_disk(
        &self,
        req: crate::model::instances::AttachDiskRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/attachDisk",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .force_attach
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("forceAttach", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn bulk_insert(
        &self,
        req: crate::model::instances::BulkInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/bulkInsert",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::instances::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_access_config(
        &self,
        req: crate::model::instances::DeleteAccessConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/deleteAccessConfig",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("accessConfig", &req.access_config)]);
                let builder = builder.query(&[("networkInterface", &req.network_interface)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_network_interface(
        &self,
        req: crate::model::instances::DeleteNetworkInterfaceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/deleteNetworkInterface",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder =
                    builder.query(&[("networkInterfaceName", &req.network_interface_name)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn detach_disk(
        &self,
        req: crate::model::instances::DetachDiskRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/detachDisk",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("deviceName", &req.device_name)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::instances::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Instance>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_effective_firewalls(
        &self,
        req: crate::model::instances::GetEffectiveFirewallsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstancesGetEffectiveFirewallsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/getEffectiveFirewalls",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("networkInterface", &req.network_interface)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_guest_attributes(
        &self,
        req: crate::model::instances::GetGuestAttributesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GuestAttributes>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/getGuestAttributes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .query_path
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("queryPath", p)]));
                let builder = req
                    .variable_key
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("variableKey", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::instances::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_screenshot(
        &self,
        req: crate::model::instances::GetScreenshotRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Screenshot>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/screenshot",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_serial_port_output(
        &self,
        req: crate::model::instances::GetSerialPortOutputRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SerialPortOutput>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/serialPort",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .port
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("port", p)]));
                let builder = req
                    .start
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("start", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_shielded_instance_identity(
        &self,
        req: crate::model::instances::GetShieldedInstanceIdentityRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ShieldedInstanceIdentity>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/getShieldedInstanceIdentity",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::instances::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .source_instance_template
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("sourceInstanceTemplate", p)])
                    });
                let builder = req.source_machine_image.iter().fold(builder, |builder, p| {
                    builder.query(&[("sourceMachineImage", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::instances::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_referrers(
        &self,
        req: crate::model::instances::ListReferrersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceListReferrers>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/referrers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn perform_maintenance(
        &self,
        req: crate::model::instances::PerformMaintenanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/performMaintenance",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_resource_policies(
        &self,
        req: crate::model::instances::RemoveResourcePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/removeResourcePolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn report_host_as_faulty(
        &self,
        req: crate::model::instances::ReportHostAsFaultyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/reportHostAsFaulty",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn reset(
        &self,
        req: crate::model::instances::ResetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/reset",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn resume(
        &self,
        req: crate::model::instances::ResumeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/resume",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn send_diagnostic_interrupt(
        &self,
        req: crate::model::instances::SendDiagnosticInterruptRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/sendDiagnosticInterrupt",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_deletion_protection(
        &self,
        req: crate::model::instances::SetDeletionProtectionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setDeletionProtection",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req.deletion_protection.iter().fold(builder, |builder, p| {
                    builder.query(&[("deletionProtection", p)])
                });
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_disk_auto_delete(
        &self,
        req: crate::model::instances::SetDiskAutoDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setDiskAutoDelete",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("autoDelete", &req.auto_delete)]);
                let builder = builder.query(&[("deviceName", &req.device_name)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::instances::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::instances::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_machine_resources(
        &self,
        req: crate::model::instances::SetMachineResourcesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setMachineResources",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_machine_type(
        &self,
        req: crate::model::instances::SetMachineTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setMachineType",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_metadata(
        &self,
        req: crate::model::instances::SetMetadataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setMetadata",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_min_cpu_platform(
        &self,
        req: crate::model::instances::SetMinCpuPlatformRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setMinCpuPlatform",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_name(
        &self,
        req: crate::model::instances::SetNameRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setName",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_scheduling(
        &self,
        req: crate::model::instances::SetSchedulingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setScheduling",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_security_policy(
        &self,
        req: crate::model::instances::SetSecurityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setSecurityPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_service_account(
        &self,
        req: crate::model::instances::SetServiceAccountRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setServiceAccount",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_shielded_instance_integrity_policy(
        &self,
        req: crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/instances/{}/setShieldedInstanceIntegrityPolicy",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_tags(
        &self,
        req: crate::model::instances::SetTagsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setTags",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn simulate_maintenance_event(
        &self,
        req: crate::model::instances::SimulateMaintenanceEventRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/simulateMaintenanceEvent",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .with_extended_notifications
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("withExtendedNotifications", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn start(
        &self,
        req: crate::model::instances::StartRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/start",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn start_with_encryption_key(
        &self,
        req: crate::model::instances::StartWithEncryptionKeyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/startWithEncryptionKey",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn stop(
        &self,
        req: crate::model::instances::StopRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/stop",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req.discard_local_ssd.iter().fold(builder, |builder, p| {
                    builder.query(&[("discardLocalSsd", p)])
                });
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn suspend(
        &self,
        req: crate::model::instances::SuspendRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/suspend",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req.discard_local_ssd.iter().fold(builder, |builder, p| {
                    builder.query(&[("discardLocalSsd", p)])
                });
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::instances::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::instances::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = req
                    .minimal_action
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("minimalAction", p)]));
                let builder = req
                    .most_disruptive_allowed_action
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("mostDisruptiveAllowedAction", p)])
                    });
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_access_config(
        &self,
        req: crate::model::instances::UpdateAccessConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/updateAccessConfig",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("networkInterface", &req.network_interface)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_display_device(
        &self,
        req: crate::model::instances::UpdateDisplayDeviceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/updateDisplayDevice",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_network_interface(
        &self,
        req: crate::model::instances::UpdateNetworkInterfaceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/updateNetworkInterface",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = builder.query(&[("networkInterface", &req.network_interface)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_shielded_instance_config(
        &self,
        req: crate::model::instances::UpdateShieldedInstanceConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/updateShieldedInstanceConfig",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [MachineTypes](super::stub::MachineTypes) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "machine-types")]
#[derive(Clone)]
pub struct MachineTypes {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "machine-types")]
impl std::fmt::Debug for MachineTypes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("MachineTypes")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "machine-types")]
impl MachineTypes {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "machine-types")]
impl super::stub::MachineTypes for MachineTypes {
    async fn aggregated_list(
        &self,
        req: crate::model::machine_types::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineTypeAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/machineTypes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::machine_types::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineType>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/machineTypes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.machine_type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.machine_type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "machine_type",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::machine_types::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineTypeList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/machineTypes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [ZoneOperations](super::stub::ZoneOperations) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "zone-operations")]
#[derive(Clone)]
pub struct ZoneOperations {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "zone-operations")]
impl std::fmt::Debug for ZoneOperations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ZoneOperations")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "zone-operations")]
impl ZoneOperations {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "zone-operations")]
impl super::stub::ZoneOperations for ZoneOperations {
    async fn delete(
        &self,
        req: crate::model::zone_operations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::zone_operations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn wait(
        &self,
        req: crate::model::zone_operations::WaitRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}/wait",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [Zones](super::stub::Zones) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "zones")]
#[derive(Clone)]
pub struct Zones {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "zones")]
impl std::fmt::Debug for Zones {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Zones").field("inner", &self.inner).finish()
    }
}

#[cfg(feature = "zones")]
impl Zones {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "zones")]
impl super::stub::Zones for Zones {
    async fn get(
        &self,
        req: crate::model::zones::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Zone>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::zones::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ZoneList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}
