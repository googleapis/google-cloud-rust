// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[cfg(any(
    feature = "accelerator-types",
    feature = "addresses",
    feature = "autoscalers",
    feature = "backend-buckets",
    feature = "backend-services",
    feature = "cross-site-networks",
    feature = "disk-types",
    feature = "disks",
    feature = "external-vpn-gateways",
    feature = "firewall-policies",
    feature = "firewalls",
    feature = "forwarding-rules",
    feature = "future-reservations",
    feature = "global-addresses",
    feature = "global-forwarding-rules",
    feature = "global-network-endpoint-groups",
    feature = "global-operations",
    feature = "global-organization-operations",
    feature = "global-public-delegated-prefixes",
    feature = "health-checks",
    feature = "http-health-checks",
    feature = "https-health-checks",
    feature = "image-family-views",
    feature = "images",
    feature = "instance-group-manager-resize-requests",
    feature = "instance-group-managers",
    feature = "instance-groups",
    feature = "instance-settings",
    feature = "instance-templates",
    feature = "instances",
    feature = "instant-snapshots",
    feature = "interconnect-attachment-groups",
    feature = "interconnect-attachments",
    feature = "interconnect-groups",
    feature = "interconnect-locations",
    feature = "interconnect-remote-locations",
    feature = "interconnects",
    feature = "license-codes",
    feature = "licenses",
    feature = "machine-images",
    feature = "machine-types",
    feature = "network-attachments",
    feature = "network-edge-security-services",
    feature = "network-endpoint-groups",
    feature = "network-firewall-policies",
    feature = "network-profiles",
    feature = "networks",
    feature = "node-groups",
    feature = "node-templates",
    feature = "node-types",
    feature = "organization-security-policies",
    feature = "packet-mirrorings",
    feature = "preview-features",
    feature = "projects",
    feature = "public-advertised-prefixes",
    feature = "public-delegated-prefixes",
    feature = "region-autoscalers",
    feature = "region-backend-services",
    feature = "region-commitments",
    feature = "region-disk-types",
    feature = "region-disks",
    feature = "region-health-check-services",
    feature = "region-health-checks",
    feature = "region-instance-group-managers",
    feature = "region-instance-groups",
    feature = "region-instance-templates",
    feature = "region-instances",
    feature = "region-instant-snapshots",
    feature = "region-network-endpoint-groups",
    feature = "region-network-firewall-policies",
    feature = "region-notification-endpoints",
    feature = "region-operations",
    feature = "region-security-policies",
    feature = "region-ssl-certificates",
    feature = "region-ssl-policies",
    feature = "region-target-http-proxies",
    feature = "region-target-https-proxies",
    feature = "region-target-tcp-proxies",
    feature = "region-url-maps",
    feature = "region-zones",
    feature = "regions",
    feature = "reservation-blocks",
    feature = "reservation-sub-blocks",
    feature = "reservations",
    feature = "resource-policies",
    feature = "routers",
    feature = "routes",
    feature = "security-policies",
    feature = "service-attachments",
    feature = "snapshot-settings",
    feature = "snapshots",
    feature = "ssl-certificates",
    feature = "ssl-policies",
    feature = "storage-pool-types",
    feature = "storage-pools",
    feature = "subnetworks",
    feature = "target-grpc-proxies",
    feature = "target-http-proxies",
    feature = "target-https-proxies",
    feature = "target-instances",
    feature = "target-pools",
    feature = "target-ssl-proxies",
    feature = "target-tcp-proxies",
    feature = "target-vpn-gateways",
    feature = "url-maps",
    feature = "vpn-gateways",
    feature = "vpn-tunnels",
    feature = "wire-groups",
    feature = "zone-operations",
    feature = "zones",
))]
use crate::Result;
#[allow(unused_imports)]
use gax::error::Error;

/// Implements [AcceleratorTypes](super::stub::AcceleratorTypes) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "accelerator-types")]
#[derive(Clone)]
pub struct AcceleratorTypes {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "accelerator-types")]
impl std::fmt::Debug for AcceleratorTypes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("AcceleratorTypes")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "accelerator-types")]
impl AcceleratorTypes {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "accelerator-types")]
impl super::stub::AcceleratorTypes for AcceleratorTypes {
    async fn aggregated_list(
        &self,
        req: crate::model::accelerator_types::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AcceleratorTypeAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/acceleratorTypes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::accelerator_types::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AcceleratorType>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/acceleratorTypes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.accelerator_type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.accelerator_type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "accelerator_type",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::accelerator_types::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AcceleratorTypeList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/acceleratorTypes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [Addresses](super::stub::Addresses) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "addresses")]
#[derive(Clone)]
pub struct Addresses {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "addresses")]
impl std::fmt::Debug for Addresses {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Addresses")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "addresses")]
impl Addresses {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "addresses")]
impl super::stub::Addresses for Addresses {
    async fn aggregated_list(
        &self,
        req: crate::model::addresses::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AddressAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/addresses",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::addresses::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/addresses/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.address).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.address).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "address",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::addresses::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Address>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/addresses/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.address).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.address).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "address",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::addresses::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/addresses",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::addresses::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AddressList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/addresses",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn r#move(
        &self,
        req: crate::model::addresses::MoveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/addresses/{}/move",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.address).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.address).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "address",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::addresses::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/addresses/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::addresses::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/addresses/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [Autoscalers](super::stub::Autoscalers) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "autoscalers")]
#[derive(Clone)]
pub struct Autoscalers {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "autoscalers")]
impl std::fmt::Debug for Autoscalers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Autoscalers")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "autoscalers")]
impl Autoscalers {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "autoscalers")]
impl super::stub::Autoscalers for Autoscalers {
    async fn aggregated_list(
        &self,
        req: crate::model::autoscalers::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AutoscalerAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/autoscalers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::autoscalers::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/autoscalers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.autoscaler).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.autoscaler).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "autoscaler",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::autoscalers::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Autoscaler>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/autoscalers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.autoscaler).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.autoscaler).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "autoscaler",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::autoscalers::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/autoscalers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::autoscalers::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AutoscalerList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/autoscalers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::autoscalers::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/autoscalers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .autoscaler
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("autoscaler", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::autoscalers::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/autoscalers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = req
                    .autoscaler
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("autoscaler", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [BackendBuckets](super::stub::BackendBuckets) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "backend-buckets")]
#[derive(Clone)]
pub struct BackendBuckets {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "backend-buckets")]
impl std::fmt::Debug for BackendBuckets {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("BackendBuckets")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "backend-buckets")]
impl BackendBuckets {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "backend-buckets")]
impl super::stub::BackendBuckets for BackendBuckets {
    async fn add_signed_url_key(
        &self,
        req: crate::model::backend_buckets::AddSignedUrlKeyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendBuckets/{}/addSignedUrlKey",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_bucket).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_bucket).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_bucket",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::backend_buckets::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendBuckets/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_bucket).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_bucket).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_bucket",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_signed_url_key(
        &self,
        req: crate::model::backend_buckets::DeleteSignedUrlKeyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendBuckets/{}/deleteSignedUrlKey",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_bucket).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("keyName", &req.key_name)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_bucket).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_bucket",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::backend_buckets::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendBucket>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendBuckets/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_bucket).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_bucket).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_bucket",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::backend_buckets::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendBuckets/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::backend_buckets::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendBuckets",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::backend_buckets::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendBucketList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendBuckets",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::backend_buckets::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendBuckets/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_bucket).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_bucket).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_bucket",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_edge_security_policy(
        &self,
        req: crate::model::backend_buckets::SetEdgeSecurityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendBuckets/{}/setEdgeSecurityPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_bucket).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_bucket).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_bucket",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::backend_buckets::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendBuckets/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::backend_buckets::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendBuckets/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::backend_buckets::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendBuckets/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_bucket).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_bucket).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_bucket",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [BackendServices](super::stub::BackendServices) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "backend-services")]
#[derive(Clone)]
pub struct BackendServices {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "backend-services")]
impl std::fmt::Debug for BackendServices {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("BackendServices")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "backend-services")]
impl BackendServices {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "backend-services")]
impl super::stub::BackendServices for BackendServices {
    async fn add_signed_url_key(
        &self,
        req: crate::model::backend_services::AddSignedUrlKeyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendServices/{}/addSignedUrlKey",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn aggregated_list(
        &self,
        req: crate::model::backend_services::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendServiceAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/backendServices",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::backend_services::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendServices/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_signed_url_key(
        &self,
        req: crate::model::backend_services::DeleteSignedUrlKeyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendServices/{}/deleteSignedUrlKey",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("keyName", &req.key_name)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::backend_services::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendService>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendServices/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_effective_security_policies(
        &self,
        req: crate::model::backend_services::GetEffectiveSecurityPoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/global/backendServices/{}/getEffectiveSecurityPolicies",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "backend_service",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_health(
        &self,
        req: crate::model::backend_services::GetHealthRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendServiceGroupHealth>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendServices/{}/getHealth",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::backend_services::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendServices/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::backend_services::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendServices",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::backend_services::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendServiceList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendServices",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_usable(
        &self,
        req: crate::model::backend_services::ListUsableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendServiceListUsable>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendServices/listUsable",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::backend_services::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendServices/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_edge_security_policy(
        &self,
        req: crate::model::backend_services::SetEdgeSecurityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendServices/{}/setEdgeSecurityPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::backend_services::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendServices/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_security_policy(
        &self,
        req: crate::model::backend_services::SetSecurityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendServices/{}/setSecurityPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::backend_services::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendServices/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::backend_services::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/backendServices/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [CrossSiteNetworks](super::stub::CrossSiteNetworks) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "cross-site-networks")]
#[derive(Clone)]
pub struct CrossSiteNetworks {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "cross-site-networks")]
impl std::fmt::Debug for CrossSiteNetworks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("CrossSiteNetworks")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "cross-site-networks")]
impl CrossSiteNetworks {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "cross-site-networks")]
impl super::stub::CrossSiteNetworks for CrossSiteNetworks {
    async fn delete(
        &self,
        req: crate::model::cross_site_networks::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/crossSiteNetworks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.cross_site_network)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.cross_site_network)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cross_site_network",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::cross_site_networks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CrossSiteNetwork>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/crossSiteNetworks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.cross_site_network)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.cross_site_network)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cross_site_network",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::cross_site_networks::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/crossSiteNetworks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .validate_only
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("validateOnly", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::cross_site_networks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CrossSiteNetworkList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/crossSiteNetworks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::cross_site_networks::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/crossSiteNetworks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.cross_site_network)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .request_id
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    let builder = req
                        .validate_only
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("validateOnly", p)]));
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.cross_site_network)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cross_site_network",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [DiskTypes](super::stub::DiskTypes) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "disk-types")]
#[derive(Clone)]
pub struct DiskTypes {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "disk-types")]
impl std::fmt::Debug for DiskTypes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("DiskTypes")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "disk-types")]
impl DiskTypes {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "disk-types")]
impl super::stub::DiskTypes for DiskTypes {
    async fn aggregated_list(
        &self,
        req: crate::model::disk_types::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DiskTypeAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/diskTypes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::disk_types::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DiskType>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/diskTypes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk_type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk_type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk_type",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::disk_types::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DiskTypeList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/diskTypes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [Disks](super::stub::Disks) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "disks")]
#[derive(Clone)]
pub struct Disks {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "disks")]
impl std::fmt::Debug for Disks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Disks").field("inner", &self.inner).finish()
    }
}

#[cfg(feature = "disks")]
impl Disks {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "disks")]
impl super::stub::Disks for Disks {
    async fn add_resource_policies(
        &self,
        req: crate::model::disks::AddResourcePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/disks/{}/addResourcePolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn aggregated_list(
        &self,
        req: crate::model::disks::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DiskAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/disks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn bulk_insert(
        &self,
        req: crate::model::disks::BulkInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/disks/bulkInsert",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn bulk_set_labels(
        &self,
        req: crate::model::disks::BulkSetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/disks/bulkSetLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .resource
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("resource", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn create_snapshot(
        &self,
        req: crate::model::disks::CreateSnapshotRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/disks/{}/createSnapshot",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .guest_flush
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("guestFlush", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::disks::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/disks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::disks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Disk>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/disks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::disks::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/disks/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::disks::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/disks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .source_image
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("sourceImage", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::disks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DiskList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/disks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_resource_policies(
        &self,
        req: crate::model::disks::RemoveResourcePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/disks/{}/removeResourcePolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn resize(
        &self,
        req: crate::model::disks::ResizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/disks/{}/resize",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::disks::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/disks/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::disks::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/disks/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn start_async_replication(
        &self,
        req: crate::model::disks::StartAsyncReplicationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/disks/{}/startAsyncReplication",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn stop_async_replication(
        &self,
        req: crate::model::disks::StopAsyncReplicationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/disks/{}/stopAsyncReplication",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn stop_group_async_replication(
        &self,
        req: crate::model::disks::StopGroupAsyncReplicationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/disks/stopGroupAsyncReplication",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::disks::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/disks/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::disks::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/disks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .paths
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("paths", p)]));
                    let builder = req
                        .request_id
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [ExternalVpnGateways](super::stub::ExternalVpnGateways) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "external-vpn-gateways")]
#[derive(Clone)]
pub struct ExternalVpnGateways {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "external-vpn-gateways")]
impl std::fmt::Debug for ExternalVpnGateways {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ExternalVpnGateways")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "external-vpn-gateways")]
impl ExternalVpnGateways {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "external-vpn-gateways")]
impl super::stub::ExternalVpnGateways for ExternalVpnGateways {
    async fn delete(
        &self,
        req: crate::model::external_vpn_gateways::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/externalVpnGateways/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.external_vpn_gateway)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.external_vpn_gateway)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "external_vpn_gateway",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::external_vpn_gateways::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ExternalVpnGateway>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/externalVpnGateways/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.external_vpn_gateway)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.external_vpn_gateway)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "external_vpn_gateway",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::external_vpn_gateways::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/externalVpnGateways",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::external_vpn_gateways::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ExternalVpnGatewayList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/externalVpnGateways",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::external_vpn_gateways::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/externalVpnGateways/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::external_vpn_gateways::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/externalVpnGateways/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [FirewallPolicies](super::stub::FirewallPolicies) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "firewall-policies")]
#[derive(Clone)]
pub struct FirewallPolicies {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "firewall-policies")]
impl std::fmt::Debug for FirewallPolicies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("FirewallPolicies")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "firewall-policies")]
impl FirewallPolicies {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "firewall-policies")]
impl super::stub::FirewallPolicies for FirewallPolicies {
    async fn add_association(
        &self,
        req: crate::model::firewall_policies::AddAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/firewallPolicies/{}/addAssociation",
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .replace_existing_association
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("replaceExistingAssociation", p)])
                    });
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn add_rule(
        &self,
        req: crate::model::firewall_policies::AddRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/firewallPolicies/{}/addRule",
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn clone_rules(
        &self,
        req: crate::model::firewall_policies::CloneRulesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/firewallPolicies/{}/cloneRules",
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .source_firewall_policy
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("sourceFirewallPolicy", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::firewall_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/firewallPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::firewall_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/firewallPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_association(
        &self,
        req: crate::model::firewall_policies::GetAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyAssociation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/firewallPolicies/{}/getAssociation",
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .name
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("name", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::firewall_policies::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/firewallPolicies/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_rule(
        &self,
        req: crate::model::firewall_policies::GetRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyRule>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/firewallPolicies/{}/getRule",
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::firewall_policies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        let (builder, method) = None
            .or_else(|| {
                let path = "/compute/v1/locations/global/firewallPolicies".to_string();

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .parent_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("parentId", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::firewall_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        let (builder, method) = None
            .or_else(|| {
                let path = "/compute/v1/locations/global/firewallPolicies".to_string();

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .parent_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("parentId", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_associations(
        &self,
        req: crate::model::firewall_policies::ListAssociationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPoliciesListAssociationsResponse>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        let (builder, method) = None
            .or_else(|| {
                let path =
                    "/compute/v1/locations/global/firewallPolicies/listAssociations".to_string();

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req.target_resource.iter().fold(builder, |builder, p| {
                    builder.query(&[("targetResource", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn r#move(
        &self,
        req: crate::model::firewall_policies::MoveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/firewallPolicies/{}/move",
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .parent_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("parentId", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::firewall_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/firewallPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch_rule(
        &self,
        req: crate::model::firewall_policies::PatchRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/firewallPolicies/{}/patchRule",
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_association(
        &self,
        req: crate::model::firewall_policies::RemoveAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/firewallPolicies/{}/removeAssociation",
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .name
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("name", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_rule(
        &self,
        req: crate::model::firewall_policies::RemoveRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/firewallPolicies/{}/removeRule",
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::firewall_policies::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/firewallPolicies/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::firewall_policies::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/firewallPolicies/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_organization_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .parent_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("parentId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [Firewalls](super::stub::Firewalls) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "firewalls")]
#[derive(Clone)]
pub struct Firewalls {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "firewalls")]
impl std::fmt::Debug for Firewalls {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Firewalls")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "firewalls")]
impl Firewalls {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "firewalls")]
impl super::stub::Firewalls for Firewalls {
    async fn delete(
        &self,
        req: crate::model::firewalls::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewalls/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::firewalls::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Firewall>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewalls/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::firewalls::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewalls",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::firewalls::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewalls",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::firewalls::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewalls/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::firewalls::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewalls/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [ForwardingRules](super::stub::ForwardingRules) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "forwarding-rules")]
#[derive(Clone)]
pub struct ForwardingRules {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "forwarding-rules")]
impl std::fmt::Debug for ForwardingRules {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ForwardingRules")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "forwarding-rules")]
impl ForwardingRules {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "forwarding-rules")]
impl super::stub::ForwardingRules for ForwardingRules {
    async fn aggregated_list(
        &self,
        req: crate::model::forwarding_rules::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ForwardingRuleAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/forwardingRules",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::forwarding_rules::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/forwardingRules/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.forwarding_rule).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.forwarding_rule).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "forwarding_rule",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::forwarding_rules::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ForwardingRule>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/forwardingRules/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.forwarding_rule).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.forwarding_rule).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "forwarding_rule",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::forwarding_rules::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/forwardingRules",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::forwarding_rules::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ForwardingRuleList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/forwardingRules",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::forwarding_rules::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/forwardingRules/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.forwarding_rule).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.forwarding_rule).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "forwarding_rule",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::forwarding_rules::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/forwardingRules/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_target(
        &self,
        req: crate::model::forwarding_rules::SetTargetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/forwardingRules/{}/setTarget",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.forwarding_rule).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.forwarding_rule).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "forwarding_rule",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [FutureReservations](super::stub::FutureReservations) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "future-reservations")]
#[derive(Clone)]
pub struct FutureReservations {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "future-reservations")]
impl std::fmt::Debug for FutureReservations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("FutureReservations")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "future-reservations")]
impl FutureReservations {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "future-reservations")]
impl super::stub::FutureReservations for FutureReservations {
    async fn aggregated_list(
        &self,
        req: crate::model::future_reservations::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FutureReservationsAggregatedListResponse>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/futureReservations",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn cancel(
        &self,
        req: crate::model::future_reservations::CancelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/futureReservations/{}/cancel",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.future_reservation)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.future_reservation)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "future_reservation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::future_reservations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/futureReservations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.future_reservation)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.future_reservation)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "future_reservation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::future_reservations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FutureReservation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/futureReservations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.future_reservation)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.future_reservation)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "future_reservation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::future_reservations::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/futureReservations",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::future_reservations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FutureReservationsListResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/futureReservations",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::future_reservations::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/futureReservations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.future_reservation)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .request_id
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.future_reservation)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "future_reservation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [GlobalAddresses](super::stub::GlobalAddresses) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "global-addresses")]
#[derive(Clone)]
pub struct GlobalAddresses {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "global-addresses")]
impl std::fmt::Debug for GlobalAddresses {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("GlobalAddresses")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "global-addresses")]
impl GlobalAddresses {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "global-addresses")]
impl super::stub::GlobalAddresses for GlobalAddresses {
    async fn delete(
        &self,
        req: crate::model::global_addresses::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/addresses/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.address).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.address).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "address",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::global_addresses::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Address>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/addresses/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.address).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.address).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "address",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::global_addresses::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/addresses",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::global_addresses::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::AddressList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/addresses",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn r#move(
        &self,
        req: crate::model::global_addresses::MoveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/addresses/{}/move",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.address).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.address).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "address",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::global_addresses::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/addresses/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::global_addresses::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/addresses/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [GlobalForwardingRules](super::stub::GlobalForwardingRules) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "global-forwarding-rules")]
#[derive(Clone)]
pub struct GlobalForwardingRules {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "global-forwarding-rules")]
impl std::fmt::Debug for GlobalForwardingRules {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("GlobalForwardingRules")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "global-forwarding-rules")]
impl GlobalForwardingRules {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "global-forwarding-rules")]
impl super::stub::GlobalForwardingRules for GlobalForwardingRules {
    async fn delete(
        &self,
        req: crate::model::global_forwarding_rules::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/forwardingRules/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.forwarding_rule).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.forwarding_rule).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "forwarding_rule",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::global_forwarding_rules::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ForwardingRule>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/forwardingRules/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.forwarding_rule).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.forwarding_rule).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "forwarding_rule",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::global_forwarding_rules::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/forwardingRules",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::global_forwarding_rules::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ForwardingRuleList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/forwardingRules",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::global_forwarding_rules::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/forwardingRules/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.forwarding_rule).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.forwarding_rule).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "forwarding_rule",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::global_forwarding_rules::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/forwardingRules/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_target(
        &self,
        req: crate::model::global_forwarding_rules::SetTargetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/forwardingRules/{}/setTarget",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.forwarding_rule).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.forwarding_rule).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "forwarding_rule",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [GlobalNetworkEndpointGroups](super::stub::GlobalNetworkEndpointGroups) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "global-network-endpoint-groups")]
#[derive(Clone)]
pub struct GlobalNetworkEndpointGroups {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "global-network-endpoint-groups")]
impl std::fmt::Debug for GlobalNetworkEndpointGroups {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("GlobalNetworkEndpointGroups")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "global-network-endpoint-groups")]
impl GlobalNetworkEndpointGroups {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "global-network-endpoint-groups")]
impl super::stub::GlobalNetworkEndpointGroups for GlobalNetworkEndpointGroups {
    async fn attach_network_endpoints(
        &self,
        req: crate::model::global_network_endpoint_groups::AttachNetworkEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/global/networkEndpointGroups/{}/attachNetworkEndpoints",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.network_endpoint_group).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.network_endpoint_group).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "network_endpoint_group",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::global_network_endpoint_groups::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networkEndpointGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.network_endpoint_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.network_endpoint_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network_endpoint_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn detach_network_endpoints(
        &self,
        req: crate::model::global_network_endpoint_groups::DetachNetworkEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/global/networkEndpointGroups/{}/detachNetworkEndpoints",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.network_endpoint_group).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.network_endpoint_group).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "network_endpoint_group",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::global_network_endpoint_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroup>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networkEndpointGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.network_endpoint_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.network_endpoint_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network_endpoint_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::global_network_endpoint_groups::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networkEndpointGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::global_network_endpoint_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroupList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networkEndpointGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_network_endpoints(
        &self,
        req: crate::model::global_network_endpoint_groups::ListNetworkEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroupsListNetworkEndpoints>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networkEndpointGroups/{}/listNetworkEndpoints",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.network_endpoint_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.network_endpoint_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network_endpoint_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [GlobalOperations](super::stub::GlobalOperations) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "global-operations")]
#[derive(Clone)]
pub struct GlobalOperations {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "global-operations")]
impl std::fmt::Debug for GlobalOperations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("GlobalOperations")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "global-operations")]
impl GlobalOperations {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "global-operations")]
impl super::stub::GlobalOperations for GlobalOperations {
    async fn aggregated_list(
        &self,
        req: crate::model::global_operations::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/operations",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::global_operations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::global_operations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn wait(
        &self,
        req: crate::model::global_operations::WaitRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}/wait",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [GlobalOrganizationOperations](super::stub::GlobalOrganizationOperations) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "global-organization-operations")]
#[derive(Clone)]
pub struct GlobalOrganizationOperations {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "global-organization-operations")]
impl std::fmt::Debug for GlobalOrganizationOperations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("GlobalOrganizationOperations")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "global-organization-operations")]
impl GlobalOrganizationOperations {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "global-organization-operations")]
impl super::stub::GlobalOrganizationOperations for GlobalOrganizationOperations {
    async fn delete(
        &self,
        req: crate::model::global_organization_operations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .parent_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("parentId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::global_organization_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .parent_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("parentId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::global_organization_operations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        let (builder, method) = None
            .or_else(|| {
                let path = "/compute/v1/locations/global/operations".to_string();

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .parent_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("parentId", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [GlobalPublicDelegatedPrefixes](super::stub::GlobalPublicDelegatedPrefixes) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "global-public-delegated-prefixes")]
#[derive(Clone)]
pub struct GlobalPublicDelegatedPrefixes {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "global-public-delegated-prefixes")]
impl std::fmt::Debug for GlobalPublicDelegatedPrefixes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("GlobalPublicDelegatedPrefixes")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "global-public-delegated-prefixes")]
impl GlobalPublicDelegatedPrefixes {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "global-public-delegated-prefixes")]
impl super::stub::GlobalPublicDelegatedPrefixes for GlobalPublicDelegatedPrefixes {
    async fn delete(
        &self,
        req: crate::model::global_public_delegated_prefixes::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/publicDelegatedPrefixes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.public_delegated_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.public_delegated_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "public_delegated_prefix",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::global_public_delegated_prefixes::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PublicDelegatedPrefix>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/publicDelegatedPrefixes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.public_delegated_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.public_delegated_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "public_delegated_prefix",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::global_public_delegated_prefixes::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/publicDelegatedPrefixes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::global_public_delegated_prefixes::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PublicDelegatedPrefixList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/publicDelegatedPrefixes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::global_public_delegated_prefixes::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/publicDelegatedPrefixes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.public_delegated_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.public_delegated_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "public_delegated_prefix",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [HealthChecks](super::stub::HealthChecks) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "health-checks")]
#[derive(Clone)]
pub struct HealthChecks {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "health-checks")]
impl std::fmt::Debug for HealthChecks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("HealthChecks")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "health-checks")]
impl HealthChecks {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "health-checks")]
impl super::stub::HealthChecks for HealthChecks {
    async fn aggregated_list(
        &self,
        req: crate::model::health_checks::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HealthChecksAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/healthChecks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::health_checks::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/healthChecks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "health_check",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::health_checks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HealthCheck>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/healthChecks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "health_check",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::health_checks::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/healthChecks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::health_checks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HealthCheckList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/healthChecks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::health_checks::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/healthChecks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "health_check",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::health_checks::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/healthChecks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "health_check",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [HttpHealthChecks](super::stub::HttpHealthChecks) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "http-health-checks")]
#[derive(Clone)]
pub struct HttpHealthChecks {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "http-health-checks")]
impl std::fmt::Debug for HttpHealthChecks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("HttpHealthChecks")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "http-health-checks")]
impl HttpHealthChecks {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "http-health-checks")]
impl super::stub::HttpHealthChecks for HttpHealthChecks {
    async fn delete(
        &self,
        req: crate::model::http_health_checks::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/httpHealthChecks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.http_health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.http_health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "http_health_check",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::http_health_checks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HttpHealthCheck>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/httpHealthChecks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.http_health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.http_health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "http_health_check",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::http_health_checks::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/httpHealthChecks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::http_health_checks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HttpHealthCheckList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/httpHealthChecks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::http_health_checks::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/httpHealthChecks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.http_health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.http_health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "http_health_check",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::http_health_checks::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/httpHealthChecks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.http_health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.http_health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "http_health_check",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [HttpsHealthChecks](super::stub::HttpsHealthChecks) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "https-health-checks")]
#[derive(Clone)]
pub struct HttpsHealthChecks {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "https-health-checks")]
impl std::fmt::Debug for HttpsHealthChecks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("HttpsHealthChecks")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "https-health-checks")]
impl HttpsHealthChecks {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "https-health-checks")]
impl super::stub::HttpsHealthChecks for HttpsHealthChecks {
    async fn delete(
        &self,
        req: crate::model::https_health_checks::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/httpsHealthChecks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.https_health_check)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.https_health_check)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "https_health_check",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::https_health_checks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HttpsHealthCheck>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/httpsHealthChecks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.https_health_check)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.https_health_check)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "https_health_check",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::https_health_checks::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/httpsHealthChecks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::https_health_checks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HttpsHealthCheckList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/httpsHealthChecks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::https_health_checks::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/httpsHealthChecks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.https_health_check)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.https_health_check)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "https_health_check",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::https_health_checks::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/httpsHealthChecks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.https_health_check)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.https_health_check)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "https_health_check",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [ImageFamilyViews](super::stub::ImageFamilyViews) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "image-family-views")]
#[derive(Clone)]
pub struct ImageFamilyViews {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "image-family-views")]
impl std::fmt::Debug for ImageFamilyViews {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ImageFamilyViews")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "image-family-views")]
impl ImageFamilyViews {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "image-family-views")]
impl super::stub::ImageFamilyViews for ImageFamilyViews {
    async fn get(
        &self,
        req: crate::model::image_family_views::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ImageFamilyView>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/imageFamilyViews/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.family).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.family).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "family",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [Images](super::stub::Images) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "images")]
#[derive(Clone)]
pub struct Images {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "images")]
impl std::fmt::Debug for Images {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Images")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "images")]
impl Images {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "images")]
impl super::stub::Images for Images {
    async fn delete(
        &self,
        req: crate::model::images::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "image",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn deprecate(
        &self,
        req: crate::model::images::DeprecateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}/deprecate",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "image",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::images::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Image>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "image",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_from_family(
        &self,
        req: crate::model::images::GetFromFamilyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Image>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/family/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.family).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.family).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "family",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::images::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::images::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .force_create
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("forceCreate", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::images::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ImageList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::images::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "image",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::images::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::images::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::images::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/images/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [InstanceGroupManagerResizeRequests](super::stub::InstanceGroupManagerResizeRequests) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "instance-group-manager-resize-requests")]
#[derive(Clone)]
pub struct InstanceGroupManagerResizeRequests {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl std::fmt::Debug for InstanceGroupManagerResizeRequests {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("InstanceGroupManagerResizeRequests")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl InstanceGroupManagerResizeRequests {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "instance-group-manager-resize-requests")]
impl super::stub::InstanceGroupManagerResizeRequests for InstanceGroupManagerResizeRequests {
    async fn cancel(
        &self,
        req: crate::model::instance_group_manager_resize_requests::CancelRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/resizeRequests/{}/cancel",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.resize_request).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resize_request).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "resize_request",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::instance_group_manager_resize_requests::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/resizeRequests/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resize_request).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resize_request).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resize_request",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::instance_group_manager_resize_requests::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagerResizeRequest>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/resizeRequests/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resize_request).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resize_request).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resize_request",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::instance_group_manager_resize_requests::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/resizeRequests",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::instance_group_manager_resize_requests::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagerResizeRequestsListResponse>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/resizeRequests",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [InstanceGroupManagers](super::stub::InstanceGroupManagers) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "instance-group-managers")]
#[derive(Clone)]
pub struct InstanceGroupManagers {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "instance-group-managers")]
impl std::fmt::Debug for InstanceGroupManagers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("InstanceGroupManagers")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "instance-group-managers")]
impl InstanceGroupManagers {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "instance-group-managers")]
impl super::stub::InstanceGroupManagers for InstanceGroupManagers {
    async fn abandon_instances(
        &self,
        req: crate::model::instance_group_managers::AbandonInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/abandonInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn aggregated_list(
        &self,
        req: crate::model::instance_group_managers::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagerAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/instanceGroupManagers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn apply_updates_to_instances(
        &self,
        req: crate::model::instance_group_managers::ApplyUpdatesToInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/applyUpdatesToInstances",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn create_instances(
        &self,
        req: crate::model::instance_group_managers::CreateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/createInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::instance_group_managers::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_instances(
        &self,
        req: crate::model::instance_group_managers::DeleteInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/deleteInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_per_instance_configs(
        &self,
        req: crate::model::instance_group_managers::DeletePerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/deletePerInstanceConfigs",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::instance_group_managers::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManager>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::instance_group_managers::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::instance_group_managers::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagerList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_errors(
        &self,
        req: crate::model::instance_group_managers::ListErrorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManagersListErrorsResponse>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/listErrors",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_managed_instances(
        &self,
        req: crate::model::instance_group_managers::ListManagedInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<crate::model::InstanceGroupManagersListManagedInstancesResponse>,
    > {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/listManagedInstances",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.filter.iter().fold(builder, |builder, p| builder.query(&[("filter", p)]));
            let builder = req.max_results.iter().fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
            let builder = req.order_by.iter().fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
            let builder = req.page_token.iter().fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
            let builder = req.return_partial_success.iter().fold(builder, |builder, p| builder.query(&[("returnPartialSuccess", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_per_instance_configs(
        &self,
        req: crate::model::instance_group_managers::ListPerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<crate::model::InstanceGroupManagersListPerInstanceConfigsResp>,
    > {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/listPerInstanceConfigs",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.filter.iter().fold(builder, |builder, p| builder.query(&[("filter", p)]));
            let builder = req.max_results.iter().fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
            let builder = req.order_by.iter().fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
            let builder = req.page_token.iter().fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
            let builder = req.return_partial_success.iter().fold(builder, |builder, p| builder.query(&[("returnPartialSuccess", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::instance_group_managers::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch_per_instance_configs(
        &self,
        req: crate::model::instance_group_managers::PatchPerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/patchPerInstanceConfigs",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn recreate_instances(
        &self,
        req: crate::model::instance_group_managers::RecreateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/recreateInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn resize(
        &self,
        req: crate::model::instance_group_managers::ResizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/resize",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = builder.query(&[("size", &req.size)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn resume_instances(
        &self,
        req: crate::model::instance_group_managers::ResumeInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/resumeInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_instance_template(
        &self,
        req: crate::model::instance_group_managers::SetInstanceTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/setInstanceTemplate",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_target_pools(
        &self,
        req: crate::model::instance_group_managers::SetTargetPoolsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/setTargetPools",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn start_instances(
        &self,
        req: crate::model::instance_group_managers::StartInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/startInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn stop_instances(
        &self,
        req: crate::model::instance_group_managers::StopInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/stopInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn suspend_instances(
        &self,
        req: crate::model::instance_group_managers::SuspendInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/suspendInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_per_instance_configs(
        &self,
        req: crate::model::instance_group_managers::UpdatePerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/instanceGroupManagers/{}/updatePerInstanceConfigs",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [InstanceGroups](super::stub::InstanceGroups) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "instance-groups")]
#[derive(Clone)]
pub struct InstanceGroups {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "instance-groups")]
impl std::fmt::Debug for InstanceGroups {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("InstanceGroups")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "instance-groups")]
impl InstanceGroups {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "instance-groups")]
impl super::stub::InstanceGroups for InstanceGroups {
    async fn add_instances(
        &self,
        req: crate::model::instance_groups::AddInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroups/{}/addInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn aggregated_list(
        &self,
        req: crate::model::instance_groups::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/instanceGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::instance_groups::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::instance_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroup>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::instance_groups::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::instance_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_instances(
        &self,
        req: crate::model::instance_groups::ListInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupsListInstances>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroups/{}/listInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_instances(
        &self,
        req: crate::model::instance_groups::RemoveInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroups/{}/removeInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_named_ports(
        &self,
        req: crate::model::instance_groups::SetNamedPortsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroups/{}/setNamedPorts",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::instance_groups::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceGroups/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [InstanceSettings](super::stub::InstanceSettings) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "instance-settings")]
#[derive(Clone)]
pub struct InstanceSettings {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "instance-settings")]
impl std::fmt::Debug for InstanceSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("InstanceSettings")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "instance-settings")]
impl InstanceSettings {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "instance-settings")]
impl super::stub::InstanceSettings for InstanceSettings {
    async fn get(
        &self,
        req: crate::model::instance_settings::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceSettings>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceSettings",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::instance_settings::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instanceSettings",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .request_id
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [InstanceTemplates](super::stub::InstanceTemplates) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "instance-templates")]
#[derive(Clone)]
pub struct InstanceTemplates {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "instance-templates")]
impl std::fmt::Debug for InstanceTemplates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("InstanceTemplates")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "instance-templates")]
impl InstanceTemplates {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "instance-templates")]
impl super::stub::InstanceTemplates for InstanceTemplates {
    async fn aggregated_list(
        &self,
        req: crate::model::instance_templates::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceTemplateAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/instanceTemplates",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::instance_templates::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/instanceTemplates/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_template).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_template).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_template",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::instance_templates::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceTemplate>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/instanceTemplates/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_template).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_template).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_template",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::instance_templates::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/instanceTemplates/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::instance_templates::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/instanceTemplates",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::instance_templates::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceTemplateList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/instanceTemplates",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::instance_templates::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/instanceTemplates/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::instance_templates::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/instanceTemplates/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [Instances](super::stub::Instances) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "instances")]
#[derive(Clone)]
pub struct Instances {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "instances")]
impl std::fmt::Debug for Instances {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Instances")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "instances")]
impl Instances {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "instances")]
impl super::stub::Instances for Instances {
    async fn add_access_config(
        &self,
        req: crate::model::instances::AddAccessConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/addAccessConfig",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("networkInterface", &req.network_interface)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn add_network_interface(
        &self,
        req: crate::model::instances::AddNetworkInterfaceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/addNetworkInterface",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn add_resource_policies(
        &self,
        req: crate::model::instances::AddResourcePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/addResourcePolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn aggregated_list(
        &self,
        req: crate::model::instances::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/instances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn attach_disk(
        &self,
        req: crate::model::instances::AttachDiskRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/attachDisk",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .force_attach
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("forceAttach", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn bulk_insert(
        &self,
        req: crate::model::instances::BulkInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/bulkInsert",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::instances::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_access_config(
        &self,
        req: crate::model::instances::DeleteAccessConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/deleteAccessConfig",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("accessConfig", &req.access_config)]);
                let builder = builder.query(&[("networkInterface", &req.network_interface)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_network_interface(
        &self,
        req: crate::model::instances::DeleteNetworkInterfaceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/deleteNetworkInterface",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder =
                    builder.query(&[("networkInterfaceName", &req.network_interface_name)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn detach_disk(
        &self,
        req: crate::model::instances::DetachDiskRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/detachDisk",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("deviceName", &req.device_name)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::instances::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Instance>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_effective_firewalls(
        &self,
        req: crate::model::instances::GetEffectiveFirewallsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstancesGetEffectiveFirewallsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/getEffectiveFirewalls",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("networkInterface", &req.network_interface)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_guest_attributes(
        &self,
        req: crate::model::instances::GetGuestAttributesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::GuestAttributes>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/getGuestAttributes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .query_path
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("queryPath", p)]));
                let builder = req
                    .variable_key
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("variableKey", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::instances::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_screenshot(
        &self,
        req: crate::model::instances::GetScreenshotRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Screenshot>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/screenshot",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_serial_port_output(
        &self,
        req: crate::model::instances::GetSerialPortOutputRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SerialPortOutput>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/serialPort",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .port
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("port", p)]));
                let builder = req
                    .start
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("start", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_shielded_instance_identity(
        &self,
        req: crate::model::instances::GetShieldedInstanceIdentityRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ShieldedInstanceIdentity>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/getShieldedInstanceIdentity",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::instances::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .source_instance_template
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("sourceInstanceTemplate", p)])
                    });
                let builder = req.source_machine_image.iter().fold(builder, |builder, p| {
                    builder.query(&[("sourceMachineImage", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::instances::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_referrers(
        &self,
        req: crate::model::instances::ListReferrersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceListReferrers>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/referrers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn perform_maintenance(
        &self,
        req: crate::model::instances::PerformMaintenanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/performMaintenance",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_resource_policies(
        &self,
        req: crate::model::instances::RemoveResourcePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/removeResourcePolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn report_host_as_faulty(
        &self,
        req: crate::model::instances::ReportHostAsFaultyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/reportHostAsFaulty",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn reset(
        &self,
        req: crate::model::instances::ResetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/reset",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn resume(
        &self,
        req: crate::model::instances::ResumeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/resume",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn send_diagnostic_interrupt(
        &self,
        req: crate::model::instances::SendDiagnosticInterruptRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/sendDiagnosticInterrupt",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_deletion_protection(
        &self,
        req: crate::model::instances::SetDeletionProtectionRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setDeletionProtection",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req.deletion_protection.iter().fold(builder, |builder, p| {
                    builder.query(&[("deletionProtection", p)])
                });
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_disk_auto_delete(
        &self,
        req: crate::model::instances::SetDiskAutoDeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setDiskAutoDelete",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("autoDelete", &req.auto_delete)]);
                let builder = builder.query(&[("deviceName", &req.device_name)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::instances::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::instances::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_machine_resources(
        &self,
        req: crate::model::instances::SetMachineResourcesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setMachineResources",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_machine_type(
        &self,
        req: crate::model::instances::SetMachineTypeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setMachineType",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_metadata(
        &self,
        req: crate::model::instances::SetMetadataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setMetadata",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_min_cpu_platform(
        &self,
        req: crate::model::instances::SetMinCpuPlatformRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setMinCpuPlatform",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_name(
        &self,
        req: crate::model::instances::SetNameRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setName",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_scheduling(
        &self,
        req: crate::model::instances::SetSchedulingRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setScheduling",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_security_policy(
        &self,
        req: crate::model::instances::SetSecurityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setSecurityPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_service_account(
        &self,
        req: crate::model::instances::SetServiceAccountRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setServiceAccount",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_shielded_instance_integrity_policy(
        &self,
        req: crate::model::instances::SetShieldedInstanceIntegrityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/instances/{}/setShieldedInstanceIntegrityPolicy",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::PATCH, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::PATCH)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_tags(
        &self,
        req: crate::model::instances::SetTagsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/setTags",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn simulate_maintenance_event(
        &self,
        req: crate::model::instances::SimulateMaintenanceEventRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/simulateMaintenanceEvent",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .with_extended_notifications
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("withExtendedNotifications", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn start(
        &self,
        req: crate::model::instances::StartRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/start",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn start_with_encryption_key(
        &self,
        req: crate::model::instances::StartWithEncryptionKeyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/startWithEncryptionKey",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn stop(
        &self,
        req: crate::model::instances::StopRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/stop",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req.discard_local_ssd.iter().fold(builder, |builder, p| {
                    builder.query(&[("discardLocalSsd", p)])
                });
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn suspend(
        &self,
        req: crate::model::instances::SuspendRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/suspend",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req.discard_local_ssd.iter().fold(builder, |builder, p| {
                    builder.query(&[("discardLocalSsd", p)])
                });
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::instances::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::instances::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = req
                    .minimal_action
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("minimalAction", p)]));
                let builder = req
                    .most_disruptive_allowed_action
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("mostDisruptiveAllowedAction", p)])
                    });
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_access_config(
        &self,
        req: crate::model::instances::UpdateAccessConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/updateAccessConfig",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("networkInterface", &req.network_interface)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_display_device(
        &self,
        req: crate::model::instances::UpdateDisplayDeviceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/updateDisplayDevice",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_network_interface(
        &self,
        req: crate::model::instances::UpdateNetworkInterfaceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/updateNetworkInterface",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = builder.query(&[("networkInterface", &req.network_interface)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_shielded_instance_config(
        &self,
        req: crate::model::instances::UpdateShieldedInstanceConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instances/{}/updateShieldedInstanceConfig",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [InstantSnapshots](super::stub::InstantSnapshots) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "instant-snapshots")]
#[derive(Clone)]
pub struct InstantSnapshots {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "instant-snapshots")]
impl std::fmt::Debug for InstantSnapshots {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("InstantSnapshots")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "instant-snapshots")]
impl InstantSnapshots {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "instant-snapshots")]
impl super::stub::InstantSnapshots for InstantSnapshots {
    async fn aggregated_list(
        &self,
        req: crate::model::instant_snapshots::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstantSnapshotAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/instantSnapshots",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::instant_snapshots::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instantSnapshots/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instant_snapshot).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instant_snapshot).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instant_snapshot",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::instant_snapshots::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstantSnapshot>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instantSnapshots/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instant_snapshot).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instant_snapshot).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instant_snapshot",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::instant_snapshots::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instantSnapshots/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::instant_snapshots::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instantSnapshots",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::instant_snapshots::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstantSnapshotList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instantSnapshots",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::instant_snapshots::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instantSnapshots/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::instant_snapshots::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instantSnapshots/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::instant_snapshots::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/instantSnapshots/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [InterconnectAttachmentGroups](super::stub::InterconnectAttachmentGroups) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "interconnect-attachment-groups")]
#[derive(Clone)]
pub struct InterconnectAttachmentGroups {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "interconnect-attachment-groups")]
impl std::fmt::Debug for InterconnectAttachmentGroups {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("InterconnectAttachmentGroups")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
impl InterconnectAttachmentGroups {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "interconnect-attachment-groups")]
impl super::stub::InterconnectAttachmentGroups for InterconnectAttachmentGroups {
    async fn delete(
        &self,
        req: crate::model::interconnect_attachment_groups::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectAttachmentGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.interconnect_attachment_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.interconnect_attachment_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "interconnect_attachment_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::interconnect_attachment_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectAttachmentGroup>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectAttachmentGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.interconnect_attachment_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.interconnect_attachment_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "interconnect_attachment_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::interconnect_attachment_groups::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectAttachmentGroups/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operational_status(
        &self,
        req: crate::model::interconnect_attachment_groups::GetOperationalStatusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<
            crate::model::InterconnectAttachmentGroupsGetOperationalStatusResponse,
        >,
    > {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/global/interconnectAttachmentGroups/{}/getOperationalStatus",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.interconnect_attachment_group).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.interconnect_attachment_group).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "interconnect_attachment_group",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::interconnect_attachment_groups::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectAttachmentGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::interconnect_attachment_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectAttachmentGroupsListResponse>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectAttachmentGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::interconnect_attachment_groups::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectAttachmentGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.interconnect_attachment_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .request_id
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.interconnect_attachment_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "interconnect_attachment_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::interconnect_attachment_groups::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectAttachmentGroups/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::interconnect_attachment_groups::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/global/interconnectAttachmentGroups/{}/testIamPermissions",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.resource).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "resource",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [InterconnectAttachments](super::stub::InterconnectAttachments) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "interconnect-attachments")]
#[derive(Clone)]
pub struct InterconnectAttachments {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "interconnect-attachments")]
impl std::fmt::Debug for InterconnectAttachments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("InterconnectAttachments")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "interconnect-attachments")]
impl InterconnectAttachments {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "interconnect-attachments")]
impl super::stub::InterconnectAttachments for InterconnectAttachments {
    async fn aggregated_list(
        &self,
        req: crate::model::interconnect_attachments::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectAttachmentAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/interconnectAttachments",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::interconnect_attachments::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/interconnectAttachments/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.interconnect_attachment)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.interconnect_attachment)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "interconnect_attachment",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::interconnect_attachments::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectAttachment>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/interconnectAttachments/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.interconnect_attachment)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.interconnect_attachment)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "interconnect_attachment",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::interconnect_attachments::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/interconnectAttachments",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .validate_only
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("validateOnly", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::interconnect_attachments::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectAttachmentList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/interconnectAttachments",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::interconnect_attachments::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/interconnectAttachments/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.interconnect_attachment)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.interconnect_attachment)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "interconnect_attachment",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::interconnect_attachments::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/interconnectAttachments/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [InterconnectGroups](super::stub::InterconnectGroups) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "interconnect-groups")]
#[derive(Clone)]
pub struct InterconnectGroups {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "interconnect-groups")]
impl std::fmt::Debug for InterconnectGroups {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("InterconnectGroups")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "interconnect-groups")]
impl InterconnectGroups {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "interconnect-groups")]
impl super::stub::InterconnectGroups for InterconnectGroups {
    async fn create_members(
        &self,
        req: crate::model::interconnect_groups::CreateMembersRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectGroups/{}/createMembers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.interconnect_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.interconnect_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "interconnect_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::interconnect_groups::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.interconnect_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.interconnect_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "interconnect_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::interconnect_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectGroup>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.interconnect_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.interconnect_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "interconnect_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::interconnect_groups::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectGroups/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operational_status(
        &self,
        req: crate::model::interconnect_groups::GetOperationalStatusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectGroupsGetOperationalStatusResponse>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectGroups/{}/getOperationalStatus",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.interconnect_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.interconnect_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "interconnect_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::interconnect_groups::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::interconnect_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectGroupsListResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::interconnect_groups::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.interconnect_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .request_id
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.interconnect_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "interconnect_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::interconnect_groups::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectGroups/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::interconnect_groups::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectGroups/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [InterconnectLocations](super::stub::InterconnectLocations) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "interconnect-locations")]
#[derive(Clone)]
pub struct InterconnectLocations {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "interconnect-locations")]
impl std::fmt::Debug for InterconnectLocations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("InterconnectLocations")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "interconnect-locations")]
impl InterconnectLocations {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "interconnect-locations")]
impl super::stub::InterconnectLocations for InterconnectLocations {
    async fn get(
        &self,
        req: crate::model::interconnect_locations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectLocation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectLocations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.interconnect_location)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.interconnect_location)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "interconnect_location",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::interconnect_locations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectLocationList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectLocations",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [InterconnectRemoteLocations](super::stub::InterconnectRemoteLocations) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "interconnect-remote-locations")]
#[derive(Clone)]
pub struct InterconnectRemoteLocations {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "interconnect-remote-locations")]
impl std::fmt::Debug for InterconnectRemoteLocations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("InterconnectRemoteLocations")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "interconnect-remote-locations")]
impl InterconnectRemoteLocations {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "interconnect-remote-locations")]
impl super::stub::InterconnectRemoteLocations for InterconnectRemoteLocations {
    async fn get(
        &self,
        req: crate::model::interconnect_remote_locations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectRemoteLocation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectRemoteLocations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.interconnect_remote_location)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.interconnect_remote_location)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "interconnect_remote_location",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::interconnect_remote_locations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectRemoteLocationList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnectRemoteLocations",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [Interconnects](super::stub::Interconnects) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "interconnects")]
#[derive(Clone)]
pub struct Interconnects {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "interconnects")]
impl std::fmt::Debug for Interconnects {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Interconnects")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "interconnects")]
impl Interconnects {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "interconnects")]
impl super::stub::Interconnects for Interconnects {
    async fn delete(
        &self,
        req: crate::model::interconnects::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnects/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.interconnect).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.interconnect).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "interconnect",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::interconnects::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Interconnect>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnects/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.interconnect).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.interconnect).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "interconnect",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_diagnostics(
        &self,
        req: crate::model::interconnects::GetDiagnosticsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectsGetDiagnosticsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnects/{}/getDiagnostics",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.interconnect).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.interconnect).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "interconnect",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_macsec_config(
        &self,
        req: crate::model::interconnects::GetMacsecConfigRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectsGetMacsecConfigResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnects/{}/getMacsecConfig",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.interconnect).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.interconnect).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "interconnect",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::interconnects::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnects",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::interconnects::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InterconnectList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnects",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::interconnects::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnects/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.interconnect).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.interconnect).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "interconnect",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::interconnects::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/interconnects/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [LicenseCodes](super::stub::LicenseCodes) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "license-codes")]
#[derive(Clone)]
pub struct LicenseCodes {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "license-codes")]
impl std::fmt::Debug for LicenseCodes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("LicenseCodes")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "license-codes")]
impl LicenseCodes {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "license-codes")]
impl super::stub::LicenseCodes for LicenseCodes {
    async fn get(
        &self,
        req: crate::model::license_codes::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LicenseCode>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/licenseCodes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.license_code).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.license_code).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "license_code",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::license_codes::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/licenseCodes/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [Licenses](super::stub::Licenses) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "licenses")]
#[derive(Clone)]
pub struct Licenses {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "licenses")]
impl std::fmt::Debug for Licenses {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Licenses")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "licenses")]
impl Licenses {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "licenses")]
impl super::stub::Licenses for Licenses {
    async fn delete(
        &self,
        req: crate::model::licenses::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/licenses/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.license).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.license).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "license",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::licenses::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::License>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/licenses/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.license).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.license).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "license",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::licenses::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/licenses/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::licenses::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/licenses",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::licenses::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::LicensesListResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/licenses",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::licenses::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/licenses/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::licenses::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/licenses/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::licenses::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/licenses/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.license).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .request_id
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.license).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "license",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [MachineImages](super::stub::MachineImages) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "machine-images")]
#[derive(Clone)]
pub struct MachineImages {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "machine-images")]
impl std::fmt::Debug for MachineImages {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("MachineImages")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "machine-images")]
impl MachineImages {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "machine-images")]
impl super::stub::MachineImages for MachineImages {
    async fn delete(
        &self,
        req: crate::model::machine_images::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/machineImages/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.machine_image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.machine_image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "machine_image",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::machine_images::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineImage>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/machineImages/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.machine_image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.machine_image).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "machine_image",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::machine_images::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/machineImages/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::machine_images::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/machineImages",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req.source_instance.iter().fold(builder, |builder, p| {
                    builder.query(&[("sourceInstance", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::machine_images::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineImageList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/machineImages",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::machine_images::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/machineImages/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::machine_images::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/machineImages/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::machine_images::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/machineImages/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [MachineTypes](super::stub::MachineTypes) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "machine-types")]
#[derive(Clone)]
pub struct MachineTypes {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "machine-types")]
impl std::fmt::Debug for MachineTypes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("MachineTypes")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "machine-types")]
impl MachineTypes {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "machine-types")]
impl super::stub::MachineTypes for MachineTypes {
    async fn aggregated_list(
        &self,
        req: crate::model::machine_types::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineTypeAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/machineTypes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::machine_types::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineType>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/machineTypes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.machine_type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.machine_type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "machine_type",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::machine_types::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::MachineTypeList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/machineTypes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [NetworkAttachments](super::stub::NetworkAttachments) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "network-attachments")]
#[derive(Clone)]
pub struct NetworkAttachments {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "network-attachments")]
impl std::fmt::Debug for NetworkAttachments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("NetworkAttachments")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "network-attachments")]
impl NetworkAttachments {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "network-attachments")]
impl super::stub::NetworkAttachments for NetworkAttachments {
    async fn aggregated_list(
        &self,
        req: crate::model::network_attachments::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkAttachmentAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/networkAttachments",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::network_attachments::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/networkAttachments/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.network_attachment)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.network_attachment)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network_attachment",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::network_attachments::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkAttachment>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/networkAttachments/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.network_attachment)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.network_attachment)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network_attachment",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::network_attachments::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/networkAttachments/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::network_attachments::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/networkAttachments",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::network_attachments::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkAttachmentList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/networkAttachments",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::network_attachments::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/networkAttachments/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.network_attachment)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.network_attachment)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network_attachment",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::network_attachments::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/networkAttachments/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::network_attachments::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/networkAttachments/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [NetworkEdgeSecurityServices](super::stub::NetworkEdgeSecurityServices) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "network-edge-security-services")]
#[derive(Clone)]
pub struct NetworkEdgeSecurityServices {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "network-edge-security-services")]
impl std::fmt::Debug for NetworkEdgeSecurityServices {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("NetworkEdgeSecurityServices")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "network-edge-security-services")]
impl NetworkEdgeSecurityServices {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "network-edge-security-services")]
impl super::stub::NetworkEdgeSecurityServices for NetworkEdgeSecurityServices {
    async fn aggregated_list(
        &self,
        req: crate::model::network_edge_security_services::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEdgeSecurityServiceAggregatedList>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/networkEdgeSecurityServices",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::network_edge_security_services::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/networkEdgeSecurityServices/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.network_edge_security_service)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.network_edge_security_service)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network_edge_security_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::network_edge_security_services::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEdgeSecurityService>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/networkEdgeSecurityServices/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.network_edge_security_service)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.network_edge_security_service)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network_edge_security_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::network_edge_security_services::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/networkEdgeSecurityServices",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .validate_only
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("validateOnly", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::network_edge_security_services::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/networkEdgeSecurityServices/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.network_edge_security_service)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .paths
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("paths", p)]));
                    let builder = req
                        .request_id
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.network_edge_security_service)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network_edge_security_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [NetworkEndpointGroups](super::stub::NetworkEndpointGroups) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "network-endpoint-groups")]
#[derive(Clone)]
pub struct NetworkEndpointGroups {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "network-endpoint-groups")]
impl std::fmt::Debug for NetworkEndpointGroups {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("NetworkEndpointGroups")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "network-endpoint-groups")]
impl NetworkEndpointGroups {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "network-endpoint-groups")]
impl super::stub::NetworkEndpointGroups for NetworkEndpointGroups {
    async fn aggregated_list(
        &self,
        req: crate::model::network_endpoint_groups::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroupAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/networkEndpointGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn attach_network_endpoints(
        &self,
        req: crate::model::network_endpoint_groups::AttachNetworkEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/networkEndpointGroups/{}/attachNetworkEndpoints",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.network_endpoint_group).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.network_endpoint_group).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "network_endpoint_group",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::network_endpoint_groups::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/networkEndpointGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.network_endpoint_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.network_endpoint_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network_endpoint_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn detach_network_endpoints(
        &self,
        req: crate::model::network_endpoint_groups::DetachNetworkEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/networkEndpointGroups/{}/detachNetworkEndpoints",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.network_endpoint_group).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.network_endpoint_group).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "network_endpoint_group",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::network_endpoint_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroup>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/networkEndpointGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.network_endpoint_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.network_endpoint_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network_endpoint_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::network_endpoint_groups::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/networkEndpointGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::network_endpoint_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroupList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/networkEndpointGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_network_endpoints(
        &self,
        req: crate::model::network_endpoint_groups::ListNetworkEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroupsListNetworkEndpoints>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/networkEndpointGroups/{}/listNetworkEndpoints",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.network_endpoint_group).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.filter.iter().fold(builder, |builder, p| builder.query(&[("filter", p)]));
            let builder = req.max_results.iter().fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
            let builder = req.order_by.iter().fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
            let builder = req.page_token.iter().fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
            let builder = req.return_partial_success.iter().fold(builder, |builder, p| builder.query(&[("returnPartialSuccess", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.network_endpoint_group).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "network_endpoint_group",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::network_endpoint_groups::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/networkEndpointGroups/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [NetworkFirewallPolicies](super::stub::NetworkFirewallPolicies) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "network-firewall-policies")]
#[derive(Clone)]
pub struct NetworkFirewallPolicies {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "network-firewall-policies")]
impl std::fmt::Debug for NetworkFirewallPolicies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("NetworkFirewallPolicies")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "network-firewall-policies")]
impl NetworkFirewallPolicies {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "network-firewall-policies")]
impl super::stub::NetworkFirewallPolicies for NetworkFirewallPolicies {
    async fn add_association(
        &self,
        req: crate::model::network_firewall_policies::AddAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies/{}/addAssociation",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .replace_existing_association
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("replaceExistingAssociation", p)])
                    });
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn add_packet_mirroring_rule(
        &self,
        req: crate::model::network_firewall_policies::AddPacketMirroringRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies/{}/addPacketMirroringRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .max_priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxPriority", p)]));
                let builder = req
                    .min_priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("minPriority", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn add_rule(
        &self,
        req: crate::model::network_firewall_policies::AddRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies/{}/addRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .max_priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxPriority", p)]));
                let builder = req
                    .min_priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("minPriority", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn aggregated_list(
        &self,
        req: crate::model::network_firewall_policies::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkFirewallPolicyAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/firewallPolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn clone_rules(
        &self,
        req: crate::model::network_firewall_policies::CloneRulesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies/{}/cloneRules",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .source_firewall_policy
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("sourceFirewallPolicy", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::network_firewall_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::network_firewall_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_association(
        &self,
        req: crate::model::network_firewall_policies::GetAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyAssociation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies/{}/getAssociation",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .name
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("name", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::network_firewall_policies::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_packet_mirroring_rule(
        &self,
        req: crate::model::network_firewall_policies::GetPacketMirroringRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyRule>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies/{}/getPacketMirroringRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_rule(
        &self,
        req: crate::model::network_firewall_policies::GetRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyRule>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies/{}/getRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::network_firewall_policies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::network_firewall_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::network_firewall_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch_packet_mirroring_rule(
        &self,
        req: crate::model::network_firewall_policies::PatchPacketMirroringRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies/{}/patchPacketMirroringRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch_rule(
        &self,
        req: crate::model::network_firewall_policies::PatchRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies/{}/patchRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_association(
        &self,
        req: crate::model::network_firewall_policies::RemoveAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies/{}/removeAssociation",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .name
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("name", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_packet_mirroring_rule(
        &self,
        req: crate::model::network_firewall_policies::RemovePacketMirroringRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies/{}/removePacketMirroringRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_rule(
        &self,
        req: crate::model::network_firewall_policies::RemoveRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies/{}/removeRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::network_firewall_policies::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::network_firewall_policies::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/firewallPolicies/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [NetworkProfiles](super::stub::NetworkProfiles) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "network-profiles")]
#[derive(Clone)]
pub struct NetworkProfiles {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "network-profiles")]
impl std::fmt::Debug for NetworkProfiles {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("NetworkProfiles")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "network-profiles")]
impl NetworkProfiles {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "network-profiles")]
impl super::stub::NetworkProfiles for NetworkProfiles {
    async fn get(
        &self,
        req: crate::model::network_profiles::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkProfile>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networkProfiles/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.network_profile).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.network_profile).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network_profile",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::network_profiles::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkProfilesListResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networkProfiles",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [Networks](super::stub::Networks) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "networks")]
#[derive(Clone)]
pub struct Networks {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "networks")]
impl std::fmt::Debug for Networks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Networks")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "networks")]
impl Networks {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "networks")]
impl super::stub::Networks for Networks {
    async fn add_peering(
        &self,
        req: crate::model::networks::AddPeeringRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networks/{}/addPeering",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::networks::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::networks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Network>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_effective_firewalls(
        &self,
        req: crate::model::networks::GetEffectiveFirewallsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworksGetEffectiveFirewallsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networks/{}/getEffectiveFirewalls",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::networks::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::networks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_peering_routes(
        &self,
        req: crate::model::networks::ListPeeringRoutesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ExchangedPeeringRoutesList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networks/{}/listPeeringRoutes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .direction
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("direction", p)]));
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .peering_name
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("peeringName", p)]));
                let builder = req
                    .region
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("region", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::networks::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_peering(
        &self,
        req: crate::model::networks::RemovePeeringRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networks/{}/removePeering",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn request_remove_peering(
        &self,
        req: crate::model::networks::RequestRemovePeeringRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networks/{}/requestRemovePeering",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn switch_to_custom_mode(
        &self,
        req: crate::model::networks::SwitchToCustomModeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networks/{}/switchToCustomMode",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_peering(
        &self,
        req: crate::model::networks::UpdatePeeringRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/networks/{}/updatePeering",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.network).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [NodeGroups](super::stub::NodeGroups) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "node-groups")]
#[derive(Clone)]
pub struct NodeGroups {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "node-groups")]
impl std::fmt::Debug for NodeGroups {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("NodeGroups")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "node-groups")]
impl NodeGroups {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "node-groups")]
impl super::stub::NodeGroups for NodeGroups {
    async fn add_nodes(
        &self,
        req: crate::model::node_groups::AddNodesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/nodeGroups/{}/addNodes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.node_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.node_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "node_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn aggregated_list(
        &self,
        req: crate::model::node_groups::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeGroupAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/nodeGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::node_groups::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/nodeGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.node_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.node_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "node_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_nodes(
        &self,
        req: crate::model::node_groups::DeleteNodesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/nodeGroups/{}/deleteNodes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.node_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.node_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "node_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::node_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeGroup>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/nodeGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.node_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.node_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "node_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::node_groups::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/nodeGroups/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::node_groups::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/nodeGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = builder.query(&[("initialNodeCount", &req.initial_node_count)]);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::node_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeGroupList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/nodeGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_nodes(
        &self,
        req: crate::model::node_groups::ListNodesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeGroupsListNodes>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/nodeGroups/{}/listNodes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.node_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.node_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "node_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::node_groups::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/nodeGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.node_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.node_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "node_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn perform_maintenance(
        &self,
        req: crate::model::node_groups::PerformMaintenanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/nodeGroups/{}/performMaintenance",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.node_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.node_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "node_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::node_groups::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/nodeGroups/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_node_template(
        &self,
        req: crate::model::node_groups::SetNodeTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/nodeGroups/{}/setNodeTemplate",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.node_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.node_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "node_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn simulate_maintenance_event(
        &self,
        req: crate::model::node_groups::SimulateMaintenanceEventRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/nodeGroups/{}/simulateMaintenanceEvent",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.node_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.node_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "node_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::node_groups::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/nodeGroups/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [NodeTemplates](super::stub::NodeTemplates) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "node-templates")]
#[derive(Clone)]
pub struct NodeTemplates {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "node-templates")]
impl std::fmt::Debug for NodeTemplates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("NodeTemplates")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "node-templates")]
impl NodeTemplates {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "node-templates")]
impl super::stub::NodeTemplates for NodeTemplates {
    async fn aggregated_list(
        &self,
        req: crate::model::node_templates::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeTemplateAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/nodeTemplates",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::node_templates::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/nodeTemplates/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.node_template).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.node_template).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "node_template",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::node_templates::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeTemplate>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/nodeTemplates/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.node_template).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.node_template).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "node_template",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::node_templates::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/nodeTemplates/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::node_templates::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/nodeTemplates",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::node_templates::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeTemplateList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/nodeTemplates",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::node_templates::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/nodeTemplates/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::node_templates::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/nodeTemplates/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [NodeTypes](super::stub::NodeTypes) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "node-types")]
#[derive(Clone)]
pub struct NodeTypes {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "node-types")]
impl std::fmt::Debug for NodeTypes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("NodeTypes")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "node-types")]
impl NodeTypes {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "node-types")]
impl super::stub::NodeTypes for NodeTypes {
    async fn aggregated_list(
        &self,
        req: crate::model::node_types::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeTypeAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/nodeTypes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::node_types::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeType>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/nodeTypes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.node_type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.node_type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "node_type",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::node_types::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NodeTypeList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/nodeTypes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [OrganizationSecurityPolicies](super::stub::OrganizationSecurityPolicies) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "organization-security-policies")]
#[derive(Clone)]
pub struct OrganizationSecurityPolicies {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "organization-security-policies")]
impl std::fmt::Debug for OrganizationSecurityPolicies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("OrganizationSecurityPolicies")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "organization-security-policies")]
impl OrganizationSecurityPolicies {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "organization-security-policies")]
impl super::stub::OrganizationSecurityPolicies for OrganizationSecurityPolicies {
    async fn add_association(
        &self,
        req: crate::model::organization_security_policies::AddAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/securityPolicies/{}/addAssociation",
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .replace_existing_association
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("replaceExistingAssociation", p)])
                    });
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn add_rule(
        &self,
        req: crate::model::organization_security_policies::AddRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/securityPolicies/{}/addRule",
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn copy_rules(
        &self,
        req: crate::model::organization_security_policies::CopyRulesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/securityPolicies/{}/copyRules",
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .source_security_policy
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("sourceSecurityPolicy", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::organization_security_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/securityPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::organization_security_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/securityPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_association(
        &self,
        req: crate::model::organization_security_policies::GetAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicyAssociation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/securityPolicies/{}/getAssociation",
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .name
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("name", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_rule(
        &self,
        req: crate::model::organization_security_policies::GetRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicyRule>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/securityPolicies/{}/getRule",
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::organization_security_policies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        let (builder, method) = None
            .or_else(|| {
                let path = "/compute/v1/locations/global/securityPolicies".to_string();

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .parent_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("parentId", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::organization_security_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicyList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        let (builder, method) = None
            .or_else(|| {
                let path = "/compute/v1/locations/global/securityPolicies".to_string();

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .parent_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("parentId", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_associations(
        &self,
        req: crate::model::organization_security_policies::ListAssociationsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<crate::model::OrganizationSecurityPoliciesListAssociationsResponse>,
    > {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        let (builder, method) = None
            .or_else(|| {
                let path =
                    "/compute/v1/locations/global/securityPolicies/listAssociations".to_string();

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req.target_resource.iter().fold(builder, |builder, p| {
                    builder.query(&[("targetResource", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_preconfigured_expression_sets(
        &self,
        req: crate::model::organization_security_policies::ListPreconfiguredExpressionSetsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<
            crate::model::SecurityPoliciesListPreconfiguredExpressionSetsResponse,
        >,
    > {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        let (builder, method) = None
            .or_else(|| {
                let path =
                    "/compute/v1/locations/global/securityPolicies/listPreconfiguredExpressionSets"
                        .to_string();

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .parent_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("parentId", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn r#move(
        &self,
        req: crate::model::organization_security_policies::MoveRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/securityPolicies/{}/move",
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .parent_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("parentId", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::organization_security_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/securityPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch_rule(
        &self,
        req: crate::model::organization_security_policies::PatchRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/securityPolicies/{}/patchRule",
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_association(
        &self,
        req: crate::model::organization_security_policies::RemoveAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/securityPolicies/{}/removeAssociation",
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .name
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("name", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_rule(
        &self,
        req: crate::model::organization_security_policies::RemoveRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/securityPolicies/{}/removeRule",
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_organization_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/locations/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .parent_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("parentId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [PacketMirrorings](super::stub::PacketMirrorings) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "packet-mirrorings")]
#[derive(Clone)]
pub struct PacketMirrorings {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "packet-mirrorings")]
impl std::fmt::Debug for PacketMirrorings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("PacketMirrorings")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "packet-mirrorings")]
impl PacketMirrorings {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "packet-mirrorings")]
impl super::stub::PacketMirrorings for PacketMirrorings {
    async fn aggregated_list(
        &self,
        req: crate::model::packet_mirrorings::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PacketMirroringAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/packetMirrorings",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::packet_mirrorings::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/packetMirrorings/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.packet_mirroring).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.packet_mirroring).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "packet_mirroring",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::packet_mirrorings::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PacketMirroring>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/packetMirrorings/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.packet_mirroring).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.packet_mirroring).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "packet_mirroring",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::packet_mirrorings::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/packetMirrorings",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::packet_mirrorings::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PacketMirroringList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/packetMirrorings",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::packet_mirrorings::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/packetMirrorings/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.packet_mirroring).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.packet_mirroring).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "packet_mirroring",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::packet_mirrorings::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/packetMirrorings/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [PreviewFeatures](super::stub::PreviewFeatures) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "preview-features")]
#[derive(Clone)]
pub struct PreviewFeatures {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "preview-features")]
impl std::fmt::Debug for PreviewFeatures {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("PreviewFeatures")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "preview-features")]
impl PreviewFeatures {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "preview-features")]
impl super::stub::PreviewFeatures for PreviewFeatures {
    async fn get(
        &self,
        req: crate::model::preview_features::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PreviewFeature>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/previewFeatures/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.preview_feature).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.preview_feature).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "preview_feature",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::preview_features::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PreviewFeatureList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/previewFeatures",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::preview_features::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/previewFeatures/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.preview_feature).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.preview_feature).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "preview_feature",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [Projects](super::stub::Projects) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "projects")]
#[derive(Clone)]
pub struct Projects {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "projects")]
impl std::fmt::Debug for Projects {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Projects")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "projects")]
impl Projects {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "projects")]
impl super::stub::Projects for Projects {
    async fn disable_xpn_host(
        &self,
        req: crate::model::projects::DisableXpnHostRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/disableXpnHost",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn disable_xpn_resource(
        &self,
        req: crate::model::projects::DisableXpnResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/disableXpnResource",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn enable_xpn_host(
        &self,
        req: crate::model::projects::EnableXpnHostRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/enableXpnHost",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn enable_xpn_resource(
        &self,
        req: crate::model::projects::EnableXpnResourceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/enableXpnResource",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::projects::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Project>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_xpn_host(
        &self,
        req: crate::model::projects::GetXpnHostRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Project>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/getXpnHost",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_xpn_resources(
        &self,
        req: crate::model::projects::GetXpnResourcesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ProjectsGetXpnResources>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/getXpnResources",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_xpn_hosts(
        &self,
        req: crate::model::projects::ListXpnHostsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::XpnHostList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/listXpnHosts",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn move_disk(
        &self,
        req: crate::model::projects::MoveDiskRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/moveDisk",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn move_instance(
        &self,
        req: crate::model::projects::MoveInstanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/moveInstance",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_cloud_armor_tier(
        &self,
        req: crate::model::projects::SetCloudArmorTierRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/setCloudArmorTier",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_common_instance_metadata(
        &self,
        req: crate::model::projects::SetCommonInstanceMetadataRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/setCommonInstanceMetadata",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_default_network_tier(
        &self,
        req: crate::model::projects::SetDefaultNetworkTierRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/setDefaultNetworkTier",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_usage_export_bucket(
        &self,
        req: crate::model::projects::SetUsageExportBucketRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/setUsageExportBucket",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [PublicAdvertisedPrefixes](super::stub::PublicAdvertisedPrefixes) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "public-advertised-prefixes")]
#[derive(Clone)]
pub struct PublicAdvertisedPrefixes {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "public-advertised-prefixes")]
impl std::fmt::Debug for PublicAdvertisedPrefixes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("PublicAdvertisedPrefixes")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "public-advertised-prefixes")]
impl PublicAdvertisedPrefixes {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "public-advertised-prefixes")]
impl super::stub::PublicAdvertisedPrefixes for PublicAdvertisedPrefixes {
    async fn announce(
        &self,
        req: crate::model::public_advertised_prefixes::AnnounceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/publicAdvertisedPrefixes/{}/announce",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.public_advertised_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.public_advertised_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "public_advertised_prefix",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::public_advertised_prefixes::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/publicAdvertisedPrefixes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.public_advertised_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.public_advertised_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "public_advertised_prefix",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::public_advertised_prefixes::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PublicAdvertisedPrefix>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/publicAdvertisedPrefixes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.public_advertised_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.public_advertised_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "public_advertised_prefix",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::public_advertised_prefixes::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/publicAdvertisedPrefixes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::public_advertised_prefixes::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PublicAdvertisedPrefixList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/publicAdvertisedPrefixes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::public_advertised_prefixes::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/publicAdvertisedPrefixes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.public_advertised_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.public_advertised_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "public_advertised_prefix",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn withdraw(
        &self,
        req: crate::model::public_advertised_prefixes::WithdrawRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/publicAdvertisedPrefixes/{}/withdraw",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.public_advertised_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.public_advertised_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "public_advertised_prefix",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [PublicDelegatedPrefixes](super::stub::PublicDelegatedPrefixes) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "public-delegated-prefixes")]
#[derive(Clone)]
pub struct PublicDelegatedPrefixes {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "public-delegated-prefixes")]
impl std::fmt::Debug for PublicDelegatedPrefixes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("PublicDelegatedPrefixes")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "public-delegated-prefixes")]
impl PublicDelegatedPrefixes {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "public-delegated-prefixes")]
impl super::stub::PublicDelegatedPrefixes for PublicDelegatedPrefixes {
    async fn aggregated_list(
        &self,
        req: crate::model::public_delegated_prefixes::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PublicDelegatedPrefixAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/publicDelegatedPrefixes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn announce(
        &self,
        req: crate::model::public_delegated_prefixes::AnnounceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/publicDelegatedPrefixes/{}/announce",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.public_delegated_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.public_delegated_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "public_delegated_prefix",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::public_delegated_prefixes::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/publicDelegatedPrefixes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.public_delegated_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.public_delegated_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "public_delegated_prefix",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::public_delegated_prefixes::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PublicDelegatedPrefix>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/publicDelegatedPrefixes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.public_delegated_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.public_delegated_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "public_delegated_prefix",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::public_delegated_prefixes::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/publicDelegatedPrefixes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::public_delegated_prefixes::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::PublicDelegatedPrefixList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/publicDelegatedPrefixes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::public_delegated_prefixes::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/publicDelegatedPrefixes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.public_delegated_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.public_delegated_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "public_delegated_prefix",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn withdraw(
        &self,
        req: crate::model::public_delegated_prefixes::WithdrawRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/publicDelegatedPrefixes/{}/withdraw",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.public_delegated_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.public_delegated_prefix)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "public_delegated_prefix",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionAutoscalers](super::stub::RegionAutoscalers) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-autoscalers")]
#[derive(Clone)]
pub struct RegionAutoscalers {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-autoscalers")]
impl std::fmt::Debug for RegionAutoscalers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionAutoscalers")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-autoscalers")]
impl RegionAutoscalers {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-autoscalers")]
impl super::stub::RegionAutoscalers for RegionAutoscalers {
    async fn delete(
        &self,
        req: crate::model::region_autoscalers::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/autoscalers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.autoscaler).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.autoscaler).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "autoscaler",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_autoscalers::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Autoscaler>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/autoscalers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.autoscaler).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.autoscaler).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "autoscaler",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_autoscalers::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/autoscalers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_autoscalers::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionAutoscalerList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/autoscalers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::region_autoscalers::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/autoscalers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .autoscaler
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("autoscaler", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::region_autoscalers::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/autoscalers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = req
                    .autoscaler
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("autoscaler", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionBackendServices](super::stub::RegionBackendServices) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-backend-services")]
#[derive(Clone)]
pub struct RegionBackendServices {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-backend-services")]
impl std::fmt::Debug for RegionBackendServices {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionBackendServices")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-backend-services")]
impl RegionBackendServices {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-backend-services")]
impl super::stub::RegionBackendServices for RegionBackendServices {
    async fn delete(
        &self,
        req: crate::model::region_backend_services::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/backendServices/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_backend_services::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendService>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/backendServices/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_health(
        &self,
        req: crate::model::region_backend_services::GetHealthRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendServiceGroupHealth>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/backendServices/{}/getHealth",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::region_backend_services::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/backendServices/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_backend_services::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/backendServices",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_backend_services::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendServiceList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/backendServices",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_usable(
        &self,
        req: crate::model::region_backend_services::ListUsableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::BackendServiceListUsable>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/backendServices/listUsable",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::region_backend_services::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/backendServices/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::region_backend_services::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/backendServices/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_security_policy(
        &self,
        req: crate::model::region_backend_services::SetSecurityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/backendServices/{}/setSecurityPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::region_backend_services::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/backendServices/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::region_backend_services::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/backendServices/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.backend_service).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "backend_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionCommitments](super::stub::RegionCommitments) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-commitments")]
#[derive(Clone)]
pub struct RegionCommitments {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-commitments")]
impl std::fmt::Debug for RegionCommitments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionCommitments")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-commitments")]
impl RegionCommitments {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-commitments")]
impl super::stub::RegionCommitments for RegionCommitments {
    async fn aggregated_list(
        &self,
        req: crate::model::region_commitments::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CommitmentAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/commitments",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_commitments::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Commitment>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/commitments/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.commitment).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.commitment).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "commitment",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_commitments::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/commitments",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_commitments::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::CommitmentList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/commitments",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::region_commitments::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/commitments/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.commitment).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .paths
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("paths", p)]));
                    let builder = req
                        .request_id
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.commitment).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "commitment",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionDiskTypes](super::stub::RegionDiskTypes) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-disk-types")]
#[derive(Clone)]
pub struct RegionDiskTypes {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-disk-types")]
impl std::fmt::Debug for RegionDiskTypes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionDiskTypes")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-disk-types")]
impl RegionDiskTypes {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-disk-types")]
impl super::stub::RegionDiskTypes for RegionDiskTypes {
    async fn get(
        &self,
        req: crate::model::region_disk_types::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DiskType>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/diskTypes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk_type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk_type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk_type",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_disk_types::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionDiskTypeList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/diskTypes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [RegionDisks](super::stub::RegionDisks) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-disks")]
#[derive(Clone)]
pub struct RegionDisks {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-disks")]
impl std::fmt::Debug for RegionDisks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionDisks")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-disks")]
impl RegionDisks {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-disks")]
impl super::stub::RegionDisks for RegionDisks {
    async fn add_resource_policies(
        &self,
        req: crate::model::region_disks::AddResourcePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/disks/{}/addResourcePolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn bulk_insert(
        &self,
        req: crate::model::region_disks::BulkInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/disks/bulkInsert",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn create_snapshot(
        &self,
        req: crate::model::region_disks::CreateSnapshotRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/disks/{}/createSnapshot",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::region_disks::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/disks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_disks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Disk>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/disks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::region_disks::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/disks/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_disks::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/disks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .source_image
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("sourceImage", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_disks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::DiskList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/disks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_resource_policies(
        &self,
        req: crate::model::region_disks::RemoveResourcePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/disks/{}/removeResourcePolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn resize(
        &self,
        req: crate::model::region_disks::ResizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/disks/{}/resize",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::region_disks::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/disks/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::region_disks::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/disks/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn start_async_replication(
        &self,
        req: crate::model::region_disks::StartAsyncReplicationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/disks/{}/startAsyncReplication",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn stop_async_replication(
        &self,
        req: crate::model::region_disks::StopAsyncReplicationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/disks/{}/stopAsyncReplication",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn stop_group_async_replication(
        &self,
        req: crate::model::region_disks::StopGroupAsyncReplicationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/disks/stopGroupAsyncReplication",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::region_disks::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/disks/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::region_disks::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/disks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .paths
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("paths", p)]));
                    let builder = req
                        .request_id
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.disk).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "disk",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionHealthCheckServices](super::stub::RegionHealthCheckServices) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-health-check-services")]
#[derive(Clone)]
pub struct RegionHealthCheckServices {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-health-check-services")]
impl std::fmt::Debug for RegionHealthCheckServices {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionHealthCheckServices")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-health-check-services")]
impl RegionHealthCheckServices {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-health-check-services")]
impl super::stub::RegionHealthCheckServices for RegionHealthCheckServices {
    async fn delete(
        &self,
        req: crate::model::region_health_check_services::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/healthCheckServices/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.health_check_service)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.health_check_service)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "health_check_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_health_check_services::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HealthCheckService>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/healthCheckServices/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.health_check_service)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.health_check_service)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "health_check_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_health_check_services::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/healthCheckServices",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_health_check_services::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HealthCheckServicesList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/healthCheckServices",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::region_health_check_services::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/healthCheckServices/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.health_check_service)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.health_check_service)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "health_check_service",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionHealthChecks](super::stub::RegionHealthChecks) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-health-checks")]
#[derive(Clone)]
pub struct RegionHealthChecks {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-health-checks")]
impl std::fmt::Debug for RegionHealthChecks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionHealthChecks")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-health-checks")]
impl RegionHealthChecks {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-health-checks")]
impl super::stub::RegionHealthChecks for RegionHealthChecks {
    async fn delete(
        &self,
        req: crate::model::region_health_checks::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/healthChecks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "health_check",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_health_checks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HealthCheck>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/healthChecks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "health_check",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_health_checks::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/healthChecks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_health_checks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::HealthCheckList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/healthChecks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::region_health_checks::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/healthChecks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "health_check",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::region_health_checks::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/healthChecks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.health_check).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "health_check",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionInstanceGroupManagers](super::stub::RegionInstanceGroupManagers) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-instance-group-managers")]
#[derive(Clone)]
pub struct RegionInstanceGroupManagers {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-instance-group-managers")]
impl std::fmt::Debug for RegionInstanceGroupManagers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionInstanceGroupManagers")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl RegionInstanceGroupManagers {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-instance-group-managers")]
impl super::stub::RegionInstanceGroupManagers for RegionInstanceGroupManagers {
    async fn abandon_instances(
        &self,
        req: crate::model::region_instance_group_managers::AbandonInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/abandonInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn apply_updates_to_instances(
        &self,
        req: crate::model::region_instance_group_managers::ApplyUpdatesToInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/applyUpdatesToInstances",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.region).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "region",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn create_instances(
        &self,
        req: crate::model::region_instance_group_managers::CreateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/createInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::region_instance_group_managers::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_instances(
        &self,
        req: crate::model::region_instance_group_managers::DeleteInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/deleteInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_per_instance_configs(
        &self,
        req: crate::model::region_instance_group_managers::DeletePerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/deletePerInstanceConfigs",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.region).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "region",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_instance_group_managers::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroupManager>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_instance_group_managers::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_instance_group_managers::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionInstanceGroupManagerList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_errors(
        &self,
        req: crate::model::region_instance_group_managers::ListErrorsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionInstanceGroupManagersListErrorsResponse>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/listErrors",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_managed_instances(
        &self,
        req: crate::model::region_instance_group_managers::ListManagedInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<crate::model::RegionInstanceGroupManagersListInstancesResponse>,
    > {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/listManagedInstances",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.region).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.filter.iter().fold(builder, |builder, p| builder.query(&[("filter", p)]));
            let builder = req.max_results.iter().fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
            let builder = req.order_by.iter().fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
            let builder = req.page_token.iter().fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
            let builder = req.return_partial_success.iter().fold(builder, |builder, p| builder.query(&[("returnPartialSuccess", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "region",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_per_instance_configs(
        &self,
        req: crate::model::region_instance_group_managers::ListPerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<crate::model::RegionInstanceGroupManagersListInstanceConfigsResp>,
    > {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/listPerInstanceConfigs",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.region).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.filter.iter().fold(builder, |builder, p| builder.query(&[("filter", p)]));
            let builder = req.max_results.iter().fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
            let builder = req.order_by.iter().fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
            let builder = req.page_token.iter().fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
            let builder = req.return_partial_success.iter().fold(builder, |builder, p| builder.query(&[("returnPartialSuccess", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "region",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::region_instance_group_managers::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch_per_instance_configs(
        &self,
        req: crate::model::region_instance_group_managers::PatchPerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/patchPerInstanceConfigs",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.region).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "region",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn recreate_instances(
        &self,
        req: crate::model::region_instance_group_managers::RecreateInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/recreateInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn resize(
        &self,
        req: crate::model::region_instance_group_managers::ResizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/resize",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = builder.query(&[("size", &req.size)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn resume_instances(
        &self,
        req: crate::model::region_instance_group_managers::ResumeInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/resumeInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_instance_template(
        &self,
        req: crate::model::region_instance_group_managers::SetInstanceTemplateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/setInstanceTemplate",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.region).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "region",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_target_pools(
        &self,
        req: crate::model::region_instance_group_managers::SetTargetPoolsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/setTargetPools",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn start_instances(
        &self,
        req: crate::model::region_instance_group_managers::StartInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/startInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn stop_instances(
        &self,
        req: crate::model::region_instance_group_managers::StopInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/stopInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn suspend_instances(
        &self,
        req: crate::model::region_instance_group_managers::SuspendInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/suspendInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.instance_group_manager)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group_manager",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_per_instance_configs(
        &self,
        req: crate::model::region_instance_group_managers::UpdatePerInstanceConfigsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/regions/{}/instanceGroupManagers/{}/updatePerInstanceConfigs",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.region).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "region",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.instance_group_manager).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "instance_group_manager",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionInstanceGroups](super::stub::RegionInstanceGroups) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-instance-groups")]
#[derive(Clone)]
pub struct RegionInstanceGroups {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-instance-groups")]
impl std::fmt::Debug for RegionInstanceGroups {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionInstanceGroups")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-instance-groups")]
impl RegionInstanceGroups {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-instance-groups")]
impl super::stub::RegionInstanceGroups for RegionInstanceGroups {
    async fn get(
        &self,
        req: crate::model::region_instance_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceGroup>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_instance_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionInstanceGroupList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_instances(
        &self,
        req: crate::model::region_instance_groups::ListInstancesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionInstanceGroupsListInstances>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroups/{}/listInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_named_ports(
        &self,
        req: crate::model::region_instance_groups::SetNamedPortsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroups/{}/setNamedPorts",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::region_instance_groups::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceGroups/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionInstanceTemplates](super::stub::RegionInstanceTemplates) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-instance-templates")]
#[derive(Clone)]
pub struct RegionInstanceTemplates {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-instance-templates")]
impl std::fmt::Debug for RegionInstanceTemplates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionInstanceTemplates")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-instance-templates")]
impl RegionInstanceTemplates {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-instance-templates")]
impl super::stub::RegionInstanceTemplates for RegionInstanceTemplates {
    async fn delete(
        &self,
        req: crate::model::region_instance_templates::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceTemplates/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_template).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_template).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_template",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_instance_templates::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceTemplate>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceTemplates/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instance_template).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instance_template).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instance_template",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_instance_templates::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceTemplates",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_instance_templates::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstanceTemplateList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instanceTemplates",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionInstances](super::stub::RegionInstances) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-instances")]
#[derive(Clone)]
pub struct RegionInstances {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-instances")]
impl std::fmt::Debug for RegionInstances {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionInstances")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-instances")]
impl RegionInstances {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-instances")]
impl super::stub::RegionInstances for RegionInstances {
    async fn bulk_insert(
        &self,
        req: crate::model::region_instances::BulkInsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instances/bulkInsert",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionInstantSnapshots](super::stub::RegionInstantSnapshots) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-instant-snapshots")]
#[derive(Clone)]
pub struct RegionInstantSnapshots {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-instant-snapshots")]
impl std::fmt::Debug for RegionInstantSnapshots {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionInstantSnapshots")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-instant-snapshots")]
impl RegionInstantSnapshots {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-instant-snapshots")]
impl super::stub::RegionInstantSnapshots for RegionInstantSnapshots {
    async fn delete(
        &self,
        req: crate::model::region_instant_snapshots::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instantSnapshots/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instant_snapshot).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instant_snapshot).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instant_snapshot",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_instant_snapshots::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstantSnapshot>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instantSnapshots/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.instant_snapshot).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.instant_snapshot).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "instant_snapshot",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::region_instant_snapshots::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instantSnapshots/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_instant_snapshots::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instantSnapshots",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_instant_snapshots::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::InstantSnapshotList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instantSnapshots",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::region_instant_snapshots::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instantSnapshots/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::region_instant_snapshots::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instantSnapshots/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::region_instant_snapshots::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/instantSnapshots/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionNetworkEndpointGroups](super::stub::RegionNetworkEndpointGroups) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-network-endpoint-groups")]
#[derive(Clone)]
pub struct RegionNetworkEndpointGroups {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-network-endpoint-groups")]
impl std::fmt::Debug for RegionNetworkEndpointGroups {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionNetworkEndpointGroups")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-network-endpoint-groups")]
impl RegionNetworkEndpointGroups {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-network-endpoint-groups")]
impl super::stub::RegionNetworkEndpointGroups for RegionNetworkEndpointGroups {
    async fn attach_network_endpoints(
        &self,
        req: crate::model::region_network_endpoint_groups::AttachNetworkEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/regions/{}/networkEndpointGroups/{}/attachNetworkEndpoints",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.region).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.network_endpoint_group).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "region",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.network_endpoint_group).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "network_endpoint_group",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::region_network_endpoint_groups::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/networkEndpointGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.network_endpoint_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.network_endpoint_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network_endpoint_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn detach_network_endpoints(
        &self,
        req: crate::model::region_network_endpoint_groups::DetachNetworkEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/regions/{}/networkEndpointGroups/{}/detachNetworkEndpoints",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.region).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.network_endpoint_group).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "region",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.network_endpoint_group).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "network_endpoint_group",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_network_endpoint_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroup>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/networkEndpointGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.network_endpoint_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.network_endpoint_group)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "network_endpoint_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_network_endpoint_groups::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/networkEndpointGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_network_endpoint_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroupList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/networkEndpointGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_network_endpoints(
        &self,
        req: crate::model::region_network_endpoint_groups::ListNetworkEndpointsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NetworkEndpointGroupsListNetworkEndpoints>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/regions/{}/networkEndpointGroups/{}/listNetworkEndpoints",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.region).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.network_endpoint_group).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.filter.iter().fold(builder, |builder, p| builder.query(&[("filter", p)]));
            let builder = req.max_results.iter().fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
            let builder = req.order_by.iter().fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
            let builder = req.page_token.iter().fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
            let builder = req.return_partial_success.iter().fold(builder, |builder, p| builder.query(&[("returnPartialSuccess", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "region",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.network_endpoint_group).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "network_endpoint_group",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionNetworkFirewallPolicies](super::stub::RegionNetworkFirewallPolicies) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-network-firewall-policies")]
#[derive(Clone)]
pub struct RegionNetworkFirewallPolicies {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-network-firewall-policies")]
impl std::fmt::Debug for RegionNetworkFirewallPolicies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionNetworkFirewallPolicies")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-network-firewall-policies")]
impl RegionNetworkFirewallPolicies {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-network-firewall-policies")]
impl super::stub::RegionNetworkFirewallPolicies for RegionNetworkFirewallPolicies {
    async fn add_association(
        &self,
        req: crate::model::region_network_firewall_policies::AddAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/firewallPolicies/{}/addAssociation",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .replace_existing_association
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("replaceExistingAssociation", p)])
                    });
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn add_rule(
        &self,
        req: crate::model::region_network_firewall_policies::AddRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/firewallPolicies/{}/addRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .max_priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxPriority", p)]));
                let builder = req
                    .min_priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("minPriority", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn clone_rules(
        &self,
        req: crate::model::region_network_firewall_policies::CloneRulesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/firewallPolicies/{}/cloneRules",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .source_firewall_policy
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("sourceFirewallPolicy", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::region_network_firewall_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/firewallPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_network_firewall_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/firewallPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_association(
        &self,
        req: crate::model::region_network_firewall_policies::GetAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyAssociation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/firewallPolicies/{}/getAssociation",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .name
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("name", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_effective_firewalls(
        &self,
        req: crate::model::region_network_firewall_policies::GetEffectiveFirewallsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<
            crate::model::RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse,
        >,
    > {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/firewallPolicies/getEffectiveFirewalls",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = builder.query(&[("network", &req.network)]);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::region_network_firewall_policies::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/firewallPolicies/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_rule(
        &self,
        req: crate::model::region_network_firewall_policies::GetRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyRule>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/firewallPolicies/{}/getRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_network_firewall_policies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/firewallPolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_network_firewall_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::FirewallPolicyList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/firewallPolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::region_network_firewall_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/firewallPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch_rule(
        &self,
        req: crate::model::region_network_firewall_policies::PatchRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/firewallPolicies/{}/patchRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_association(
        &self,
        req: crate::model::region_network_firewall_policies::RemoveAssociationRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/firewallPolicies/{}/removeAssociation",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .name
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("name", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_rule(
        &self,
        req: crate::model::region_network_firewall_policies::RemoveRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/firewallPolicies/{}/removeRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.firewall_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "firewall_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::region_network_firewall_policies::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/firewallPolicies/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::region_network_firewall_policies::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/firewallPolicies/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionNotificationEndpoints](super::stub::RegionNotificationEndpoints) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-notification-endpoints")]
#[derive(Clone)]
pub struct RegionNotificationEndpoints {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-notification-endpoints")]
impl std::fmt::Debug for RegionNotificationEndpoints {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionNotificationEndpoints")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-notification-endpoints")]
impl RegionNotificationEndpoints {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-notification-endpoints")]
impl super::stub::RegionNotificationEndpoints for RegionNotificationEndpoints {
    async fn delete(
        &self,
        req: crate::model::region_notification_endpoints::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/notificationEndpoints/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.notification_endpoint)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.notification_endpoint)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "notification_endpoint",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_notification_endpoints::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationEndpoint>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/notificationEndpoints/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.notification_endpoint)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.notification_endpoint)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "notification_endpoint",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_notification_endpoints::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/notificationEndpoints",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_notification_endpoints::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NotificationEndpointList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/notificationEndpoints",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionOperations](super::stub::RegionOperations) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-operations")]
#[derive(Clone)]
pub struct RegionOperations {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-operations")]
impl std::fmt::Debug for RegionOperations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionOperations")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-operations")]
impl RegionOperations {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-operations")]
impl super::stub::RegionOperations for RegionOperations {
    async fn delete(
        &self,
        req: crate::model::region_operations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_operations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn wait(
        &self,
        req: crate::model::region_operations::WaitRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}/wait",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [RegionSecurityPolicies](super::stub::RegionSecurityPolicies) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-security-policies")]
#[derive(Clone)]
pub struct RegionSecurityPolicies {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-security-policies")]
impl std::fmt::Debug for RegionSecurityPolicies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionSecurityPolicies")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-security-policies")]
impl RegionSecurityPolicies {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-security-policies")]
impl super::stub::RegionSecurityPolicies for RegionSecurityPolicies {
    async fn add_rule(
        &self,
        req: crate::model::region_security_policies::AddRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/securityPolicies/{}/addRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .validate_only
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("validateOnly", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::region_security_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/securityPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_security_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/securityPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_rule(
        &self,
        req: crate::model::region_security_policies::GetRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicyRule>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/securityPolicies/{}/getRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_security_policies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/securityPolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .validate_only
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("validateOnly", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_security_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicyList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/securityPolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::region_security_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/securityPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .request_id
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch_rule(
        &self,
        req: crate::model::region_security_policies::PatchRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/securityPolicies/{}/patchRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = (|| {
                    let builder = req
                        .priority
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    let builder = req
                        .validate_only
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("validateOnly", p)]));
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_rule(
        &self,
        req: crate::model::region_security_policies::RemoveRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/securityPolicies/{}/removeRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::region_security_policies::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/securityPolicies/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionSslCertificates](super::stub::RegionSslCertificates) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-ssl-certificates")]
#[derive(Clone)]
pub struct RegionSslCertificates {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-ssl-certificates")]
impl std::fmt::Debug for RegionSslCertificates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionSslCertificates")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-ssl-certificates")]
impl RegionSslCertificates {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-ssl-certificates")]
impl super::stub::RegionSslCertificates for RegionSslCertificates {
    async fn delete(
        &self,
        req: crate::model::region_ssl_certificates::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/sslCertificates/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.ssl_certificate).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.ssl_certificate).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "ssl_certificate",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_ssl_certificates::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCertificate>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/sslCertificates/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.ssl_certificate).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.ssl_certificate).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "ssl_certificate",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_ssl_certificates::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/sslCertificates",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_ssl_certificates::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCertificateList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/sslCertificates",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionSslPolicies](super::stub::RegionSslPolicies) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-ssl-policies")]
#[derive(Clone)]
pub struct RegionSslPolicies {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-ssl-policies")]
impl std::fmt::Debug for RegionSslPolicies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionSslPolicies")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-ssl-policies")]
impl RegionSslPolicies {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-ssl-policies")]
impl super::stub::RegionSslPolicies for RegionSslPolicies {
    async fn delete(
        &self,
        req: crate::model::region_ssl_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/sslPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.ssl_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.ssl_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "ssl_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_ssl_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslPolicy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/sslPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.ssl_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.ssl_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "ssl_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_ssl_policies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/sslPolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_ssl_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslPoliciesList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/sslPolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_available_features(
        &self,
        req: crate::model::region_ssl_policies::ListAvailableFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslPoliciesListAvailableFeaturesResponse>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/sslPolicies/listAvailableFeatures",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::region_ssl_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/sslPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.ssl_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.ssl_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "ssl_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionTargetHttpProxies](super::stub::RegionTargetHttpProxies) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-target-http-proxies")]
#[derive(Clone)]
pub struct RegionTargetHttpProxies {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-target-http-proxies")]
impl std::fmt::Debug for RegionTargetHttpProxies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionTargetHttpProxies")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-target-http-proxies")]
impl RegionTargetHttpProxies {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-target-http-proxies")]
impl super::stub::RegionTargetHttpProxies for RegionTargetHttpProxies {
    async fn delete(
        &self,
        req: crate::model::region_target_http_proxies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetHttpProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_http_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_http_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_http_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_target_http_proxies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpProxy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetHttpProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_http_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_http_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_http_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_target_http_proxies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetHttpProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_target_http_proxies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpProxyList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetHttpProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_url_map(
        &self,
        req: crate::model::region_target_http_proxies::SetUrlMapRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetHttpProxies/{}/setUrlMap",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_http_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_http_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_http_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionTargetHttpsProxies](super::stub::RegionTargetHttpsProxies) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-target-https-proxies")]
#[derive(Clone)]
pub struct RegionTargetHttpsProxies {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-target-https-proxies")]
impl std::fmt::Debug for RegionTargetHttpsProxies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionTargetHttpsProxies")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-target-https-proxies")]
impl RegionTargetHttpsProxies {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-target-https-proxies")]
impl super::stub::RegionTargetHttpsProxies for RegionTargetHttpsProxies {
    async fn delete(
        &self,
        req: crate::model::region_target_https_proxies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetHttpsProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_https_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_target_https_proxies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpsProxy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetHttpsProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_https_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_target_https_proxies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetHttpsProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_target_https_proxies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpsProxyList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetHttpsProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::region_target_https_proxies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetHttpsProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_https_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_ssl_certificates(
        &self,
        req: crate::model::region_target_https_proxies::SetSslCertificatesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetHttpsProxies/{}/setSslCertificates",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_https_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_url_map(
        &self,
        req: crate::model::region_target_https_proxies::SetUrlMapRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetHttpsProxies/{}/setUrlMap",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_https_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionTargetTcpProxies](super::stub::RegionTargetTcpProxies) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-target-tcp-proxies")]
#[derive(Clone)]
pub struct RegionTargetTcpProxies {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-target-tcp-proxies")]
impl std::fmt::Debug for RegionTargetTcpProxies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionTargetTcpProxies")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-target-tcp-proxies")]
impl RegionTargetTcpProxies {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-target-tcp-proxies")]
impl super::stub::RegionTargetTcpProxies for RegionTargetTcpProxies {
    async fn delete(
        &self,
        req: crate::model::region_target_tcp_proxies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetTcpProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_tcp_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_tcp_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_tcp_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_target_tcp_proxies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetTcpProxy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetTcpProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_tcp_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_tcp_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_tcp_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_target_tcp_proxies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetTcpProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_target_tcp_proxies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetTcpProxyList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetTcpProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionUrlMaps](super::stub::RegionUrlMaps) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-url-maps")]
#[derive(Clone)]
pub struct RegionUrlMaps {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-url-maps")]
impl std::fmt::Debug for RegionUrlMaps {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionUrlMaps")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-url-maps")]
impl RegionUrlMaps {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-url-maps")]
impl super::stub::RegionUrlMaps for RegionUrlMaps {
    async fn delete(
        &self,
        req: crate::model::region_url_maps::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/urlMaps/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "url_map",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::region_url_maps::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UrlMap>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/urlMaps/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "url_map",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::region_url_maps::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/urlMaps",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::region_url_maps::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UrlMapList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/urlMaps",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::region_url_maps::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/urlMaps/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "url_map",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::region_url_maps::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/urlMaps/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "url_map",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn validate(
        &self,
        req: crate::model::region_url_maps::ValidateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UrlMapsValidateResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/urlMaps/{}/validate",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "url_map",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [RegionZones](super::stub::RegionZones) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "region-zones")]
#[derive(Clone)]
pub struct RegionZones {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "region-zones")]
impl std::fmt::Debug for RegionZones {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("RegionZones")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "region-zones")]
impl RegionZones {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "region-zones")]
impl super::stub::RegionZones for RegionZones {
    async fn list(
        &self,
        req: crate::model::region_zones::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ZoneList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/zones",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [Regions](super::stub::Regions) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "regions")]
#[derive(Clone)]
pub struct Regions {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "regions")]
impl std::fmt::Debug for Regions {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Regions")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "regions")]
impl Regions {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "regions")]
impl super::stub::Regions for Regions {
    async fn get(
        &self,
        req: crate::model::regions::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Region>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::regions::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RegionList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [ReservationBlocks](super::stub::ReservationBlocks) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "reservation-blocks")]
#[derive(Clone)]
pub struct ReservationBlocks {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "reservation-blocks")]
impl std::fmt::Debug for ReservationBlocks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ReservationBlocks")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "reservation-blocks")]
impl ReservationBlocks {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "reservation-blocks")]
impl super::stub::ReservationBlocks for ReservationBlocks {
    async fn get(
        &self,
        req: crate::model::reservation_blocks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReservationBlocksGetResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/reservations/{}/reservationBlocks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.reservation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.reservation_block).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .view
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("view", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.reservation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "reservation",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.reservation_block).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "reservation_block",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::reservation_blocks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReservationBlocksListResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/reservations/{}/reservationBlocks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.reservation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.reservation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "reservation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn perform_maintenance(
        &self,
        req: crate::model::reservation_blocks::PerformMaintenanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/reservations/{}/reservationBlocks/{}/performMaintenance",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.reservation).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.reservation_block).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.reservation).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "reservation",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.reservation_block).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "reservation_block",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [ReservationSubBlocks](super::stub::ReservationSubBlocks) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "reservation-sub-blocks")]
#[derive(Clone)]
pub struct ReservationSubBlocks {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "reservation-sub-blocks")]
impl std::fmt::Debug for ReservationSubBlocks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ReservationSubBlocks")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "reservation-sub-blocks")]
impl ReservationSubBlocks {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "reservation-sub-blocks")]
impl super::stub::ReservationSubBlocks for ReservationSubBlocks {
    async fn get(
        &self,
        req: crate::model::reservation_sub_blocks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReservationSubBlocksGetResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/{}/reservationSubBlocks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.parent_name).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.reservation_sub_block)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent_name).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "parent_name",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.reservation_sub_block)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "reservation_sub_block",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::reservation_sub_blocks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReservationSubBlocksListResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/{}/reservationSubBlocks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.parent_name).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent_name).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "parent_name",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn perform_maintenance(
        &self,
        req: crate::model::reservation_sub_blocks::PerformMaintenanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/zones/{}/{}/reservationSubBlocks/{}/performMaintenance",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.zone).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.parent_name).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
                try_match(Some(&req).map(|m| &m.reservation_sub_block).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::POST, path);
            let builder = req.request_id.iter().fold(builder, |builder, p| builder.query(&[("requestId", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::POST)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "zone",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.parent_name).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "parent_name",
                    "*");
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.reservation_sub_block).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "reservation_sub_block",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn report_faulty(
        &self,
        req: crate::model::reservation_sub_blocks::ReportFaultyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/{}/reservationSubBlocks/{}/reportFaulty",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.parent_name).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.reservation_sub_block)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.parent_name).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "parent_name",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.reservation_sub_block)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "reservation_sub_block",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [Reservations](super::stub::Reservations) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "reservations")]
#[derive(Clone)]
pub struct Reservations {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "reservations")]
impl std::fmt::Debug for Reservations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Reservations")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "reservations")]
impl Reservations {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "reservations")]
impl super::stub::Reservations for Reservations {
    async fn aggregated_list(
        &self,
        req: crate::model::reservations::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReservationAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/reservations",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::reservations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/reservations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.reservation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.reservation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "reservation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::reservations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Reservation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/reservations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.reservation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.reservation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "reservation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::reservations::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/reservations/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::reservations::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/reservations",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::reservations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ReservationList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/reservations",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn perform_maintenance(
        &self,
        req: crate::model::reservations::PerformMaintenanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/reservations/{}/performMaintenance",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.reservation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.reservation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "reservation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn resize(
        &self,
        req: crate::model::reservations::ResizeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/reservations/{}/resize",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.reservation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.reservation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "reservation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::reservations::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/reservations/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::reservations::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/reservations/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::reservations::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/reservations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.reservation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .paths
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("paths", p)]));
                    let builder = req
                        .request_id
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.reservation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "reservation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [ResourcePolicies](super::stub::ResourcePolicies) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "resource-policies")]
#[derive(Clone)]
pub struct ResourcePolicies {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "resource-policies")]
impl std::fmt::Debug for ResourcePolicies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ResourcePolicies")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "resource-policies")]
impl ResourcePolicies {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "resource-policies")]
impl super::stub::ResourcePolicies for ResourcePolicies {
    async fn aggregated_list(
        &self,
        req: crate::model::resource_policies::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResourcePolicyAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/resourcePolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::resource_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/resourcePolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::resource_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResourcePolicy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/resourcePolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::resource_policies::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/resourcePolicies/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::resource_policies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/resourcePolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::resource_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ResourcePolicyList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/resourcePolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::resource_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/resourcePolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .request_id
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::resource_policies::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/resourcePolicies/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::resource_policies::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/resourcePolicies/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [Routers](super::stub::Routers) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "routers")]
#[derive(Clone)]
pub struct Routers {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "routers")]
impl std::fmt::Debug for Routers {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Routers")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "routers")]
impl Routers {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "routers")]
impl super::stub::Routers for Routers {
    async fn aggregated_list(
        &self,
        req: crate::model::routers::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RouterAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/routers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::routers::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/routers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "router",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete_route_policy(
        &self,
        req: crate::model::routers::DeleteRoutePolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/routers/{}/deleteRoutePolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .policy
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("policy", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "router",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::routers::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Router>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/routers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "router",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_nat_ip_info(
        &self,
        req: crate::model::routers::GetNatIpInfoRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::NatIpInfoResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/routers/{}/getNatIpInfo",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .nat_name
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("natName", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "router",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_nat_mapping_info(
        &self,
        req: crate::model::routers::GetNatMappingInfoRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::VmEndpointNatMappingsList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/routers/{}/getNatMappingInfo",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .nat_name
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("natName", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "router",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_route_policy(
        &self,
        req: crate::model::routers::GetRoutePolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RoutersGetRoutePolicyResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/routers/{}/getRoutePolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .policy
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("policy", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "router",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_router_status(
        &self,
        req: crate::model::routers::GetRouterStatusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RouterStatusResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/routers/{}/getRouterStatus",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "router",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::routers::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/routers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::routers::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RouterList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/routers",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_bgp_routes(
        &self,
        req: crate::model::routers::ListBgpRoutesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RoutersListBgpRoutes>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/routers/{}/listBgpRoutes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .address_family
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("addressFamily", p)]));
                let builder = req.destination_prefix.iter().fold(builder, |builder, p| {
                    builder.query(&[("destinationPrefix", p)])
                });
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .peer
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("peer", p)]));
                let builder = req
                    .policy_applied
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("policyApplied", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .route_type
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("routeType", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "router",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_route_policies(
        &self,
        req: crate::model::routers::ListRoutePoliciesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RoutersListRoutePolicies>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/routers/{}/listRoutePolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "router",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::routers::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/routers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "router",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch_route_policy(
        &self,
        req: crate::model::routers::PatchRoutePolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/routers/{}/patchRoutePolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "router",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn preview(
        &self,
        req: crate::model::routers::PreviewRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RoutersPreviewResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/routers/{}/preview",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "router",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::routers::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/routers/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "router",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update_route_policy(
        &self,
        req: crate::model::routers::UpdateRoutePolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/routers/{}/updateRoutePolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.router).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "router",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [Routes](super::stub::Routes) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "routes")]
#[derive(Clone)]
pub struct Routes {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "routes")]
impl std::fmt::Debug for Routes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Routes")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "routes")]
impl Routes {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "routes")]
impl super::stub::Routes for Routes {
    async fn delete(
        &self,
        req: crate::model::routes::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/routes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.route).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.route).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "route",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::routes::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Route>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/routes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.route).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.route).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "route",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::routes::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/routes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::routes::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::RouteList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/routes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [SecurityPolicies](super::stub::SecurityPolicies) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "security-policies")]
#[derive(Clone)]
pub struct SecurityPolicies {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "security-policies")]
impl std::fmt::Debug for SecurityPolicies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SecurityPolicies")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "security-policies")]
impl SecurityPolicies {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "security-policies")]
impl super::stub::SecurityPolicies for SecurityPolicies {
    async fn add_rule(
        &self,
        req: crate::model::security_policies::AddRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/securityPolicies/{}/addRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .validate_only
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("validateOnly", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn aggregated_list(
        &self,
        req: crate::model::security_policies::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPoliciesAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/securityPolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::security_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/securityPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::security_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/securityPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_rule(
        &self,
        req: crate::model::security_policies::GetRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicyRule>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/securityPolicies/{}/getRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::security_policies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/securityPolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .validate_only
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("validateOnly", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::security_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SecurityPolicyList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/securityPolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_preconfigured_expression_sets(
        &self,
        req: crate::model::security_policies::ListPreconfiguredExpressionSetsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<
        gax::response::Response<
            crate::model::SecurityPoliciesListPreconfiguredExpressionSetsResponse,
        >,
    > {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
        .or_else(|| {
            let path = format!(
                "/compute/v1/projects/{}/global/securityPolicies/listPreconfiguredExpressionSets",
                try_match(Some(&req).map(|m| &m.project).map(|s| s.as_str()), &[Segment::SingleWildcard])?,
            );

            let builder = self
                .inner
                .builder(reqwest::Method::GET, path);
            let builder = req.filter.iter().fold(builder, |builder, p| builder.query(&[("filter", p)]));
            let builder = req.max_results.iter().fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
            let builder = req.order_by.iter().fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
            let builder = req.page_token.iter().fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
            let builder = req.return_partial_success.iter().fold(builder, |builder, p| builder.query(&[("returnPartialSuccess", p)]));
            let builder = Ok(builder);
            Some(builder.map(|b| (b, reqwest::Method::GET)))
        })
        .ok_or_else(|| {
            let mut paths = Vec::new();
            {
                let builder = PathMismatchBuilder::default();
                let builder = builder.maybe_add(
                    Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                    &[Segment::SingleWildcard],
                    "project",
                    "*");
                paths.push(builder.build());
            }
            gax::error::Error::binding(BindingError { paths })
        })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::security_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/securityPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .request_id
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch_rule(
        &self,
        req: crate::model::security_policies::PatchRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/securityPolicies/{}/patchRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = (|| {
                    let builder = req
                        .priority
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    let builder = req
                        .validate_only
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("validateOnly", p)]));
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_rule(
        &self,
        req: crate::model::security_policies::RemoveRuleRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/securityPolicies/{}/removeRule",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .priority
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("priority", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.security_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "security_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::security_policies::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/securityPolicies/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [ServiceAttachments](super::stub::ServiceAttachments) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "service-attachments")]
#[derive(Clone)]
pub struct ServiceAttachments {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "service-attachments")]
impl std::fmt::Debug for ServiceAttachments {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ServiceAttachments")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "service-attachments")]
impl ServiceAttachments {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "service-attachments")]
impl super::stub::ServiceAttachments for ServiceAttachments {
    async fn aggregated_list(
        &self,
        req: crate::model::service_attachments::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServiceAttachmentAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/serviceAttachments",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::service_attachments::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/serviceAttachments/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.service_attachment)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.service_attachment)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "service_attachment",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::service_attachments::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServiceAttachment>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/serviceAttachments/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.service_attachment)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .show_nat_ips
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("showNatIps", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.service_attachment)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "service_attachment",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::service_attachments::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/serviceAttachments/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::service_attachments::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/serviceAttachments",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::service_attachments::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ServiceAttachmentList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/serviceAttachments",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::service_attachments::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/serviceAttachments/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.service_attachment)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.service_attachment)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "service_attachment",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::service_attachments::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/serviceAttachments/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::service_attachments::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/serviceAttachments/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [SnapshotSettings](super::stub::SnapshotSettings) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "snapshot-settings")]
#[derive(Clone)]
pub struct SnapshotSettings {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "snapshot-settings")]
impl std::fmt::Debug for SnapshotSettings {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SnapshotSettings")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "snapshot-settings")]
impl SnapshotSettings {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "snapshot-settings")]
impl super::stub::SnapshotSettings for SnapshotSettings {
    async fn get(
        &self,
        req: crate::model::snapshot_settings::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SnapshotSettings>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/snapshotSettings",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::snapshot_settings::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/snapshotSettings",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .request_id
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [Snapshots](super::stub::Snapshots) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "snapshots")]
#[derive(Clone)]
pub struct Snapshots {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "snapshots")]
impl std::fmt::Debug for Snapshots {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Snapshots")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "snapshots")]
impl Snapshots {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "snapshots")]
impl super::stub::Snapshots for Snapshots {
    async fn delete(
        &self,
        req: crate::model::snapshots::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/snapshots/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.snapshot).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.snapshot).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "snapshot",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::snapshots::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Snapshot>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/snapshots/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.snapshot).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.snapshot).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "snapshot",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::snapshots::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/snapshots/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::snapshots::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/snapshots",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::snapshots::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SnapshotList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/snapshots",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::snapshots::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/snapshots/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::snapshots::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/snapshots/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::snapshots::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/snapshots/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [SslCertificates](super::stub::SslCertificates) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "ssl-certificates")]
#[derive(Clone)]
pub struct SslCertificates {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "ssl-certificates")]
impl std::fmt::Debug for SslCertificates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SslCertificates")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "ssl-certificates")]
impl SslCertificates {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "ssl-certificates")]
impl super::stub::SslCertificates for SslCertificates {
    async fn aggregated_list(
        &self,
        req: crate::model::ssl_certificates::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCertificateAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/sslCertificates",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::ssl_certificates::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/sslCertificates/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.ssl_certificate).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.ssl_certificate).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "ssl_certificate",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::ssl_certificates::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCertificate>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/sslCertificates/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.ssl_certificate).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.ssl_certificate).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "ssl_certificate",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::ssl_certificates::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/sslCertificates",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::ssl_certificates::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslCertificateList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/sslCertificates",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [SslPolicies](super::stub::SslPolicies) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "ssl-policies")]
#[derive(Clone)]
pub struct SslPolicies {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "ssl-policies")]
impl std::fmt::Debug for SslPolicies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("SslPolicies")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "ssl-policies")]
impl SslPolicies {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "ssl-policies")]
impl super::stub::SslPolicies for SslPolicies {
    async fn aggregated_list(
        &self,
        req: crate::model::ssl_policies::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslPoliciesAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/sslPolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::ssl_policies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/sslPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.ssl_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.ssl_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "ssl_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::ssl_policies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslPolicy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/sslPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.ssl_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.ssl_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "ssl_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::ssl_policies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/sslPolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::ssl_policies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslPoliciesList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/sslPolicies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_available_features(
        &self,
        req: crate::model::ssl_policies::ListAvailableFeaturesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SslPoliciesListAvailableFeaturesResponse>>
    {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/sslPolicies/listAvailableFeatures",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::ssl_policies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/sslPolicies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.ssl_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.ssl_policy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "ssl_policy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [StoragePoolTypes](super::stub::StoragePoolTypes) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "storage-pool-types")]
#[derive(Clone)]
pub struct StoragePoolTypes {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "storage-pool-types")]
impl std::fmt::Debug for StoragePoolTypes {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("StoragePoolTypes")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "storage-pool-types")]
impl StoragePoolTypes {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "storage-pool-types")]
impl super::stub::StoragePoolTypes for StoragePoolTypes {
    async fn aggregated_list(
        &self,
        req: crate::model::storage_pool_types::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::StoragePoolTypeAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/storagePoolTypes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::storage_pool_types::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::StoragePoolType>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/storagePoolTypes/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.storage_pool_type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.storage_pool_type).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "storage_pool_type",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::storage_pool_types::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::StoragePoolTypeList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/storagePoolTypes",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [StoragePools](super::stub::StoragePools) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "storage-pools")]
#[derive(Clone)]
pub struct StoragePools {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "storage-pools")]
impl std::fmt::Debug for StoragePools {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("StoragePools")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "storage-pools")]
impl StoragePools {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "storage-pools")]
impl super::stub::StoragePools for StoragePools {
    async fn aggregated_list(
        &self,
        req: crate::model::storage_pools::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::StoragePoolAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/storagePools",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::storage_pools::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/storagePools/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.storage_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.storage_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "storage_pool",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::storage_pools::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::StoragePool>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/storagePools/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.storage_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.storage_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "storage_pool",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::storage_pools::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/storagePools/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::storage_pools::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/storagePools",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::storage_pools::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::StoragePoolList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/storagePools",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_disks(
        &self,
        req: crate::model::storage_pools::ListDisksRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::StoragePoolListDisks>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/storagePools/{}/listDisks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.storage_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.storage_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "storage_pool",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::storage_pools::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/storagePools/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::storage_pools::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/storagePools/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::storage_pools::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/storagePools/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.storage_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .request_id
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.storage_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "storage_pool",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [Subnetworks](super::stub::Subnetworks) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "subnetworks")]
#[derive(Clone)]
pub struct Subnetworks {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "subnetworks")]
impl std::fmt::Debug for Subnetworks {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Subnetworks")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "subnetworks")]
impl Subnetworks {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "subnetworks")]
impl super::stub::Subnetworks for Subnetworks {
    async fn aggregated_list(
        &self,
        req: crate::model::subnetworks::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SubnetworkAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/subnetworks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::subnetworks::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/subnetworks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.subnetwork).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.subnetwork).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "subnetwork",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn expand_ip_cidr_range(
        &self,
        req: crate::model::subnetworks::ExpandIpCidrRangeRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/subnetworks/{}/expandIpCidrRange",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.subnetwork).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.subnetwork).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "subnetwork",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::subnetworks::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Subnetwork>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/subnetworks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.subnetwork).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .views
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("views", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.subnetwork).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "subnetwork",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_iam_policy(
        &self,
        req: crate::model::subnetworks::GetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/subnetworks/{}/getIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .options_requested_policy_version
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("optionsRequestedPolicyVersion", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::subnetworks::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/subnetworks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::subnetworks::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::SubnetworkList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/subnetworks",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .views
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("views", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list_usable(
        &self,
        req: crate::model::subnetworks::ListUsableRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UsableSubnetworksAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/subnetworks/listUsable",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req.service_project.iter().fold(builder, |builder, p| {
                    builder.query(&[("serviceProject", p)])
                });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::subnetworks::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/subnetworks/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.subnetwork).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .drain_timeout_seconds
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("drainTimeoutSeconds", p)])
                    });
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.subnetwork).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "subnetwork",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_iam_policy(
        &self,
        req: crate::model::subnetworks::SetIamPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Policy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/subnetworks/{}/setIamPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_private_ip_google_access(
        &self,
        req: crate::model::subnetworks::SetPrivateIpGoogleAccessRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/subnetworks/{}/setPrivateIpGoogleAccess",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.subnetwork).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.subnetwork).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "subnetwork",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::subnetworks::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/subnetworks/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [TargetGrpcProxies](super::stub::TargetGrpcProxies) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "target-grpc-proxies")]
#[derive(Clone)]
pub struct TargetGrpcProxies {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "target-grpc-proxies")]
impl std::fmt::Debug for TargetGrpcProxies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("TargetGrpcProxies")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "target-grpc-proxies")]
impl TargetGrpcProxies {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "target-grpc-proxies")]
impl super::stub::TargetGrpcProxies for TargetGrpcProxies {
    async fn delete(
        &self,
        req: crate::model::target_grpc_proxies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetGrpcProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_grpc_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_grpc_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_grpc_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::target_grpc_proxies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetGrpcProxy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetGrpcProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_grpc_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_grpc_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_grpc_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::target_grpc_proxies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetGrpcProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::target_grpc_proxies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetGrpcProxyList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetGrpcProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::target_grpc_proxies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetGrpcProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_grpc_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_grpc_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_grpc_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [TargetHttpProxies](super::stub::TargetHttpProxies) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "target-http-proxies")]
#[derive(Clone)]
pub struct TargetHttpProxies {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "target-http-proxies")]
impl std::fmt::Debug for TargetHttpProxies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("TargetHttpProxies")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "target-http-proxies")]
impl TargetHttpProxies {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "target-http-proxies")]
impl super::stub::TargetHttpProxies for TargetHttpProxies {
    async fn aggregated_list(
        &self,
        req: crate::model::target_http_proxies::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpProxyAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/targetHttpProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::target_http_proxies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetHttpProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_http_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_http_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_http_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::target_http_proxies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpProxy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetHttpProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_http_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_http_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_http_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::target_http_proxies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetHttpProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::target_http_proxies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpProxyList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetHttpProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::target_http_proxies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetHttpProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_http_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_http_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_http_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_url_map(
        &self,
        req: crate::model::target_http_proxies::SetUrlMapRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/targetHttpProxies/{}/setUrlMap",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_http_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_http_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_http_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [TargetHttpsProxies](super::stub::TargetHttpsProxies) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "target-https-proxies")]
#[derive(Clone)]
pub struct TargetHttpsProxies {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "target-https-proxies")]
impl std::fmt::Debug for TargetHttpsProxies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("TargetHttpsProxies")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "target-https-proxies")]
impl TargetHttpsProxies {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "target-https-proxies")]
impl super::stub::TargetHttpsProxies for TargetHttpsProxies {
    async fn aggregated_list(
        &self,
        req: crate::model::target_https_proxies::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpsProxyAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/targetHttpsProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::target_https_proxies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetHttpsProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_https_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::target_https_proxies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpsProxy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetHttpsProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_https_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::target_https_proxies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetHttpsProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::target_https_proxies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetHttpsProxyList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetHttpsProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::target_https_proxies::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetHttpsProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_https_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_certificate_map(
        &self,
        req: crate::model::target_https_proxies::SetCertificateMapRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetHttpsProxies/{}/setCertificateMap",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_https_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_quic_override(
        &self,
        req: crate::model::target_https_proxies::SetQuicOverrideRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetHttpsProxies/{}/setQuicOverride",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_https_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_ssl_certificates(
        &self,
        req: crate::model::target_https_proxies::SetSslCertificatesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/targetHttpsProxies/{}/setSslCertificates",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_https_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_ssl_policy(
        &self,
        req: crate::model::target_https_proxies::SetSslPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetHttpsProxies/{}/setSslPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_https_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_url_map(
        &self,
        req: crate::model::target_https_proxies::SetUrlMapRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/targetHttpsProxies/{}/setUrlMap",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.target_https_proxy)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_https_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [TargetInstances](super::stub::TargetInstances) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "target-instances")]
#[derive(Clone)]
pub struct TargetInstances {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "target-instances")]
impl std::fmt::Debug for TargetInstances {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("TargetInstances")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "target-instances")]
impl TargetInstances {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "target-instances")]
impl super::stub::TargetInstances for TargetInstances {
    async fn aggregated_list(
        &self,
        req: crate::model::target_instances::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetInstanceAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/targetInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::target_instances::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/targetInstances/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::target_instances::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetInstance>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/targetInstances/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::target_instances::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/targetInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::target_instances::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetInstanceList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/targetInstances",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_security_policy(
        &self,
        req: crate::model::target_instances::SetSecurityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/targetInstances/{}/setSecurityPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_instance).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_instance",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::target_instances::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/targetInstances/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [TargetPools](super::stub::TargetPools) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "target-pools")]
#[derive(Clone)]
pub struct TargetPools {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "target-pools")]
impl std::fmt::Debug for TargetPools {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("TargetPools")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "target-pools")]
impl TargetPools {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "target-pools")]
impl super::stub::TargetPools for TargetPools {
    async fn add_health_check(
        &self,
        req: crate::model::target_pools::AddHealthCheckRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetPools/{}/addHealthCheck",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_pool",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn add_instance(
        &self,
        req: crate::model::target_pools::AddInstanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetPools/{}/addInstance",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_pool",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn aggregated_list(
        &self,
        req: crate::model::target_pools::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetPoolAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/targetPools",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::target_pools::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetPools/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_pool",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::target_pools::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetPool>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetPools/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_pool",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_health(
        &self,
        req: crate::model::target_pools::GetHealthRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetPoolInstanceHealth>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetPools/{}/getHealth",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_pool",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::target_pools::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetPools",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::target_pools::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetPoolList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetPools",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_health_check(
        &self,
        req: crate::model::target_pools::RemoveHealthCheckRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetPools/{}/removeHealthCheck",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_pool",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn remove_instance(
        &self,
        req: crate::model::target_pools::RemoveInstanceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetPools/{}/removeInstance",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_pool",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_backup(
        &self,
        req: crate::model::target_pools::SetBackupRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetPools/{}/setBackup",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .failover_ratio
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("failoverRatio", p)]));
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_pool",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_security_policy(
        &self,
        req: crate::model::target_pools::SetSecurityPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetPools/{}/setSecurityPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_pool).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_pool",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::target_pools::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetPools/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [TargetSslProxies](super::stub::TargetSslProxies) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "target-ssl-proxies")]
#[derive(Clone)]
pub struct TargetSslProxies {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "target-ssl-proxies")]
impl std::fmt::Debug for TargetSslProxies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("TargetSslProxies")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "target-ssl-proxies")]
impl TargetSslProxies {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "target-ssl-proxies")]
impl super::stub::TargetSslProxies for TargetSslProxies {
    async fn delete(
        &self,
        req: crate::model::target_ssl_proxies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetSslProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_ssl_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_ssl_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_ssl_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::target_ssl_proxies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetSslProxy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetSslProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_ssl_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_ssl_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_ssl_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::target_ssl_proxies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetSslProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::target_ssl_proxies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetSslProxyList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetSslProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_backend_service(
        &self,
        req: crate::model::target_ssl_proxies::SetBackendServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetSslProxies/{}/setBackendService",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_ssl_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_ssl_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_ssl_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_certificate_map(
        &self,
        req: crate::model::target_ssl_proxies::SetCertificateMapRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetSslProxies/{}/setCertificateMap",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_ssl_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_ssl_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_ssl_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_proxy_header(
        &self,
        req: crate::model::target_ssl_proxies::SetProxyHeaderRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetSslProxies/{}/setProxyHeader",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_ssl_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_ssl_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_ssl_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_ssl_certificates(
        &self,
        req: crate::model::target_ssl_proxies::SetSslCertificatesRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetSslProxies/{}/setSslCertificates",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_ssl_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_ssl_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_ssl_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_ssl_policy(
        &self,
        req: crate::model::target_ssl_proxies::SetSslPolicyRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetSslProxies/{}/setSslPolicy",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_ssl_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_ssl_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_ssl_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [TargetTcpProxies](super::stub::TargetTcpProxies) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "target-tcp-proxies")]
#[derive(Clone)]
pub struct TargetTcpProxies {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "target-tcp-proxies")]
impl std::fmt::Debug for TargetTcpProxies {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("TargetTcpProxies")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "target-tcp-proxies")]
impl TargetTcpProxies {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "target-tcp-proxies")]
impl super::stub::TargetTcpProxies for TargetTcpProxies {
    async fn aggregated_list(
        &self,
        req: crate::model::target_tcp_proxies::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetTcpProxyAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/targetTcpProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::target_tcp_proxies::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetTcpProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_tcp_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_tcp_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_tcp_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::target_tcp_proxies::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetTcpProxy>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetTcpProxies/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_tcp_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_tcp_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_tcp_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::target_tcp_proxies::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetTcpProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::target_tcp_proxies::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetTcpProxyList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetTcpProxies",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_backend_service(
        &self,
        req: crate::model::target_tcp_proxies::SetBackendServiceRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetTcpProxies/{}/setBackendService",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_tcp_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_tcp_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_tcp_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_proxy_header(
        &self,
        req: crate::model::target_tcp_proxies::SetProxyHeaderRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/targetTcpProxies/{}/setProxyHeader",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.target_tcp_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.target_tcp_proxy).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_tcp_proxy",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [TargetVpnGateways](super::stub::TargetVpnGateways) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "target-vpn-gateways")]
#[derive(Clone)]
pub struct TargetVpnGateways {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "target-vpn-gateways")]
impl std::fmt::Debug for TargetVpnGateways {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("TargetVpnGateways")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "target-vpn-gateways")]
impl TargetVpnGateways {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "target-vpn-gateways")]
impl super::stub::TargetVpnGateways for TargetVpnGateways {
    async fn aggregated_list(
        &self,
        req: crate::model::target_vpn_gateways::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetVpnGatewayAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/targetVpnGateways",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::target_vpn_gateways::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetVpnGateways/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.target_vpn_gateway)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.target_vpn_gateway)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_vpn_gateway",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::target_vpn_gateways::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetVpnGateway>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetVpnGateways/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.target_vpn_gateway)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.target_vpn_gateway)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "target_vpn_gateway",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::target_vpn_gateways::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetVpnGateways",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::target_vpn_gateways::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TargetVpnGatewayList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetVpnGateways",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::target_vpn_gateways::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/targetVpnGateways/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [UrlMaps](super::stub::UrlMaps) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "url-maps")]
#[derive(Clone)]
pub struct UrlMaps {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "url-maps")]
impl std::fmt::Debug for UrlMaps {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("UrlMaps")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "url-maps")]
impl UrlMaps {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "url-maps")]
impl super::stub::UrlMaps for UrlMaps {
    async fn aggregated_list(
        &self,
        req: crate::model::url_maps::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UrlMapsAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/urlMaps",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::url_maps::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/urlMaps/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "url_map",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::url_maps::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UrlMap>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/urlMaps/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "url_map",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::url_maps::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/urlMaps",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn invalidate_cache(
        &self,
        req: crate::model::url_maps::InvalidateCacheRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/urlMaps/{}/invalidateCache",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "url_map",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::url_maps::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UrlMapList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/urlMaps",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::url_maps::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/urlMaps/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "url_map",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn update(
        &self,
        req: crate::model::url_maps::UpdateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/urlMaps/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PUT, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::PUT)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "url_map",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn validate(
        &self,
        req: crate::model::url_maps::ValidateRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::UrlMapsValidateResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/urlMaps/{}/validate",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.url_map).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "url_map",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [VpnGateways](super::stub::VpnGateways) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "vpn-gateways")]
#[derive(Clone)]
pub struct VpnGateways {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "vpn-gateways")]
impl std::fmt::Debug for VpnGateways {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("VpnGateways")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "vpn-gateways")]
impl VpnGateways {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "vpn-gateways")]
impl super::stub::VpnGateways for VpnGateways {
    async fn aggregated_list(
        &self,
        req: crate::model::vpn_gateways::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::VpnGatewayAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/vpnGateways",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::vpn_gateways::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/vpnGateways/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.vpn_gateway).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.vpn_gateway).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "vpn_gateway",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::vpn_gateways::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::VpnGateway>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/vpnGateways/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.vpn_gateway).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.vpn_gateway).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "vpn_gateway",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_status(
        &self,
        req: crate::model::vpn_gateways::GetStatusRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::VpnGatewaysGetStatusResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/vpnGateways/{}/getStatus",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.vpn_gateway).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.vpn_gateway).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "vpn_gateway",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::vpn_gateways::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/vpnGateways",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::vpn_gateways::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::VpnGatewayList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/vpnGateways",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::vpn_gateways::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/vpnGateways/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn test_iam_permissions(
        &self,
        req: crate::model::vpn_gateways::TestIamPermissionsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::TestPermissionsResponse>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/vpnGateways/{}/testIamPermissions",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [VpnTunnels](super::stub::VpnTunnels) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "vpn-tunnels")]
#[derive(Clone)]
pub struct VpnTunnels {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "vpn-tunnels")]
impl std::fmt::Debug for VpnTunnels {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("VpnTunnels")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "vpn-tunnels")]
impl VpnTunnels {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "vpn-tunnels")]
impl super::stub::VpnTunnels for VpnTunnels {
    async fn aggregated_list(
        &self,
        req: crate::model::vpn_tunnels::AggregatedListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::VpnTunnelAggregatedList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/aggregated/vpnTunnels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req.include_all_scopes.iter().fold(builder, |builder, p| {
                    builder.query(&[("includeAllScopes", p)])
                });
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = req
                    .service_project_number
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("serviceProjectNumber", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn delete(
        &self,
        req: crate::model::vpn_tunnels::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/vpnTunnels/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.vpn_tunnel).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.vpn_tunnel).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "vpn_tunnel",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::vpn_tunnels::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::VpnTunnel>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/vpnTunnels/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.vpn_tunnel).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.vpn_tunnel).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "vpn_tunnel",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::vpn_tunnels::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/vpnTunnels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::vpn_tunnels::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::VpnTunnelList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/vpnTunnels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn set_labels(
        &self,
        req: crate::model::vpn_tunnels::SetLabelsRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/vpnTunnels/{}/setLabels",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.resource).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "resource",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::region_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/regions/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.region).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "region",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [WireGroups](super::stub::WireGroups) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "wire-groups")]
#[derive(Clone)]
pub struct WireGroups {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "wire-groups")]
impl std::fmt::Debug for WireGroups {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("WireGroups")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "wire-groups")]
impl WireGroups {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "wire-groups")]
impl super::stub::WireGroups for WireGroups {
    async fn delete(
        &self,
        req: crate::model::wire_groups::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/crossSiteNetworks/{}/wireGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.cross_site_network)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.wire_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.cross_site_network)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cross_site_network",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.wire_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "wire_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::wire_groups::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WireGroup>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/crossSiteNetworks/{}/wireGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.cross_site_network)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.wire_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.cross_site_network)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cross_site_network",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.wire_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "wire_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn insert(
        &self,
        req: crate::model::wire_groups::InsertRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/crossSiteNetworks/{}/wireGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.cross_site_network)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = req
                    .request_id
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                let builder = req
                    .validate_only
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("validateOnly", p)]));
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.cross_site_network)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cross_site_network",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::wire_groups::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::WireGroupList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/crossSiteNetworks/{}/wireGroups",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.cross_site_network)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.cross_site_network)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cross_site_network",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn patch(
        &self,
        req: crate::model::wire_groups::PatchRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/crossSiteNetworks/{}/wireGroups/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req)
                            .map(|m| &m.cross_site_network)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.wire_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::PATCH, path);
                let builder = (|| {
                    let builder = req
                        .request_id
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("requestId", p)]));
                    let builder = req
                        .update_mask
                        .as_ref()
                        .map(|p| serde_json::to_value(p).map_err(Error::ser))
                        .transpose()?
                        .into_iter()
                        .fold(builder, |builder, v| {
                            use gaxi::query_parameter::QueryParameter;
                            v.add(builder, "updateMask")
                        });
                    let builder = req
                        .validate_only
                        .iter()
                        .fold(builder, |builder, p| builder.query(&[("validateOnly", p)]));
                    Ok(builder)
                })();
                Some(builder.map(|b| (b, reqwest::Method::PATCH)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req)
                            .map(|m| &m.cross_site_network)
                            .map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "cross_site_network",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.wire_group).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "wire_group",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(req.body, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get_operation(
        &self,
        req: crate::model::global_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/global/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    fn get_polling_error_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_error_policy::PollingErrorPolicy> {
        self.inner.get_polling_error_policy(options)
    }

    fn get_polling_backoff_policy(
        &self,
        options: &gax::options::RequestOptions,
    ) -> std::sync::Arc<dyn gax::polling_backoff_policy::PollingBackoffPolicy> {
        self.inner.get_polling_backoff_policy(options)
    }
}

/// Implements [ZoneOperations](super::stub::ZoneOperations) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "zone-operations")]
#[derive(Clone)]
pub struct ZoneOperations {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "zone-operations")]
impl std::fmt::Debug for ZoneOperations {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("ZoneOperations")
            .field("inner", &self.inner)
            .finish()
    }
}

#[cfg(feature = "zone-operations")]
impl ZoneOperations {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "zone-operations")]
impl super::stub::ZoneOperations for ZoneOperations {
    async fn delete(
        &self,
        req: crate::model::zone_operations::DeleteRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<wkt::Empty>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::DELETE, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::DELETE)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn get(
        &self,
        req: crate::model::zone_operations::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::zone_operations::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::OperationList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn wait(
        &self,
        req: crate::model::zone_operations::WaitRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Operation>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}/operations/{}/wait",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::POST, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::POST)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.operation).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "operation",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}

/// Implements [Zones](super::stub::Zones) using a [gaxi::http::ReqwestClient].
#[cfg(feature = "zones")]
#[derive(Clone)]
pub struct Zones {
    inner: gaxi::http::ReqwestClient,
}

#[cfg(feature = "zones")]
impl std::fmt::Debug for Zones {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        f.debug_struct("Zones").field("inner", &self.inner).finish()
    }
}

#[cfg(feature = "zones")]
impl Zones {
    pub async fn new(config: gaxi::options::ClientConfig) -> gax::client_builder::Result<Self> {
        let inner = gaxi::http::ReqwestClient::new(config, crate::DEFAULT_HOST).await?;
        Ok(Self { inner })
    }
}

#[cfg(feature = "zones")]
impl super::stub::Zones for Zones {
    async fn get(
        &self,
        req: crate::model::zones::GetRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::Zone>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones/{}",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                    try_match(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.zone).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "zone",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }

    async fn list(
        &self,
        req: crate::model::zones::ListRequest,
        options: gax::options::RequestOptions,
    ) -> Result<gax::response::Response<crate::model::ZoneList>> {
        use gax::error::binding::BindingError;
        use gaxi::path_parameter::PathMismatchBuilder;
        use gaxi::path_parameter::try_match;
        use gaxi::routing_parameter::Segment;
        let (builder, method) = None
            .or_else(|| {
                let path = format!(
                    "/compute/v1/projects/{}/zones",
                    try_match(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard]
                    )?,
                );

                let builder = self.inner.builder(reqwest::Method::GET, path);
                let builder = req
                    .filter
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("filter", p)]));
                let builder = req
                    .max_results
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("maxResults", p)]));
                let builder = req
                    .order_by
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("orderBy", p)]));
                let builder = req
                    .page_token
                    .iter()
                    .fold(builder, |builder, p| builder.query(&[("pageToken", p)]));
                let builder = req
                    .return_partial_success
                    .iter()
                    .fold(builder, |builder, p| {
                        builder.query(&[("returnPartialSuccess", p)])
                    });
                let builder = Ok(builder);
                Some(builder.map(|b| (b, reqwest::Method::GET)))
            })
            .ok_or_else(|| {
                let mut paths = Vec::new();
                {
                    let builder = PathMismatchBuilder::default();
                    let builder = builder.maybe_add(
                        Some(&req).map(|m| &m.project).map(|s| s.as_str()),
                        &[Segment::SingleWildcard],
                        "project",
                        "*",
                    );
                    paths.push(builder.build());
                }
                gax::error::Error::binding(BindingError { paths })
            })??;
        let options = gax::options::internal::set_default_idempotency(
            options,
            gaxi::http::default_idempotency(&method),
        );
        let builder = builder.query(&[("$alt", "json")]).header(
            "x-goog-api-client",
            reqwest::header::HeaderValue::from_static(&crate::info::X_GOOG_API_CLIENT_HEADER),
        );
        let body = gaxi::http::handle_empty(None::<gaxi::http::NoBody>, &method);
        self.inner.execute(builder, body, options).await
    }
}
