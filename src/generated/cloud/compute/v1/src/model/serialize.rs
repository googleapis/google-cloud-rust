// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

#[cfg(any(feature = "machine-types", feature = "zones",))]
#[doc(hidden)]
impl serde::ser::Serialize for super::DeprecationStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.deleted.is_some() {
            state.serialize_entry("deleted", &self.deleted)?;
        }
        if self.deprecated.is_some() {
            state.serialize_entry("deprecated", &self.deprecated)?;
        }
        if self.obsolete.is_some() {
            state.serialize_entry("obsolete", &self.obsolete)?;
        }
        if self.replacement.is_some() {
            state.serialize_entry("replacement", &self.replacement)?;
        }
        if self.state.is_some() {
            state.serialize_entry("state", &self.state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::MachineType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.accelerators.is_empty() {
            state.serialize_entry("accelerators", &self.accelerators)?;
        }
        if self.architecture.is_some() {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.deprecated.is_some() {
            state.serialize_entry("deprecated", &self.deprecated)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.guest_cpus.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("guestCpus", &__With(&self.guest_cpus))?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.image_space_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("imageSpaceGb", &__With(&self.image_space_gb))?;
        }
        if self.is_shared_cpu.is_some() {
            state.serialize_entry("isSharedCpu", &self.is_shared_cpu)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.maximum_persistent_disks.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "maximumPersistentDisks",
                &__With(&self.maximum_persistent_disks),
            )?;
        }
        if self.maximum_persistent_disks_size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "maximumPersistentDisksSizeGb",
                &__With(&self.maximum_persistent_disks_size_gb),
            )?;
        }
        if self.memory_mb.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("memoryMb", &__With(&self.memory_mb))?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.zone.is_some() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_type::Accelerators {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.guest_accelerator_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry(
                "guestAcceleratorCount",
                &__With(&self.guest_accelerator_count),
            )?;
        }
        if self.guest_accelerator_type.is_some() {
            state.serialize_entry("guestAcceleratorType", &self.guest_accelerator_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::MachineTypeAggregatedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if !self.unreachables.is_empty() {
            state.serialize_entry("unreachables", &self.unreachables)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_type_aggregated_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_type_aggregated_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::MachineTypeList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_type_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_type_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::MachineTypesScopedList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.machine_types.is_empty() {
            state.serialize_entry("machineTypes", &self.machine_types)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_types_scoped_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "machine-types")]
#[doc(hidden)]
impl serde::ser::Serialize for super::machine_types_scoped_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "zones")]
#[doc(hidden)]
impl serde::ser::Serialize for super::Zone {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.available_cpu_platforms.is_empty() {
            state.serialize_entry("availableCpuPlatforms", &self.available_cpu_platforms)?;
        }
        if self.creation_timestamp.is_some() {
            state.serialize_entry("creationTimestamp", &self.creation_timestamp)?;
        }
        if self.deprecated.is_some() {
            state.serialize_entry("deprecated", &self.deprecated)?;
        }
        if self.description.is_some() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.id.is_some() {
            struct __With<'a>(&'a std::option::Option<u64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::U64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("id", &__With(&self.id))?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.name.is_some() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.region.is_some() {
            state.serialize_entry("region", &self.region)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.status.is_some() {
            state.serialize_entry("status", &self.status)?;
        }
        if self.supports_pzs.is_some() {
            state.serialize_entry("supportsPzs", &self.supports_pzs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "zones")]
#[doc(hidden)]
impl serde::ser::Serialize for super::ZoneList {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.id.is_some() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.items.is_empty() {
            state.serialize_entry("items", &self.items)?;
        }
        if self.kind.is_some() {
            state.serialize_entry("kind", &self.kind)?;
        }
        if self.next_page_token.is_some() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if self.self_link.is_some() {
            state.serialize_entry("selfLink", &self.self_link)?;
        }
        if self.warning.is_some() {
            state.serialize_entry("warning", &self.warning)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "zones")]
#[doc(hidden)]
impl serde::ser::Serialize for super::zone_list::Warning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.code.is_some() {
            state.serialize_entry("code", &self.code)?;
        }
        if !self.data.is_empty() {
            state.serialize_entry("data", &self.data)?;
        }
        if self.message.is_some() {
            state.serialize_entry("message", &self.message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

#[cfg(feature = "zones")]
#[doc(hidden)]
impl serde::ser::Serialize for super::zone_list::warning::Data {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.key.is_some() {
            state.serialize_entry("key", &self.key)?;
        }
        if self.value.is_some() {
            state.serialize_entry("value", &self.value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
